[
    {
        "ID": "10002-10002",
        "Code": "def issafe ( m , n , i , j ) : NEW_LINE INDENT if i < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i >= m : NEW_LINE INDENT return False NEW_LINE DEDENT if j >= n : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def endpoints ( arr , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE current_d = ' r ' NEW_LINE rcd = { ' l ' : ' u ' , ' u ' : ' r ' , ' r ' : ' d ' , ' d ' : ' l ' } NEW_LINE while issafe ( m , n , i , j ) : NEW_LINE INDENT current_i = i NEW_LINE current_j = j NEW_LINE if arr [ i ] [ j ] == 1 : NEW_LINE INDENT move_in = rcd [ current_d ] NEW_LINE arr [ i ] [ j ] = 0 NEW_LINE if move_in == ' u ' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif move_in == ' d ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif move_in == ' l ' : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT elif move_in == ' r ' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT current_d = move_in NEW_LINE DEDENT else : NEW_LINE INDENT if current_d == ' u ' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif current_d == ' d ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif current_d == ' l ' : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT elif current_d == ' r ' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return ( current_i , current_j ) NEW_LINE DEDENT M = 3 NEW_LINE N = 5 NEW_LINE arr = [ [ 0 , 1 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 0 , 1 ] , [ 1 , 1 , 1 , 0 , 0 ] , ] NEW_LINE print ( endpoints ( arr , M , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Coordinates of the last cell in a Matrix on which performing given operations exits from the Matrix | Function to check if the indices ( i , j ) are valid indices in a Matrix or not ; Cases for invalid cells ; Return true if valid ; Function to find indices of cells of a matrix from which traversal leads to out of the matrix ; Starting from cell ( 0 , 0 ) , traverse in right direction ; Stores direction changes ; Iterate until the current cell exceeds beyond the matrix ; Current index ; If the current cell is 1 ; Update arr [ i ] [ j ] = 0 ; Update indices according to the direction ; Otherwise ; Update indices according to the direction ; The exit cooridnates ; Number of rows ; Number of columns ; Given matrix arr [ ] [ ]",
        "Category": "Matrix"
    },
    {
        "ID": "10006-10006",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self , val = 0 , left = None , right = None ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = left NEW_LINE self . right = right NEW_LINE DEDENT DEDENT def findSum ( root ) : NEW_LINE INDENT que = [ root ] NEW_LINE ans = 0 NEW_LINE while ( len ( que ) ) : NEW_LINE INDENT leaf = 0 NEW_LINE nonleaf = 0 NEW_LINE length = len ( que ) NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE if not temp . left and not temp . right : NEW_LINE INDENT leaf += temp . val NEW_LINE DEDENT else : NEW_LINE INDENT nonleaf += temp . val NEW_LINE DEDENT if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT ans += leaf & nonleaf NEW_LINE DEDENT return ans NEW_LINE DEDENT root = TreeNode ( 5 ) NEW_LINE root . left = TreeNode ( 3 ) NEW_LINE root . right = TreeNode ( 9 ) NEW_LINE root . left . left = TreeNode ( 6 ) NEW_LINE root . left . right = TreeNode ( 4 ) NEW_LINE root . left . left . right = TreeNode ( 7 ) NEW_LINE print ( findSum ( root ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of Bitwise AND of the sum of all leaf and non | Structure of a Binary tree node ; Helper function to allocate a new node with the given data and left and right pointers as None ; Function to calculate the sum of bitwise AND of the sum of all leaf nodes and non - leaf nodes for each level ; Initialize a queue and append root to it ; Store the required answer ; Stores the sum of leaf nodes at the current level ; Stores the sum of non - leaf nodes at the current level ; Get the size of the queue ; Iterate for all the nodes in the queue currently ; Dequeue a node from queue ; Check if the node is a leaf node ; If true , update the leaf node sum ; Otherwise , update the non - leaf node sum ; Enqueue left and right children of removed node ; Update the answer ; Return the answer ; Given Tree ; Function Call",
        "Category": "Binary Tree"
    },
    {
        "ID": "10010-10010",
        "Code": "import math NEW_LINE def sumOfTwoCubes ( n ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = round ( math . pow ( n , 1 / 3 ) ) NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT curr = ( lo * lo * lo + hi * hi * hi ) NEW_LINE if ( curr == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr < n ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 28 NEW_LINE if ( sumOfTwoCubes ( N ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number can be represented as sum of two positive perfect cubes | Python3 program for the above approach ; Function to check if N can be represented as sum of two perfect cubes or not ; If it is same return true ; ; If the curr smaller than n increment the lo ; If the curr is greater than curr decrement the hi ; Driver Code ; Function call to check if N can be represented as sum of two perfect cubes or not",
        "Category": "Two Pointers"
    },
    {
        "ID": "10023-10023",
        "Code": "def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE print ( findNthNumber ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Nth natural number after removing all numbers consisting of the digit 9 | Function to find Nth number in base 9 ; Stores the Nth number ; Iterate while N is greater than 0 ; Update result ; Divide N by 9 ; Multiply p by 10 ; Return result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10031-10031",
        "Code": "import math NEW_LINE def poorPigs ( buckets , minutesToDie , minutesToTest ) : NEW_LINE INDENT print ( math . ceil ( math . log ( buckets ) // math . log ( ( minutesToTest   \\ // minutesToDie ) + 1 ) ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 1000 ; NEW_LINE M = 15 ; NEW_LINE P = 60 ; NEW_LINE poorPigs ( N , M , P ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of pigs required to find the poisonous bucket | Python program for the above approach ; Function to find the minimum number of pigs required to find the poisonous bucket ; Prthe result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10033-10033",
        "Code": "import math NEW_LINE def check ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dig1 = math . floor ( math . log10 ( A ) + 1 ) NEW_LINE dig2 = math . floor ( math . log10 ( B ) + 1 ) NEW_LINE if ( dig1 != dig2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT temp = A NEW_LINE while ( True ) : NEW_LINE INDENT power = pow ( 10 , dig1 - 1 ) NEW_LINE firstdigit = A // power NEW_LINE A = A - firstdigit * power NEW_LINE A = A * 10 + firstdigit NEW_LINE if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( A == temp ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT A , B = 967 , 679 NEW_LINE if ( check ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if an integer is rotation of another given integer | Python3 implementation of the approach ; Function to check if the integer A is a rotation of the integer B ; Stores the count of digits in A ; Stores the count of digits in B ; If dig1 not equal to dig2 ; Stores position of first digit ; Stores the first digit ; Rotate the digits of the integer ; If A is equal to B ; If A is equal to the initial value of integer A ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10045-10045",
        "Code": "def pronic ( num ) : NEW_LINE INDENT N = int ( num ** ( 1 / 2 ) ) ; NEW_LINE if ( N * ( N + 1 ) <= num ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT return N - 1 ; NEW_LINE DEDENT def countPronic ( A , B ) : NEW_LINE INDENT return pronic ( B ) - pronic ( A - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 3 ; NEW_LINE B = 20 ; NEW_LINE print ( countPronic ( A , B ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count Pronic numbers from a given range | Function to count pronic numbers in the range [ A , B ] ; Check upto sqrt N ; If product of consecutive numbers are less than equal to num ; Return N - 1 ; Function to count pronic numbers in the range [ A , B ] ; Subtract the count of pronic numbers which are <= ( A - 1 ) from the count f pronic numbers which are <= B ; Driver Code ; Function call to count pronic numbers in the range [ A , B ]",
        "Category": "Math"
    },
    {
        "ID": "10046-10046",
        "Code": "def sameProductQuadruples ( nums , N ) : NEW_LINE INDENT umap = { } ; NEW_LINE res = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT prod = nums [ i ] * nums [ j ] ; NEW_LINE if prod in umap : NEW_LINE INDENT res += 8 * umap [ prod ] ; NEW_LINE umap [ prod ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT umap [ prod ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 6 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE sameProductQuadruples ( arr , N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of quadruples with product of a pair equal to the product of the remaining pair | Function to count the number of unique quadruples from an array that satisfies the given condition ; Hashmap to store the product of pairs ; Store the count of required quadruples ; Traverse the array arr [ ] and generate all possible pairs ; Store their product ; Pair ( a , b ) can be used to generate 8 unique permutations with another pair ( c , d ) ; Increment umap [ prod ] by 1 ; Print the result ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "10047-10047",
        "Code": "def oddDivisors ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT powerOfTwo = 2 ; NEW_LINE count = 0 ; NEW_LINE while ( powerOfTwo <= arr [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE powerOfTwo = 2 * powerOfTwo ; NEW_LINE DEDENT print ( count , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 15 , 16 , 20 , 35 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE oddDivisors ( arr , N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count integers from a given range with no odd divisors | Function to count integers in the range 1 to N having no odd divisors ; Traverse the array ; Stores the nearest power of two less than arr [ i ] ; Stores the count of integers with no odd divisor for each query ; Iterate until powerOfTwo is less then or equal to arr [ i ] ; Print the answer for the current element ; Driver Code ; Given array ; Size of the array",
        "Category": "Math"
    },
    {
        "ID": "10066-10066",
        "Code": "MOD = 1000000007 NEW_LINE def power ( x , y , p = MOD ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def totalWays ( N , M ) : NEW_LINE INDENT X = N // 2 NEW_LINE S = ( X * ( X + 1 ) ) % MOD NEW_LINE print ( power ( S , M , MOD ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M = 5 , 2 NEW_LINE totalWays ( N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count ways to place M objects in distinct partitions of N boxes | Python3 implementation of the above Approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize Result ; Update x if x >= MOD to avoid multiplication overflow ; If y is odd , multiply x with result ; y = y / 2 ; Change x to x ^ 2 ; Utility function to find the Total Number of Ways ; Number of Even Indexed Boxes ; Number of partitions of Even Indexed Boxes ; Number of ways to distribute objects ; Driver Code ; N = number of boxes M = number of distinct objects ; Function call to get Total Number of Ways",
        "Category": "Math"
    },
    {
        "ID": "10077-10077",
        "Code": "def flippingBits ( N , K ) : NEW_LINE INDENT X = ( 1 << ( K - 1 ) ) - 1 NEW_LINE N = X - N NEW_LINE print ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , K = 1 , 8 NEW_LINE flippingBits ( N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Flip all K | Function to flip all K - bits of an unsigned number N ; Stores ( 2 ^ K ) - 1 ; Update N ; Print the answer ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10079-10079",
        "Code": "def generateMatrix ( N ) : NEW_LINE INDENT odd = 1 ; NEW_LINE even = 2 ; NEW_LINE mat = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i + j ) % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ j ] = odd ; NEW_LINE odd += 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = even ; NEW_LINE even += 2 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE generateMatrix ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate a matrix having even sum of all diagonals in each 2 x 2 submatrices | Function to construct a matrix such that the sum elements in both diagonals of every 2 * 2 matrices is even ; Stores odd numbers ; Stores even numbers ; Store matrix elements such that sum of elements in both diagonals of every 2 * 2 submatrices is even ; Fill all the values of matrix elements ; Update odd ; Update even ; Prthe matrix ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "1008-1008",
        "Code": "def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , \" ( \" + op2 + i + op1 + \" ) \" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Postfix to Infix | Python3 program to find infix for a given postfix . ; Get Infix for a given postfix expression ; Push operands ; We assume that input is a valid postfix and expect an operator . ; There must be a single element in stack now which is the required infix . ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "10088-10088",
        "Code": "def findDay ( Y , B ) : NEW_LINE INDENT lyear , rest , totaldays , day = 0 , 0 , 0 , 0 ; NEW_LINE Y = ( Y - 1 ) - B ; NEW_LINE lyear = Y // 4 ; NEW_LINE rest = Y - lyear ; NEW_LINE totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; NEW_LINE day = ( totaldays % 7 ) ; NEW_LINE if ( day == 0 ) : NEW_LINE INDENT print ( \" Monday \" ) ; NEW_LINE DEDENT elif ( day == 1 ) : NEW_LINE INDENT print ( \" Tuesday \" ) ; NEW_LINE DEDENT elif ( day == 2 ) : NEW_LINE INDENT print ( \" Wednesday \" ) ; NEW_LINE DEDENT elif ( day == 3 ) : NEW_LINE INDENT print ( \" Thursday \" ) ; NEW_LINE DEDENT elif ( day == 4 ) : NEW_LINE INDENT print ( \" Friday \" ) ; NEW_LINE DEDENT elif ( day == 5 ) : NEW_LINE INDENT print ( \" Saturday \" ) ; NEW_LINE DEDENT elif ( day == 6 ) : NEW_LINE INDENT print ( \" Sunday \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" INPUT ▁ YEAR ▁ IS ▁ WRONG ! \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Y = 2020 ; B = 1900 ; NEW_LINE findDay ( Y , B ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the first day of a given year from a base year having first day as Monday | Function to find the day of 1 st January of Y year ; Count years between years Y and B ; Count leap years ; Non leap years ; Total number of days in the years lying between the years Y and B ; Actual day ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10094-10094",
        "Code": "def printArray ( arr , N ) : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT def modifyArray ( arr , N , Q , cntQuery ) : NEW_LINE INDENT arr1 = [ 0 for i in range ( N + 2 ) ] NEW_LINE arr2 = [ 0 for i in range ( N + 2 ) ] NEW_LINE for i in range ( cntQuery ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] + 1 NEW_LINE R = Q [ i ] [ 1 ] + 1 NEW_LINE arr1 [ L ] += 1 NEW_LINE arr1 [ R + 1 ] -= 1 NEW_LINE arr2 [ R + 1 ] -= R - L + 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr1 [ i ] += arr1 [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr2 [ i ] += arr2 [ i - 1 ] + arr1 [ i ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = arr2 [ i ] NEW_LINE DEDENT printArray ( arr , N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 0 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE Q = [ [ 1 , 3 ] , [ 0 , 1 ] ] NEW_LINE cntQuery = len ( Q ) NEW_LINE modifyArray ( arr , N , Q , cntQuery ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to update array elements in a range [ L , R ] to satisfy given conditions | Function to prthe array ; Function to perform the query in range [ L , R ] such that arr [ i ] += i - L + 1 ; Initialize array ; Traverse the query array ; Stores range in 1 - based index ; Update arr1 [ L ] ; Update arr1 [ R + 1 ] ; Update arr2 [ R + 1 ] ; Calculate prefix sum ; Traverse the array , arr2 [ ] ; Copy arr2 [ ] into arr [ ] ; Driver Code ; Given array ; Size of the array ; Stores count of query ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "10096-10096",
        "Code": "def gcd ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( y , x % y ) NEW_LINE DEDENT def lcm ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT def minimumCost ( x , y ) : NEW_LINE INDENT lcm_ = lcm ( x , y ) NEW_LINE costx = ( lcm_ - x ) // x NEW_LINE costy = ( lcm_ - y ) // y NEW_LINE return costx + costy NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 5 NEW_LINE y = 17 NEW_LINE print ( minimumCost ( x , y ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize cost to make X and Y equal by given increments | Function to find gcd of x and y ; Function to find lcm of x and y ; Function to find minimum Cost ; Subtracted initial cost of x ; Subtracted initial cost of y ; Driver Code ; Returns the minimum cost required",
        "Category": "Math"
    },
    {
        "ID": "10100-10100",
        "Code": "import math NEW_LINE mod = 1000000007 ; NEW_LINE def power ( a , n , d ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( ( n % 2 ) != 0 ) : NEW_LINE INDENT res = ( ( res % d ) * ( a % d ) ) % d ; NEW_LINE DEDENT a = ( ( a % d ) * ( a % d ) ) % d ; NEW_LINE n /= 2 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def gcd ( p , q , n ) : NEW_LINE INDENT if ( p == q ) : NEW_LINE INDENT return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod ; NEW_LINE DEDENT candidate = 1 ; NEW_LINE num = p - q ; NEW_LINE sq = ( int ) ( math . sqrt ( num ) ) ; NEW_LINE for i in range ( 1 , sq ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT X = power ( p , n , i ) ; NEW_LINE Y = power ( q , n , i ) ; NEW_LINE temp = ( X + Y ) % i ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT candidate = max ( candidate , i ) ; NEW_LINE DEDENT temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) ; NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT candidate = max ( candidate , num / i ) ; NEW_LINE DEDENT DEDENT DEDENT return candidate % mod ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 10 ; NEW_LINE q = 6 ; NEW_LINE n = 5 ; NEW_LINE print ( ( int ) ( gcd ( p , q , n ) ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find GCD between the sum of two given integers raised to the power of N and their difference | Python program for the above approach ; Function to find the value of ( a ^ n ) % d ; Stores the value of ( a ^ n ) % d ; Calculate the value of ( a ^ n ) % d ; If n is odd ; Update res ; Update a ; Update n ; Function to find the GCD of ( p ^ n + q ^ n ) and p - q mod d ; If p and q are equal ; Stores GCD of ( p ^ n + q ^ n ) and ( p - q ) mod d ; Stores the value of ( p - q ) ; Stores square root of num ; Find the divisors of num . ; If i divides num ; Stores power of ( p ^ n ) mod i ; Stores power of ( q ^ n ) mod i ; Stores power of ( p ^ n + q ^ n ) mod i ; If ( p ^ n + q ^ n ) is divisible by i ; Calculate the largest divisor . ; If i divides num , ( num / i ) also divides num . Hence , calculate temp . ; If ( p ^ n + q ^ n ) is divisible by ( num / i ) ; Calculate the largest divisor . ; Driver code ; Given p , q and n ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10110-10110",
        "Code": "def minSwaps ( b ) : NEW_LINE INDENT n = len ( b ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT rowSum = 0 NEW_LINE colSum = 0 NEW_LINE rowSwap = 0 NEW_LINE colSwap = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rowSum += b [ i ] [ 0 ] NEW_LINE colSum += b [ 0 ] [ i ] NEW_LINE rowSwap += b [ i ] [ 0 ] == i % 2 NEW_LINE colSwap += b [ 0 ] [ i ] == i % 2 NEW_LINE DEDENT if ( rowSum != n // 2 and rowSum != ( n + 1 ) // 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( colSum != n // 2 and colSum != ( n + 1 ) // 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT if ( colSwap % 2 ) : NEW_LINE INDENT colSwap = n - colSwap NEW_LINE DEDENT if ( rowSwap % 2 ) : NEW_LINE INDENT rowSwap = n - rowSwap NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT colSwap = min ( colSwap , n - colSwap ) NEW_LINE rowSwap = min ( rowSwap , n - rowSwap ) NEW_LINE DEDENT return ( rowSwap + colSwap ) // 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = [ [ 0 , 1 , 1 , 0 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ] NEW_LINE ans = minSwaps ( M ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum row or column swaps required to make every pair of adjacent cell of a Binary Matrix distinct | Function to return number of moves to convert matrix into chessboard ; Size of the matrix ; Traverse the matrix ; Initialize rowSum to count 1 s in row ; Initialize colSum to count 1 s in column ; To store no . of rows to be corrected ; To store no . of columns to be corrected ; Traverse in the range [ 0 , N - 1 ] ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if N is odd ; Check if column required to be corrected is odd and then assign N - colSwap to colSwap ; Check if rows required to be corrected is odd and then assign N - rowSwap to rowSwap ; Take min of colSwap and N - colSwap ; Take min of rowSwap and N - rowSwap ; Finally return answer ; Driver Code ; Given matrix ; Function Call ; Print answer",
        "Category": "Matrix"
    },
    {
        "ID": "10112-10112",
        "Code": "def MinimumNoOfWays ( arr , n ) : NEW_LINE INDENT min_no_of_ways = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT mini_no_of_ways = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT mini_no_of_ways = n // 2 + 1 NEW_LINE DEDENT return mini_no_of_ways NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 1 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumNoOfWays ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split array into minimum number of subsets such that elements of all pairs are present in different subsets at least once | Function to find minimum count of ways to split the array into two subset such that elements of each pair occurs in two different subset ; Stores minimum count of ways to split array into two subset such that elements of each pair occurs in two different subset ; if n is odd ; driver code",
        "Category": "Math"
    },
    {
        "ID": "10115-10115",
        "Code": "import math NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def invertBits ( n ) : NEW_LINE INDENT x = ( int ) ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE m = 1 << x NEW_LINE m = m | m - 1 NEW_LINE n = n ^ m NEW_LINE return n NEW_LINE DEDENT def invertSum ( A , B ) : NEW_LINE INDENT temp = countSetBits ( A ) + countSetBits ( B ) NEW_LINE print ( invertBits ( temp ) ) NEW_LINE DEDENT A = 5 NEW_LINE B = 7 NEW_LINE invertSum ( A , B ) NEW_LINE",
        "Type": "py",
        "NL": "Flip bits of the sum of count of set bits of two given numbers | Python3 program for the above approach ; Function to count number of set bits in integer ; Variable for counting set bits ; Function to invert bits of a number ; Calculate number of bits of N - 1 ; ; Function to invert the sum of set bits in A and B ; Stores sum of set bits ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10118-10118",
        "Code": "def minChocolates ( a , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE val , res = 1 , 0 NEW_LINE while ( j < n - 1 ) : NEW_LINE INDENT if ( a [ j ] > a [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT res += val NEW_LINE DEDENT else : NEW_LINE INDENT res += get_sum ( val , i , j ) NEW_LINE DEDENT if ( a [ j ] < a [ j + 1 ] ) : NEW_LINE INDENT val += 1 NEW_LINE DEDENT else : NEW_LINE INDENT val = 1 NEW_LINE DEDENT j += 1 NEW_LINE i = j NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT res += val NEW_LINE DEDENT else : NEW_LINE INDENT res += get_sum ( val , i , j ) NEW_LINE DEDENT return res NEW_LINE DEDENT def get_sum ( peak , start , end ) : NEW_LINE INDENT count = end - start + 1 NEW_LINE peak = max ( peak , count ) NEW_LINE s = peak + ( ( ( count - 1 ) * count ) >> 1 ) NEW_LINE return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( ' Minimum ▁ number ▁ of ▁ chocolates ▁ = ' , minChocolates ( a , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Chocolate Distribution Problem | Set 2 | Function to return minimum number of chocolates ; decreasing sequence ; add the chocolates received by that person ; end point of decreasing sequence ; val = 1 reset value at that index ; increasing sequence ; flat sequence ; add value of chocolates at position n - 1 ; Helper function to get sum of decreasing sequence ; value obtained from decreasing sequence also the count of values in the sequence ; assigning max of values obtained from increasing and decreasing sequences ; sum of count - 1 values & peak value sum of natural numbers : ( n * ( n + 1 ) ) / 2 ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "1012-1012",
        "Code": "def calculateSpan ( A , n , ans ) : NEW_LINE INDENT ans [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT counter = 1 NEW_LINE while ( ( i - counter ) >= 0 and A [ i ] >= A [ i - counter ] ) : NEW_LINE INDENT counter += ans [ i - counter ] NEW_LINE DEDENT ans [ i ] = counter NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT price = [ 10 , 4 , 5 , 90 , 120 , 80 ] NEW_LINE n = len ( price ) NEW_LINE S = [ 0 ] * ( n ) NEW_LINE calculateSpan ( price , n , S ) NEW_LINE printArray ( S , n ) NEW_LINE",
        "Type": "py",
        "NL": "The Stock Span Problem | An efficient method to calculate stock span values implementing the same idea without using stack ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; A utility function to print elements of array ; Driver code ; Fill the span values in array S [ ] ; Print the calculated span values",
        "Category": "Stack"
    },
    {
        "ID": "10134-10134",
        "Code": "def findSum ( a , b , N ) : NEW_LINE INDENT sum = 0 NEW_LINE x = a ^ b NEW_LINE if N % 3 == 0 : NEW_LINE INDENT sum = ( N // 3 ) * ( a + b + x ) NEW_LINE DEDENT elif N % 3 == 1 : NEW_LINE INDENT sum = ( N // 3 ) * ( a + b + x ) + a NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( N // 3 ) * ( a + b + x ) + a + b NEW_LINE DEDENT print ( sum ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 5 NEW_LINE N = 8 NEW_LINE findSum ( a , b , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of the first N terms of XOR Fibonacci series | Function to calculate sum of the first N terms of XOR Fibonacci Series ; Store the sum of first n terms ; Store xor of a and b ; Case 1 : If n is divisible by 3 ; Case 2 : If n % 3 leaves remainder 1 ; Case 3 : If n % 3 leaves remainder 2 on division by 3 ; Print the final sum ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10138-10138",
        "Code": "import math NEW_LINE def onesComplement ( n , maxElement ) : NEW_LINE INDENT bits = math . floor ( math . log2 ( maxElement ) ) + 1 NEW_LINE return ( ( 1 << bits ) - 1 ) ^ n NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE maxElement = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE if ( maxElement < arr [ i ] ) : NEW_LINE INDENT maxElement = arr [ i ] NEW_LINE DEDENT DEDENT res = onesComplement ( res , maxElement ) NEW_LINE return ( res ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findNumber ( arr , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum value to be added to maximize Bitwise XOR of the given array | Python program for the above approach ; Function to find complement of an integer ; Count the number of bits of maxElement ; Return 1 's complement ; Function to find the value required to be added to maximize XOR of the given array ; Stores the required value to be added to the array ; Stores the maximum array element ; Traverse the array ; Update XOR of the array ; Find maximum element in array ; Calculate 1 s ' complement ; Return the answer ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10139-10139",
        "Code": "def calculateFactorial ( N ) : NEW_LINE INDENT fact = [ 0 ] * ( N + 1 ) NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def cntWaysSelection ( arr , N , K , L , R ) : NEW_LINE INDENT cntWays = 0 NEW_LINE cntNum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] >= L and arr [ i ] <= R ) : NEW_LINE INDENT cntNum += 1 NEW_LINE DEDENT DEDENT fact = list ( calculateFactorial ( cntNum ) ) NEW_LINE for i in range ( K , cntNum + 1 ) : NEW_LINE INDENT cntWays += fact [ cntNum ] // ( fact [ i ] * fact [ cntNum - i ] ) NEW_LINE DEDENT return cntWays NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 4 , 6 , 13 , 5 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE L = 4 NEW_LINE R = 10 NEW_LINE print ( cntWaysSelection ( arr , N , K , L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count ways to select K array elements lying in a given range | Function to calculate factorial of all the numbers up to N ; Factorial of 0 is 1 ; Calculate factorial of all the numbers upto N ; Calculate factorial of i ; Function to find count of ways to select at least K elements whose values in range [ L , R ] ; Stores count of ways to select at leas K elements whose values in range [ L , R ] ; Stores count of numbers having Value lies in the range [ L , R ] ; Traverse the array ; Check if the array elements Lie in the given range ; Update cntNum ; Stores factorial of numbers upto N ; Calculate total ways to select at least K elements whose values Lies in [ L , R ] ; Update cntWays ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10151-10151",
        "Code": "M = 1000000007 NEW_LINE def power ( x , N ) : NEW_LINE INDENT global M NEW_LINE res = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT res = ( res * x ) % M NEW_LINE DEDENT x = ( x * x ) % M NEW_LINE N = N >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def modinv ( X ) : NEW_LINE INDENT return power ( X , M - 2 ) NEW_LINE DEDENT def findTripleSum ( A , B , C ) : NEW_LINE INDENT global M NEW_LINE MMI = modinv ( 8 ) NEW_LINE res = 0 NEW_LINE res = ( ( ( ( A % M * ( A + 1 ) % M ) % M * ( B % M * ( B + 1 ) % M ) % M ) % M * ( C % M * ( C + 1 ) % M ) % M ) % M * MMI ) % M NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 10 NEW_LINE B = 100 NEW_LINE C = 1000 NEW_LINE print ( findTripleSum ( A , B , C ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all possible triplet products from given ranges | Python3 implementation to implement the above approach ; Function to find the value of power ( X , N ) % M ; Stores the value of ( X ^ N ) % M ; Calculate the value of power ( x , N ) % M ; If N is odd ; Update res ; Update x ; Update N ; Function to find modulo multiplicative inverse of X under modulo M ; Function to find the sum of all possible triplet products ( i * j * k ) ; Stores modulo multiplicative inverse of 8 ; Stores the sum of all possible values of ( i * j * k ) ; Update res ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10166-10166",
        "Code": "from math import sqrt , floor , ceil NEW_LINE def checkPerfectSquare ( N ) : NEW_LINE INDENT if ( N <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sq = sqrt ( N ) NEW_LINE if ( floor ( sq ) == ceil ( sq ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def checktwoSidesareRighTriangle ( A , B ) : NEW_LINE INDENT checkTriangle = False NEW_LINE if ( checkPerfectSquare ( A * A + B * B ) ) : NEW_LINE INDENT checkTriangle = True NEW_LINE DEDENT if ( checkPerfectSquare ( A * A - B * B ) ) : NEW_LINE INDENT checkTriangle = True NEW_LINE DEDENT if ( checkPerfectSquare ( B * B - A * A ) ) : NEW_LINE INDENT checkTriangle = True NEW_LINE DEDENT return checkTriangle NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 3 NEW_LINE B = 4 NEW_LINE if ( checktwoSidesareRighTriangle ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a right | Python3 program to implement the above approach ; Function to check if N is a perfect square number or not ; If N is a non positive integer ; Stores square root of N ; Check for perfect square ; If N is not a perfect square number ; Function to check if given two sides of a triangle forms a right - angled triangle ; If the value of ( A * A + B * B ) is a perfect square number ; Update checkTriangle ; If the value of ( A * A - B * B ) is a perfect square number ; Update checkTriangle ; If the value of ( B * B - A * A ) is a perfect square number ; Update checkTriangle ; Driver Code ; If the given two sides of a triangle forms a right - angled triangle ; Otherwise",
        "Category": "Math"
    },
    {
        "ID": "10167-10167",
        "Code": "r , c = 0 , 0 ; NEW_LINE dir = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] , [ - 1 , - 1 ] , [ - 1 , 1 ] , [ 1 , 1 ] , [ 1 , - 1 ] ] ; NEW_LINE def valid ( i , j ) : NEW_LINE INDENT if ( i >= 0 and j >= 0 and i < r and j < c ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def find ( i , j , v ) : NEW_LINE INDENT s = 0 ; NEW_LINE for k in range ( 8 ) : NEW_LINE INDENT ni = i + dir [ k ] [ 0 ] ; NEW_LINE nj = j + dir [ k ] [ 1 ] ; NEW_LINE if ( valid ( ni , nj ) ) : NEW_LINE INDENT s += v [ ni ] [ nj ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT def findsumofneighbors ( M ) : NEW_LINE INDENT v = [ [ 0 for i in range ( c ) ] for j in range ( r ) ] ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT v [ i ] [ j ] = find ( i , j , M ) ; NEW_LINE print ( v [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = [ [ 1 , 4 , 1 ] , [ 2 , 4 , 5 ] , [ 3 , 1 , 2 ] ] ; NEW_LINE r = len ( M [ 0 ] ) ; NEW_LINE c = len ( M [ 1 ] ) ; NEW_LINE findsumofneighbors ( M ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct a Matrix such that each cell consists of sum of adjacent elements of respective cells in given Matrix | Initialize rows and columns ; Store all 8 directions ; Function to check if a cell ( i , j ) is valid or not ; Function to find sum of adjacent cells for cell ( i , j ) ; Initialize sum ; Visit all 8 directions ; Check if cell is valid ; Return sum ; Function to print sum of adjacent elements ; Stores the resultant matrix ; Iterate each elements of matrix ; Find adjacent sum ; Driver code ; Given matrix ; Size of matrix ; Function call",
        "Category": "Matrix"
    },
    {
        "ID": "10178-10178",
        "Code": "def printFinalArray ( a , n , operations , p , capacity ) : NEW_LINE INDENT curr = 0 NEW_LINE picked = False NEW_LINE for i in range ( p ) : NEW_LINE INDENT s = operations [ i ] NEW_LINE flag = False NEW_LINE if ( curr != 0 ) : NEW_LINE INDENT curr -= 1 NEW_LINE break NEW_LINE DEDENT if ( curr != n - 1 ) : NEW_LINE INDENT curr += 1 NEW_LINE break NEW_LINE DEDENT if ( picked == False and a [ curr ] != 0 ) : NEW_LINE INDENT picked = True NEW_LINE a [ curr ] -= 1 NEW_LINE break NEW_LINE DEDENT if ( picked == True and a [ curr ] != capacity ) : NEW_LINE INDENT picked = False NEW_LINE a [ curr ] += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT capacity = 5 NEW_LINE a = [ 2 , 5 , 2 ] NEW_LINE N = len ( a ) NEW_LINE operations = [ 3 , 2 , 4 , 1 , 4 , 5 ] NEW_LINE M = len ( operations ) NEW_LINE printFinalArray ( a , N , operations , M , capacity ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of packets placed in each box after performing given operations | Function to print final array after performing all the operations ; Initialize variables ; Traverse through all operations ; Operation Type ; Move left ; Move right ; Pick a packet ; Drop a packet ; Exit ; Print final array ; Driver Code ; Given capacity ; Given array with initial values ; Array size ; Operations ; Number of operations ; Function call",
        "Category": "Array"
    },
    {
        "ID": "10183-10183",
        "Code": "def checkPalindrome ( N ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = N NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rev = rev * 10 + N % 10 NEW_LINE N = N // 10 NEW_LINE DEDENT N = temp NEW_LINE if ( N == rev ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def closestSmallerPalindrome ( N ) : NEW_LINE INDENT while N >= 0 and not checkPalindrome ( N ) : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT return N NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4000 NEW_LINE print ( closestSmallerPalindrome ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smaller palindromic number closest to N | Function to check if a number is palindrome or not ; Stores reverse of N ; Stores the value of N ; Calculate reverse of N ; Update rev ; Update N ; Update N ; If N is equal to rev of N ; Function to find the closest smaller palindromic number to N ; Calculate closest smaller palindromic number to N ; Update N ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10184-10184",
        "Code": "def MinimumOperationReq ( N ) : NEW_LINE INDENT cntDecr = 0 ; NEW_LINE temp = N ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT X = int ( pow ( temp , 1 / 2 ) ) NEW_LINE if ( X * X == temp ) : NEW_LINE INDENT break ; NEW_LINE DEDENT temp = temp - 2 ; NEW_LINE cntDecr += 1 ; NEW_LINE DEDENT cntIncr = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT X = int ( pow ( N , 1 / 2 ) ) NEW_LINE if ( X * X == N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT N = N + 2 ; NEW_LINE cntIncr += 1 ; NEW_LINE DEDENT return min ( cntIncr , cntDecr ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE print ( MinimumOperationReq ( N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize increments or decrements by 2 to convert given value to a perfect square | Function to find the minimum number of operations required to make N a perfect square ; Stores count of operations by performing decrements ; Stores value of N ; Decrement the value of temp ; Stores square root of temp ; If temp is a perfect square ; Update temp ; Store count of operations by performing increments ; Increment the value of N ; Stores sqrt of N ; If N is a perfect square ; Update temp ; Return the minimum count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10195-10195",
        "Code": "mod = 1e9 + 7 NEW_LINE def NthTerm ( F , C , K , n ) : NEW_LINE INDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE i = 0 NEW_LINE while i < K : NEW_LINE INDENT ans [ i ] = F [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i = K NEW_LINE while i <= n : NEW_LINE INDENT j = i - K NEW_LINE while j < i : NEW_LINE INDENT ans [ i ] += ans [ j ] NEW_LINE ans [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( int ( ans [ n ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT F = [ 0 , 1 ] NEW_LINE C = [ 1 , 1 ] NEW_LINE K = 2 NEW_LINE N = 10 NEW_LINE NthTerm ( F , C , K , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Nth term of a recurrence relation generated by two given arrays | Python3 program for the above approach ; Function to calculate Nth term of general recurrence relations ; Stores the generated sequence ; Current term is sum of previous k terms ; Print the nth term ; Driver code ; Given Array F [ ] and C [ ] ; Given N and K ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "10196-10196",
        "Code": "mod = 1e9 + 7 NEW_LINE T = [ [ 0 for x in range ( 2000 ) ] for y in range ( 2000 ) ] NEW_LINE result = [ [ 0 for x in range ( 2000 ) ] for y in range ( 2000 ) ] NEW_LINE def mul_2 ( K ) : NEW_LINE INDENT temp = [ [ 0 for x in range ( K + 1 ) ] for y in range ( K + 1 ) ] NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT for k in range ( 1 , K + 1 ) : NEW_LINE INDENT temp [ i ] [ j ] = ( ( temp [ i ] [ j ] + ( T [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT T [ i ] [ j ] = temp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def mul_1 ( K ) : NEW_LINE INDENT temp = [ [ 0 for x in range ( K + 1 ) ] for y in range ( K + 1 ) ] NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT for k in range ( 1 , K + 1 ) : NEW_LINE INDENT temp [ i ] [ j ] = ( ( temp [ i ] [ j ] + ( result [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT result [ i ] [ j ] = temp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def matrix_pow ( K , n ) : NEW_LINE INDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT result [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT while ( n > 0 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT mul_1 ( K ) NEW_LINE DEDENT mul_2 ( K ) NEW_LINE n //= 2 NEW_LINE DEDENT DEDENT def NthTerm ( F , C , K , n ) : NEW_LINE INDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT T [ i ] [ K ] = C [ K - i ] NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT T [ i + 1 ] [ i ] = 1 NEW_LINE DEDENT matrix_pow ( K , n ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT answer += F [ i - 1 ] * result [ i ] [ 1 ] NEW_LINE DEDENT print ( int ( answer ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT F = [ 1 , 2 , 3 ] NEW_LINE C = [ 1 , 1 , 1 ] NEW_LINE K = 3 NEW_LINE N = 10 NEW_LINE NthTerm ( F , C , K , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Nth term of a recurrence relation generated by two given arrays | Python3 program for the above approach ; Declare T [ ] [ ] as global matrix ; Result matrix ; Function to multiply two matrices ; Create an auxiliary matrix to store elements of the multiplication matrix ; Iterate over range [ 0 , K ] ; Update temp [ i ] [ j ] ; Update the final matrix ; Function to multiply two matrices ; Create an auxiliary matrix to store elements of the multiplication matrix ; Iterate over range [ 0 , K ] ; Update temp [ i ] [ j ] ; Update the final matrix ; Function to calculate matrix ^ n using binary exponentaion ; Initialize result matrix and unity matrix ; Function to calculate nth term of general recurrence ; Fill T [ ] [ ] with appropriate value ; Function Call to calculate T ^ n ; Calculate nth term as first element of F * ( T ^ n ) ; Print the result ; Driver Code ; Given Initial terms ; Given coefficients ; Given K ; Given N ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "10198-10198",
        "Code": "def computeSalary ( basic , grade ) : NEW_LINE INDENT hra = 0.2 * basic NEW_LINE da = 0.5 * basic NEW_LINE pf = 0.11 * basic NEW_LINE if grade == ' A ' : NEW_LINE INDENT allowance = 1700.0 NEW_LINE DEDENT elif grade == ' B ' : NEW_LINE INDENT allowance = 1500.0 NEW_LINE DEDENT else : NEW_LINE INDENT allowance = 1300.0 ; NEW_LINE DEDENT gross = round ( basic + hra + da + allowance - pf ) NEW_LINE return gross NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT basic = 10000 NEW_LINE grade = ' A ' NEW_LINE print ( computeSalary ( basic , grade ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate gross salary of a person | Function to calculate the salary of the person ; Condition to compute the allowance for the person ; Calculate gross salary ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10204-10204",
        "Code": "def checkPalindromeB ( N , B ) : NEW_LINE INDENT rev = 0 ; NEW_LINE N1 = N ; NEW_LINE while ( N1 > 0 ) : NEW_LINE INDENT rev = rev * B + N1 % B ; NEW_LINE N1 = N1 // B ; NEW_LINE DEDENT return N == rev ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; B = 2 ; NEW_LINE if ( checkPalindromeB ( N , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if number is palindrome or not in base B | Function to check if N in base B is palindrome or not ; Stores the reverse of N ; Stores the value of N ; Extract all the digits of N ; Generate its reverse ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10211-10211",
        "Code": "def balancedTernary ( n ) : NEW_LINE INDENT output = \" \" NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 3 NEW_LINE n = n // 3 NEW_LINE if ( rem == 2 ) : NEW_LINE INDENT rem = - 1 NEW_LINE n += 1 NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT output = '0' + output NEW_LINE DEDENT else : NEW_LINE INDENT if ( rem == 1 ) : NEW_LINE INDENT output = '1' + output NEW_LINE DEDENT else : NEW_LINE INDENT output = ' Z ' + output NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT n = 238 NEW_LINE print ( \" Equivalent ▁ Balanced ▁ Ternary ▁ of \" , n , \" is : \" , balancedTernary ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Balanced Ternary Number System | Python3 program to convert positive decimals into balanced ternary system ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10213-10213",
        "Code": "def modexp ( x , n , m ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return modexp ( ( x * x ) % m , n / 2 , m ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) NEW_LINE DEDENT DEDENT DEDENT def modInverse ( x , m ) : NEW_LINE INDENT return modexp ( x , m - 2 , m ) NEW_LINE DEDENT def countNumbers ( N ) : NEW_LINE INDENT m = 1000000007 NEW_LINE factorial = [ 0 for x in range ( 100001 ) ] NEW_LINE factorial [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % m NEW_LINE DEDENT count = [ 0 for x in range ( 10 ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT length = len ( N ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT count [ int ( N [ i ] ) ] += 1 NEW_LINE DEDENT result = factorial [ int ( length ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT result = ( result * modInverse ( factorial [ int ( count [ i ] ) ] , m ) ) % m NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT N = \"0223\" ; NEW_LINE countNumbers ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Count of distinct numbers formed by shuffling the digits of a large number N | Recursive function to return the value of ( x ^ n ) % m ; Base Case ; If N is even ; Else N is odd ; Function to find modular inverse of a number x under modulo m ; Using Fermat 's little theorem ; Function to count of numbers formed by shuffling the digits of a large number N ; Modulo value ; Array to store the factorials upto the maximum value of N ; Store factorial of i at index i ; To store count of occurrence of a digit ; Increment the count of digit occured ; Assign the factorial of length of input ; Multiplying result with the modulo multiplicative inverse of factorial of count of i ; Print the result ; Given number as string ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10218-10218",
        "Code": "def findlcm ( n ) : NEW_LINE INDENT ans = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ( ( ( i * ans ) ) // ( __gcd ( i , ans ) ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def highestPower ( n ) : NEW_LINE INDENT lcm = findlcm ( n ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = int ( pow ( 2 , i ) ) ; NEW_LINE if ( lcm % x == 0 ) : NEW_LINE INDENT ans = i ; NEW_LINE DEDENT if ( x > n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 ; NEW_LINE print ( highestPower ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Highest power of 2 that divides the LCM of first N Natural numbers . | Function to find LCM of first N natural numbers ; Initialize result ; Ans contains LCM of 1 , 2 , 3 , . . i after i 'th iteration ; Function to find the highest power of 2 which divides LCM of first n natural numbers ; Find lcm of first N natural numbers ; To store the highest required power of 2 ; Counting number of consecutive zeros from the end in the given binary String ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10221-10221",
        "Code": "def checkFactors ( N ) : NEW_LINE INDENT ev_count = 0 ; od_count = 0 ; NEW_LINE for i in range ( 1 , int ( pow ( N , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N / i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT if ( ( N / i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ev_count % 2 == 0 and od_count % 2 == 1 ) : NEW_LINE INDENT print ( \" Yes \" + \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" + \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 36 ; NEW_LINE checkFactors ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number has an odd count of odd divisors and even count of even divisors | Function to find the count of even and odd factors of N ; Loop runs till square root ; Condition to check if the even factors of the number N is is even and count of odd factors is odd ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10222-10222",
        "Code": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = pow ( x , 1 / 2 ) ; NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) ; NEW_LINE DEDENT def checkFactors ( x ) : NEW_LINE INDENT if ( isPerfectSquare ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 36 ; NEW_LINE checkFactors ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number has an odd count of odd divisors and even count of even divisors | Python3 implementation of the above approach ; Function to check if the number is a perfect square ; Find floating povalue of square root of x . ; If square root is an integer ; Function to check if count of even divisors is even and count of odd divisors is odd ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10224-10224",
        "Code": "def answer ( L , R ) : NEW_LINE INDENT if ( 2 * L <= R ) : NEW_LINE INDENT print ( L , \" , \" , 2 * L ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT L = 3 NEW_LINE R = 8 NEW_LINE answer ( L , R ) NEW_LINE",
        "Type": "py",
        "NL": "Find two distinct numbers such that their LCM lies in given range | Function to find two distinct numbers X and Y s . t . their LCM lies between L and R and X , Y are minimum possible ; Check if 2 * L lies in range L , R ; Print the answer ; Given value of ranges ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10227-10227",
        "Code": "def gcd ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return y NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT def countPairwiseCoprime ( N , M ) : NEW_LINE INDENT answer = 1 NEW_LINE g = gcd ( N , M ) NEW_LINE temp = g NEW_LINE for i in range ( 2 , g + 1 ) : NEW_LINE INDENT if i * i > g : NEW_LINE INDENT break NEW_LINE DEDENT if ( temp % i == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE while ( temp % i == 0 ) : NEW_LINE INDENT temp //= i NEW_LINE DEDENT DEDENT DEDENT if ( temp != 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT def countCoprimePair ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( countPairwiseCoprime ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 12 , 18 ] , [ 420 , 660 ] ] NEW_LINE N = len ( arr ) NEW_LINE countCoprimePair ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum count of pairwise co | Function to find the gcd of two numbers ; Function to of pairwise co - prime and common divisors of two numbers ; Initialize answer with 1 , to include 1 in the count ; Count of primes of gcd ( N , M ) ; Finding prime factors of gcd ; Increment count if it is divisible by i ; Return the total count ; Function Call for each pair to calculate the count of pairwise co - prime divisors ; Driver Code ; Given array of pairs ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10230-10230",
        "Code": "import math NEW_LINE def printt ( N ) : NEW_LINE INDENT for i in range ( 100000 ) : NEW_LINE INDENT if ( pow ( i + 1 , 3 ) - pow ( i , 3 ) == N ) : NEW_LINE INDENT print ( i , ' ' , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def diffCube ( N ) : NEW_LINE INDENT return isPerfectSquare ( 12 * N - 3 ) NEW_LINE DEDENT N = 19 NEW_LINE if ( diffCube ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE printt ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a number can be represented as difference of two consecutive cubes | Python3 program for the above approach ; Function to print the two consecutive numbers whose difference is N ; Iterate in the range [ 0 , 10 ^ 5 ] ; Function to check if N is a perfect cube ; Find floating povalue of square root of x . ; If square root is an integer ; Function to check whether a number can be represented as difference of two consecutive cubes ; Check if 12 * N - 3 is a perfect square or not ; Given number N",
        "Category": "Math"
    },
    {
        "ID": "10231-10231",
        "Code": "def Kmultiples ( n , k ) : NEW_LINE INDENT a = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( \" { } ▁ * ▁ { } ▁ = ▁ { } \" . format ( n , i , a ) ) NEW_LINE j = 0 NEW_LINE while ( n >= ( 1 << j ) ) : NEW_LINE INDENT a += n & ( 1 << j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT N = 16 NEW_LINE K = 7 NEW_LINE Kmultiples ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Generate first K multiples of N using Bitwise operators | Function to print the first K multiples of N ; Print the value of N * i ; Iterate each bit of N and add pow ( 2 , pos ) , where pos is the index of each set bit ; Check if current bit at pos j is fixed or not ; For next set bit ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10234-10234",
        "Code": "def calculateB ( x , y , n ) : NEW_LINE INDENT sx = sum ( x ) NEW_LINE sy = sum ( y ) NEW_LINE sxsy = 0 NEW_LINE sx2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sxsy += x [ i ] * y [ i ] NEW_LINE sx2 += x [ i ] * x [ i ] NEW_LINE DEDENT b = ( n * sxsy - sx * sy ) / ( n * sx2 - sx * sx ) NEW_LINE return b NEW_LINE DEDENT def leastRegLine ( X , Y , n ) : NEW_LINE INDENT b = calculateB ( X , Y , n ) NEW_LINE meanX = int ( sum ( X ) / n ) NEW_LINE meanY = int ( sum ( Y ) / n ) NEW_LINE a = meanY - b * meanX NEW_LINE print ( \" Regression ▁ line : \" ) NEW_LINE print ( \" Y ▁ = ▁ \" , ' % .3f ' % a , \" ▁ + ▁ \" , ' % .3f ' % b , \" * X \" , sep = \" \" ) NEW_LINE DEDENT X = [ 95 , 85 , 80 , 70 , 60 ] NEW_LINE Y = [ 90 , 80 , 70 , 65 , 60 ] NEW_LINE n = len ( X ) NEW_LINE leastRegLine ( X , Y , n ) NEW_LINE",
        "Type": "py",
        "NL": "Least Square Regression Line | Function to calculate b ; sum of array x ; sum of array y ; for sum of product of x and y ; sum of square of x ; Function to find the least regression line ; Finding b ; Calculating a ; Printing regression line ; Statistical data",
        "Category": "Math"
    },
    {
        "ID": "10236-10236",
        "Code": "def countRepeatingDigits ( N ) : NEW_LINE INDENT res = 0 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT rem = N % 10 NEW_LINE cnt [ rem ] += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( cnt [ i ] > 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT N = 12 NEW_LINE print ( countRepeatingDigits ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of repeating digits in a given Number | Function that returns the count of repeating digits of the given number ; Initialize a variable to store count of Repeating digits ; Initialize cnt array to store digit count ; Iterate through the digits of N ; Retrieve the last digit of N ; Increase the count of digit ; Remove the last digit of N ; Iterate through the cnt array ; If frequency of digit is greater than 1 ; Increment the count of Repeating digits ; Return count of repeating digit ; Given array arr [ ] ; Function call",
        "Category": "Hash Table"
    },
    {
        "ID": "10240-10240",
        "Code": "from math import * NEW_LINE def modPower ( a , b , M ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res * a % M NEW_LINE DEDENT a = a * a % M NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def findFirstAndLastM ( N , K , M ) : NEW_LINE INDENT lastM = modPower ( N , K , int ( pow ( 10 , M ) ) ) NEW_LINE firstM = 0 NEW_LINE y = K * log10 ( N * 1.0 ) NEW_LINE y = y - int ( y ) NEW_LINE temp = pow ( 10.0 , y ) NEW_LINE firstM = int ( temp * pow ( 10 , M - 1 ) ) NEW_LINE print ( firstM , lastM ) NEW_LINE DEDENT N = 12 NEW_LINE K = 12 NEW_LINE M = 4 NEW_LINE findFirstAndLastM ( N , K , M ) NEW_LINE",
        "Type": "py",
        "NL": "Find the first and last M digits from K | Python3 program to implement the above approach ; Function to find a ^ b modulo M ; Function to find the first and last M digits from N ^ K ; Calculate Last M digits ; Calculate First M digits ; Extract the number after decimal ; Find 10 ^ y ; Move the Decimal Point M - 1 digits forward ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10241-10241",
        "Code": "import sys NEW_LINE from collections import defaultdict NEW_LINE def Find_min ( diff_mod , count_mod , k ) : NEW_LINE INDENT min_oprn = sys . maxsize NEW_LINE oprn = 0 NEW_LINE for x in range ( k ) : NEW_LINE INDENT oprn = 0 NEW_LINE for w in diff_mod : NEW_LINE INDENT if ( w != x ) : NEW_LINE INDENT if ( w == 0 ) : NEW_LINE INDENT oprn += ( min ( x , k - x ) * count_mod [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oprn += ( min ( abs ( x - w ) , k + x - w ) * count_mod [ w ] ) NEW_LINE DEDENT DEDENT DEDENT if ( oprn < min_oprn ) : NEW_LINE INDENT min_oprn = oprn NEW_LINE DEDENT DEDENT return min_oprn NEW_LINE DEDENT def Cal_min ( arr , n , k ) : NEW_LINE INDENT diff_mod = set ( [ ] ) NEW_LINE count_mod = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff_mod . add ( arr [ i ] % k ) NEW_LINE count_mod [ arr [ i ] % k ] += 1 NEW_LINE DEDENT return Find_min ( diff_mod , count_mod , k ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 35 , 48 , 23 , 52 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( Cal_min ( arr , n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize increment / decrement of Array elements to make each modulo K equal | Python3 program for the above approach ; Function to find the minimum operations required to make the modulo of each element of the array equal to each other ; Variable to store minimum operation required ; To store operation required to make all modulo equal ; Iterating through all possible modulo value ; Iterating through all different modulo obtained so far ; Calculating oprn required to make all modulos equal to x ; Checking the operations that will cost less ; Check operation that will cost less ; Update the minimum number of operations ; Returning the answer ; Function to store different modulos ; Set to store all different modulo ; Map to store count of all different modulo obtained ; Storing all different modulo count ; Insert into the set ; Increment count ; Function call to return value of min oprn required ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "10250-10250",
        "Code": "def findTemperature ( x , y , s ) : NEW_LINE INDENT diff = ( x - y ) * 6 NEW_LINE Day2 = ( diff + s ) // 2 NEW_LINE Day1 = s - Day2 NEW_LINE print ( \" Day1 ▁ : ▁ \" , Day1 ) NEW_LINE print ( \" Day2 ▁ : ▁ \" , Day2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE y = 10 NEW_LINE s = 40 NEW_LINE findTemperature ( x , y , s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find temperature of missing days using given sum and average | Function for finding the temperature ; Store Day1 - Day2 in diff ; Remaining from s will be Day1 ; Print Day1 and Day2 ; Driver Code ; Functions",
        "Category": "Math"
    },
    {
        "ID": "10253-10253",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data , left , right ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = left NEW_LINE self . right = right NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT return Node ( data , None , None ) ; NEW_LINE DEDENT def inorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return ; NEW_LINE DEDENT inorder ( node . left ) ; NEW_LINE print ( node . data , end = ' ▁ ' ) ; NEW_LINE inorder ( node . right ) ; NEW_LINE DEDENT def MaximumBinaryTree ( t1 , t2 ) : NEW_LINE INDENT if ( t1 == None ) : NEW_LINE INDENT return t2 ; NEW_LINE DEDENT if ( t2 == None ) : NEW_LINE INDENT return t1 ; NEW_LINE DEDENT t1 . data = max ( t1 . data , t2 . data ) ; NEW_LINE t1 . left = MaximumBinaryTree ( t1 . left , t2 . left ) ; NEW_LINE t1 . right = MaximumBinaryTree ( t1 . right , t2 . right ) ; NEW_LINE return t1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = newNode ( 3 ) ; NEW_LINE root1 . left = newNode ( 2 ) ; NEW_LINE root1 . right = newNode ( 6 ) ; NEW_LINE root1 . left . left = newNode ( 20 ) ; NEW_LINE root2 = newNode ( 5 ) ; NEW_LINE root2 . left = newNode ( 1 ) ; NEW_LINE root2 . right = newNode ( 8 ) ; NEW_LINE root2 . left . right = newNode ( 2 ) ; NEW_LINE root2 . right . right = newNode ( 8 ) ; NEW_LINE root3 = MaximumBinaryTree ( root1 , root2 ) ; NEW_LINE inorder ( root3 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct a Maximum Binary Tree from two given Binary Trees | A binary tree node has data , pointer to left child and a pointer to right child ; Helper method that allocates a new node with the given data and None left and right pointers . ; Given a binary tree , print its nodes in inorder ; first recur on left child ; then print the data of node ; now recur on right child ; Method to find the maximum binary tree from two binary trees ; Driver Code ; First Binary Tree 3 / \\ 2 6 / 20 ; Second Binary Tree 5 / \\ 1 8 \\ \\ 2 8",
        "Category": "Binary Tree"
    },
    {
        "ID": "10254-10254",
        "Code": "from math import sqrt NEW_LINE def MinimumString ( x ) : NEW_LINE INDENT b = 1 NEW_LINE left_lim = sqrt ( x ) + 1.0 NEW_LINE right_lim = sqrt ( x ) + 2.0 NEW_LINE for i in range ( int ( left_lim ) , int ( right_lim ) + 1 ) : NEW_LINE INDENT if ( i > left_lim and i < right_lim ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT return b + r NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE print ( MinimumString ( X ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum size binary string required such that probability of deleting two 1 's at random is 1/X | Python3 implementation of the above approach ; Function returns the minimum size of the string ; From formula ; Left limit of r ; Right limit of r ; Smallest integer in the valid range ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10258-10258",
        "Code": "from math import sqrt , floor , ceil NEW_LINE def isPerfectSquare ( N ) : NEW_LINE INDENT floorSqrt = floor ( sqrt ( N ) ) NEW_LINE return ( N == floorSqrt * floorSqrt ) NEW_LINE DEDENT def legendreFunction ( N ) : NEW_LINE INDENT while ( N % 4 == 0 ) : NEW_LINE INDENT N //= 4 NEW_LINE DEDENT if ( N % 8 != 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def minSquares ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if i * i < N : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPerfectSquare ( N - i * i ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if ( legendreFunction ( N ) ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT return 4 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 123 NEW_LINE print ( minSquares ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of squares whose sum equals to a given number N | Set | Python3 program for the above approach ; Function that returns True if N is a perfect square ; Function that returns True check if N is sum of three squares ; Factor out the powers of 4 ; N is NOT of the form 4 ^ a * ( 8 b + 7 ) ; Function that finds the minimum number of square whose sum is N ; If N is perfect square ; If N is sum of 2 perfect squares ; If N is sum of 3 perfect squares ; Otherwise , N is the sum of 4 perfect squares ; Driver code ; Given number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10263-10263",
        "Code": "def isUgly ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( isUgly ( n // 2 ) ) NEW_LINE DEDENT if ( n % 3 == 0 ) : NEW_LINE INDENT return ( isUgly ( n // 3 ) ) NEW_LINE DEDENT if ( n % 5 == 0 ) : NEW_LINE INDENT return ( isUgly ( n // 5 ) ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT no = isUgly ( 14 ) NEW_LINE if ( no == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether a given number is an ugly number or not | Function to check if a number is an ugly number or not ; Base Cases ; Condition to check if the number is divided by 2 , 3 , or 5 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10264-10264",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getLastTwoPerson ( n ) : NEW_LINE INDENT total = n NEW_LINE head = newNode ( 1 ) NEW_LINE temp = head NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT temp . next = newNode ( i ) NEW_LINE temp = temp . next NEW_LINE DEDENT temp . next = head NEW_LINE temp = head NEW_LINE de = None NEW_LINE while ( total != 2 ) : NEW_LINE INDENT de = temp . next . next NEW_LINE temp . next . next = temp . next . next . next NEW_LINE temp = temp . next NEW_LINE del de NEW_LINE total -= 1 NEW_LINE DEDENT print ( temp . val , temp . next . val ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE getLastTwoPerson ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find last 2 survivors in N persons standing in a circle after killing next to immediate neighbour | Node for a Linked List ; Function to find the last 2 survivors ; Total is the count of alive people ; Initiating the list of n people ; Total != 2 is terminating condition because at last only two - person will remain alive ; de represent next person to be deleted or killed ; Last two person to survive ( in any order ) ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "10266-10266",
        "Code": "def calculate ( p , q ) : NEW_LINE INDENT mod = 998244353 NEW_LINE expo = 0 NEW_LINE expo = mod - 2 NEW_LINE while ( expo ) : NEW_LINE INDENT if ( expo & 1 ) : NEW_LINE INDENT p = ( p * q ) % mod NEW_LINE DEDENT q = ( q * q ) % mod NEW_LINE expo >>= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 1 NEW_LINE q = 4 NEW_LINE print ( calculate ( p , q ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the value of P and modular inverse of Q modulo 998244353 | Function to find the value of P * Q ^ - 1 mod 998244353 ; Loop to find the value until the expo is not zero ; Multiply p with q if expo is odd ; Reduce the value of expo by 2 ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10280-10280",
        "Code": "def numberOfObjects ( N , M ) : NEW_LINE INDENT initial = min ( N , M ) NEW_LINE final = ( N + M ) // 3 NEW_LINE return min ( initial , final ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE M = 7 NEW_LINE print ( numberOfObjects ( N , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of objects that can be created as per given conditions | Function for finding the maximum number of objects from N type - 1 and M type - 2 items ; Storing minimum of N and M ; Storing maximum number of objects from given items ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10281-10281",
        "Code": "import math NEW_LINE x , y = 0 , 0 NEW_LINE def gcd_extend ( a , b ) : NEW_LINE INDENT global x , y NEW_LINE if ( b == 0 ) : NEW_LINE INDENT x = 1 NEW_LINE y = 0 NEW_LINE return a NEW_LINE DEDENT else : NEW_LINE INDENT g = gcd_extend ( b , a % b ) NEW_LINE x1 , y1 = x , y NEW_LINE x = y1 NEW_LINE y = x1 - math . floor ( a / b ) * y1 NEW_LINE return g NEW_LINE DEDENT DEDENT def print_solution ( a , b , c ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT if ( c == 0 ) : NEW_LINE INDENT print ( \" Infinite ▁ Solutions ▁ Exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Solution ▁ exists \" ) NEW_LINE DEDENT DEDENT gcd = gcd_extend ( a , b ) NEW_LINE if ( c % gcd != 0 ) : NEW_LINE INDENT print ( \" No ▁ Solution ▁ exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" x ▁ = ▁ \" , int ( x * ( c / gcd ) ) , \" , ▁ y ▁ = ▁ \" , int ( y * ( c / gcd ) ) , sep = \" \" ) NEW_LINE DEDENT DEDENT a = 4 NEW_LINE b = 18 NEW_LINE c = 10 NEW_LINE print_solution ( a , b , c ) NEW_LINE",
        "Type": "py",
        "NL": "Find initial integral solution of Linear Diophantine equation if finite solution exists | Python3 program for the above approach ; Function to implement the extended euclid algorithm ; Base Case ; Recursively find the gcd ; Function to prlet the solutions of the given equations ax + by = c ; Condition for infinite solutions ; Condition for no solutions exist ; Condition for no solutions exist ; Print the solution ; Given coefficients ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10296-10296",
        "Code": "def DiStirngMatch ( Str ) : NEW_LINE INDENT N = len ( Str ) NEW_LINE arr = ( N + 1 ) * [ 0 ] NEW_LINE START , END = 0 , N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Str [ i ] == ' I ' ) : NEW_LINE INDENT arr [ i ] = START NEW_LINE START += 1 NEW_LINE DEDENT if ( Str [ i ] == ' D ' ) : NEW_LINE INDENT arr [ i ] = END NEW_LINE END -= 1 NEW_LINE DEDENT DEDENT arr [ N ] = START NEW_LINE return arr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Str = \" IDID \" NEW_LINE N = len ( Str ) NEW_LINE ptr = DiStirngMatch ( Str ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT print ( ptr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Generate an alternate increasing and decreasing Array | Function that returns generated array ; Dynamically allocate array ; START , END = 0 , N ; Iterate over array ; If Str [ i ] = = ' I ' assign arr [ i ] as START and increment START ; If str [ i ] = = ' D ' assign arr [ i ] as END and decrement END ; Assign A [ N ] as START ; Return starting address of array A ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "10297-10297",
        "Code": "from collections import defaultdict NEW_LINE def countQuadraples ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for a in range ( 1 , N + 1 ) : NEW_LINE INDENT for b in range ( 1 , N + 1 ) : NEW_LINE INDENT x = a * a + b * b NEW_LINE m [ x ] += 1 NEW_LINE DEDENT DEDENT for c in range ( 1 , N + 1 ) : NEW_LINE INDENT for d in range ( 1 , N + 1 ) : NEW_LINE INDENT x = c * c + d * d NEW_LINE if x in m : NEW_LINE INDENT cnt += m [ x ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 2 NEW_LINE print ( countQuadraples ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count quadruplets ( A , B , C , D ) till N such that sum of square of A and B is equal to that of C and D | Python3 program for the above approach ; Function to count the quadruples ; Counter variable ; Map to store the sum of pair ( a ^ 2 + b ^ 2 ) ; Iterate till N ; Calculate a ^ 2 + b ^ 2 ; Increment the value in map ; Check if this sum was also in a ^ 2 + b ^ 2 ; Return the count ; Driver Code ; Given N ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "103-103",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def push ( head_ref , node ) : NEW_LINE INDENT node . right = ( head_ref ) NEW_LINE node . left = None NEW_LINE if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . left = node NEW_LINE DEDENT ( head_ref ) = node NEW_LINE DEDENT def printList ( node ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( node ) ) : NEW_LINE INDENT print ( node [ i ] . data , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def spiralLevelOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE stk = [ ] NEW_LINE level = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT nodeCount = len ( q ) NEW_LINE if ( level & 1 ) : NEW_LINE INDENT while ( nodeCount > 0 ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE stk . append ( node ) NEW_LINE if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT nodeCount -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( nodeCount > 0 ) : NEW_LINE INDENT node = q [ - 1 ] NEW_LINE q . pop ( - 1 ) NEW_LINE stk . append ( node ) NEW_LINE if ( node . right != None ) : NEW_LINE INDENT q . insert ( 0 , node . right ) NEW_LINE DEDENT if ( node . left != None ) : NEW_LINE INDENT q . insert ( 0 , node . left ) NEW_LINE DEDENT nodeCount -= 1 NEW_LINE DEDENT DEDENT level += 1 NEW_LINE DEDENT head = [ ] NEW_LINE while ( len ( stk ) ) : NEW_LINE INDENT head . append ( stk [ 0 ] ) NEW_LINE stk . pop ( 0 ) NEW_LINE DEDENT print ( \" Created ▁ DLL ▁ is : \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . left . left . right = newNode ( 9 ) NEW_LINE root . left . right . left = newNode ( 10 ) NEW_LINE root . left . right . right = newNode ( 11 ) NEW_LINE root . right . left . right = newNode ( 13 ) NEW_LINE root . right . right . left = newNode ( 14 ) NEW_LINE spiralLevelOrder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert a Binary Tree into Doubly Linked List in spiral fashion | Binary tree node ; Given a reference to the head of a list and a node , inserts the node on the front of the list . ; Make right of given node as head and left as None ; change left of head node to given node ; move the head to point to the given node ; Function to prints contents of DLL ; Function to prcorner node at each level ; Base Case ; Create an empty deque for doing spiral level order traversal and enqueue root ; create a stack to store Binary Tree nodes to insert into DLL later ; nodeCount indicates number of Nodes at current level . ; Dequeue all Nodes of current level and Enqueue all Nodes of next level odd level ; dequeue node from front & push it to stack ; insert its left and right children in the back of the deque ; even level ; dequeue node from the back & push it to stack ; inserts its right and left children in the front of the deque ; head pointer for DLL ; pop all nodes from stack and push them in the beginning of the list ; Driver Code ; Let us create Binary Tree as shown in above example ; root . right . left . left = newNode ( 12 ) ; root . right . right . right = newNode ( 15 )",
        "Category": "Binary Tree"
    },
    {
        "ID": "10310-10310",
        "Code": "import math NEW_LINE def findGCD ( arr , n ) : NEW_LINE INDENT gcd = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT gcd = int ( math . gcd ( arr [ i ] , gcd ) ) NEW_LINE if ( gcd == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = int ( ( ( ( arr [ i ] * lcm ) ) / ( math . gcd ( arr [ i ] , lcm ) ) ) ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def findRatio ( arr , n ) : NEW_LINE INDENT gcd = findGCD ( arr , n ) NEW_LINE lcm = findLCM ( arr , n ) NEW_LINE print ( int ( lcm / gcd ) , \" : \" , \"1\" ) NEW_LINE DEDENT arr = [ 6 , 12 , 36 ] NEW_LINE N = len ( arr ) NEW_LINE findRatio ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Find the ratio of LCM to GCD of a given Array | Python3 program to implement above approach ; Function to calculate and return GCD of the given array ; Initialise GCD ; Once GCD is 1 , it will always be 1 with all other elements ; Return GCD ; Function to calculate and return LCM of the given array ; Initialise LCM ; LCM of two numbers is evaluated as [ ( a * b ) / gcd ( a , b ) ] ; Return LCM ; Function to print the ratio of LCM to GCD of the given array ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10322-10322",
        "Code": "def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( 2 * n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= 2 * n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n * 2 ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT primes = [ ] NEW_LINE for p in range ( 2 , ( 2 * n ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minChanges ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE ans = 0 NEW_LINE maxi = max ( arr ) NEW_LINE primes = SieveOfEratosthenes ( maxi ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = - 1 NEW_LINE for j in range ( len ( primes ) ) : NEW_LINE INDENT if ( arr [ i ] == primes [ j ] ) : NEW_LINE INDENT x = j NEW_LINE break NEW_LINE DEDENT elif ( arr [ i ] < primes [ j ] ) : NEW_LINE INDENT x = j NEW_LINE break NEW_LINE DEDENT DEDENT minm = abs ( primes [ x ] - arr [ i ] ) NEW_LINE if ( x > 1 ) : NEW_LINE INDENT minm = min ( minm , abs ( primes [ x - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT ans += minm NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 25 , 13 , 6 , 20 ] NEW_LINE print ( minChanges ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum changes required to make all Array elements Prime | Function to generate all primes ; If p is a prime ; Mark all its multiples as non - prime ; Store all prime numbers ; Return the list of primes ; Function to calculate the minimum increments to convert every array elements to a prime ; Extract maximum element of the given array ; Extract the index which has the next greater prime ; Store the difference between the prime and the array element ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10323-10323",
        "Code": "def calcSum ( k , n ) : NEW_LINE INDENT value = ( k * n * ( n + 1 ) ) // 2 NEW_LINE return value NEW_LINE DEDENT def findSum ( a , n , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( L % a [ i ] == 0 and L != 0 ) : NEW_LINE INDENT sum += ( calcSum ( a [ i ] , R // a [ i ] ) - calcSum ( a [ i ] , ( L - 1 ) // a [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += ( calcSum ( a [ i ] , R // a [ i ] ) - calcSum ( a [ i ] , L // a [ i ] ) ) NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 7 , 3 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE L = 7 NEW_LINE R = 20 NEW_LINE print ( findSum ( arr , N , L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of multiples of Array elements within a given range [ L , R ] | Function to find the sum of all multiples of N up to K ; Calculate the sum ; Return the sum ; Function to find the total sum ; If L is divisible by a [ i ] ; Otherwise ; Return the final sum ; Driver code ; Given array arr [ ] ; Given range ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10327-10327",
        "Code": "def get_concentration ( mass , volume ) : NEW_LINE INDENT if ( volume == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( mass / volume ) * 1000 ; NEW_LINE DEDENT DEDENT mass = 100.00 ; NEW_LINE volume = 500.00 ; NEW_LINE print ( get_concentration ( mass , volume ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the concentration of a solution using given Mass and Volume | Function to calculate concentration from the given mass of solute and volume of a solution ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10334-10334",
        "Code": "def PentacontahenagonNum ( N ) : NEW_LINE INDENT return ( 49 * N * N - 47 * N ) // 2 ; NEW_LINE DEDENT N = 3 ; NEW_LINE print ( \"3rd ▁ Pentacontahenagon ▁ Number ▁ is \" , PentacontahenagonNum ( N ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Pentacontahenagon Number | Function to find the N - th Pentacontahenagon Number ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10341-10341",
        "Code": "def isRepdigit ( num , b ) : NEW_LINE INDENT prev = - 1 NEW_LINE while ( num ) : NEW_LINE INDENT digit = num % b NEW_LINE num //= b NEW_LINE if ( prev != - 1 and digit != prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = digit NEW_LINE DEDENT return True NEW_LINE DEDENT num = 2000 NEW_LINE base = 7 NEW_LINE if ( isRepdigit ( num , base ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Repdigit Numbers | Function to check if a number is a Repdigit number ; To store previous digit ( Assigning initial value which is less than any digit ) ; Traverse all digits from right to left and check if any digit is smaller than previous . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10342-10342",
        "Code": "limit = 10000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def getSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT Sum = Sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def isHonakerPrime ( n ) : NEW_LINE INDENT pos = position [ n ] NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return bool ( getSum ( n ) == getSum ( pos ) ) NEW_LINE DEDENT sieve ( ) NEW_LINE N = 121 NEW_LINE if ( isHonakerPrime ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Honaker Prime Number | Python3 program for the above approach ; Function to precompute the position of every prime number using Sieve ; 0 and 1 are not prime numbers ; Variable to store the position ; Incrementing the position for every prime number ; Function to get sum of digits ; Function to check whether the given number is Honaker Prime number or not ; Precompute the prime numbers till 10 ^ 6 ; Given Number ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10343-10343",
        "Code": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT return ( x * power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT def isPerfectDigitalInvariant ( x ) : NEW_LINE INDENT fixed_power = 0 NEW_LINE while True : NEW_LINE INDENT fixed_power += 1 NEW_LINE temp = x NEW_LINE summ = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT r = temp % 10 NEW_LINE summ = summ + power ( r , fixed_power ) NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( summ == x ) : NEW_LINE INDENT return ( True ) NEW_LINE DEDENT if ( summ > x ) : NEW_LINE INDENT return ( False ) NEW_LINE DEDENT DEDENT DEDENT N = 4150 NEW_LINE if ( isPerfectDigitalInvariant ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Perfect Digital Invariants number | Function to find the sum of divisors ; Function to check whether the given number is Perfect Digital Invariant number or not ; For each digit in temp ; If satisfies Perfect Digital Invariant condition ; If sum exceeds n , then not possible ; Given Number N ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10346-10346",
        "Code": "import math NEW_LINE def isComposite ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT def concatenatePrimeFactors ( n ) : NEW_LINE INDENT concatenate = \" \" NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT concatenate += \"2\" NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i <= int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT concatenate += str ( i ) NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT concatenate += str ( n ) NEW_LINE DEDENT return concatenate NEW_LINE DEDENT def isEnlightened ( N ) : NEW_LINE INDENT if ( not isComposite ( N ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = str ( N ) NEW_LINE prefixConc = concatenatePrimeFactors ( N ) NEW_LINE return int ( prefixConc ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 250 NEW_LINE if ( isEnlightened ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Enlightened Numbers | Python3 implementation of the above approach ; Function to check if N is a Composite Number ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to return concatenation of distinct prime factors of a given number n ; Handle prime factor 2 explicitly so that can optimally handle other prime factors . ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check if a number is is an enlightened number ; Number should not be prime ; Converting N to string ; Function call ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10354-10354",
        "Code": "import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = math . log10 ( n ) NEW_LINE n = ( n / math . pow ( 10 , digits ) ) NEW_LINE return n NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT def isGapful ( n ) : NEW_LINE INDENT concatenation = ( firstDigit ( n ) * 10 ) + lastDigit ( n ) NEW_LINE return ( n % concatenation ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 108 NEW_LINE if ( isGapful ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Gapful Numbers | Python3 program for the above approach ; Find the first digit ; Find total number of digits - 1 ; Find first digit ; Return first digit ; Find the last digit ; return the last digit ; A function to check Gapful numbers ; Return true if n is gapful number ; Driver Code ; Given Number ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10359-10359",
        "Code": "MAX = 1000050 NEW_LINE spf = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def calculate_SPF ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT spf [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAX + 1 , 2 ) : NEW_LINE INDENT spf [ i ] = 2 ; NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= MAX ) : NEW_LINE INDENT if ( spf [ i ] == i ) NEW_LINE INDENT j = i * i NEW_LINE while ( j <= MAX ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i ; NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT tfactor = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE pre = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def CountTotalfactors ( ) : NEW_LINE INDENT tfactor [ 1 ] = pre [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT mspf = spf [ i ] ; NEW_LINE prim = mspf ; NEW_LINE temp = i ; NEW_LINE cnt = 0 ; NEW_LINE while ( temp % mspf == 0 ) : NEW_LINE INDENT temp //= mspf ; NEW_LINE cnt += 1 ; NEW_LINE prim = prim * mspf ; NEW_LINE DEDENT tfactor [ i ] = ( cnt + 1 ) * NEW_LINE INDENT tfactor [ temp ] ; NEW_LINE DEDENT pre [ i ] = pre [ i - 1 ] + NEW_LINE INDENT tfactor [ i ] ; NEW_LINE DEDENT DEDENT DEDENT def BinarySearch ( X ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = MAX - 1 ; NEW_LINE while ( start < end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( pre [ mid ] == X ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( pre [ mid ] < X ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid ; NEW_LINE DEDENT DEDENT return start ; NEW_LINE DEDENT def findSumOfCount ( X ) : NEW_LINE INDENT calculate_SPF ( ) ; NEW_LINE CountTotalfactors ( ) ; NEW_LINE print ( BinarySearch ( X ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 10 ; NEW_LINE findSumOfCount ( X ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimise N such that sum of count of all factors upto N is greater than or equal to X | Python3 program for the above approach ; Array to store smallest prime factors of each no . ; Function to calculate smallest prime factor of N . ; Marking spf [ j ] if it is not previously marked ; Array to store the count of factor for N ; Prefix array which contains the count of factors from 1 to N ; Function to count total factors from 1 to N ; Store total factors of i ; Stores total factors from 1 to i ; Function to search lowest X such that the given condition is satisfied ; Find mid ; Search in the right half ; Search in the left half ; Return the position after Binary Search ; Function to find the required sum ; Precompute smallest prime factor of each value ; Calculate count of total factors from 1 to N ; Binary search to find minimum N ; Driver code ; Given Sum ; Function Call",
        "Category": "Binary Search"
    },
    {
        "ID": "10362-10362",
        "Code": "import math NEW_LINE def gaussEaster ( Y ) : NEW_LINE INDENT A = Y % 19 NEW_LINE B = Y % 4 NEW_LINE C = Y % 7 NEW_LINE P = math . floor ( Y / 100 ) NEW_LINE Q = math . floor ( ( 13 + 8 * P ) / 25 ) NEW_LINE M = ( 15 - Q + P - P // 4 ) % 30 NEW_LINE N = ( 4 + P - P // 4 ) % 7 NEW_LINE D = ( 19 * A + M ) % 30 NEW_LINE E = ( 2 * B + 4 * C + 6 * D + N ) % 7 NEW_LINE days = ( 22 + D + E ) NEW_LINE if ( ( D == 29 ) and ( E == 6 ) ) : NEW_LINE INDENT print ( Y , \" - 04-19\" ) NEW_LINE return NEW_LINE DEDENT elif ( ( D == 28 ) and ( E == 6 ) ) : NEW_LINE INDENT print ( Y , \" - 04-18\" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT if ( days > 31 ) : NEW_LINE INDENT print ( Y , \" - 04 - \" , ( days - 31 ) ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( Y , \" - 03 - \" , days ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT Y = 2020 NEW_LINE gaussEaster ( Y ) NEW_LINE",
        "Type": "py",
        "NL": "How to calculate the Easter date for a given year using Gauss ' Algorithm | Python3 program for the above approach ; Function calculates and prints easter date for given year Y ; All calculations done on the basis of Gauss Easter Algorithm ; A corner case , when D is 29 ; Another corner case , when D is 28 ; If days > 31 , move to April April = 4 th Month ; Otherwise , stay on March March = 3 rd Month ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10368-10368",
        "Code": "def placeValue ( N , num ) : NEW_LINE INDENT total = 1 NEW_LINE value = 0 NEW_LINE rem = 0 NEW_LINE while ( True ) : NEW_LINE INDENT rem = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( rem == num ) : NEW_LINE INDENT value = total * rem NEW_LINE break NEW_LINE DEDENT total = total * 10 NEW_LINE DEDENT return value NEW_LINE DEDENT D = 5 NEW_LINE N = 85932 NEW_LINE print ( placeValue ( N , D ) ) NEW_LINE",
        "Type": "py",
        "NL": "Place Value of a given digit in a number | Function to find place value ; Digit , which we want to find place value . ; Number from where we want to find place value .",
        "Category": "Math"
    },
    {
        "ID": "10379-10379",
        "Code": "import math NEW_LINE def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def countDigit ( n ) : NEW_LINE INDENT return math . floor ( math . log10 ( n ) + 1 ) NEW_LINE DEDENT def isBrilliant ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT x = n // i NEW_LINE if ( isPrime [ i ] and isPrime [ x ] and x * i == n ) : NEW_LINE INDENT if ( countDigit ( i ) == countDigit ( x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT n = 1711 NEW_LINE if ( isBrilliant ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Brilliant Numbers | Python3 program for the above approach ; Function to generate all prime numbers less than n ; Initialize all entries of boolean array as true . A value in isPrime [ i ] will finally be false if i is Not a prime ; If isPrime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to return the number of digits in a number ; Function to check if N is a Brilliant number ; Generating primes using Sieve ; Traversing all numbers to find first pair ; Given Number ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "10386-10386",
        "Code": "def checkSame ( n , b ) : NEW_LINE INDENT m = { } NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE n = n // b NEW_LINE if r in m : NEW_LINE INDENT m [ r ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ r ] = 1 NEW_LINE DEDENT DEDENT last = - 1 NEW_LINE for i in m : NEW_LINE INDENT if last != - 1 and m [ i ] != last : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT last = m [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 9 NEW_LINE base = 2 NEW_LINE if ( checkSame ( n , base ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Digitally balanced numbers | Function to check if the digits in the number is the same number of digits ; Loop to iterate over the digits of the number N ; Loop to iterate over the map ; Driver code ; Function to check",
        "Category": "Hash Table"
    },
    {
        "ID": "10390-10390",
        "Code": "def CountGreater ( n , k ) : NEW_LINE INDENT a = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) > k ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return a NEW_LINE DEDENT def PrintList ( ans ) : NEW_LINE INDENT for i in ans : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT def getNumber ( n , k ) : NEW_LINE INDENT count = CountGreater ( n , k ) NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( n ) NEW_LINE return NEW_LINE DEDENT ans = [ ] NEW_LINE changed = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( changed == True ) : NEW_LINE INDENT ans . insert ( 0 , digit ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( count == 0 and digit < k ) : NEW_LINE INDENT ans . insert ( 0 , digit + 1 ) NEW_LINE changed = True NEW_LINE DEDENT else : NEW_LINE INDENT ans . insert ( 0 , 1 ) NEW_LINE if ( digit > k ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT DEDENT n = n // 10 NEW_LINE DEDENT if ( changed == False ) : NEW_LINE INDENT ans . insert ( 0 , 1 ) NEW_LINE DEDENT PrintList ( ans ) NEW_LINE return NEW_LINE DEDENT N = 51234 NEW_LINE K = 4 NEW_LINE getNumber ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number greater than or equal to N using only digits 1 to K | Function to count the digits greater than K ; Function to print the list ; Function to find the number greater than or equal to n , which is only made of first k digits ; If the number itself satisfy the conditions ; Check digit from back ; If digit > K is present previously and current digit is less than K ; If current digit is greater than K ; If an extra digit needs to be added ; Print the number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10393-10393",
        "Code": "def seriesSumUtil ( k , n , prevSum , multi , add ) : NEW_LINE INDENT if ( k == n + 1 ) : NEW_LINE INDENT return prevSum ; NEW_LINE DEDENT multi = multi * k ; NEW_LINE add = add + k ; NEW_LINE prevSum = prevSum + multi - add ; NEW_LINE return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; NEW_LINE DEDENT def seriesSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT prevSum = 0 ; NEW_LINE multi = 1 ; NEW_LINE add = 1 ; NEW_LINE return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE print ( seriesSum ( N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of series formed by difference between product and sum of N natural numbers | Recursive Function to calculate the sum upto Nth term ; If N - th term is calculated ; Update multi to store product upto K ; Update add to store sum upto K ; Update prevSum to store sum upto K ; Proceed to next K ; Function to calculate and return the Sum upto Nth term ; Recursive Function ; Driver code",
        "Category": "Recursion"
    },
    {
        "ID": "10395-10395",
        "Code": "def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT ans += N NEW_LINE N //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT N = 5 NEW_LINE solve ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Count of total bits toggled / flipped in binary representation of 0 to N | Function to count and pr the required number of toggles ; Store the count of toggles ; Add the contribution of the current LSB ; Update N ; Print the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10396-10396",
        "Code": "def maximumAND ( L , R ) : NEW_LINE INDENT return R NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 3 NEW_LINE r = 7 NEW_LINE print ( maximumAND ( l , r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum Bitwise AND pair ( X , Y ) from given range such that X and Y can be same | Function to return the maximum bitwise AND ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "1040-1040",
        "Code": "def reverserWords ( string ) : NEW_LINE INDENT st = list ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] != \" ▁ \" : NEW_LINE INDENT st . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = \" \" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = \" \" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Geeks ▁ for ▁ Geeks \" NEW_LINE reverserWords ( string ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse individual words | reverses individual words of a string ; Traverse given string and push all characters to stack until we see a space . ; When we see a space , we print contents of stack . ; Since there may not be space after last word . ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "10400-10400",
        "Code": "x , y , x1 , y1 = 0 , 0 , 0 , 0 NEW_LINE x0 , y0 , g = 0 , 0 , 0 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT global x , y , x1 , y1 NEW_LINE if ( b == 0 ) : NEW_LINE INDENT x = 1 NEW_LINE y = 0 NEW_LINE return a NEW_LINE DEDENT store_gcd = gcd ( b , a % b ) NEW_LINE x = y1 NEW_LINE y = x1 - y1 * ( a // b ) NEW_LINE return store_gcd NEW_LINE DEDENT def possible_solution ( a , b , c ) : NEW_LINE INDENT global x0 , y0 , g NEW_LINE g = gcd ( abs ( a ) , abs ( b ) ) NEW_LINE if ( c % g != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x0 *= c // g NEW_LINE y0 *= c // g NEW_LINE if ( a < 0 ) : NEW_LINE INDENT x0 *= - 1 NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT y0 *= - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def shift_solution ( a , b , shift_var ) : NEW_LINE INDENT global x , y NEW_LINE x += shift_var * b NEW_LINE y -= shift_var * a NEW_LINE DEDENT def find_min_sum ( a , b , c ) : NEW_LINE INDENT global x , y , g NEW_LINE x , y , g = 0 , 0 , 0 NEW_LINE if ( possible_solution ( a , b , c ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( g != 0 ) : NEW_LINE INDENT a //= g NEW_LINE b //= g NEW_LINE DEDENT if a > 0 : NEW_LINE INDENT sign_a = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign_a = - 1 NEW_LINE DEDENT if b > 0 : NEW_LINE INDENT sign_b = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign_b = - 1 NEW_LINE DEDENT shift_solution ( a , b , - x // b ) NEW_LINE if ( x < 0 ) : NEW_LINE INDENT shift_solution ( a , b , sign_b ) NEW_LINE DEDENT minx1 = x NEW_LINE shift_solution ( a , b , y // a ) NEW_LINE if ( y < 0 ) : NEW_LINE INDENT shift_solution ( a , b , - sign_a ) NEW_LINE DEDENT minx2 = x NEW_LINE if ( minx2 > x ) : NEW_LINE INDENT temp = minx2 NEW_LINE minx2 = x NEW_LINE x = temp NEW_LINE DEDENT minx = max ( minx1 , minx2 ) NEW_LINE if ( minx > x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT miny = ( c - a * x ) // b NEW_LINE return ( miny + minx ) NEW_LINE DEDENT a , b , c = 2 , 2 , 0 NEW_LINE print ( find_min_sum ( a , b , c ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of minimum value of x and y satisfying the equation ax + by = c | Python3 program for the above approach ; x and y store solution of equation ax + by = g ; Euclidean Algorithm ; store_gcd returns the gcd of a and b ; Function to find any possible solution ; Condition if solution does not exists ; Adjusting the sign of x0 and y0 ; Function to shift solution ; Shifting to obtain another solution ; Function to find minimum value of x and y ; g is the gcd of a and b ; Store sign of a and b ; If x is less than 0 , then shift solution ; If y is less than 0 , then shift solution ; Find intersection such that both x and y are positive ; miny is value of y corresponding to minx ; Returns minimum value of x + y ; Given a , b , and c ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10435-10435",
        "Code": "import math ; NEW_LINE def isDroll ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum_even = 0 ; NEW_LINE sum_odd = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT sum_even += 2 ; NEW_LINE n = n // 2 ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT sum_odd += i ; NEW_LINE n = n // i ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT sum_odd += n ; NEW_LINE DEDENT return sum_even == sum_odd ; NEW_LINE DEDENT N = 72 ; NEW_LINE if ( isDroll ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Droll Numbers | Python3 program for the above approach ; Function to check droll numbers ; To store sum of even prime factors ; To store sum of odd prime factors ; Add the number of 2 s that divide n in sum_even ; N must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Condition to check droll number ; Given Number N ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10437-10437",
        "Code": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT TEN = 10 NEW_LINE def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n = n // TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def OrmistonPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and areAnagrams ( n1 , n2 ) ) NEW_LINE DEDENT n1 , n2 = 1913 , 1931 NEW_LINE if ( OrmistonPrime ( n1 , n2 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Ormiston prime Pairs | Function to check if the number is a prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to update the frequency array such that freq [ i ] stores the frequency of digit i in n ; While there are digits left to process ; Update the frequency of the current digit ; Remove the last digit ; Function that returns true if a and b are anagrams of each other ; To store the frequencies of the digits in a and b ; Update the frequency of the digits in a ; Update the frequency of the digits in b ; Match the frequencies of the common digits ; If frequency differs for any digit then the numbers are not anagrams of each other ; Returns true if n1 and n2 are Ormiston primes ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1044-1044",
        "Code": "from typing import List NEW_LINE MAXN = 100005 NEW_LINE def makeNext ( arr : List [ int ] , n : int , nextBig : List [ int ] ) -> None : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT nextBig [ i ] = i NEW_LINE while len ( s ) and s [ - 1 ] [ 0 ] < arr [ i ] : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) : NEW_LINE INDENT nextBig [ i ] = s [ - 1 ] [ 1 ] NEW_LINE DEDENT s . append ( ( arr [ i ] , i ) ) NEW_LINE DEDENT DEDENT def makePrev ( arr : List [ int ] , n : int , prevBig : List [ int ] ) -> None : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prevBig [ i ] = - 1 NEW_LINE while ( len ( s ) and s [ - 1 ] [ 0 ] < arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) ) : NEW_LINE INDENT prevBig [ i ] = s [ - 1 ] [ 1 ] NEW_LINE DEDENT s . append ( ( arr [ i ] , i ) ) NEW_LINE DEDENT DEDENT def wrapper ( arr : List [ int ] , n : int ) -> int : NEW_LINE INDENT nextBig = [ 0 ] * MAXN NEW_LINE prevBig = [ 0 ] * MAXN NEW_LINE maxi = [ 0 ] * MAXN NEW_LINE ans = 0 NEW_LINE makePrev ( arr , n , prevBig ) NEW_LINE makeNext ( arr , n , nextBig ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( nextBig [ i ] != i ) : NEW_LINE INDENT maxi [ nextBig [ i ] - i ] = max ( maxi [ nextBig [ i ] - i ] , i - prevBig [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT ans += maxi [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( wrapper ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count subarrays where second highest lie before highest | Python3 program to count number of distinct instance where second highest number lie before highest number in all subarrays . ; Finding the next greater element of the array . ; Finding the previous greater element of the array . ; Wrapper Function ; Finding previous largest element ; Finding next largest element ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "10450-10450",
        "Code": "def strikerate ( bowls , runs ) : NEW_LINE INDENT z = ( float ( runs ) / bowls ) * 100 ; NEW_LINE return z ; NEW_LINE DEDENT A = 264 ; NEW_LINE B = 173 ; NEW_LINE print ( strikerate ( B , A ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "How to calculate strike rate of a batsman | function to calculate strike rate of a batsman ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10451-10451",
        "Code": "import math NEW_LINE def factorize ( N ) : NEW_LINE INDENT count = 0 NEW_LINE cnt = 0 NEW_LINE while ( ( N % 2 ) == 0 ) : NEW_LINE INDENT N = N // 2 NEW_LINE count += 1 NEW_LINE DEDENT cnt = cnt + count NEW_LINE sq = int ( math . sqrt ( N ) ) NEW_LINE for i in range ( 3 , sq , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE N = N // i NEW_LINE DEDENT cnt = cnt + count NEW_LINE DEDENT if ( N > 2 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def ifNumberExists ( X , Y ) : NEW_LINE INDENT C = X - Y - 1 NEW_LINE dsum = factorize ( X ) NEW_LINE if ( dsum >= C ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 NEW_LINE Y = 4 NEW_LINE ifNumberExists ( X , Y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number exists with X divisors out of which Y are composite | Python3 program to check if a number exists having exactly X positive divisors out of which Y are composite divisors ; Count the number of times 2 divides N ; Check for all possible numbers that can divide it ; If N at the end is a prime number . ; Function to check if any such number exists ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10472-10472",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , s ) : NEW_LINE INDENT self . i = s NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def Majority_in_linklist ( head ) : NEW_LINE INDENT s , t = \" \" , \" \" NEW_LINE p , q = 0 , 0 NEW_LINE ptr = None NEW_LINE while head != None : NEW_LINE INDENT if s == head . i : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if t == head . i : NEW_LINE INDENT q = q + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if p == 0 : NEW_LINE INDENT s = head . i NEW_LINE p = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if q == 0 : NEW_LINE INDENT t = head . i NEW_LINE q = 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = p - 1 NEW_LINE q = q - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT head = head . next NEW_LINE DEDENT head = ptr NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE while head != None : NEW_LINE INDENT if s == head . i : NEW_LINE INDENT p = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if t == head . i : NEW_LINE INDENT q = 1 NEW_LINE DEDENT DEDENT head = head . next NEW_LINE DEDENT if p > q : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return t NEW_LINE DEDENT DEDENT ptr = None NEW_LINE head = Node ( \" geeks \" ) NEW_LINE head . next = Node ( \" geeks \" ) NEW_LINE head . next . next = Node ( \" abcd \" ) NEW_LINE head . next . next . next = Node ( \" game \" ) NEW_LINE head . next . next . next . next = Node ( \" game \" ) NEW_LINE head . next . next . next . next . next = Node ( \" knight \" ) NEW_LINE head . next . next . next . next . next . next = Node ( \" harry \" ) NEW_LINE head . next . next . next . next . next . next . next = Node ( \" geeks \" ) NEW_LINE print ( Majority_in_linklist ( head ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the element in a linked list with frequency at least N / 3 | Structure of a node for the linked list ; Function to find and return the element with frequency of at least N / 3 ; Candidates for being the required majority element ; Store the frequencies of the respective candidates ; Iterate all nodes ; Increase frequency of candidate s ; Increase frequency of candidate t ; Set the new sting as candidate for majority ; Set the new sting as second candidate for majority ; Decrease the frequency ; Check the frequency of two final selected candidate linklist ; Increase the frequency of first candidate ; Increase the frequency of second candidate ; Return the string with higher frequency ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "10477-10477",
        "Code": "def gonNum120 ( n ) : NEW_LINE INDENT return ( 118 * n * n - 116 * n ) // 2 ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( gonNum120 ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "120 | Function to find the nth 120 - gon Number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10505-10505",
        "Code": "from math import log10 , floor NEW_LINE def numberOfDigits ( N ) : NEW_LINE INDENT nod = floor ( log10 ( N ) + 1 ) ; NEW_LINE toDecrease = ( pow ( 10 , nod ) - 1 ) // 9 NEW_LINE print ( ( N + 1 ) * nod - toDecrease ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 13 NEW_LINE numberOfDigits ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of digits after concatenation of first N positive integers | Python3 program to find the number of digits after concatenating the first N positive integers ; Function to find the number of digits after concatenating the first N positive integers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10508-10508",
        "Code": "def isPossible ( arr , N , K ) : NEW_LINE INDENT oddCount = 0 NEW_LINE evenCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT evenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( evenCount == N or ( oddCount == N and K % 2 == 0 ) or ( K == N and oddCount % 2 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 8 ] NEW_LINE K = 5 NEW_LINE N = len ( arr ) NEW_LINE if ( isPossible ( arr , N , K ) ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if sum of exactly K elements of the Array can be odd or not | Function returns true if it is possible to have odd sum ; Counting number of odd and even elements ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10514-10514",
        "Code": "from math import * NEW_LINE def prob ( x , y ) : NEW_LINE INDENT num = abs ( x - y + 1 ) * abs ( x - y + 1 ) NEW_LINE den = ( x + 1 ) * ( x + 1 ) NEW_LINE gcd1 = gcd ( num , den ) NEW_LINE print ( num // gcd1 , end = \" \" ) NEW_LINE print ( \" / \" , end = \" \" ) NEW_LINE print ( den // gcd1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE Y = 1 NEW_LINE prob ( X , Y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability that an arbitrary positive divisor of 10 ^ X is an integral multiple of 10 ^ Y | Python3 program to find the probability of an arbitrary positive divisor of Xth power of 10 to be a multiple of Yth power of 10 ; Function to calculate and print the required probability ; Count of potential divisors of X - th power of 10 which are also multiples of Y - th power of 10 ; Count of divisors of X - th power of 10 ; Calculate GCD ; Print the reduced fraction probability ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10515-10515",
        "Code": "import math ; NEW_LINE def is_Chiliagon ( N ) : NEW_LINE INDENT n = ( 996 + math . sqrt ( 7984 * N + 992016 ) ) // 1996 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT N = 1000 ; NEW_LINE if ( is_Chiliagon ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check if N is a Chiliagon Number | Python3 for the above approach ; Function to check that if N is Chiliagon Number or not ; Condition to check if N is a Chiliagon Number ; Given Number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10516-10516",
        "Code": "def commonSubarrays ( A , B , N ) : NEW_LINE INDENT Map = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT Map [ A [ i ] ] = i NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT B [ i ] = Map [ B [ i ] ] NEW_LINE DEDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT K = 1 NEW_LINE i += 1 NEW_LINE while i < N and B [ i ] == B [ i - 1 ] + 1 : NEW_LINE INDENT i += 1 NEW_LINE K += 1 NEW_LINE DEDENT count = count + ( ( K ) * ( K + 1 ) ) // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 3 NEW_LINE A = [ 1 , 2 , 3 ] NEW_LINE B = [ 2 , 3 , 1 ] NEW_LINE print ( commonSubarrays ( A , B , N ) ) NEW_LINE N = 5 NEW_LINE A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE B = [ 2 , 3 , 1 , 4 , 5 ] NEW_LINE print ( commonSubarrays ( A , B , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of common subarrays in two different permutations of 1 to N | Python3 implementation of above approach ; Initialising Map for Index Mapping ; Mapping elements of A ; Modify elements of B according to Map ; Changing B [ i ] as the index of B [ i ] in A ; Count of common subarrays ; Traversing array B ; While consecutive elements are found , we increment K ; Add number of subarrays with length K to total count ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10520-10520",
        "Code": "def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def derivative ( x ) : NEW_LINE INDENT return 3 * x * x NEW_LINE DEDENT def Image ( x , k ) : NEW_LINE INDENT return x * x * x - k NEW_LINE DEDENT def next_power ( a_t , t , a1 , prime , k ) : NEW_LINE INDENT power_p = int ( pow ( prime , t + 1 ) ) NEW_LINE next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p NEW_LINE if ( next_a < 0 ) : NEW_LINE INDENT next_a += power_p NEW_LINE return next_a NEW_LINE DEDENT return next_a NEW_LINE DEDENT def powerOfPrime ( prime , power , k , a1 ) : NEW_LINE INDENT if ( derivative ( a1 ) != 0 ) : NEW_LINE INDENT a_t = a1 NEW_LINE for p in range ( 1 , power ) : NEW_LINE INDENT a_t = next_power ( a_t , p , a1 , prime , k ) NEW_LINE DEDENT return a_t NEW_LINE DEDENT return - 1 NEW_LINE DEDENT prime = 7 NEW_LINE a1 = 3 NEW_LINE power = 2 NEW_LINE k = 3 NEW_LINE print ( powerOfPrime ( prime , power , k , a1 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Hensel 's Lemma | Function to find the modular inverse of a modulo m ; Apply the Euclidean algorithm , to find the modular inverse ; Function to find the derivative of f ( x ) and f '(x) = 3 * (x ^ 2) ; Function to find the image of x in f ( x ) = x ^ 3 - k . ; Function to find the next power of the number ; Next power of prime for which solution is to be found ; Using Hensel 's recursion to  find the solution(next_a) for  next power of prime ; If next_a < 0 return equivalent positive remainder modulo p ; Return the next power of a ; Function to find the solution of the required exponent of prime ; The lemma does not work for derivative of f ( x ) at a1 ; Looping from 1 to power of prime whose solution is to be found ; Final answer after evaluating all the exponents up till the required exponent ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10522-10522",
        "Code": "import math NEW_LINE def count_same_digit ( L , R ) : NEW_LINE INDENT tmp = 0 ; ans = 0 ; NEW_LINE n = int ( math . log10 ( R ) + 1 ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tmp = tmp * 10 + 1 ; NEW_LINE for j in range ( 1 , 9 ) : NEW_LINE INDENT if ( L <= ( tmp * j ) and ( tmp * j ) <= R ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT L = 12 ; R = 68 ; NEW_LINE print ( count_same_digit ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of numbers with all digits same in a given range | Python3 program to count the total numbers in the range L and R which have all the digit same ; Function that count the total numbersProgram between L and R which have all the digit same ; length of R ; tmp has all digits as 1 ; For each multiple of tmp in range 1 to 9 , check if it present in range [ L , R ] ; Increment the required count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10523-10523",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def findlcm ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ( ( arr [ i ] * ans ) ) // ( gcd ( arr [ i ] , ans ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def addReduce ( n , num , den ) : NEW_LINE INDENT final_numerator = 0 NEW_LINE final_denominator = findlcm ( den , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT final_numerator = ( final_numerator + ( num [ i ] ) * ( final_denominator // den [ i ] ) ) NEW_LINE DEDENT GCD = gcd ( final_numerator , final_denominator ) NEW_LINE final_numerator //= GCD NEW_LINE final_denominator //= GCD NEW_LINE print ( final_numerator , \" / \" , final_denominator ) NEW_LINE DEDENT N = 3 NEW_LINE arr1 = [ 1 , 2 , 5 ] NEW_LINE arr2 = [ 2 , 1 , 6 ] NEW_LINE addReduce ( N , arr1 , arr2 ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of given N fractions in reduced form | Function to find GCD of a & b using Euclid Lemma ; Base Case ; Function to find the LCM of all elements in arr [ ] ; Initialize result ; Iterate arr [ ] to find LCM ; Return the final LCM ; Function to find the sum of N fraction in reduced form ; To store the sum of all final numerators ; Find the LCM of all denominator ; Find the sum of all N numerators & denominators ; Add each fraction one by one ; Find GCD of final numerator and denominator ; Convert into reduced form by dividing from GCD ; Print the final fraction ; Given N ; Given Numerator ; Given Denominator ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10529-10529",
        "Code": "from math import * NEW_LINE MOD = 1000000007 NEW_LINE def inv ( a ) : NEW_LINE INDENT o = 1 NEW_LINE p = MOD - 2 NEW_LINE while ( p > 0 ) : NEW_LINE INDENT if ( p % 2 == 1 ) : NEW_LINE INDENT o = ( o * a ) % MOD NEW_LINE DEDENT a = ( a * a ) % MOD NEW_LINE p >>= 1 NEW_LINE DEDENT return o NEW_LINE DEDENT inv6 = inv ( 6 ) NEW_LINE def sumOfSquares ( n ) : NEW_LINE INDENT n %= MOD NEW_LINE return ( ( ( n * ( n + 1 ) ) % MOD * ( 2 * n + 1 ) ) % MOD * inv6 ) % MOD NEW_LINE DEDENT def sums ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT curStart = 2 NEW_LINE ans = 0 NEW_LINE sqrtN = int ( sqrt ( n ) ) NEW_LINE while ( curStart <= n // curStart ) : NEW_LINE INDENT V = n // ( curStart * curStart ) NEW_LINE end = int ( sqrt ( n // V ) ) NEW_LINE ans += ( ( n // ( curStart * curStart ) % MOD * ( sumOfSquares ( end ) + MOD - sumOfSquares ( curStart - 1 ) ) ) % MOD ) NEW_LINE if ( ans >= MOD ) : NEW_LINE INDENT ans -= MOD NEW_LINE DEDENT curStart = end + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Input = [ 5 ] NEW_LINE for x in Input : NEW_LINE INDENT print ( \" sum ▁ of ▁ all ▁ perfect ▁ \" \\ \" square ▁ \" , end = ' ' ) NEW_LINE print ( \" divisors ▁ from ▁ 1 ▁ to \" , x , \" is : ▁ \" , end = ' ' ) NEW_LINE print ( x + sums ( x ) ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Sum of all perfect square divisors of numbers from 1 to N | Python3 program to find the sum of all perfect square divisors of numbers from 1 to N ; Function for finding inverse of a number iteratively Here we will find the inverse of 6 , since it appears as denominator in the formula of sum of squares from 1 to N ; Store the value of the inverse of 6 once as we don 't need to call the function again and again ; Formula for finding the sum of first n squares ; No perfect square exists which is less than 4 ; Starting from 2 , present value of start is denoted here as curStart ; Finding end of the segment for which the contribution will be same ; Using the above mentioned formula to find ans % MOD ; Now for mthe next iteration start will become end + 1 ; Finally return the answer ; Driver Code ; Here we are adding x because we have not counted 1 as perfect squares so if u want to add it you can just add that number to the ans",
        "Category": "Math"
    },
    {
        "ID": "10533-10533",
        "Code": "import math NEW_LINE def get_divisors ( A ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( 1 ) NEW_LINE for i in range ( 2 , math . floor ( math . sqrt ( A ) ) + 1 ) : NEW_LINE INDENT if ( A % i == 0 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE if ( ( i * i ) != A ) : NEW_LINE INDENT ans . append ( A // i ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def summ_Possible ( sett , summ ) : NEW_LINE INDENT n = len ( sett ) NEW_LINE subsett = [ [ 0 for i in range ( summ + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subsett [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , summ + 1 ) : NEW_LINE INDENT subsett [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( summ + 1 ) : NEW_LINE INDENT if ( j < sett [ i - 1 ] ) : NEW_LINE INDENT subsett [ i ] [ j ] = subsett [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j >= sett [ i - 1 ] ) : NEW_LINE INDENT subsett [ i ] [ j ] = ( subsett [ i - 1 ] [ j ] or subsett [ i - 1 ] [ j - sett [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return subsett [ n ] [ summ ] NEW_LINE DEDENT def Is_Practical ( A ) : NEW_LINE INDENT divisors = [ ] NEW_LINE divisors = get_divisors ( A ) NEW_LINE for i in range ( 2 , A ) : NEW_LINE INDENT if ( summ_Possible ( divisors , i ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def print_practica_No ( A , B ) : NEW_LINE INDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( Is_Practical ( i ) == True ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT A = 1 NEW_LINE B = 100 NEW_LINE print_practica_No ( A , B ) NEW_LINE",
        "Type": "py",
        "NL": "Panarithmic numbers within a given range | Python3 program to print Practical Numbers in given range ; Function to compute divisors of a number ; Vector to store divisors ; 1 will always be a divisor ; Check if i is squareroot of A then only one time insert it in ans ; Function to check that a number can be represented as summ of distinct divisor or not ; The value of subsett [ i ] [ j ] will be True if there is a subsett of sett [ 0. . j - 1 ] with summ equal to i ; If summ is 0 , then answer is True ; If summ is not 0 and sett is empty , then answer is False ; Fill the subsett table in bottom up manner ; Return the possibility of given summ ; Function to check a number is Practical or not ; Vector to store divisors ; If all numbers can be represented as summ of unique divisors ; Function to prPractical Numbers in a range ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "10535-10535",
        "Code": "def sumOfProductOfDigits ( n1 , n2 ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE while ( n1 > 0 and n2 > 0 ) : NEW_LINE INDENT sum1 += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; NEW_LINE n1 = n1 // 10 ; NEW_LINE n2 = n2 // 10 ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT n1 = 25 ; NEW_LINE n2 = 1548 ; NEW_LINE print ( sumOfProductOfDigits ( n1 , n2 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Sum of the products of same placed digits of two numbers | Function to find the sum of the products of their corresponding digits ; Loop until one of the numbers have no digits remaining ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10537-10537",
        "Code": "import math NEW_LINE N = 21 NEW_LINE A = math . sqrt ( 2 * N + 0.25 ) - 0.5 NEW_LINE B = int ( A ) NEW_LINE if B != A : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the sequence number of a triangular number | Python3 code to print sequence number of a triangular number ; if N is not tringular number",
        "Category": "Math"
    },
    {
        "ID": "10548-10548",
        "Code": "digit = [ 0 ] * 10 NEW_LINE def digitsPresent ( n ) : NEW_LINE INDENT lastDigit = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT lastDigit = n % 10 ; NEW_LINE digit [ int ( lastDigit ) ] = 1 ; NEW_LINE n /= 10 ; NEW_LINE DEDENT DEDENT def checkLastDigit ( num ) : NEW_LINE INDENT count = 0 ; NEW_LINE lastDigit = 0 ; NEW_LINE lastDigit = num % 10 ; NEW_LINE if ( digit [ int ( lastDigit ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count ; NEW_LINE DEDENT def findCount ( N , K , arr ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( K ) : NEW_LINE INDENT if checkLastDigit ( arr [ i ] ) == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT N = 1731 ; NEW_LINE digitsPresent ( N ) ; NEW_LINE K = 5 ; NEW_LINE arr = [ 57 , 6786 , 1111 , 3 , 9812 ] ; NEW_LINE findCount ( N , K , arr ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count of numbers in Array ending with digits of number N | Array to keep the track of digits occurred Initially all are 0 ( false ) ; Function to initialize true if the digit is present ; Variable to store the last digit ; Loop to iterate through every digit of the number N ; Updating the array according to the presence of the digit in n at the array index ; Function to check if the numbers in the array end with the digits of the number N ; Variable to store the count ; Variable to store the last digit ; Checking the presence of the last digit in N ; Function to find the required count ; Driver code ; Preprocessing",
        "Category": "Array"
    },
    {
        "ID": "1055-1055",
        "Code": "def TowerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( \" Move ▁ disk ▁ 1 ▁ from ▁ rod \" , from_rod , \" to ▁ rod \" , to_rod ) NEW_LINE return NEW_LINE DEDENT TowerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) NEW_LINE print ( \" Move ▁ disk \" , n , \" from ▁ rod \" , from_rod , \" to ▁ rod \" , to_rod ) NEW_LINE TowerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) NEW_LINE DEDENT n = 4 NEW_LINE TowerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Tower of Hanoi | Recursive Python function to solve tower of hanoi ; Number of disks ; A , C , B are the name of rods",
        "Category": "Backtracking"
    },
    {
        "ID": "10552-10552",
        "Code": "def find ( K , N ) : NEW_LINE INDENT N = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT curr_term = K NEW_LINE min_d = 9 NEW_LINE max_d = 0 NEW_LINE while curr_term > 0 : NEW_LINE INDENT r = int ( curr_term % 10 ) NEW_LINE min_d = min ( min_d , r ) NEW_LINE max_d = max ( max_d , r ) NEW_LINE curr_term = int ( curr_term / 10 ) NEW_LINE DEDENT if min_d == 0 : NEW_LINE break NEW_LINE K = K + min_d * max_d NEW_LINE return K NEW_LINE DEDENT DEDENT K = 487 NEW_LINE N = 2 NEW_LINE print ( find ( K , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Nth term of a sequence formed by sum of current term with product of its largest and smallest digit | Function to find integer ; Because 1 st integer is K itself ; Initialize min_d and max_d ; Updating min_d and max_d ; Break if min digit is 0 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10553-10553",
        "Code": "def Convert ( degree ) : NEW_LINE INDENT pi = 3.14159265359 ; NEW_LINE return ( degree * ( pi / 180 ) ) ; NEW_LINE DEDENT degree = 30 ; NEW_LINE radian = Convert ( degree ) ; NEW_LINE print ( radian ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to convert Degree to Radian | Function for conversion ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10560-10560",
        "Code": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isBalancedPrime ( n ) : NEW_LINE INDENT if not isPrime ( n ) or n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE while not isPrime ( next_prime ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT while not isPrime ( previous_prime ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT mean = ( previous_prime + next_prime ) / 2 NEW_LINE if n == mean : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 53 NEW_LINE if isBalancedPrime ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if N is a Balanced Prime number or not | Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a Balanced prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a weak prime ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10564-10564",
        "Code": "def getCount ( d , n ) : NEW_LINE INDENT no = n // d ; NEW_LINE result = no ; NEW_LINE for p in range ( 2 , int ( pow ( no , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( no % p == 0 ) : NEW_LINE INDENT while ( no % p == 0 ) : NEW_LINE INDENT no //= p ; NEW_LINE DEDENT result -= result // p ; NEW_LINE DEDENT DEDENT if ( no > 1 ) : NEW_LINE INDENT result -= result // no ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def sumOfGCDofPairs ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT d1 = i ; NEW_LINE d2 = n // i ; NEW_LINE res += d1 * getCount ( d1 , n ) ; NEW_LINE if ( d1 != d2 ) : NEW_LINE INDENT res += d2 * getCount ( d2 , n ) ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE print ( sumOfGCDofPairs ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of GCD of all numbers upto N with N itself | Function to Find Sum of GCD of each numbers ; Consider all prime factors of no . and subtract their multiples from result ; Check if p is a prime factor ; If yes , then update no and result ; If no has a prime factor greater than Math . sqrt ( n ) then at - most one such prime factor exists ; Return the result ; Finding GCD of pairs ; Calculate the divisors ; Return count of numbers from 1 to N with GCD d with N ; Check if d1 and d2 are equal then skip this ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10566-10566",
        "Code": "def lastDigitFactorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : return 1 NEW_LINE elif ( n <= 2 ) : return n NEW_LINE elif ( n == 3 ) : return 6 NEW_LINE elif ( n == 4 ) : return 4 NEW_LINE else : return 0 NEW_LINE DEDENT print ( lastDigitFactorial ( 6 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find last digit in factorial | Python3 program to find last digit in factorial n . ; Explicitly handle all numbers less than or equal to 4 ; For all numbers greater than 4 the last digit is 0 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10571-10571",
        "Code": "def lowerBound ( array , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( value <= array [ mid ] ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT def costCalculation ( current , arr , n , pref , a , r , minimum ) : NEW_LINE INDENT index = lowerBound ( arr , len ( arr ) , current ) NEW_LINE left = index * current - pref [ index ] NEW_LINE right = ( pref [ n ] - pref [ index ] - ( n - index ) * current ) NEW_LINE res = min ( left , right ) NEW_LINE left -= res NEW_LINE right -= res NEW_LINE total = res * minimum NEW_LINE total += left * a NEW_LINE total += right * r NEW_LINE return total NEW_LINE DEDENT def solve ( arr , n , a , r , m ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimum = min ( a + r , m ) NEW_LINE pref = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref [ i + 1 ] = pref [ i ] + arr [ i ] NEW_LINE DEDENT ans = 10000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) NEW_LINE DEDENT ans = min ( ans , costCalculation ( pref [ n ] // n , arr , n , pref , a , r , minimum ) ) NEW_LINE ans = min ( ans , costCalculation ( pref [ n ] // n + 1 , arr , n , pref , a , r , minimum ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 5 , 3 , 6 , 5 ] NEW_LINE A = 1 NEW_LINE R = 2 NEW_LINE M = 4 NEW_LINE size = len ( arr ) NEW_LINE solve ( arr , size , A , R , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum Cost to make all array elements equal using given operations | Python3 implementation to find the minimum cost to make all array elements equal ; Checks if the value is less than middle element of the array ; Function that returns the cost of making all elements equal to current element ; Compute the lower bound of current element ; Calculate the requirement of add operation ; Calculate the requirement of subtract operation ; Compute minimum of left and right ; Computing the total cost of add and subtract operations ; Function that prints minimum cost of making all elements equal ; Sort the given array ; Calculate minimum from a + r and m ; Compute prefix sum and store in pref array ; Find the minimum cost from the given elements ; Finding the minimum cost from the other cases where minimum cost can occur ; Printing the minimum cost of making all elements equal ; Driver Code ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "10576-10576",
        "Code": "def bcdToHexaDecimal ( s ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE check = 0 NEW_LINE num = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE ans = [ ] NEW_LINE i = len1 - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) * mul NEW_LINE mul *= 2 NEW_LINE check += 1 NEW_LINE if ( check == 4 or i == 0 ) : NEW_LINE INDENT if ( sum <= 9 ) : NEW_LINE INDENT ans . append ( chr ( sum + ord ( '0' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( chr ( sum + 55 ) ) ; NEW_LINE DEDENT check = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT len1 = len ( ans ) NEW_LINE i = len1 - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \" ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"100000101111\" NEW_LINE bcdToHexaDecimal ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to convert a Binary Number to Hexa | Function to convert BCD to hexadecimal ; Iterating through the bits backwards ; Computing the hexadecimal number formed so far and storing it in a vector . ; Reinitializing all variables for next group . ; Printing the hexadecimal number formed so far . ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10578-10578",
        "Code": "from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def checkDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT dig = n % 10 NEW_LINE if ( dig == 4 and dig == 6 and dig == 7 and dig == 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def isFullfibonacci ( n ) : NEW_LINE INDENT return ( checkDigits ( n ) and isFibonacci ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE if ( isFullfibonacci ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number is Full Fibonacci or not | Python3 program to check if a given number is a Full Fibonacci Number or not ; A utility function that returns true if x is perfect square ; Returns true if N is a Fibonacci Number and false otherwise ; N is Fibonacci if one of 5 * N ^ 2 + 4 or 5 * N ^ 2 - 4 or both is a perferct square ; Function to check digits ; Check if all digits are fibonacci or not ; Extract digit ; Check if the current digit is not fibonacci ; Function to check and return if N is a Full Fibonacci number or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10579-10579",
        "Code": "def isDivisible ( s ) : NEW_LINE INDENT flag = 0 NEW_LINE while ( len ( s ) > 4 ) : NEW_LINE INDENT l = len ( s ) - 1 NEW_LINE x = ( ord ( s [ l ] ) - ord ( '0' ) ) * 37 NEW_LINE s = s [ : : - 1 ] NEW_LINE s = s . replace ( '0' , ' ' , 1 ) NEW_LINE i = 0 NEW_LINE carry = 0 NEW_LINE while ( x ) : NEW_LINE INDENT d = ( ( ord ( s [ i ] ) - ord ( '0' ) ) - ( x % 10 ) - carry ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT d += 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT s = s . replace ( s [ i ] , chr ( d + ord ( '0' ) ) , 1 ) NEW_LINE x //= 10 NEW_LINE i += 1 NEW_LINE DEDENT while ( carry and i < l ) : NEW_LINE INDENT d = ( ord ( s [ i ] ) - ord ( '0' ) ) - carry NEW_LINE if ( d < 0 ) : NEW_LINE INDENT d += 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT s = s . replace ( s [ i ] , chr ( d + ord ( '0' ) ) , 1 ) NEW_LINE i += 1 NEW_LINE DEDENT s = s [ : : - 1 ] NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num % 53 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = \"1843246219106\" NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether a large number is divisible by 53 or not | Function to check if the number is divisible by 53 or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10580-10580",
        "Code": "def checksilverRatio ( a , b ) : NEW_LINE INDENT a , b = max ( a , b ) , min ( a , b ) NEW_LINE ratio1 = round ( a / b , 3 ) NEW_LINE ratio2 = round ( ( 2 * a + b ) / a , 3 ) NEW_LINE if ratio1 == ratio2 and ratio1 == 2.414 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2.414 NEW_LINE b = 1 NEW_LINE checksilverRatio ( a , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether two numbers are in silver ratio | Function to check that two numbers are in silver ratio ; Swapping the numbers such that A contains the maximum number between these numbers ; First Ratio ; Second Ratio ; Condition to check that two numbers are in silver ratio ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10581-10581",
        "Code": "def MIN ( n ) : NEW_LINE INDENT ans = 11 NEW_LINE while n : NEW_LINE INDENT ans = min ( ans , n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def MAX ( n ) : NEW_LINE INDENT ans = - 1 NEW_LINE while n : NEW_LINE INDENT ans = max ( ans , n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def Find_value ( n , k ) : NEW_LINE INDENT k -= 1 NEW_LINE ( x , y ) = ( 0 , 0 ) NEW_LINE while k : NEW_LINE INDENT k -= 1 NEW_LINE x = MIN ( n ) NEW_LINE y = MAX ( n ) NEW_LINE if ( ( y - x ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT n *= ( y - x ) NEW_LINE DEDENT print ( n , end = ' ▁ ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , D ) = ( 487 , 5 ) NEW_LINE Find_value ( N , D ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Nth term where K + 1 th term is product of Kth term with difference of max and min digit of Kth term | Function to find minimum digit in the decimal representation of N ; Loop to find the minimum digit in the number ; Function to find maximum digit in the decimal representation of N ; Loop to find the maximum digit in the number ; Function to find the value of the given function ; Loop to compute the values of the given number ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10582-10582",
        "Code": "from math import * NEW_LINE def countBinaries ( N ) : NEW_LINE INDENT ctr = 1 NEW_LINE ans = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 == 1 ) : NEW_LINE INDENT ans += pow ( 2 , ctr - 1 ) NEW_LINE DEDENT elif ( N % 10 > 1 ) : NEW_LINE INDENT ans = pow ( 2 , ctr ) - 1 NEW_LINE DEDENT ctr += 1 NEW_LINE N //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( int ( countBinaries ( N ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of integers up to N which represent a Binary number | Python3 program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10594-10594",
        "Code": "import math NEW_LINE def isMyriagon ( N ) : NEW_LINE INDENT n = ( 9996 + math . sqrt ( 79984 * N + 99920016 ) ) / 19996 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT n = 10000 NEW_LINE if ( isMyriagon ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check if N is a Myriagon Number | Python3 implementation to check that a number is a myriagon number or not ; Function to check that the number is a myriagon number ; Condition to check if the number is a myriagon number ; Given Number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10596-10596",
        "Code": "import math NEW_LINE def isOctadecagon ( N ) : NEW_LINE INDENT n = ( 14 + math . sqrt ( 128 * N + 196 ) ) // 32 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 18 NEW_LINE if isOctadecagon ( N ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Program to check if N is a Octadecagon number | Python3 program for the above approach ; Function to check if N is a octadecagon number ; Condition to check if the number is a octadecagon number ; Driver code ; Given number ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "106-106",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def convertTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT convertTree ( root . left ) NEW_LINE convertTree ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT root . data = ( ( root . left . data ) & ( root . right . data ) ) NEW_LINE DEDENT DEDENT def printInorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( root . left ) NEW_LINE print ( root . data , end = \" ▁ \" ) NEW_LINE printInorder ( root . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 0 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . right = newNode ( 0 ) NEW_LINE root . left . left = newNode ( 0 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ before ▁ conversion \" , end = \" ▁ \" ) NEW_LINE printInorder ( root ) NEW_LINE convertTree ( root ) NEW_LINE print ( \" Inorder traversal after conversion \" , ▁ end ▁ = ▁ \"   \" ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert a given Binary tree to a tree that holds Logical AND property | Program to convert an aribitary binary tree to a tree that holds children sum property Helper function that allocates a new node with the given data and None left and right poers . ; Construct to create a new node ; Convert the given tree to a tree where each node is logical AND of its children The main idea is to do Postorder traversal ; first recur on left child ; then recur on right child ; first recur on left child ; then print the data of node ; now recur on right child ; Driver Code ; Create following Binary Tree 1 / \\ 1 0 / \\ / \\ 0 1 1 1",
        "Category": "Binary Tree"
    },
    {
        "ID": "1060-1060",
        "Code": "def findMaxLen ( s ) : NEW_LINE INDENT if ( len ( s ) <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT curMax = 0 NEW_LINE longest = [ 0 ] * ( len ( s ) ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( ( s [ i ] == ' ) ' and i - longest [ i - 1 ] - 1 >= 0 and s [ i - longest [ i - 1 ] - 1 ] == ' ( ' ) ) : NEW_LINE INDENT longest [ i ] = longest [ i - 1 ] + 2 NEW_LINE if ( i - longest [ i - 1 ] - 2 >= 0 ) : NEW_LINE INDENT longest [ i ] += ( longest [ i - longest [ i - 1 ] - 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT longest [ i ] += 0 NEW_LINE DEDENT curMax = max ( longest [ i ] , curMax ) NEW_LINE DEDENT DEDENT return curMax NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = \" ( ( ( ) ( ) \" NEW_LINE print ( findMaxLen ( Str ) ) NEW_LINE Str = \" ( ) ( ( ) ) ) ) ) \" NEW_LINE print ( findMaxLen ( Str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the longest valid substring | Python3 program to find length of the longest valid substring ; Initialize curMax to zero ; Iterate over the string starting from second index ; Driver Code ; Function call ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "10602-10602",
        "Code": "def digSum ( a ) : NEW_LINE INDENT _sum = 0 NEW_LINE while ( a ) : NEW_LINE INDENT _sum += a % 10 NEW_LINE a = a // 10 NEW_LINE DEDENT return _sum NEW_LINE DEDENT def isPrime ( r ) : NEW_LINE INDENT s = True NEW_LINE i = 2 NEW_LINE while i * i <= r : NEW_LINE INDENT if ( r % i == 0 ) : NEW_LINE INDENT s = False NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return s NEW_LINE DEDENT def moranNo ( n ) : NEW_LINE INDENT dup = n NEW_LINE _sum = digSum ( dup ) NEW_LINE if ( n % _sum == 0 ) : NEW_LINE INDENT c = n // _sum NEW_LINE if ( isPrime ( c ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" No \" ) NEW_LINE DEDENT n = 21 NEW_LINE moranNo ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether given number N is a Moran Number or not | Function to calculate digit sum ; Function to check if number is prime ; Function to check if number is moran number ; Calculate digit sum ; Check if n is completely divisible by digit sum ; Calculate the quotient ; Check if the number is prime ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10619-10619",
        "Code": "def formed_no ( N , K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT answer = N NEW_LINE while ( K != 0 ) : NEW_LINE INDENT a_current = prod_of_max_min ( answer ) NEW_LINE if ( a_current == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT answer += a_current NEW_LINE K -= 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT def prod_of_max_min ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 10 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT return largest * smallest NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 487 NEW_LINE K = 100000000 NEW_LINE print ( formed_no ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number formed by adding product of its max and min digit K times | Function to find the formed number ; K -= 1 M ( 1 ) = N ; Check if minimum digit is 0 ; Function that returns the product of maximum and minimum digit of N number . ; Find the last digit . ; Moves to next digit ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10637-10637",
        "Code": "import math NEW_LINE def isCenterednonadecagonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 152 * N + 209 ) ) / 38 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT n = 20 ; NEW_LINE if ( isCenterednonadecagonal ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check if N is a Centered nonadecagonal number | Python3 implementation to check that a number is a Centered nonadecagonal number or not ; Function to check that the number is a Centered nonadecagonal number ; Condition to check if the number is a Centered nonadecagonal number ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "10640-10640",
        "Code": "import math NEW_LINE def kth_root ( n , k ) : NEW_LINE INDENT return ( pow ( k , ( ( 1.0 / k ) * ( math . log ( n ) / math . log ( k ) ) ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8.0 NEW_LINE k = 3 NEW_LINE print ( round ( kth_root ( n , k ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Logarithm tricks for Competitive Programming | Python3 implementation to find Kth root of the number ; Function to find the Kth root of the number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10642-10642",
        "Code": "from math import log NEW_LINE def isPower ( n , k ) : NEW_LINE INDENT res1 = int ( log ( n ) / log ( k ) ) NEW_LINE res2 = log ( n ) / log ( k ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE k = 2 NEW_LINE if ( isPower ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Logarithm tricks for Competitive Programming | Python3 implementation to check if a number is a power of the other number ; Function to check if the number is power of K ; Logarithm function to calculate value ; Compare to the result1 or result2 both are equal ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10646-10646",
        "Code": "def cntArray ( A , N ) : NEW_LINE INDENT result = 0 NEW_LINE frequency = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT frequency [ A [ i ] ] = frequency [ A [ i ] ] + 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT frequency_of_i = frequency [ i ] NEW_LINE result = result + ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 NEW_LINE DEDENT print ( int ( result ) ) NEW_LINE print ( \" \" ) NEW_LINE DEDENT A = [ 1 , 5 , 6 , 1 , 9 , 5 , 8 , 10 , 8 , 9 ] NEW_LINE N = len ( A ) NEW_LINE cntArray ( A , N ) NEW_LINE",
        "Type": "py",
        "NL": "Count of subarrays which start and end with the same element | Function to find total sub - array which start and end with same element ; Initialize result with 0 ; Array to count frequency of 1 to N ; Update frequency of A [ i ] ; Update result with sub - array contributed by number i ; Print the result ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10647-10647",
        "Code": "def findMaxSize ( a , n ) : NEW_LINE INDENT frq = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frq [ a [ i ] ] += 1 NEW_LINE DEDENT maxfrq = max ( frq ) NEW_LINE dist = n + 1 - frq . count ( 0 ) NEW_LINE ans1 = min ( maxfrq - 1 , dist ) NEW_LINE ans2 = min ( maxfrq , dist - 1 ) NEW_LINE ans = max ( ans1 , ans2 ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 1 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSize ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of array pair formed where one contains all distinct elements and other all same elements | Function to find the max size possible ; Counting the maximum frequency ; Counting total distinct elements ; Find max of both the answer ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "10649-10649",
        "Code": "def findMaxMinSubArray ( arr , K , n ) : NEW_LINE INDENT min = n NEW_LINE max = 0 NEW_LINE left = 0 NEW_LINE right = n NEW_LINE tmp = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tmp = 1 NEW_LINE left = i NEW_LINE while ( left - 1 >= 0 and abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) : NEW_LINE INDENT left = left - 1 NEW_LINE tmp = tmp + 1 NEW_LINE DEDENT right = i NEW_LINE while ( right + 1 <= n - 1 and abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) : NEW_LINE INDENT right = right + 1 NEW_LINE tmp = tmp + 1 NEW_LINE DEDENT if ( min > tmp ) : NEW_LINE INDENT min = tmp NEW_LINE DEDENT if ( max < tmp ) : NEW_LINE INDENT max = tmp NEW_LINE DEDENT DEDENT print ( min , end = ' , ▁ ' ) NEW_LINE print ( max , end =   ' ' ) NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 6 , 7 ] NEW_LINE K = 2 NEW_LINE n = len ( arr ) NEW_LINE findMaxMinSubArray ( arr , K , n ) NEW_LINE",
        "Type": "py",
        "NL": "Min and max length subarray having adjacent element difference atmost K | Function to find the maximum and minimum length subarray ; Initialise minimum and maximum size of subarray in worst case ; Left will scan the size of possible subarray in left of selected element ; Right will scan the size of possible subarray in right of selected element ; Temp will store size of group associateed with every element ; Loop to find size of subarray for every element of array ; Left will move in left direction and compare difference between itself and element left to it ; Right will move in right direction and compare difference between itself and element right to it ; If subarray of much lesser or much greater is found than yet known then update ; Print minimum and maximum possible size of subarray ; Driver Code ; Function call to find maximum and minimum possible sub array",
        "Category": "Sliding Window"
    },
    {
        "ID": "10663-10663",
        "Code": "import math ; NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) ; NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) ; NEW_LINE DEDENT def countSquares ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( int ( math . pow ( 10 , ( n - 1 ) ) ) , int ( math . pow ( 10 , n ) ) ) : NEW_LINE INDENT if ( i != 0 and isPerfectSquare ( i ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( countSquares ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count of perfect squares of given length | Python3 Program to count perfect squares of given length ; Function to check if a number is perfect square ; Find floating point value of square root of x . ; If square root is an integer ; Function to return the count of n digit perfect squares ; Initialize result ; Traverse through all numbers of n digits ; Check if current number ' i ' is perfect square ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10675-10675",
        "Code": "import sys NEW_LINE def kthNonDivisible ( N , K ) : NEW_LINE INDENT L = 1 NEW_LINE H = sys . maxsize NEW_LINE ans = 0 NEW_LINE while ( L <= H ) : NEW_LINE INDENT mid = ( L + H ) // 2 NEW_LINE sol = mid - mid // N NEW_LINE if ( sol > K ) : NEW_LINE INDENT H = mid - 1 NEW_LINE DEDENT elif ( sol < K ) : NEW_LINE L = mid + 1 NEW_LINE else : NEW_LINE INDENT ans = mid NEW_LINE H = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT N = 3 NEW_LINE K = 7 NEW_LINE kthNonDivisible ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Find the Kth number which is not divisible by N | Python3 implementation for above approach ; Function to find the Kth not divisible by N ; Lowest possible value ; Highest possible value ; To store the Kth non divisible number of N ; Using binary search ; Calculating mid value ; Sol would have the value by subtracting all multiples of n till mid ; Check if sol is greater than k ; H should be reduced to find minimum possible value ; Check if sol is less than k then L will be mid + 1 ; Check if sol is equal to k ; ans will be mid ; H would be reduced to find any more possible value ; Print the answer ; Driver Code ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "10683-10683",
        "Code": "def NumbertoCharacter ( n ) : NEW_LINE INDENT rev = 0 ; r = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT r = n % 10 ; NEW_LINE rev = rev * 10 + r ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT while ( rev > 0 ) : NEW_LINE INDENT r = rev % 10 ; NEW_LINE switcher = { 0 : \" zero ▁ \" , 1 : \" one ▁ \" , 2 : \" two ▁ \" , 3 : \" three ▁ \" , 4 : \" four ▁ \" , 5 : \" five ▁ \" , 6 : \" six ▁ \" , 7 : \" seven ▁ \" , 8 : \" eight ▁ \" , 9 : \" nine ▁ \" } NEW_LINE print ( switcher . get ( r , \" UnValid \" ) , end = \" ▁ \" ) ; NEW_LINE rev = rev // 10 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 ; NEW_LINE NumbertoCharacter ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to convert Number in characters | Python3 program to convert number in characters ; To calculate the reverse of the number ; The remainder will give the last digit of the number ; Extract the first digit of the reversed number ; Match it with switch case ; Divide the number by 10 to get the next number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10689-10689",
        "Code": "def prodSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT s [ i * i ] = 1 NEW_LINE if ( ( n // ( i * i ) ) in s ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 25 NEW_LINE if ( prodSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether a number can be represented by the product of two squares | Function to check if there exist two numbers product of whose squares is n ; Initialize dict / map ; Store square value in hashmap ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "10696-10696",
        "Code": "import math NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n //= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT def longestPowerfulSubsequence ( arr , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPowerful ( arr [ i ] ) ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT arr = [ 6 , 4 , 10 , 13 , 9 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPowerfulSubsequence ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of longest Powerful number subsequence in an Array | Python3 program to find the length of Longest Powerful Subsequence in an Array ; Function to check if the number is powerful ; First divide the number repeatedly by 2 ; Check if only 2 ^ 1 divides n , then return false ; Check if n is not a power of 2 then this loop will execute repeat above process ; Find highest power of \" factor \" that divides n ; If only factor ^ 1 divides n , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Function to find the longest subsequence which contain all powerful numbers ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10704-10704",
        "Code": "def calculateBill ( units ) : NEW_LINE INDENT if ( units <= 100 ) : NEW_LINE INDENT return units * 10 ; NEW_LINE DEDENT elif ( units <= 200 ) : NEW_LINE INDENT return ( ( 100 * 10 ) + ( units - 100 ) * 15 ) ; NEW_LINE DEDENT elif ( units <= 300 ) : NEW_LINE INDENT return ( ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ) ; NEW_LINE DEDENT elif ( units > 300 ) : NEW_LINE INDENT return ( ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ) ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT units = 250 ; NEW_LINE print ( calculateBill ( units ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate Electricity Bill | Function to calculate the electricity bill ; Condition to find the charges bar in which the units consumed is fall ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10708-10708",
        "Code": "def reverse ( a ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT r = a % 10 ; NEW_LINE rev = rev * 10 + r ; NEW_LINE a = a // 10 ; NEW_LINE DEDENT return ( rev ) ; NEW_LINE DEDENT def prime ( a ) : NEW_LINE INDENT k = 0 ; NEW_LINE for i in range ( 2 , a ) : NEW_LINE INDENT if ( a % i == 0 ) : NEW_LINE INDENT k = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT return ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 ) ; NEW_LINE DEDENT DEDENT def adam ( a ) : NEW_LINE INDENT r1 = reverse ( a ) ; NEW_LINE s1 = a * a ; NEW_LINE s2 = r1 * r1 ; NEW_LINE r2 = reverse ( s2 ) ; NEW_LINE if ( s1 == r2 ) : NEW_LINE INDENT return ( 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( 0 ) ; NEW_LINE DEDENT DEDENT def find ( m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT print ( \" INVALID INPUT \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT c = 0 ; NEW_LINE DEDENT for i in range ( m , n ) : NEW_LINE INDENT l = prime ( i ) ; NEW_LINE k = adam ( i ) ; NEW_LINE if ( ( l == 1 ) and ( k == 1 ) ) : NEW_LINE INDENT print ( i , \" TABSYMBOL \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT L = 5 ; R = 100 ; NEW_LINE find ( L , R ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find Prime Adam integers in the given range [ L , R ] | Python3 program to find all prime adam numbers in the given range ; Reversing a number by taking remainder at a time ; Function to check if a number is a prime or not ; Iterating till the number ; Checking for factors ; Returning 1 if the there are no factors of the number other than 1 or itself ; Function to check whether a number is an adam number or not ; Reversing given number ; Squaring given number ; Squaring reversed number ; Reversing the square of the reversed number ; Checking if the square of the number and the square of its reverse are equal or not ; Function to find all the prime adam numbers in the given range ; If the first number is greater than the second number , print invalid ; Iterating through all the numbers in the given range ; Checking for prime number ; Checking for Adam number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10713-10713",
        "Code": "pref = [ 0 ] * 100001 NEW_LINE def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isComposite ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) NEW_LINE DEDENT def printSumcomposite ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Q = 2 NEW_LINE arr = [ [ 10 , 13 ] , [ 12 , 21 ] ] NEW_LINE printSumcomposite ( arr , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all composite numbers lying in the range [ L , R ] for Q queries | Prefix array to precompute the sum of all composite number ; Function that return number num if num is composite else return 0 ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to precompute the sum of all composite numbers upto 100000 ; checkcomposite ( ) return the number i if i is composite else return 0 ; Function to print the sum for each query ; Function to prsum of all composite numbers between ; Function that pre computes the sum of all composite numbers ; Iterate over all Queries to print the sum ; Driver code ; Queries ; Function that print the the sum of all composite number in Range [ L , R ]",
        "Category": "Array"
    },
    {
        "ID": "10716-10716",
        "Code": "def CgpaCalc ( marks , n ) : NEW_LINE INDENT grade = [ 0 ] * n NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE grade [ i ] = ( marks [ i ] / 10 ) NEW_LINE for i in range ( n ) : NEW_LINE Sum += grade [ i ] NEW_LINE cgpa = Sum / n NEW_LINE return cgpa NEW_LINE DEDENT n = 5 NEW_LINE marks = [ 90 , 80 , 70 , 80 , 90 ] NEW_LINE cgpa = CgpaCalc ( marks , n ) NEW_LINE print ( \" CGPA ▁ = ▁ \" , ' % .1f ' % cgpa ) NEW_LINE print ( \" CGPA ▁ Percentage ▁ = ▁ \" , ' % .2f ' % ( cgpa * 9.5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Calculate the CGPA and CGPA % of marks obtained by a Student in N subjects | Python3 program to calculate the CGPA and CGPA percentage of a student ; Variable to store the grades in every subject ; Variables to store CGPA and the sum of all the grades ; Computing the grades ; Computing the sum of grades ; Computing the CGPA ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10720-10720",
        "Code": "def checkGoldenRatio ( a , b ) : NEW_LINE INDENT a , b = max ( a , b ) , min ( a , b ) NEW_LINE ratio1 = round ( a / b , 3 ) NEW_LINE ratio2 = round ( ( a + b ) / a , 3 ) NEW_LINE if ratio1 == ratio2 and ratio1 == 1.618 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 0.618 NEW_LINE b = 1 NEW_LINE checkGoldenRatio ( a , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether two numbers are in golden ratio | Function to check that two numbers are in golden ratio ; Swapping the numbers such that A contains the maximum number between these numbers ; First Ratio ; Second Ratio ; Condition to check that two numbers are in golden ratio ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10724-10724",
        "Code": "import math NEW_LINE import numpy as np NEW_LINE def previousPerfectSquare ( N ) : NEW_LINE INDENT prevN = math . floor ( math . sqrt ( N ) ) ; NEW_LINE if ( prevN * prevN == N ) : NEW_LINE INDENT prevN -= 1 ; NEW_LINE DEDENT return prevN * prevN ; NEW_LINE DEDENT def previousPerfectCube ( N ) : NEW_LINE INDENT prevN = math . floor ( np . cbrt ( N ) ) ; NEW_LINE if ( prevN * prevN * prevN == N ) : NEW_LINE INDENT prevN -= 1 ; NEW_LINE DEDENT return prevN * prevN * prevN ; NEW_LINE DEDENT n = 30 ; NEW_LINE print ( previousPerfectSquare ( n ) ) ; NEW_LINE print ( previousPerfectCube ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Previous perfect square and cube number smaller than number N | Python3 implementation to find the previous perfect square and cube smaller than the given number ; Function to find the previous perfect square of the number N ; If N is already a perfect square decrease prevN by 1. ; Function to find the previous perfect cube ; If N is already a perfect cube decrease prevN by 1. ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10728-10728",
        "Code": "def sumDig ( n ) : NEW_LINE INDENT s = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT s = s + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return s NEW_LINE DEDENT def Pec ( n ) : NEW_LINE INDENT dup = n NEW_LINE dig = sumDig ( n ) NEW_LINE if ( dig * 3 == dup ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT n = 36 NEW_LINE if Pec ( n ) == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Determine whether the given integer N is a Peculiar Number or not | Function to get sum of digits of a number ; Function to check if the number is peculiar ; Store a duplicate of n ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10730-10730",
        "Code": "MOD = 1000000007 NEW_LINE def power ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( a , b // 2 ) NEW_LINE temp = ( temp * temp ) % MOD NEW_LINE if ( b % 2 != 0 ) : NEW_LINE INDENT temp = ( temp * a ) % MOD NEW_LINE DEDENT return temp NEW_LINE DEDENT def palindromicSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( \"9\" ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT print ( \"99\" ) NEW_LINE return NEW_LINE DEDENT ways = N // 2 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT ways -= 1 NEW_LINE DEDENT res = power ( 9 , ways - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = sum * 10 + 45 * res NEW_LINE sum %= MOD NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE palindromicSum ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all N | Python 3 program for the above approach ; Function to find a ^ b efficiently ; Base Case ; To store the value of a ^ b ; Multiply temp by a until b is not 0 ; Return the final ans a ^ b ; Function to find sum of all N - digit palindromic number divisible by 9 ; Base Case ; If N is even , decrease ways by 1 ; Find the total number of ways ; Iterate over [ 1 , N ] and find the sum at each index ; Print the final Sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10732-10732",
        "Code": "def joinNumbers ( numA , numB ) : NEW_LINE INDENT revB = 0 NEW_LINE while ( numB > 0 ) : NEW_LINE INDENT revB = revB * 10 + ( numB % 10 ) NEW_LINE numB = numB // 10 NEW_LINE DEDENT while ( revB > 0 ) : NEW_LINE INDENT numA = numA * 10 + ( revB % 10 ) NEW_LINE revB = revB // 10 NEW_LINE DEDENT return numA NEW_LINE DEDENT def findMaxSum ( A , B , n ) : NEW_LINE INDENT maxArr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = joinNumbers ( A [ i ] , B [ i ] ) NEW_LINE Y = joinNumbers ( B [ i ] , A [ i ] ) NEW_LINE mx = max ( X , Y ) NEW_LINE maxArr [ i ] = mx NEW_LINE DEDENT maxAns = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxAns += maxArr [ i ] NEW_LINE DEDENT return maxAns NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE A = [ 11 , 23 , 38 , 43 , 59 ] NEW_LINE B = [ 36 , 24 , 17 , 40 , 56 ] NEW_LINE print ( findMaxSum ( A , B , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize array sum by concatenating corresponding elements of given two arrays | Function to join the two numbers ; Loop to reverse the digits of the one number ; Loop to join two numbers ; Function to find the maximum array sum ; Loop to iterate over the two elements of the array ; Find the array sum ; Return the array sum ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "10733-10733",
        "Code": "def digit_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT m = n % 10 ; NEW_LINE sum = sum + m ; NEW_LINE n = n // 10 NEW_LINE DEDENT return ( sum ) NEW_LINE DEDENT def reverse ( n ) : NEW_LINE INDENT r = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = r * 10 NEW_LINE r = r + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return ( r ) NEW_LINE DEDENT def operation ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT a = digit_sum ( i ) NEW_LINE r = reverse ( i ) NEW_LINE if ( i % a == 0 and r % a == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE operation ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find N numbers such that a number and its reverse are divisible by sum of its digits | Function to calculate the sum of digits ; Loop to iterate through every digit of the number ; Returning the sum of digits ; Function to calculate the reverse of a number ; Loop to calculate the reverse of the number ; Return the reverse of the number ; Function to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Loop to continuously check and generate number until there are n outputs ; Variable to hold the sum of the digit of the number ; Computing the reverse of the number ; Checking if the condition satisfies . Increment the count and print the number if it satisfies . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10742-10742",
        "Code": "import math NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT def contiguousPowerfulNumber ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerful ( arr [ i ] ) ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 7 , 36 , 4 , 6 , 28 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( contiguousPowerfulNumber ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of largest subarray whose all elements Powerful number | Python 3 program to find the length of the largest sub - array of an array every element of whose is a powerful number ; function to check if the number is powerful ; First divide the number repeatedly by 2 ; If only 2 ^ 1 divides n ( not higher powers ) , then return false ; If n is not a power of 2 then this loop will execute repeat above process ; Find highest power of \" factor \" that divides n ; If only factor ^ 1 divides n ( not higher powers ) , then return false ; n must be 1 now if it is not a prime numenr . Since prime numbers are not powerful , we return false if n is not 1. ; Function to return the length of the largest sub - array of an array every element of whose is a powerful number ; If arr [ i ] is a Powerful number ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "10746-10746",
        "Code": "from math import pow NEW_LINE def count ( N , B ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( B - 1 ) * pow ( B , i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE B = 10 NEW_LINE print ( int ( count ( N , B ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the total count of numbers up to N digits in a given base B | Python3 implementation to find the count of natural numbers up to N digits ; Function to return the count of natural numbers upto N digits ; Loop to iterate from 1 to N and calculating number of natural numbers for every ' i ' th digit . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10757-10757",
        "Code": "def stepRequired ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N & ( N - 1 ) ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 23 ; NEW_LINE print ( stepRequired ( N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum steps to reach the Nth stair in jumps of perfect power of 2 | Function to count the number of jumps required to reach Nth stairs . ; Till N becomes 0 ; Removes the set bits from the right to left ; Driver Code ; Number of stairs ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10758-10758",
        "Code": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE if s * s == x : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def fibonacciSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE if ( isFibonacci ( sum ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT arr = [ 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacciSubarrays ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Count of total subarrays whose sum is a Fibonacci Numbers | Python3 program for the above approach ; Function to check whether a number is perfect square or not ; Function to check whether a number is fibonacci number or not ; If 5 * n * n + 4 or 5 * n * n - 5 is a perfect square , then the number is Fibonacci ; Function to count the subarray with sum fibonacci number ; Traverse the array arr [ ] to find the sum of each subarray ; To store the sum ; Check whether sum of subarray between [ i , j ] is fibonacci or not ; Driver Code ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "10761-10761",
        "Code": "import math ; NEW_LINE def numPrimeArrangements ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT factor = 2 NEW_LINE while factor * i <= n : NEW_LINE INDENT prime [ factor * i ] = False NEW_LINE factor += 1 NEW_LINE DEDENT DEDENT DEDENT primeIndices = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT primeIndices += 1 NEW_LINE DEDENT DEDENT mod = 1000000007 NEW_LINE res = 1 NEW_LINE for i in range ( 1 , primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT for i in range ( 1 , n - primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( numPrimeArrangements ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Permutation of first N positive integers such that prime numbers are at prime indices | Set 2 | Python3 program to count permutations from 1 to N such that prime numbers occur at prime indices ;  ; Computing count of prime numbers using sieve ; Computing permutations for primes ; Computing permutations for non - primes ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10762-10762",
        "Code": "mod = 1000000007 NEW_LINE factorial = [ 0 for i in range ( 100005 ) ] NEW_LINE def StoreFactorials ( n ) : NEW_LINE INDENT factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT factorial [ i ] = ( i * factorial [ i - 1 ] ) % mod NEW_LINE DEDENT DEDENT def Power ( x , y ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT ans = ( ans * x ) % mod NEW_LINE DEDENT x = ( x * x ) % mod NEW_LINE y //= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def invmod ( x ) : NEW_LINE INDENT return Power ( x , mod - 2 ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( ( factorial [ n ] * invmod ( ( factorial [ r ] * factorial [ n - r ] ) % mod ) ) % mod ) NEW_LINE DEDENT def CountWays ( n , k ) : NEW_LINE INDENT StoreFactorials ( n ) NEW_LINE ans = 0 NEW_LINE i = k NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( i % 2 == k % 2 ) : NEW_LINE INDENT ans = ( ( ans + ( Power ( i , n ) * nCr ( k , i ) ) % mod ) % mod ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( ( ans + mod - ( Power ( i , n ) * nCr ( k , i ) ) % mod ) % mod ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT ans = ( ans * nCr ( n , k ) ) % mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 5 NEW_LINE print ( CountWays ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count the number of ways to fill K boxes with N distinct items | Python3 program to calculate the above formula ; To store the factorials of all numbers ; Function to calculate factorial of all numbers ; Calculate x to the power y in O ( log n ) time ; Function to find inverse mod of a number x ; Calculate ( n C r ) ; Loop to compute the formula evaluated ; Add even power terms ; Subtract odd power terms ; Choose the k boxes which were used ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10767-10767",
        "Code": "def XOROfElements ( arr , n ) : NEW_LINE INDENT FirstHalfXOR = 0 ; NEW_LINE SecondHalfXOR = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT FirstHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT SecondHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT DEDENT print ( FirstHalfXOR , \" , \" , SecondHalfXOR ) ; NEW_LINE DEDENT arr = [ 20 , 30 , 50 , 10 , 55 , 15 , 42 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE XOROfElements ( arr , N ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find the XOR of first half and second half elements of an array | Function to find the xor of the first half elements and second half elements of an array ; xor of elements in FirstHalfXOR ; xor of elements in SecondHalfXOR ; Driver Code ; Function call",
        "Category": "Array"
    },
    {
        "ID": "1077-1077",
        "Code": "def findDuplicateparenthesis ( string ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in string : NEW_LINE INDENT if ch == ' ) ' : NEW_LINE INDENT top = Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while top != ' ( ' : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack . pop ( ) NEW_LINE DEDENT if elementsInside < 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ( ( ( a + ( b ) ) + ( c + d ) ) ) \" NEW_LINE if findDuplicateparenthesis ( string ) == True : NEW_LINE INDENT print ( \" Duplicate ▁ Found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Duplicates ▁ Found \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find if an expression has duplicate parenthesis or not | Function to find duplicate parenthesis in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ' ) ' ; pop character from the stack ; stores the number of characters between a closing and opening parenthesis if this count is less than or equal to 1 then the brackets are redundant else not ; push open parenthesis ' ( ' , operators and operands to stack ; No duplicates found ; Driver Code ; input balanced expression",
        "Category": "Stack"
    },
    {
        "ID": "10770-10770",
        "Code": "def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 10 NEW_LINE B = 3 NEW_LINE movesRequired ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum decrements to make integer A divisible by integer B | Function that print number of moves required ; Calculate modulo ; Print the required answer ; Driver Code ; Initialise A and B",
        "Category": "Math"
    },
    {
        "ID": "10776-10776",
        "Code": "import math NEW_LINE def find_volume ( area , h ) : NEW_LINE INDENT Volume = ( area * h ) NEW_LINE print ( \" Volume : ▁ \" , end = \" ▁ \" ) NEW_LINE print ( Volume ) NEW_LINE DEDENT def find_Surface_area ( area , a , h ) : NEW_LINE INDENT Surface_area = ( 2 * area ) + ( 8 * a * h ) NEW_LINE print ( \" Surface ▁ area : ▁ \" , end = \" ▁ \" ) NEW_LINE print ( Surface_area ) NEW_LINE DEDENT h = 1 NEW_LINE a = 6 NEW_LINE d = 2 NEW_LINE area = 2 * a * d NEW_LINE find_Surface_area ( area , a , h ) NEW_LINE find_volume ( area , h ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find Surface Area and Volume of Octagonal Prism | Python3 program to find the Surface area and volume of octagonal prism ; Function to find the Volume of octagonal prism ; Formula to calculate volume = ( area * h ) ; Display volume ; Function to find the surface area of octagonal prism ; Formula to calculate Surface area ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10778-10778",
        "Code": "N = 100005 NEW_LINE phi = [ 0 for i in range ( N ) ] NEW_LINE pref = [ 0 for i in range ( N ) ] NEW_LINE def precompute ( ) : NEW_LINE INDENT phi [ 1 ] = 0 NEW_LINE for i in range ( 2 , N , 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def prefix ( ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + phi [ i ] NEW_LINE DEDENT DEDENT def find_pairs ( n ) : NEW_LINE INDENT total = ( n * ( n - 1 ) ) // 2 NEW_LINE ans = total - pref [ n ] NEW_LINE print ( \" Number ▁ of ▁ pairs ▁ from ▁ 1 ▁ to \" , n , \" are \" , ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE prefix ( ) NEW_LINE q = [ 5 , 7 ] NEW_LINE n = len ( q ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT find_pairs ( q [ i ] ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Count of pairs upto N such whose LCM is not equal to their product for Q queries | Python 3 program to find the count of pairs from 1 to N such that their LCM is not equal to their product ; To store Euler 's Totient Function ; To store prefix sum table ; Compute Totients of all numbers smaller than or equal to N ; Make phi [ 1 ] = 0 since 1 cannot form any pair ; Initialise all remaining phi [ ] with i ; Compute remaining phi ; If phi [ p ] is not computed already , then number p is prime ; phi of prime number is p - 1 ; Update phi of all multiples of p ; Add the contribution of p to its multiple i by multiplying it with ( 1 - 1 / p ) ; Function to store prefix sum table ; Prefix Sum of all Euler 's Totient Values ; Total number of pairs that can be formed ; Driver Code ; Function call to compute all phi ; Function call to store all prefix sum",
        "Category": "Math"
    },
    {
        "ID": "10779-10779",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def balance ( x , y , p , q ) : NEW_LINE INDENT if ( p % x == 0 and q % y == 0 ) : NEW_LINE INDENT b1 = p // x NEW_LINE b2 = q // y NEW_LINE b3 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = p * y NEW_LINE q = q * x NEW_LINE b3 = x * y NEW_LINE temp = gcd ( p , gcd ( q , b3 ) ) NEW_LINE b1 = p // temp NEW_LINE b2 = q // temp NEW_LINE b3 = b3 // temp NEW_LINE DEDENT print ( b1 , b2 , b3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE p = 4 NEW_LINE q = 5 NEW_LINE balance ( x , y , p , q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to balance the given Chemical Equation | Function to calculate GCD ; Function to calculate b1 , b2 and b3 ; Variable declaration ; temp variable to store gcd ; Computing GCD ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10789-10789",
        "Code": "def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = ( ( b - a ) / n ) NEW_LINE sum = 0 NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT lowlimit = 0 NEW_LINE upplimit = 4 NEW_LINE print ( \" f ( x ) ▁ = \" , round ( BooleRule ( 0 , 4 ) , 4 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program for finding the Integral of a given function using Boole 's Rule | Function to return the value of f ( x ) for the given value of x ; Function to computes the integrand of y at the given intervals of x with step size h and the initial limit a and final limit b ; Number of intervals ; Computing the step size ; Substituing a = 0 , b = 4 and h = 1 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10790-10790",
        "Code": "mod = 1000000007 ; NEW_LINE def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT bitwiseAND = - 1 ; NEW_LINE bitwiseOR = 0 ; NEW_LINE bitwiseXOR = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( bitwiseAND == - 1 ) : NEW_LINE INDENT bitwiseAND = a [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT bitwiseAND &= a [ j ] ; NEW_LINE DEDENT bitwiseOR |= a [ j ] ; NEW_LINE bitwiseXOR ^= a [ j ] ; NEW_LINE DEDENT DEDENT if ( bitwiseAND == bitwiseOR and bitwiseOR == bitwiseXOR ) : NEW_LINE INDENT answer = ( answer + 1 ) % mod ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 ; NEW_LINE A = [ 1 , 3 , 2 , 1 , 2 , 1 ] ; NEW_LINE print ( countSubsets ( A , N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of subsets with same AND , OR and XOR values in an Array | Python3 implementation to find the number of subsets with equal bitwise AND , OR and XOR values ; Function to find the number of subsets with equal bitwise AND , OR and XOR values ; Traverse through all the subsets ; Finding the subsets with the bits of ' i ' which are set ; Computing the bitwise AND ; Computing the bitwise OR ; Computing the bitwise XOR ; Comparing all the three values ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10794-10794",
        "Code": "def convertToTernary ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT x = N % 3 ; NEW_LINE N //= 3 ; NEW_LINE if ( x < 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE DEDENT convertToTernary ( N ) ; NEW_LINE if ( x < 0 ) : NEW_LINE INDENT print ( x + ( 3 * - 1 ) , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , end = \" \" ) ; NEW_LINE DEDENT DEDENT def convert ( Decimal ) : NEW_LINE INDENT print ( \" Ternary ▁ number ▁ of ▁ \" , Decimal , \" ▁ is : ▁ \" , end = \" \" ) ; NEW_LINE if ( Decimal != 0 ) : NEW_LINE INDENT convertToTernary ( Decimal ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Decimal = 2747 ; NEW_LINE convert ( Decimal ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Ternary number system or Base 3 numbers | Function to convert a decimal number to a ternary number ; Base case ; Finding the remainder when N is divided by 3 ; Recursive function to call the function for the integer division of the value N / 3 ; Handling the negative cases ; Function to convert the decimal to ternary ; If the number is greater than 0 , compute the ternary representation of the number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10795-10795",
        "Code": "import math ; NEW_LINE def convertToDecimal ( N ) : NEW_LINE INDENT print ( \" Decimal ▁ number ▁ of \" , N , \" is : \" , end = \" ▁ \" ) ; NEW_LINE if ( N != 0 ) : NEW_LINE INDENT decimalNumber = 0 ; NEW_LINE i = 0 ; NEW_LINE remainder = 0 ; NEW_LINE while ( N != 0 ) : NEW_LINE INDENT remainder = N % 10 ; NEW_LINE N = N // 10 ; NEW_LINE decimalNumber += remainder * math . pow ( 3 , i ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT print ( decimalNumber ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" ) ; NEW_LINE DEDENT DEDENT Ternary = 10202202 ; NEW_LINE convertToDecimal ( Ternary ) ; NEW_LINE",
        "Type": "py",
        "NL": "Ternary number system or Base 3 numbers | Python3 program to convert a ternary number to decimal number ; Function to convert a ternary number to a decimal number ; If the number is greater than 0 , compute the decimal representation of the number ; Loop to iterate through the number ; Computing the decimal digit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10796-10796",
        "Code": "from math import sqrt , floor NEW_LINE def isPerfectSquare ( N ) : NEW_LINE INDENT sr = sqrt ( N ) NEW_LINE return ( sr - floor ( sr ) ) == 0 NEW_LINE DEDENT def BetrothedNumbers ( n , m ) : NEW_LINE INDENT Sum1 = 1 NEW_LINE Sum2 = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT Sum1 += i NEW_LINE DEDENT else : NEW_LINE INDENT Sum1 += i + n / i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , int ( sqrt ( m ) ) + 1 , 1 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT if ( isPerfectSquare ( m ) ) : NEW_LINE INDENT Sum2 += i NEW_LINE DEDENT else : NEW_LINE INDENT Sum2 += i + ( m / i ) NEW_LINE DEDENT DEDENT DEDENT if ( ( n + 1 == Sum2 ) and ( m + 1 == Sum1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9504 NEW_LINE M = 20734 NEW_LINE BetrothedNumbers ( N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given pair of Numbers are Betrothed numbers or not | Python3 program for the above approach ; Function to check whether N is Perfect Square or not ; Find sqrt ; Function to check whether the given pairs of numbers is Betrothed Numbers or not ; For finding the sum of all the divisors of first number n ; For finding the sum of all the divisors of second number m ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10798-10798",
        "Code": "def product ( mat , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 += mat [ i ] [ i ] NEW_LINE d2 += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT return d1 * d2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 5 , 8 , 1 ] , [ 5 , 10 , 3 ] , [ - 6 , 17 , - 9 ] ] NEW_LINE n = len ( mat ) NEW_LINE print ( product ( mat , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the product of sum of two diagonals of a square Matrix | Function to find the product of the sum of diagonals . ; Initialize sums of diagonals ; Return the answer ; Driven code ; Function call",
        "Category": "Matrix"
    },
    {
        "ID": "10802-10802",
        "Code": "def sumOfPrevK ( N , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i - 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE while ( j >= 0 and count < K ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE j = j - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT arr [ i ] = sum NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE K = 4 NEW_LINE sumOfPrevK ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Print the sequence of size N in which every term is sum of previous K terms | Function to generate the series in the form of array ; Pick a starting point ; Find the sum of all elements till count < K ; Find the value of sum at i position ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "10806-10806",
        "Code": "def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest number less than or equal to Z that leaves a remainder X when divided by Y | Function to get the number ; remainder can ' t ▁ be ▁ larger ▁ ▁ than ▁ the ▁ largest ▁ number , ▁ ▁ if ▁ so ▁ then ▁ answer ▁ doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; initialise the three integers",
        "Category": "Math"
    },
    {
        "ID": "10813-10813",
        "Code": "def y ( x ) : NEW_LINE INDENT num = 1 ; NEW_LINE denom = float ( 1.0 + x * x ) ; NEW_LINE return num / denom ; NEW_LINE DEDENT def WeedleRule ( a , b ) : NEW_LINE INDENT h = ( b - a ) / 6 ; NEW_LINE sum = 0 ; NEW_LINE sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 0 ; NEW_LINE b = 6 ; NEW_LINE num = WeedleRule ( a , b ) ; NEW_LINE print ( \" f ( x ) ▁ = ▁ { 0 : . 6f } \" . format ( num ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Finding Integreand using Weedle 's Rule | A sample function f ( x ) = 1 / ( 1 + x ^ 2 ) ; Function to find the integral value of f ( x ) with step size h , with initial lower limit and upper limit a and b ; Find step size h ; To store the final sum ; Find sum using Weedle 's Formula ; Return the final sum ; Driver Code ; lower limit and upper limit ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10818-10818",
        "Code": "def checkPermutation ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE prefix [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT lsum = prefix [ i ] NEW_LINE rsum = sum - prefix [ i ] NEW_LINE l_len = i + 1 NEW_LINE r_len = n - i - 1 NEW_LINE if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) and ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printPermutations ( arr , n , l1 , l2 ) : NEW_LINE INDENT for i in range ( l1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" , end ▁ = ▁ \" \" ) ; NEW_LINE for i in range ( l1 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def findPermutations ( arr , n ) : NEW_LINE INDENT if ( checkPermutation ( arr , n ) == False ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE return NEW_LINE DEDENT l1 = 0 NEW_LINE l2 = 0 NEW_LINE l1 = max ( arr ) NEW_LINE l2 = n - l1 NEW_LINE s1 = set ( ) NEW_LINE s2 = set ( ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT s1 . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( l1 , n ) : NEW_LINE INDENT s2 . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( s1 ) == l1 and len ( s2 ) == l2 ) : NEW_LINE INDENT printPermutations ( arr , n , l1 , l2 ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = l1 NEW_LINE l1 = l2 NEW_LINE l2 = temp NEW_LINE printPermutations ( arr , n , l1 , l2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 , 10 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE findPermutations ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print the two possible permutations from a given sequence | Function to check if the sequence is concatenation of two permutations or not ; Computing the sum of all the elements in the array ; Computing the prefix sum for all the elements in the array ; Iterating through the i from lengths 1 to n - 1 ; Sum of first i + 1 elements ; Sum of remaining n - i - 1 elements ; Lengths of the 2 permutations ; Checking if the sums satisfy the formula or not ; Function to print the two permutations ; Print the first permutation ; Print the second permutation ; Function to find the two permutations from the given sequence ; If the sequence is not a concatenation of two permutations ; Find the largest element in the array and set the lengths of the permutations accordingly ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10820-10820",
        "Code": "def countOfGreaterElements ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 1000 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT x = 0 NEW_LINE p = [ ] NEW_LINE q = [ ] NEW_LINE m = [ ] NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT m . append ( [ key , value ] ) NEW_LINE DEDENT m = m [ : : - 1 ] NEW_LINE for p in m : NEW_LINE INDENT temp = p [ 1 ] NEW_LINE mp [ p [ 0 ] ] = x NEW_LINE x += temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( mp [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 9 , 5 , 2 , 1 , 3 , 4 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE countOfGreaterElements ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of greater elements for each element in the Array | Python 3 implementation of the above approach ; Store the frequency of the array elements ; Store the sum of frequency of elements greater than the current element ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10823-10823",
        "Code": "def reverse ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def countReverse ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( reverse ( arr [ i ] ) == arr [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 61 , 12 , 21 , 25 ] NEW_LINE n = len ( a ) NEW_LINE print ( countReverse ( a , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs in array such that one element is reverse of another | Function to reverse the digits of the number ; Loop to iterate till the number is greater than 0 ; Extract the last digit and keep multiplying it by 10 to get the reverse of the number ; Function to find the pairs from the such that one number is reverse of the other ; Iterate through all pairs ; Increment count if one is the reverse of other ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10826-10826",
        "Code": "def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = TrialDivision ( N ) NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Trial division Algorithm for Prime Factorization | Function to check if a number is a prime number or not ; Initializing with the value 2 from where the number is checked ; Computing the square root of the number N ; While loop till the square root of N ; If any of the numbers between [ 2 , sqrt ( N ) ] is a factor of N Then the number is composite ; If none of the numbers is a factor , then it is a prime number ; Driver code ; To check if a number is a prime or not",
        "Category": "Math"
    },
    {
        "ID": "10829-10829",
        "Code": "def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) // 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count ways to divide C in two parts and add to A and B to make A strictly greater than B | Function to count the number of ways to divide C into two parts and add to A and B such that A is strictly greater than B ; Minimum value added to A to satisfy the given relation ; Number of different values of A , i . e . , number of ways to divide C ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1083-1083",
        "Code": "def decode ( Str ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE temp = \" \" NEW_LINE result = \" \" NEW_LINE i = 0 NEW_LINE while i < len ( Str ) : NEW_LINE INDENT count = 0 NEW_LINE if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE integerstack . append ( count ) NEW_LINE DEDENT elif ( Str [ i ] == ' ] ' ) : NEW_LINE INDENT temp = \" \" NEW_LINE count = 0 NEW_LINE if ( len ( integerstack ) != 0 ) : NEW_LINE INDENT count = integerstack [ - 1 ] NEW_LINE integerstack . pop ( ) NEW_LINE DEDENT while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ - 1 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == ' [ ' ) : NEW_LINE INDENT stringstack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack . append ( result [ j ] ) NEW_LINE DEDENT result = \" \" NEW_LINE DEDENT elif ( Str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while len ( stringstack ) != 0 : NEW_LINE INDENT result = stringstack [ - 1 ] + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = \"3 [ b2 [ ca ] ] \" NEW_LINE print ( decode ( Str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Decode a string recursively encoded as count followed by substring | Returns decoded string for ' str ' ; Traversing the string ; If number , convert it into number and push it into integerstack . ; If closing bracket ' ] ' , pop elemment until ' [ ' opening bracket is not found in the character stack . ; Repeating the popped string ' temo ' count number of times . ; Push it in the character stack . ; If ' [ ' opening bracket , push it into character stack . ; Pop all the elmenet , make a string and return . ; Driven code",
        "Category": "Stack"
    },
    {
        "ID": "10834-10834",
        "Code": "from math import sqrt NEW_LINE size = 1000 NEW_LINE prime = [ 0 for i in range ( size ) ] NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE def sieve ( a , b ) : NEW_LINE INDENT prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( size ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , size , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for p in range ( 1 , size , 1 ) : NEW_LINE INDENT for q in range ( 1 , size , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 0 and prime [ q ] == 0 and a * p + b * q < size ) : NEW_LINE INDENT freq [ a * p + b * q ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = 2 NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sieve ( a , b ) NEW_LINE arr = [ 15 , 25 ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find the number of ordered pairs such that a * p + b * q = N , where p and q are primes | Python3 program to find the number of ordered pairs such that a * p + b * q = N where p and q are primes ; Sieve of erastothenes to store the prime numbers and their frequency in form a * p + b * q ; Performing Sieve of Eratosthenes to find the prime numbers unto 10001 ; Loop to find the number of ordered pairs for every combination of the prime numbers ; Driver code ; Printing the number of ordered pairs for every query",
        "Category": "Graph Theory"
    },
    {
        "ID": "10839-10839",
        "Code": "def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE a = 1 ; NEW_LINE cnt = 0 ; NEW_LINE flag = True ; NEW_LINE sum += a ; NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = None ; NEW_LINE if ( flag ) : NEW_LINE INDENT nextElement = a * 2 ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * ( 3 / 2 ) ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT a = nextElement ; NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Sum of the series 1 , 2 , 3 , 6 , 9 , 18 , 27 , 54 , ... till N terms | Function to find the sum of series ; Flag to find the multiplicating factor . . i . e , by 2 or 3 / 2 ; First term ; If flag is true , multiply by 2 ; If flag is false , multiply by 3 / 2 ; Update the previous element to nextElement ; Print the sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10840-10840",
        "Code": "def sumBaseB ( a , b , base ) : NEW_LINE INDENT len_a = len ( a ) NEW_LINE len_b = len ( b ) NEW_LINE s = \" \" ; NEW_LINE sum = \" \" ; NEW_LINE diff = abs ( len_a - len_b ) ; NEW_LINE for i in range ( 1 , diff + 1 ) : NEW_LINE INDENT s += \"0\" NEW_LINE DEDENT if ( len_a < len_b ) : NEW_LINE INDENT a = s + a NEW_LINE DEDENT else : NEW_LINE INDENT b = s + b ; NEW_LINE DEDENT carry = 0 ; NEW_LINE for i in range ( max ( len_a , len_b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr = carry + ( ord ( a [ i ] ) - ord ( '0' ) ) + ( ord ( b [ i ] ) - ord ( '0' ) ) ; NEW_LINE carry = curr // base NEW_LINE curr = curr % base ; NEW_LINE sum = chr ( curr + ord ( '0' ) ) + sum NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT sum = chr ( carry + ord ( '0' ) ) + sum ; NEW_LINE DEDENT return sum NEW_LINE DEDENT a = \"123\" NEW_LINE b = \"234\" NEW_LINE base = 6 NEW_LINE sum = sumBaseB ( a , b , base ) ; NEW_LINE print ( sum ) NEW_LINE",
        "Type": "py",
        "NL": "Program to add two integers of given base | Function to find the sum of two integers of base B ; Padding 0 in front of the number to make both numbers equal ; Condition to check if the strings have lengths mis - match ; Loop to find the find the sum of two integers of base B ; Current Place value for the resultant sum ; Update carry ; Find current digit ; Update sum result ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "10841-10841",
        "Code": "def MinimumSwapOperations ( s ) : NEW_LINE INDENT zero_exist = False NEW_LINE multiple_of_2 = False NEW_LINE sum = 0 NEW_LINE index_of_zero = 0 NEW_LINE more_zero = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( zero_exist == True ) : NEW_LINE INDENT more_zero = True NEW_LINE DEDENT if ( val == 0 ) : NEW_LINE INDENT zero_exist = True NEW_LINE index_of_zero = i NEW_LINE DEDENT sum += val NEW_LINE DEDENT if ( zero_exist == False or sum % 3 != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( val % 2 == 0 and i != index_of_zero ) : NEW_LINE INDENT multiple_of_2 = True NEW_LINE DEDENT DEDENT if ( multiple_of_2 == False ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT last_val = ord ( s [ len ( s ) - 1 ] ) - ord ( '0' ) NEW_LINE second_last_val = ord ( s [ len ( s ) - 2 ] ) - ord ( '0' ) NEW_LINE if ( last_val == 0 and second_last_val % 2 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( ( last_val == 0 and second_last_val % 2 != 0 ) or ( last_val % 2 == 0 and second_last_val == 0 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( more_zero == True and ( last_val == 0 and second_last_val % 2 != 0 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = \"20\" NEW_LINE MinimumSwapOperations ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of swaps required to make a number divisible by 60 | Function that prminimum number of swap operations required ; Condition if more than one zero exist ; Condition if zero_exist ; Computing total sum of all digits ; Condition if zero does not exist or the sum is not divisible by 3 ; Condition to find a digit that is multiple of 2 other than one zero ; Condition if multiple of 2 do not exist ; Condition for zero swaps means the number is already is divisible by 60 ; Condition for only one swap ; Otherwise 2 swaps required ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10842-10842",
        "Code": "from math import pow NEW_LINE def isAutoBio ( num ) : NEW_LINE INDENT autoStr = str ( num ) NEW_LINE for i in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT index = int ( autoStr [ i ] ) NEW_LINE cnt = 0 NEW_LINE for j in range ( 0 , len ( autoStr ) ) : NEW_LINE INDENT number = int ( autoStr [ j ] ) NEW_LINE if number == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt != index : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findAutoBios ( n ) : NEW_LINE INDENT low = int ( pow ( 10 , n - 1 ) ) NEW_LINE high = int ( pow ( 10 , n ) - 1 ) NEW_LINE flag = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if isAutoBio ( i ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( i , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( \" There ▁ is ▁ no ▁ Autobiographical ▁ Number ▁ with ▁ \" + str ( n ) + \" ▁ digits \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 0 NEW_LINE findAutoBios ( N ) NEW_LINE N = 4 NEW_LINE findAutoBios ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find all Autobiographical Numbers with given number of digits | Python implementation to find Autobiographical numbers with length N ; Function to return if the number is autobiographical or not ; Converting the integer number to string ; Extracting each character from each index one by one and converting into an integer ; Initialize count as 0 ; Check if it is equal to the index i if true then increment the count ; It is an Autobiographical number ; Return false if the count and the index number are not equal ; Function to print autobiographical number with given number of digits ; Left boundary of interval ; Right boundary of interval ; Flag = 0 implies that the number is not an autobiographical no . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10844-10844",
        "Code": "MAX = 10000 ; NEW_LINE max_prime = [ 0 ] * MAX ; NEW_LINE min_prime = [ 0 ] * MAX ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( min_prime [ i ] > 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT min_prime [ i ] = i ; NEW_LINE max_prime [ i ] = i ; NEW_LINE j = i + i ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( min_prime [ j ] == 0 ) : NEW_LINE INDENT min_prime [ j ] = i ; NEW_LINE DEDENT max_prime [ j ] = i ; NEW_LINE j += i ; NEW_LINE DEDENT DEDENT DEDENT def findCost ( A , B , C , X ) : NEW_LINE INDENT sieve ( MAX ) ; NEW_LINE if ( X == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT min_cost = C + X ; NEW_LINE cost_for_prime = A ; NEW_LINE N = max_prime [ X ] ; NEW_LINE if ( N != X ) : NEW_LINE INDENT M = X // N ; NEW_LINE cost_for_prime += M ; NEW_LINE min_cost = min ( min_cost , cost_for_prime ) ; NEW_LINE DEDENT M = min_prime [ X ] ; NEW_LINE N = X // M ; NEW_LINE if ( N != min_prime [ N ] ) : NEW_LINE INDENT cost_for_comp = B + M ; NEW_LINE min_cost = min ( min_cost , cost_for_comp ) ; NEW_LINE DEDENT return min_cost ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 7 ; B = 11 ; C = 2 ; X = 20 ; NEW_LINE print ( findCost ( A , B , C , X ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize the cost of selecting two numbers whose product is X | Python3 implementation of the above approach ; max_prime [ i ] represents maximum prime number that divides the number i ; min_prime [ i ] represents minimum prime number that divides the number i ; Function to store the minimum prime factor and the maximum prime factor in two arrays ; Check for prime number if min_prime [ i ] > 0 , then it is not a prime number ; If i is a prime number , then both minimum and maximum prime numbers that divide the number is the number itself ; If this number is being visited for first time then this divisor must be the smallest prime number that divides this number ; The last prime number that divides this number will be maximum . ; Function to minimize the cost of finding two numbers for every number such that the product of those two is equal to X ; Pre - calculation ; If X == 1 , then there is no way to find N and M . Print - 1 ; Case 3 is always valid and cost for that is C + X C for choosing 1 and M = X / 1 ; Case 1 N is prime , first number cost is fixed N is max_prime number divides this number ; If X is prime then the maximum prime number is the number itself . For this case , M becomes 1 and this shouldn 't be considered. ; Find M for this case ; Add cost for the second number also ; Update min_cost , if the cost for prime is minimum ; Case 2 If N is composite For this find the minimum prime number that divides A [ i ] and consider this as M ; Find N for that number ; Check if this number is composite or not if N is prime then there is no way to find any composite number that divides X If N = min_prime [ N ] then N is prime ; Update min_cost , if the cost for the composite is minimum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10859-10859",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE return newNode NEW_LINE DEDENT def rec ( root , res , k ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return [ 0 , res ] ; NEW_LINE DEDENT xr = root . data ; NEW_LINE tmp , res = rec ( root . left , res , k ) ; NEW_LINE xr ^= tmp NEW_LINE tmp , res = rec ( root . right , res , k ) ; NEW_LINE xr ^= tmp NEW_LINE if ( xr == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return xr , res ; NEW_LINE DEDENT def findCount ( root , K ) : NEW_LINE ' NEW_LINE INDENT res = 0 ; NEW_LINE tmp , res = rec ( root , res , K ) ; NEW_LINE DEDENT ' NEW_LINE INDENT return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 2 ) ; NEW_LINE root . left = newNode ( 1 ) ; NEW_LINE root . right = newNode ( 9 ) ; NEW_LINE root . left . left = newNode ( 10 ) ; NEW_LINE root . left . right = newNode ( 5 ) ; NEW_LINE K = 5 ; NEW_LINE print ( findCount ( root , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of subtrees in a Binary Tree having XOR value K | A binary tree node ; A utility function to allocate a new node ; Base Case : If node is None , return 0 ; Calculating the XOR of the current subtree ; Increment res if xr is equal to k ; Return the XOR value of the current subtree ; Function to find the required count ; Initialize result variable 'res ; Recursively traverse the tree and compute the count ; return the count 'res ; Driver program ; Create the binary tree by adding nodes to it",
        "Category": "Binary Tree"
    },
    {
        "ID": "10862-10862",
        "Code": "def val ( c ) : NEW_LINE INDENT if ( ord ( c ) >= ord ( '0' ) and ord ( c ) <= ord ( '9' ) ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) + 10 NEW_LINE DEDENT DEDENT def toDeci ( str , base ) : NEW_LINE INDENT Len = len ( str ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( str [ i ] ) >= base ) : NEW_LINE INDENT print ( \" Invalid ▁ Number \" ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def isEven ( num , N ) : NEW_LINE INDENT deci = toDeci ( num , N ) NEW_LINE return ( deci % 2 == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = \"11A \" NEW_LINE N = 16 NEW_LINE if ( isEven ( num , N ) ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a N base number is Even or Odd | To return value of a char . ; Function to convert a number from N base to decimal ; power of base ; Decimal equivaLent is str [ Len - 1 ] * 1 + str [ Len - 1 ] * base + str [ Len - 1 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Returns true if n is even , else odd ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10867-10867",
        "Code": "N = 100005 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def longestPrimeSubsequence ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 4 , 11 , 2 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPrimeSubsequence ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of Longest Prime Subsequence in an Array | Python 3 program to find the length of Longest Prime Subsequence in an Array ; Function to create Sieve to check primes ; False here indicates that it is not prime ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to find the longest subsequence which contain all prime numbers ; Precompute N primes ; Find the length of longest prime subsequence ; Driver code ; Function call",
        "Category": "Array"
    },
    {
        "ID": "1087-1087",
        "Code": "class StackWithMax : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . mainStack = [ ] NEW_LINE self . trackStack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . mainStack . append ( x ) NEW_LINE if ( len ( self . mainStack ) == 1 ) : NEW_LINE INDENT self . trackStack . append ( x ) NEW_LINE return NEW_LINE DEDENT if ( x > self . trackStack [ - 1 ] ) : NEW_LINE INDENT self . trackStack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . trackStack . append ( self . trackStack [ - 1 ] ) NEW_LINE DEDENT DEDENT def getMax ( self ) : NEW_LINE INDENT return self . trackStack [ - 1 ] NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT self . mainStack . pop ( ) NEW_LINE self . trackStack . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = StackWithMax ( ) NEW_LINE s . push ( 20 ) NEW_LINE print ( s . getMax ( ) ) NEW_LINE s . push ( 10 ) NEW_LINE print ( s . getMax ( ) ) NEW_LINE s . push ( 50 ) NEW_LINE print ( s . getMax ( ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Tracking current Maximum Element in a Stack | Python3 program to keep track of maximum element in a stack ; main stack ; tack to keep track of max element ; If current element is greater than the top element of track stack , append the current element to track stack otherwise append the element at top of track stack again into it . ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "10872-10872",
        "Code": "import math NEW_LINE size = 101 NEW_LINE fib = [ 0 ] * 100010 NEW_LINE freq = [ 0 ] * ( 100010 ) NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return ( s * s ) == x NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def compute ( a , b ) : NEW_LINE INDENT for i in range ( 1 , 100010 ) : NEW_LINE INDENT fib [ i ] = isFibonacci ( i ) NEW_LINE DEDENT for x in range ( 1 , 100010 ) : NEW_LINE INDENT for y in range ( 1 , size ) : NEW_LINE INDENT if ( fib [ x ] == 1 and fib [ y ] == 1 and a * x + b * y < 100010 ) : NEW_LINE INDENT freq [ a * x + b * y ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT Q = 2 NEW_LINE A = 5 NEW_LINE B = 10 NEW_LINE compute ( A , B ) ; NEW_LINE arr = [ 50 , 150 ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Fibonacci pairs which satisfy the given equation | Python program to find the count of Fibonacci pairs ( x , y ) which satisfy the equation Ax + By = N ; Array to store the Fibonacci numbers ; Array to store the number of ordered pairs ; Function to find if a number is a perfect square ; Function that returns 1 if N is non - fibonacci number else 0 ; N is Fibinacci if one of 5 * n * n + 4 or 5 * n * n - 4 or both are perferct square ; Function to store the fibonacci numbers and their frequency in form a * x + b * y ; Storing the Fibonacci numbers ; For loop to find all the possible combinations of the Fibonacci numbers ; Finding the number of ordered pairs ; Driver code ; Find the ordered pair for every query",
        "Category": "Math"
    },
    {
        "ID": "10879-10879",
        "Code": "from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( N ) : NEW_LINE INDENT return isPerfectSquare ( 5 * N * N + 4 ) or isPerfectSquare ( 5 * N * N - 4 ) NEW_LINE DEDENT def nextNonFibonacci ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT if ( isFibonacci ( N + 1 ) ) : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 4 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE N = 7 NEW_LINE print ( nextNonFibonacci ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the next Non | Python 3 implementation of the approach ; Function to check if a number is perfect square ; Function to check if a number is Fibinacci Number ; N is Fibinacci if either ( 5 * N * N + 4 ) , ( 5 * N * N - 4 ) or both is a perferct square ; Function to find the next Non - Fibinacci Number ; Case 1 If N <= 3 , then 4 will be next Non - Fibinacci Number ; Case 2 If N + 1 is Fibinacci , then N + 2 will be next Non - Fibinacci Number ; If N + 1 is Non - Fibinacci , then N + 2 will be next Non - Fibinacci Number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10883-10883",
        "Code": "digit = [ 0 ] * ( 100000 ) NEW_LINE def findDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT digit [ count ] = n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def OR_of_Digits ( n , count ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT ans = ans | digit [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def AND_of_Digits ( n , count ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT ans = ans & digit [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def XOR_of_Digits ( n , count ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT ans = ans ^ digit [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def bitwise_operation ( N ) : NEW_LINE INDENT countOfDigit = findDigits ( N ) NEW_LINE print ( \" XOR ▁ = ▁ \" , XOR_of_Digits ( N , countOfDigit ) ) NEW_LINE print ( \" OR ▁ = ▁ \" , OR_of_Digits ( N , countOfDigit ) ) NEW_LINE print ( \" AND ▁ = ▁ \" , AND_of_Digits ( N , countOfDigit ) ) NEW_LINE DEDENT N = 123456 ; NEW_LINE bitwise_operation ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Bitwise Operations on Digits of a Number | Python 3 implementation of the approach ; Function to find the digits ; Function to Find OR of all digits of a number ; Find OR of all digits ; return OR of digits ; Function to Find AND of all digits of a number ; Find AND of all digits ; return AND of digits ; Function to Find XOR of all digits of a number ; Find XOR of all digits ; return XOR of digits ; Driver code ; Find and store all digits ; Find XOR of digits ; Find OR of digits ; Find AND of digits ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "10884-10884",
        "Code": "fact = [ 0 ] * 21 NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , 18 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] * i ) NEW_LINE DEDENT DEDENT def nextFactorial ( N ) : NEW_LINE INDENT for i in range ( 21 ) : NEW_LINE INDENT if N < fact [ i ] : NEW_LINE INDENT print ( fact [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT preCompute ( ) NEW_LINE N = 120 NEW_LINE nextFactorial ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Find the next Factorial greater than N | Array that stores the factorial till 20 ; Function to pre - compute the factorial till 20 ; Precomputing factorials ; Function to return the next factorial number greater than N ; Traverse the factorial array ; Find the next just greater factorial than N ; Function to precalculate the factorial till 20 ; Function call",
        "Category": "Array"
    },
    {
        "ID": "10887-10887",
        "Code": "from math import sqrt NEW_LINE def findRoots ( b , c ) : NEW_LINE INDENT a = 1 NEW_LINE d = b * b - 4 * a * c NEW_LINE sqrt_val = sqrt ( abs ( d ) ) NEW_LINE if ( d > 0 ) : NEW_LINE INDENT x = - b + sqrt_val NEW_LINE y = - b - sqrt_val NEW_LINE root1 = ( x ) // ( 2 * a ) NEW_LINE root2 = ( y ) // ( 2 * a ) NEW_LINE if ( root1 + root2 == - 1 * b and root1 * root2 == c ) : NEW_LINE INDENT print ( int ( root1 ) , \" , \" , int ( root2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT elif ( d == 0 ) : NEW_LINE INDENT root = - b // ( 2 * a ) NEW_LINE if ( root + root == - 1 * b and root * root == c ) : NEW_LINE INDENT print ( root , \" , \" , root ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE P = 6 NEW_LINE findRoots ( - S , P ) NEW_LINE S = 5 NEW_LINE P = 9 NEW_LINE findRoots ( - S , P ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print a pair of numbers with the given Sum and Product | Python3 program to find any pair which has sum S and product P . ; Prints roots of quadratic equation ax * 2 + bx + c = 0 ; calculating the sq root value for b * b - 4 * a * c ; Finding the roots ; Check if the roots are valid or not ; Finding the roots ; Check if the roots are valid or not ; when d < 0 ; No such pair exists in this case ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1089-1089",
        "Code": "st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number / 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Reverse a number using stack | Stack to maintain order of digits ; Function to push digits into stack ; Function to reverse the number ; Function call to push number 's   digits to stack ; Popping the digits and forming the reversed number ; Return the reversed number formed ; Driver Code ; Function call to reverse number",
        "Category": "Stack"
    },
    {
        "ID": "10892-10892",
        "Code": "from math import sqrt NEW_LINE mod = 1000000007 NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , 2 ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19374857 NEW_LINE mod = 17 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of factors of very large number N modulo M where M is any prime number | Python 3 implementation to find the Number of factors of very large number N modulo M ; Function for modular multiplication ; Function to find the number of factors of large Number N ; Count the number of times 2 divides the number N ; Condition to check if 2 divides it ; Check for all the possible numbers that can divide it ; Loop to check the number of times prime number i divides it ; Condition to check if prime number i divides it ; Condition to check if N at the end is a prime number . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10901-10901",
        "Code": "from math import log10 , floor NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findDigits ( 4 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 8 ) ) NEW_LINE print ( findDigits ( 12 , 16 ) ) NEW_LINE print ( findDigits ( 19 , 13 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the length of factorial of a number in any given base | A optimised program to find the number of digits in a factorial in base b ; Returns the number of digits present in n ! in base b Since the result can be large long long is used as return type ; factorial of - ve number doesn 't exists ; base case ; Use Kamenetsky formula to calculate the number of digits ; Driver Code ; calling findDigits ( Number , Base )",
        "Category": "Math"
    },
    {
        "ID": "10905-10905",
        "Code": "from math import sqrt NEW_LINE pref = [ 0 ] * 100010 NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( sqrt ( x ) ) NEW_LINE if ( s * s == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isNonFibonacci ( n ) : NEW_LINE INDENT x = 5 * n * n NEW_LINE if ( isPerfectSquare ( x + 4 ) or isPerfectSquare ( x - 4 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isNonFibonacci ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT compute ( ) NEW_LINE Q = 2 NEW_LINE arr = [ [ 1 , 5 ] , [ 6 , 10 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all Non | Python3 implementation to find the sum of all non - fibonacci numbers in a range from L to R ; Array to precompute the sum of non - fibonacci numbers ; Function to find if a number is a perfect square ; Function that returns N if N is non - fibonacci number ; N is Fibinacci if one of 5 * n * n + 4 or 5 * n * n - 4 or both are perferct square ; Function to precompute sum of non - fibonacci Numbers ; Function to find the sum of all non - fibonacci numbers in a range ; Pre - computation ; Loop to find the sum for each query",
        "Category": "Math"
    },
    {
        "ID": "10906-10906",
        "Code": "INFINITY_ = 9999999 NEW_LINE def sqrtByLongDivision ( n ) : NEW_LINE INDENT i = 0 NEW_LINE cur_divisor = 0 NEW_LINE quotient_units_digit = 0 NEW_LINE cur_quotient = 0 NEW_LINE cur_dividend = 0 NEW_LINE cur_remainder = 0 NEW_LINE a = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 100 NEW_LINE n = n // 100 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT cur_remainder = INFINITY_ NEW_LINE cur_dividend = cur_dividend * 100 + a [ j ] NEW_LINE for udigit in range ( 10 ) : NEW_LINE INDENT if ( cur_remainder >= cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) and cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) : NEW_LINE INDENT cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) NEW_LINE quotient_units_digit = udigit NEW_LINE DEDENT DEDENT cur_quotient = cur_quotient * 10 + quotient_units_digit NEW_LINE cur_divisor = cur_quotient * 2 NEW_LINE cur_dividend = cur_remainder NEW_LINE DEDENT return cur_quotient NEW_LINE DEDENT x = 1225 NEW_LINE print ( sqrtByLongDivision ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Long Division Method to find Square root with Examples | Python3 program to find the square root of a number by using long division method ; Function to find the square root of a number by using long division method ; udigit , j = 0 , 0 Loop counters ; Dividing the number into segments ; Last index of the array of segments ; Start long division from the last segment ( j = i ) ; Initialising the remainder to the maximum value ; Including the next segment in new dividend ; Loop to check for the perfect square closest to each segment ; This condition is to find the divisor after adding a digit in the range 0 to 9 ; Calculating the remainder ; Updating the units digit of the quotient ; Adding units digit to the quotient ; New divisor is two times quotient ; Including the remainder in new dividend ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10908-10908",
        "Code": "from math import sqrt NEW_LINE def previousFibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT def nextFibonacci ( n ) : NEW_LINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEW_LINE return round ( a ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT s = sqrt ( x ) NEW_LINE return ( s * s == x ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def countFibonacciPairs ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isFibonacci ( arr [ i ] ) and isFibonacci ( arr [ j ] ) ) : NEW_LINE INDENT prevFib = previousFibonacci ( arr [ i ] ) NEW_LINE nextFib = nextFibonacci ( arr [ i ] ) NEW_LINE if ( prevFib == arr [ j ] or nextFib == arr [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT a = [ 3 , 5 , 8 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( countFibonacciPairs ( a , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of consecutive Fibonacci pairs in the given Array | Python3 implementation to count the consecutive fibonacci pairs in the array ; Function to find the previous fibonacci for the number N ; Function to find the next fibonacci number for the number N ; Function to check that a Number is a perfect square or not ; Function to check that a number is fibonacci number or not ; N is Fibinacci if one of ( 5 * n * n + 4 ) or ( 5 * n * n - 4 ) is a perferct square ; Function to count the fibonacci pairs in the array ; Loop to iterate over the array to choose all pairs of the array ; Condition to check if both the number of pair is a fibonacci number ; Condition to check if both the number form consecutive fibonacci numbers ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "10914-10914",
        "Code": "mod = 1000000007 NEW_LINE ans = [ 1 ] * ( 100002 ) NEW_LINE pref = [ 0 ] * 100002 NEW_LINE def preCompute ( ) : NEW_LINE INDENT for i in range ( 2 , 100000 // 2 + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , 100000 + 1 , i ) : NEW_LINE INDENT ans [ j ] = ( ans [ j ] * i ) % mod NEW_LINE DEDENT DEDENT for i in range ( 1 , 100002 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ans [ i ] NEW_LINE pref [ i ] %= mod NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT def printSumProper ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Q = 2 NEW_LINE arr = [ [ 10 , 20 ] , [ 12 , 16 ] ] NEW_LINE printSumProper ( arr , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of product of proper divisors of all Numbers lying in range [ L , R ] | Python3 implementation to find the sum of the product of proper divisors of all the numbers lying in the range [ L , R ] ; Vector to store the product of the proper divisors of a number ; Variable to store the prefix sum of the product array ; Function to precompute the product of proper divisors of a number at it 's corresponding index ; Modificatino of sieve to store the product of the proper divisors ; Multiplying the existing value with i because i is the proper divisor of ans [ j ] ; Loop to store the prefix sum of the previously computed product array ; Computing the prefix sum ; Function to prthe sum for each query ; Function to prte sum of product of proper divisors of a number in [ L , R ] ; Calling the function that pre computes the sum of product of proper divisors ; Iterate over all Queries to prthe sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10915-10915",
        "Code": "def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 ] * N NEW_LINE genArray ( a , N ) NEW_LINE print ( a ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate an array of size N according to the given rules | Function to search the most recent location of element N If not present in the array it will return - 1 ; Function to generate an array of size N by following the given rules ; Loop to fill the array as per the given rules ; Check for the occurrence of arr [ i - 1 ] ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "10920-10920",
        "Code": "pref = [ 0 ] * 100001 NEW_LINE def checkArmstrong ( x ) : NEW_LINE INDENT n = len ( str ( x ) ) NEW_LINE sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp //= 10 NEW_LINE DEDENT if sum1 == x : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkArmstrong ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) NEW_LINE DEDENT def printSumarmstrong ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT Q = 2 NEW_LINE arr = [ [ 1 , 13 ] , [ 121 , 211 ] ] NEW_LINE printSumarmstrong ( arr , Q ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of all armstrong numbers lying in the range [ L , R ] for Q queries | pref [ ] array to precompute the sum of all armstrong number ; Function that return number num if num is armstrong else return 0 ; Function to precompute the sum of all armstrong numbers upto 100000 ; checkarmstrong ( ) return the number i if i is armstrong else return 0 ; Function to print the sum for each query ; Function to prsum of all armstrong numbers between [ L , R ] ; Function that pre computes the sum of all armstrong numbers ; Iterate over all Queries to print the sum ; Queries ; Function that print the the sum of all armstrong number in Range [ L , R ]",
        "Category": "Math"
    },
    {
        "ID": "10922-10922",
        "Code": "def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp //= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR ▁ = ▁ \" , CalculateXOR ) NEW_LINE print ( \" OR ▁ = ▁ \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXORandOR ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "XOR and OR of all N | Function to check if a number is Armstrong or not ; Function to find XOR of all N - digits Armstrong number ; To store the XOR and OR of all Armstrong number ; Starting N - digit Armstrong number ; Ending N - digit Armstrong number ; Iterate over starting and ending number ; To check if i is Armstrong or not ; Print the XOR and OR of all Armstrong number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10941-10941",
        "Code": "import math NEW_LINE def ways ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT c2 = 0 NEW_LINE c1 = n - 3 NEW_LINE l = c1 + 1 NEW_LINE s = 0 NEW_LINE exp_c2 = c1 / 2 NEW_LINE while exp_c2 >= c2 : NEW_LINE INDENT f1 = math . factorial ( l ) NEW_LINE f2 = math . factorial ( c1 ) NEW_LINE f3 = math . factorial ( c2 ) NEW_LINE s += f1 // ( f2 * f3 ) NEW_LINE c2 += 1 NEW_LINE c1 -= 2 NEW_LINE l -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE print ( ways ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count ways to reach the Nth stair using multiple 1 or 2 steps and a single step 3 | Python3 implementation to find the number the number of ways to reach Nth stair by taking 1 or 2 steps at a time and 3 rd Step exactly once ; Function to find the number of ways ; Base Case ; Count of 2 - steps ; Count of 1 - steps ; Initial length of sequence ; expected count of 2 - steps ; Loop to find the ways for every possible sequence ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10942-10942",
        "Code": "def isPerfectCube ( x ) : NEW_LINE INDENT cr = int ( x ** ( 1 / 3 ) ) ; NEW_LINE return ( cr * cr * cr == x ) ; NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 ; K = 1 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 5 ; K = 4 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 7 ; K = 2 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether N can be a Perfect Cube after adding or subtracting K | Function to check if a number is a perfect Cube or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10949-10949",
        "Code": "pref = [ 0 ] * 100001 NEW_LINE def checkPalindrome ( num ) : NEW_LINE INDENT strr = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) NEW_LINE DEDENT def printSumPalindromic ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT Q = 2 NEW_LINE arr = [ [ 10 , 13 ] , [ 12 , 21 ] ] NEW_LINE printSumPalindromic ( arr , Q ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of all palindromic numbers lying in the range [ L , R ] for Q queries | pref [ ] array to precompute the sum of all palindromic number ; Function that return number num if num is palindromic else return 0 ; Convert num to string ; Function to precompute the sum of all palindrome numbers upto 100000 ; checkPalindrome ( ) return the number i if i is palindromic else return 0 ; Function to print the sum for each query ; Function to prsum of all palindromic numbers between [ L , R ] ; Function that pre computes the sum of all palindromic numbers ; Iterate over all Queries to print the sum ; Queries ; Function that print the the sum of all palindromic number in Range [ L , R ]",
        "Category": "Array"
    },
    {
        "ID": "10959-10959",
        "Code": "def sumOfParts ( arr , N ) : NEW_LINE INDENT sum_part1 , sum_part2 , sum_part3 , sum_part4 = 0 , 0 , 0 , 0 NEW_LINE totalsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i + j < N - 1 : NEW_LINE INDENT if ( i < j and i != j and i + j ) : NEW_LINE INDENT sum_part1 += arr [ i ] [ j ] NEW_LINE DEDENT elif i != j : NEW_LINE INDENT sum_part2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i > j and i + j != N - 1 : NEW_LINE INDENT sum_part3 += arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if i + j != N - 1 and i != j : NEW_LINE INDENT sum_part4 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return sum_part1 + sum_part2 + sum_part3 + sum_part4 NEW_LINE DEDENT N = 4 NEW_LINE arr = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] NEW_LINE print ( sumOfParts ( arr , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of non | Function to return a vector which consists the sum of four portions of the matrix ; Iterating through the matrix ; Condition for selecting all values before the second diagonal of metrics ; Top portion of the matrix ; Left portion of the matrix ; Bottom portion of the matrix ; Right portion of the matrix ; Adding all the four portions into a vecto ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "10962-10962",
        "Code": "def ifPossible ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT X , Y = Y , X NEW_LINE DEDENT if ( ( X + Y ) % 5 == 0 and 3 * X >= 2 * Y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT X = 33 NEW_LINE Y = 27 NEW_LINE ifPossible ( X , Y ) NEW_LINE",
        "Type": "py",
        "NL": "Check if X and Y can be made zero by using given operation any number of times | Function to check if X and Y can be made equal to zero by using given operation any number of times ; Check for the two conditions ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10967-10967",
        "Code": "from math import log NEW_LINE def log_a_to_base_b ( a , b ) : NEW_LINE INDENT return log ( a ) // log ( b ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 ; NEW_LINE b = 2 ; NEW_LINE print ( log_a_to_base_b ( a , b ) ) ; NEW_LINE a = 256 ; NEW_LINE b = 4 ; NEW_LINE print ( log_a_to_base_b ( a , b ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to compute log a to any base b ( logb a ) | Python3 program to find log ( a ) on any base b ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10969-10969",
        "Code": "def findLargest ( N ) : NEW_LINE INDENT largest = ' F ' * N NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = '1' + '0' * ( N - 1 ) NEW_LINE return smallest ; NEW_LINE DEDENT def printAns ( largest ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( largest ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( largest ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE printAns ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest and Smallest N | Function to return the largest N - digit number in Hexa - Decimal Number System ; Append ' F ' N times ; Function to return the smallest N - digit number in Hexa - Decimal Number System ; Append '0' ( N - 1 ) times to 1 ; Function to print the largest and smallest N - digit Hexa - Decimal number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1097-1097",
        "Code": "def heapify ( arr , n , i ) : NEW_LINE INDENT largest = i NEW_LINE l = 2 * i + 1 NEW_LINE r = 2 * i + 2 NEW_LINE if l < n and arr [ largest ] < arr [ l ] : NEW_LINE INDENT largest = l NEW_LINE DEDENT if r < n and arr [ largest ] < arr [ r ] : NEW_LINE INDENT largest = r NEW_LINE DEDENT if largest != i : NEW_LINE INDENT arr [ i ] , arr [ largest ] = arr [ largest ] , arr [ i ] NEW_LINE heapify ( arr , n , largest ) NEW_LINE DEDENT DEDENT def heapSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n // 2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT heapify ( arr , n , i ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] , arr [ 0 ] = arr [ 0 ] , arr [ i ] NEW_LINE heapify ( arr , i , 0 ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE heapSort ( arr ) NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sorted ▁ array ▁ is \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( \" % d \" % arr [ i ] ) , NEW_LINE DEDENT",
        "Type": "py",
        "NL": "HeapSort | To heapify subtree rooted at index i . n is size of heap ; Initialize largest as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; See if left child of root exists and is greater than root ; See if right child of root exists and is greater than root ; Change root , if needed ; Heapify the root . ; The main function to sort an array of given size ; Build a maxheap . ; One by one extract elements ; swap ; call max heapify on the reduced heap ; Driver code",
        "Category": "Heap"
    },
    {
        "ID": "10971-10971",
        "Code": "import math NEW_LINE def prevPowerofK ( n , k ) : NEW_LINE INDENT p = int ( math . log ( n ) / math . log ( k ) ) NEW_LINE return int ( math . pow ( k , p ) ) NEW_LINE DEDENT def nextPowerOfK ( n , k ) : NEW_LINE INDENT return prevPowerofK ( n , k ) * k NEW_LINE DEDENT def printResult ( n , k ) : NEW_LINE INDENT print ( prevPowerofK ( n , k ) , nextPowerOfK ( n , k ) ) NEW_LINE DEDENT n = 6 NEW_LINE k = 3 NEW_LINE printResult ( n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Highest and Smallest power of K less than and greater than equal to N respectively | Python3 implementation of the approach ; Function to return the highest power of k less than or equal to n ; Function to return the smallest power of k greater than or equal to n ; Function to print the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10975-10975",
        "Code": "def calNum ( year ) : NEW_LINE INDENT return ( year // 4 ) - ( year // 100 ) + ( year // 400 ) ; NEW_LINE DEDENT def leapNum ( l , r ) : NEW_LINE INDENT l -= 1 ; NEW_LINE num1 = calNum ( r ) ; NEW_LINE num2 = calNum ( l ) ; NEW_LINE print ( num1 - num2 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l1 = 1 ; r1 = 400 ; NEW_LINE leapNum ( l1 , r1 ) ; NEW_LINE l2 = 400 ; r2 = 2000 ; NEW_LINE leapNum ( l2 , r2 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Leap Years in a given year range | Function to calculate the number of leap years in range of ( 1 , year ) ; Function to calculate the number of leap years in given range ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10981-10981",
        "Code": "def nature_of_roots ( a , b , c ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT print ( \" Not ▁ a ▁ Quadratic ▁ Equation \" ) ; NEW_LINE return ; NEW_LINE DEDENT D = b * b - 4 * a * c ; NEW_LINE if ( D > 0 ) : NEW_LINE INDENT print ( \" Real ▁ Roots \" ) ; NEW_LINE DEDENT elif ( D == 0 ) : NEW_LINE INDENT print ( \" Equal ▁ Roots \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Imaginary ▁ Roots \" ) ; NEW_LINE DEDENT DEDENT def checkForAllTestCase ( ) : NEW_LINE INDENT print ( \" Testcase TABSYMBOL a TABSYMBOL b TABSYMBOL c TABSYMBOL Actual ▁ Output \" ) ; NEW_LINE print ( ) ; NEW_LINE a = b = c = 0 ; NEW_LINE testcase = 1 ; NEW_LINE while ( testcase <= 13 ) : NEW_LINE INDENT if ( testcase == 1 ) : NEW_LINE INDENT a = 0 ; NEW_LINE b = 50 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 2 ) : NEW_LINE INDENT a = 1 ; NEW_LINE b = 50 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 3 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 50 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 4 ) : NEW_LINE INDENT a = 99 ; NEW_LINE b = 50 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 5 ) : NEW_LINE INDENT a = 100 ; NEW_LINE b = 50 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 6 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 0 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 7 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 1 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 8 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 99 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 9 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 100 ; NEW_LINE c = 50 ; NEW_LINE DEDENT elif ( testcase == 10 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 50 ; NEW_LINE c = 0 ; NEW_LINE DEDENT elif ( testcase == 11 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 50 ; NEW_LINE c = 1 ; NEW_LINE DEDENT elif ( testcase == 12 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 50 ; NEW_LINE c = 99 ; NEW_LINE DEDENT elif ( testcase == 13 ) : NEW_LINE INDENT a = 50 ; NEW_LINE b = 50 ; NEW_LINE c = 100 ; NEW_LINE DEDENT print ( \" TABSYMBOL \" , testcase , \" TABSYMBOL \" , a , \" TABSYMBOL \" , b , \" TABSYMBOL \" , c , \" TABSYMBOL \" , end = \" \" ) ; NEW_LINE nature_of_roots ( a , b , c ) ; NEW_LINE print ( ) ; NEW_LINE testcase += 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT checkForAllTestCase ( ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Boundary Value Analysis : Nature of Roots of a Quadratic equation | BVA for nature of roots of a quadratic equation ; If a = 0 , D / 2 a will yield exception Hence it is not a valid Quadratic Equation ; If D > 0 , it will be Real Roots ; If D == 0 , it will be Equal Roots ; If D < 0 , it will be Imaginary Roots ; Function to check for all testcases ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10982-10982",
        "Code": "def isPossible ( N , S , C , H , L , T ) : NEW_LINE INDENT total_time_required = S * C * H NEW_LINE available_time_after_vacation = ( N - L ) * T NEW_LINE if ( available_time_after_vacation >= total_time_required ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT N = 12 NEW_LINE S = 5 NEW_LINE C = 8 NEW_LINE H = 3 NEW_LINE L = 2 NEW_LINE T = 20 NEW_LINE if ( isPossible ( N , S , C , H , L , T ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT N = 1 NEW_LINE S = 2 NEW_LINE C = 3 NEW_LINE H = 4 NEW_LINE L = 5 NEW_LINE T = 6 NEW_LINE if ( isPossible ( N , S , C , H , L , T ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if the Vacation can be taken or not | Function to find if the Vacation is possible or not ; Find the required number of hours of study ; find the hours of study that can be done if the vacation is taken ; check if the required hours are less than or equal to the hours of study that can be done if the vacation is taken ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "10984-10984",
        "Code": "def maximum ( x , y ) : NEW_LINE INDENT return ( ( x + y + abs ( x - y ) ) // 2 ) NEW_LINE DEDENT def minimum ( x , y ) : NEW_LINE INDENT return ( ( x + y - abs ( x - y ) ) // 2 ) NEW_LINE DEDENT x = 99 NEW_LINE y = 18 NEW_LINE print ( \" Maximum : \" , maximum ( x , y ) ) NEW_LINE print ( \" Minimum : \" , minimum ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find Maximum and Minimum of two numbers using Absolute function | Function to return maximum among the two numbers ; Function to return minimum among the two numbers ; Driver code ; Displaying the maximum value ; Displaying the minimum value",
        "Category": "Math"
    },
    {
        "ID": "10992-10992",
        "Code": "def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Given a number N in decimal base , find the sum of digits in any base B | Function to compute sum of Digits of Number N in base B ; Initialize sum with 0 ; Compute unit digit of the number ; Add unit digit in sum ; Update value of Number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "10998-10998",
        "Code": "def squareRoot ( n , l ) : NEW_LINE INDENT x = n NEW_LINE count = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT count += 1 NEW_LINE root = 0.5 * ( x + ( n / x ) ) NEW_LINE if ( abs ( root - x ) < l ) : NEW_LINE INDENT break NEW_LINE DEDENT x = root NEW_LINE DEDENT return root NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 327 NEW_LINE l = 0.00001 NEW_LINE print ( squareRoot ( n , l ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find root of a number using Newton 's method | Function to return the square root of a number using Newtons method ; Assuming the sqrt of n as n only ; To count the number of iterations ; Calculate more closed x ; Check for closeness ; Update root ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "110-110",
        "Code": "def isSumProperty ( node ) : NEW_LINE INDENT left_data = 0 NEW_LINE right_data = 0 NEW_LINE if ( node == None or ( node . left == None and node . right == None ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( node . left != None ) : NEW_LINE INDENT left_data = node . left . data NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT right_data = node . right . data NEW_LINE DEDENT if ( ( node . data == left_data + right_data ) and isSumProperty ( node . left ) and isSumProperty ( node . right ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 2 ) NEW_LINE if ( isSumProperty ( root ) ) : NEW_LINE INDENT print ( \" The ▁ given ▁ tree ▁ satisfies ▁ the \" , \" children ▁ sum ▁ property ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy \" , \" the ▁ children ▁ sum ▁ property ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check for Children Sum Property in a Binary Tree | returns 1 if children sum property holds for the given node and both of its children ; left_data is left child data and right_data is for right child data ; If node is None or it 's a leaf   node then return true  ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; if the node and both of its children satisfy the property return 1 else 0 ; Helper class that allocates a new node with the given data and None left and right pointers . ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "11006-11006",
        "Code": "def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 ; NEW_LINE currSum = 0 ; NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N ; NEW_LINE N = N - 1 ; NEW_LINE countElements = countElements + 1 ; NEW_LINE DEDENT return countElements ; NEW_LINE DEDENT N = 5 ; NEW_LINE S = 11 ; NEW_LINE count = countNumber ( N , S ) ; NEW_LINE print ( count ) ; NEW_LINE",
        "Type": "py",
        "NL": "Length of Smallest subarray in range 1 to N with sum greater than a given value | Function to return the count of minimum elements such that the sum of those elements is > S . ; Initialize currentSum = 0 ; Loop from N to 1 to add the numbers and check the condition . ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "11011-11011",
        "Code": "mod = 10 ** 9 + 7 NEW_LINE N = 1000005 NEW_LINE lpf = [ 0 for i in range ( N ) ] NEW_LINE def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT lpf [ i ] = i NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( lpf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT if ( lpf [ j ] == j ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def sum_of_elements ( a , n ) : NEW_LINE INDENT least_prime_factor ( ) NEW_LINE prime_factor = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE single_number = dict ( ) NEW_LINE while ( temp > 1 ) : NEW_LINE INDENT x = lpf [ temp ] NEW_LINE single_number [ x ] = single_number . get ( x , 0 ) + 1 NEW_LINE temp //= x NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT prime_factor = single_number NEW_LINE DEDENT else : NEW_LINE INDENT for x in single_number : NEW_LINE INDENT if x in prime_factor : NEW_LINE INDENT prime_factor [ x ] = max ( prime_factor [ x ] , single_number [ x ] ) NEW_LINE DEDENT else : NEW_LINE INDENT prime_factor [ x ] = single_number [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans , lcm = 0 , 1 NEW_LINE for x in prime_factor : NEW_LINE INDENT lcm = ( lcm * pow ( x , prime_factor [ x ] , mod ) ) % mod NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans = ( ans + ( lcm * pow ( a [ i ] , mod - 2 , mod ) ) % mod ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( sum_of_elements ( a , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum possible sum of array B such that AiBi = AjBj for all 1 â ‰¤ i < j â ‰¤ N | Python3 implementation of the approach ; To store least prime factors of all the numbers ; Function to find the least prime factor of all the numbers ; Function to return the sum of elements of array B ; Find the prime factors of all the numbers ; To store each prime count in lcm ; Current number ; Map to store the prime count of a single number ; Basic way to calculate all prime factors ; If it is the first number in the array ; Take the maximum count of prime in a number ; Calculate lcm of given array ; Calculate sum of elements of array B ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11013-11013",
        "Code": "def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE equal_xor_sum ( arr , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if Sum and XOR of all elements of array is equal | Function to Check if Sum and XOR of all elements of array is equal ; Sum and XOR of all elements ; Checking Sum and XOR to be equal ; Driver Function ; Check Sum and XOR is equal",
        "Category": "Math"
    },
    {
        "ID": "11016-11016",
        "Code": "def findNumber ( s , d ) : NEW_LINE INDENT num = \" \" NEW_LINE val = s // d NEW_LINE rem = s % d NEW_LINE for i in range ( 1 , d - rem + 1 ) : NEW_LINE INDENT num = num + str ( val ) NEW_LINE DEDENT if ( rem ) : NEW_LINE INDENT val += 1 NEW_LINE for i in range ( d - rem + 1 , d + 1 ) : NEW_LINE INDENT num = num + str ( val ) NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = 25 NEW_LINE d = 4 NEW_LINE print ( findNumber ( s , d ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find smallest number with given number of digits and sum of digits under given constraints | Function to find the number having sum of digits as s and d number of digits such that the difference between the maximum and the minimum digit the minimum possible ; To store the final number ; To store the value that is evenly distributed among all the digits ; To store the remaining sum that still remains to be distributed among d digits ; rem stores the value that still remains to be distributed To keep the difference of digits minimum last rem digits are incremented by 1 ; In the last rem digits one is added to the value obtained by equal distribution ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "11025-11025",
        "Code": "MAXN = 1000000 NEW_LINE def maxCommonElement ( A , D , N ) : NEW_LINE INDENT cnt = [ 0 ] * MAXN NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( A [ i ] , MAXN , D [ i ] ) : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE com = 0 NEW_LINE for i in range ( MAXN ) : NEW_LINE INDENT if cnt [ i ] > ans : NEW_LINE INDENT ans = cnt [ i ] NEW_LINE com = i NEW_LINE DEDENT DEDENT return com NEW_LINE DEDENT A = [ 13 , 1 , 2 , 5 ] NEW_LINE D = [ 5 , 10 , 1 , 12 ] NEW_LINE N = len ( A ) NEW_LINE print ( maxCommonElement ( A , D , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find an integer that is common in the maximum number of given arithmetic progressions | Python implementation of the approach ; Function to return element common in maximum number of APs ; Initialize the count variable ; Increment count for every element of an AP ; Find the index with maximum count ; Return the maximum common element ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "11032-11032",
        "Code": "import math NEW_LINE r1 = 0 NEW_LINE r2 = 0 NEW_LINE r3 = 0 NEW_LINE def area ( a , b , c ) : NEW_LINE INDENT p = ( a + b + c ) / 2 NEW_LINE return ( ( math . sqrt ( p ) ) * ( math . sqrt ( p - a ) ) * ( math . sqrt ( p - b ) ) * ( math . sqrt ( p - c ) ) ) NEW_LINE DEDENT def binary_search ( ) : NEW_LINE INDENT global r1 , r2 , r3 NEW_LINE s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) NEW_LINE l = 0 NEW_LINE h = s / ( r1 + r2 + r3 ) NEW_LINE while ( h - l > 0.00000001 ) : NEW_LINE INDENT mid = ( l + h ) / 2 NEW_LINE s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) NEW_LINE s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) NEW_LINE s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) NEW_LINE if ( s1 + s2 + s3 < s ) : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT return ( ( l + h ) / 2 ) NEW_LINE DEDENT r1 = 1 NEW_LINE r2 = 2 NEW_LINE r3 = 3 NEW_LINE print ( \" { 0 : . 6f } \" . format ( binary_search ( ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Radius of the inscribed circle within three tangent circles | Python3 implementation of the approach ; Radius of the 3 given circles ; Calculation of area of a triangle by Heron 's formula ; Applying binary search to find the radius r4 of the required circle ; Area of main triangle ; Loop runs until l and h becomes approximately equal ; Area of smaller triangles ; If sum of smaller triangles is less than main triangle ; If sum of smaller triangles is greater than or equal to main triangle ; Taking r1 , r2 , r3 as input ; Call to function binary search",
        "Category": "Binary Search"
    },
    {
        "ID": "11033-11033",
        "Code": "from math import sqrt NEW_LINE r1 = 1 NEW_LINE r2 = 2 NEW_LINE r3 = 3 NEW_LINE r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) NEW_LINE print ( round ( r4 , 6 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Radius of the inscribed circle within three tangent circles | Python3 implementation of the approach ; Taking r1 , r2 , r3 as input ; Calculation of r4 using formula given above",
        "Category": "Math"
    },
    {
        "ID": "11036-11036",
        "Code": "import math NEW_LINE def isPalindrome ( s ) : NEW_LINE INDENT left = 0 NEW_LINE right = len ( s ) - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( s [ left ] != s [ right ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT left = left + 1 NEW_LINE right = right - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT start = int ( math . pow ( 10 , n - 1 ) ) NEW_LINE end = int ( math . pow ( 10 , n ) ) - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE if ( isPalindrome ( s ) ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 1 NEW_LINE ans = getSum ( n ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of all N digit palindrome numbers | Python program for the above approach ; Function to check palindrome ; Function to calculate the sum of n - digit palindrome ; Run a loop to check all possible palindrome ; If palindrome append sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11037-11037",
        "Code": "def getSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT sum = 45.0 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE ans = int ( getSum ( n ) ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all N digit palindrome numbers | Function to calculate sum of n digit number ; Corner case ; Using above approach ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11043-11043",
        "Code": "from math import ceil , sqrt NEW_LINE def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n / 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT print ( FermatFactors ( 6557 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Fermat 's Factorization Method | Python 3 implementation of fermat 's factorization ; This function finds the value of a and b and returns a + b and a - b ; since fermat 's factorization applicable  for odd positive integers only ; check if n is a even number ; if n is a perfect root , then both its square roots are its factors ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11046-11046",
        "Code": "def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE print ( * solve ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Satisfy the parabola when point ( A , B ) and the equation is given | Function to find the required values ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11054-11054",
        "Code": "sz = 10 ** 5 NEW_LINE isPrime = [ True for i in range ( sz + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < sz : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def prArray ( arr , lenn ) : NEW_LINE INDENT for i in range ( lenn ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def removePrimes ( arr , lenn ) : NEW_LINE INDENT sieve ( ) NEW_LINE i = 0 NEW_LINE while i < lenn : NEW_LINE INDENT if ( isPrime [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , lenn - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE lenn -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT prArray ( arr , lenn ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 ] NEW_LINE lenn = len ( arr ) NEW_LINE removePrimes ( arr , lenn ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove all the prime numbers from the given array | Python3 implementation of the approach ; Function for Sieve of Eratosthenes ; Function to pr the elements of the array ; Function to remove all the prime numbers ; Generate primes ; Traverse the array ; If the current element is prime ; Shift all the elements on the right of it to the left ; Decrease the loop counter by 1 to check the shifted element ; Decrease the length ; Pr the updated array ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11061-11061",
        "Code": "def digitSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 ; NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 ; NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor ; NEW_LINE trailing = n % 10 ; NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = ( n % divisor ) // 10 ; NEW_LINE divisor = divisor // 100 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) ; NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 56 ; NEW_LINE if ( isDigitSumPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if the sum of digits of N is palindrome | Function to return the sum of digits of n ; Function that returns true if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function that returns true if the digit sum of n is palindrome ; Sum of the digits of n ; If the digit sum is palindrome ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11062-11062",
        "Code": "def countDigits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def digitPowSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE pw = countDigits ( n ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += pow ( d , pw ) NEW_LINE pw -= 1 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNum ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == digitPowSum ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 200 NEW_LINE print ( countNum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of numbers whose sum of increasing powers of digits is equal to the number itself | Function to return the count of digits of n ; Function to return the sum of increasing powers of N ; To store the required answer ; Count of digits in n which will be the power of the last digit ; While there are digits left ; Get the last digit ; Add the last digit after raising it to the required power ; Decrement the power for the previous digit ; Remove the last digit ; Function to return the count of integers which satisfy the given conditions ; If current element satisfies the given condition ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11064-11064",
        "Code": "from math import ceil , sqrt NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) ; NEW_LINE n2 = number * number ; NEW_LINE number = ( number * 2 ) + 1 ; NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = \" ▁ \" ) ; NEW_LINE n2 = n2 + number ; NEW_LINE number += 2 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2 ; r = 24 ; NEW_LINE perfectSquares ( l , r ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all perfect squares from the given range | Python3 implementation of the approach ; Function to print all the perfect squares from the given range ; Getting the very first number ; First number 's square ; Next number is at the difference of ; While the perfect squares are from the range ; Print the perfect square ; Get the next perfect square ; Next odd number to be added ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11067-11067",
        "Code": "def check ( n ) : NEW_LINE INDENT if n % 2 == 1 and n > 5 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = 3 NEW_LINE b = 7 NEW_LINE check ( a ) NEW_LINE check ( b ) NEW_LINE DEDENT main ( ) NEW_LINE",
        "Type": "py",
        "NL": "Goldbach 's Weak Conjecture for Odd numbers | Function to check if a number can be represent as as a sum of 3 prime ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11068-11068",
        "Code": "from math import ceil , floor , sqrt NEW_LINE def findRemainders ( n ) : NEW_LINE INDENT vc = dict ( ) NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT vc [ n // i ] = 1 NEW_LINE DEDENT for i in range ( n // ceil ( sqrt ( n ) ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT vc [ i ] = 1 NEW_LINE DEDENT for it in sorted ( vc ) : NEW_LINE INDENT print ( it , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE findRemainders ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Find all the possible remainders when N is divided by all positive integers from 1 to N + 1 | Python3 implementation of the approach ; Function to find all the distinct remainders when n is divided by all the elements from the range [ 1 , n + 1 ] ; Set will be used to store the remainders in order to eliminate duplicates ; Find the remainders ; Print the contents of the set ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11072-11072",
        "Code": "import sys NEW_LINE MAX = 10 NEW_LINE def distinctDigits ( x ) : NEW_LINE INDENT present = [ False for i in range ( MAX ) ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( present [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT present [ digit ] = True NEW_LINE x = x // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findK ( l , r ) : NEW_LINE INDENT maxExp = - sys . maxsize - 1 NEW_LINE k = - 1 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( distinctDigits ( i ) ) : NEW_LINE INDENT exp = ( l - i ) * ( i - r ) NEW_LINE if ( exp >= maxExp ) : NEW_LINE INDENT k = i ; NEW_LINE maxExp = exp NEW_LINE DEDENT DEDENT DEDENT return k NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 50 NEW_LINE r = 60 NEW_LINE print ( findK ( l , r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find an integer in the given range that satisfies the given conditions | Python3 implementation of the approach ; Function that returns true if x contains all distinct digits ; Last digit of x ; If current digit has appeared before ; Mark the current digit to present ; Remove the last digit ; Function to return the required value of k ; To store the maximum value for the given expression ; If i contains all distinct digits ; If the value of the expression is also maximum then update k and the expression ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11075-11075",
        "Code": "def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( \" Second ▁ Player ▁ wins ▁ the ▁ game \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" First ▁ Player ▁ wins ▁ the ▁ game \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 ; NEW_LINE findWinner ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the player who will win the Coin game | Function to check the wining player ; As discussed in the above approach ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11078-11078",
        "Code": "def min_changes ( a , n ) : NEW_LINE INDENT ans_a = 0 ; NEW_LINE ans_b = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_a += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans_b += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_b += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans_a += 1 ; NEW_LINE DEDENT DEDENT DEDENT return min ( ans_a , ans_b ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( min_changes ( a , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum inversions required so that no two adjacent elements are same | Function to return the minimum inversions required so that no two adjacent elements are same ; To store the inversions required to make the array { 1 , 0 , 1 , 0 , 1 , 0 , 1 , ... } and { 0 , 1 , 0 , 1 , 0 , 1 , 0 , ... } respectively ; Find all the changes required ; Return the required answer ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11079-11079",
        "Code": "def ans ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE ans ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all the numbers present at given level in Modified Pascal ’ s triangle | Function to calculate sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11087-11087",
        "Code": "def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) // 2 + m - 1 ) // m * m ; NEW_LINE DEDENT DEDENT n = 17 NEW_LINE m = 4 NEW_LINE ans = minsteps ( n , m ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Form N by adding 1 or 2 in minimum number of operations X where X is divisible by M | Function to calculate the minimum number of steps required total steps taken is divisible by m and only 1 or 2 steps can be taken at a time ; If m > n ans is - 1 ; else discussed above approach ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11089-11089",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def removeLeadingZeros ( a ) : NEW_LINE INDENT if ( a != None and a . data == 0 ) : NEW_LINE INDENT return removeLeadingZeros ( a . next ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return a ; NEW_LINE DEDENT DEDENT def getSize ( a ) : NEW_LINE INDENT sz = 0 ; NEW_LINE while ( a != None ) : NEW_LINE INDENT a = a . next ; NEW_LINE sz += 1 NEW_LINE DEDENT return sz ; NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data ; NEW_LINE new_node . next = ( head_ref ) ; NEW_LINE ( head_ref ) = new_node ; NEW_LINE return head_ref NEW_LINE DEDENT def compare ( a , b ) : NEW_LINE INDENT a = removeLeadingZeros ( a ) ; NEW_LINE b = removeLeadingZeros ( b ) ; NEW_LINE lenA = getSize ( a ) ; NEW_LINE lenB = getSize ( b ) ; NEW_LINE if ( lenA > lenB ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( lenB > lenA ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT while ( a != None and b != None ) : NEW_LINE INDENT if ( a . data > b . data ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( a . data < b . data ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = a . next ; NEW_LINE b = b . next ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = None ; NEW_LINE a = push ( a , 7 ) ; NEW_LINE a = push ( a , 6 ) ; NEW_LINE a = push ( a , 5 ) ; NEW_LINE b = None ; NEW_LINE b = push ( b , 3 ) ; NEW_LINE b = push ( b , 3 ) ; NEW_LINE b = push ( b , 2 ) ; NEW_LINE print ( compare ( a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Compare numbers represented by Linked Lists | Structure for a linked list node ; A helper function to remove zeros from the start of the linked list ; A helper function to find the length of linked list ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; Allocate node ; Set the data ; Link the old list after the new node ; Set the head to point to the new node ; Function to compare the numbers represented as linked lists ; Remover leading zeroes from the linked lists ; Since the number represented by a has a greater length , it will be greater ; If the lengths of two numbers are equal we have to check their magnitudes ; If we reach here , then a and b are not None and their data is same , so move to next nodes in both lists ; If linked lists are identical , then we need to return zero ; Driver code ; The constructed linked lists are : a : 5.6 . 7 b : 2.3 . 3",
        "Category": "Linked List"
    },
    {
        "ID": "11099-11099",
        "Code": "from math import ceil , log2 NEW_LINE def solve ( n , x , y ) : NEW_LINE INDENT length = ceil ( log2 ( n + 2 ) ) - 1 ; NEW_LINE rank = n - ( 1 << length ) + 1 ; NEW_LINE left = \" \" ; right = \" \" ; NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT mask = ( 1 << i ) ; NEW_LINE bit = ( mask & rank ) ; NEW_LINE if ( bit ) : NEW_LINE INDENT left += y ; NEW_LINE right += y ; NEW_LINE DEDENT else : NEW_LINE INDENT left += x ; NEW_LINE right += x ; NEW_LINE DEDENT DEDENT right = right [ : : - 1 ] ; NEW_LINE res = left + right ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 ; NEW_LINE x = '4' ; NEW_LINE y = '5' ; NEW_LINE ans = solve ( n , x , y ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Nth even length palindromic number formed using digits X and Y | Python3 program to find nth even palindromic number of only even length composing of 4 ' s ▁ and ▁ 5' s . ; Utility function to compute n 'th palindrome number  ; Calculate the length from above formula as discussed above ; Calculate rank for length L ; Mask to check if i 't bit   is set or not  ; If bit is set append '5' else append '4' ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11100-11100",
        "Code": "def cntCakes ( n , m ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE quo , rem = m // sum , m % sum NEW_LINE ans = m - quo * sum NEW_LINE x = int ( ( - 1 + ( 8 * rem + 1 ) ** 0.5 ) / 2 ) NEW_LINE ans = ans - x * ( x + 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 4 NEW_LINE m = 11 NEW_LINE ans = cntCakes ( n , m ) NEW_LINE print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE",
        "Type": "py",
        "NL": "Cake Distribution Problem | Function to return the remaining count of cakes ; Sum for 1 cycle ; no . of full cycle and remainder ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11104-11104",
        "Code": "from math import gcd , sqrt NEW_LINE def isComposite ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def Power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isEulerPseudoprime ( N , A ) : NEW_LINE INDENT if ( A <= 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( N % 2 == 0 or not isComposite ( N ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( gcd ( A , N ) != 1 ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT mod = Power ( A , ( N - 1 ) // 2 , N ) ; NEW_LINE if ( mod != 1 and mod != N - 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 121 ; A = 3 ; NEW_LINE if ( isEulerPseudoprime ( N , A ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number is Euler Pseudoprime | Python3 program for nth FussCatalan Number ; Function that returns true if n is composite ; Check if there is any divisor of n . we only need check divisor till sqrt ( n ) because if there is divisor which is greater than sqrt ( n ) then there must be a divisor which is less than sqrt ( n ) ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is greater than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function that returns true if N is Euler Pseudoprime to the base A ; Invalid base ; N is not a composite odd number ; If A and N are not coprime ; All the conditions for Euler Pseudoprime are satisfied ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11105-11105",
        "Code": "from math import sqrt NEW_LINE sz = int ( 1e5 ) ; NEW_LINE isPrime = [ True ] * ( sz + 1 ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT fst = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT snd = 0 ; NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT snd = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( snd == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = snd - fst ; NEW_LINE left = snd + 1 ; NEW_LINE right = R ; NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - snd <= diff ) : NEW_LINE INDENT fst = snd ; NEW_LINE snd = i ; NEW_LINE diff = snd - fst ; NEW_LINE DEDENT DEDENT DEDENT return diff ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) ; NEW_LINE L = 21 ; R = 50 ; NEW_LINE print ( minDifference ( L , R ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum difference between any two primes from the given range | Python3 implementation of the approach ; Function for Sieve of Eratosthenes ; Function to return the minimum difference between any two prime numbers from the given range [ L , R ] ; Find the first prime from the range ; Find the second prime from the range ; If the number of primes in the given range is < 2 ; To store the minimum difference between two consecutive primes from the range ; Range left to check for primes ; For every integer in the range ; If the current integer is prime ; If the difference between i and snd is minimum so far ; Driver code ; Generate primes",
        "Category": "Math"
    },
    {
        "ID": "11116-11116",
        "Code": "def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 55 ; Y = 3 ; NEW_LINE last_digit ( X , Y ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the last digit of X in base Y | Function to find the last digit of X in base Y ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11126-11126",
        "Code": "MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum possible value of ( i * j ) % 2019 | Python3 implementation of the approach ; Function to return the minimum possible value of ( i * j ) % 2019 ; If we can get a number divisible by 2019 ; Find the minimum value by running nested loops ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11133-11133",
        "Code": "def odd_digits ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT elif ( n / 10 < 10 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT elif ( n / 100 < 10 ) : NEW_LINE INDENT return 9 + n - 99 ; NEW_LINE DEDENT elif ( n / 1000 < 10 ) : NEW_LINE INDENT return 9 + 900 ; NEW_LINE DEDENT elif ( n / 10000 < 10 ) : NEW_LINE INDENT return 909 + n - 9999 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 90909 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 893 ; NEW_LINE print ( odd_digits ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the number of positive integers less than or equal to N that have an odd number of digits | Function to return the number of positive integers less than or equal to N that have odd number of digits ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11150-11150",
        "Code": "def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * factorial ( n - 1 ) ; NEW_LINE DEDENT def countNum ( n ) : NEW_LINE INDENT if ( n > 10 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( 9 * factorial ( 9 ) // factorial ( 10 - n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( countNum ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of N | Function to return the factorial of n ; Function to return the count of n - digit numbers with all distinct digits ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11152-11152",
        "Code": "from math import sqrt NEW_LINE def count ( n ) : NEW_LINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of distinct positive integers that can be used to represent N | Python3 implementation of the approach ; Function to return the required count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11160-11160",
        "Code": "def findNums ( n ) : NEW_LINE INDENT if ( n <= 11 ) : NEW_LINE INDENT if ( n == 8 ) : NEW_LINE INDENT print ( \"4 ▁ 4\" , end = \" ▁ \" ) NEW_LINE DEDENT if ( n == 10 ) : NEW_LINE INDENT print ( \"4 ▁ 6\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \"4 ▁ \" , ( n - 4 ) , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"9 ▁ \" , n - 9 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 13 NEW_LINE findNums ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Represent the given number as the sum of two composite numbers | Function to find two composite numbers which when added give sum as n ; Only 8 and 10 can be represented as the sum of two composite integers ; If n is even ; If n is odd ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11164-11164",
        "Code": "def product ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= pow ( a [ i ] , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE a = [ 3 , 7 ] NEW_LINE print ( product ( a , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Product of values of all possible non | Function to find product of all elements in all subsets ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11166-11166",
        "Code": "NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallesteSubstr_maxDistictChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT subs = str [ i : j ] NEW_LINE subs_lenght = len ( subs ) NEW_LINE sub_distinct_char = max_distinct_char ( subs , subs_lenght ) NEW_LINE if ( subs_lenght < minl and max_distinct == sub_distinct_char ) : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" AABBBCBB \" NEW_LINE l = smallesteSubstr_maxDistictChar ( str ) ; NEW_LINE print ( \" The ▁ length ▁ of ▁ the ▁ smallest ▁ substring \" , \" consisting ▁ of ▁ maximum ▁ distinct \" , \" characters ▁ : \" , l ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the smallest sub | Python 3 program to find the length of the smallest substring consisting of maximum distinct characters ; Find maximum distinct characters in any string ; Initialize all character 's  count with 0 ; Increase the count in array if a character is found ; size of given string ; Find maximum distinct characters in any string ; result ; Brute force approach to find all substrings ; We have to check here both conditions together 1. substring ' s ▁ distinct ▁ characters ▁ is ▁ equal ▁ ▁ to ▁ maximum ▁ distinct ▁ characters ▁ ▁ 2 . ▁ substring ' s length should be minimum ; Driver Code ; Input String",
        "Category": "Sliding Window"
    },
    {
        "ID": "11170-11170",
        "Code": "from math import sqrt NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 ; NEW_LINE ch = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( ch , end = \" ▁ \" ) ; NEW_LINE ch += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) // 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE triangle ( maxHeight ( N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Printing the Triangle Pattern using last term N | Python3 code for printing the Triangle Pattern using last term N ; Function to demonstrate printing pattern ; number of spaces ; character to be printed ; outer loop to handle number of rows n in this case ; inner loop to handle number spaces values changing acc . to requirement ; decrementing k after each loop ; inner loop to handle number of columns values changing acc . to outer loop ; printing stars ; ending line after each row ; Function to find the max height or the number of lines in the triangle pattern ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11175-11175",
        "Code": "from math import gcd NEW_LINE def FindRatio ( a , b , c ) : NEW_LINE INDENT up = abs ( b - c ) NEW_LINE down = abs ( c - a ) NEW_LINE g = gcd ( up , down ) NEW_LINE up //= g NEW_LINE down //= g NEW_LINE print ( up , \" : \" , down ) NEW_LINE DEDENT a = 4 NEW_LINE b = 10 NEW_LINE c = 6 NEW_LINE FindRatio ( a , b , c ) NEW_LINE",
        "Type": "py",
        "NL": "Find the ratio of number of elements in two Arrays from their individual and combined average | Python3 program to Find the Ratio of number of Elements in two Arrays from their individual and combined Average ; function to find the ratio of number of array elements ; calculating GCD of them ; make neumarator and denominator coprime ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11176-11176",
        "Code": "def longest_gap ( N ) : NEW_LINE INDENT distance = 0 NEW_LINE count = 0 NEW_LINE first_1 = - 1 NEW_LINE last_1 = - 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE r = N & 1 NEW_LINE if ( r == 1 ) : NEW_LINE INDENT if first_1 == - 1 : NEW_LINE INDENT first_1 = count NEW_LINE DEDENT else : NEW_LINE INDENT first_1 = first_1 NEW_LINE DEDENT last_1 = count NEW_LINE DEDENT N = N // 2 NEW_LINE DEDENT if ( last_1 <= first_1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT distance = last_1 - first_1 - 1 NEW_LINE return distance NEW_LINE DEDENT DEDENT N = 131 NEW_LINE print ( longest_gap ( N ) ) NEW_LINE N = 8 NEW_LINE print ( longest_gap ( N ) ) NEW_LINE N = 17 NEW_LINE print ( longest_gap ( N ) ) NEW_LINE N = 33 NEW_LINE print ( longest_gap ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum distance between two 1 's in Binary representation of N | Python3 program to find the Maximum distance between two 1 's in Binary representation of N ; Compute the binary representation ; if N is a power of 2 then return - 1 ; else find the distance between the first position of 1 and last position of 1 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11177-11177",
        "Code": "def isPossible ( x , y , k ) : NEW_LINE INDENT minMoves = abs ( x ) + abs ( y ) NEW_LINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x = 5 NEW_LINE y = 8 NEW_LINE k = 20 NEW_LINE if ( isPossible ( x , y , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to move from ( 0 , 0 ) to ( X , Y ) in exactly K steps | Function that returns true if it is possible to move from ( 0 , 0 ) to ( x , y ) in exactly k moves ; Minimum moves required ; If possible ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11181-11181",
        "Code": "MAX = 10 NEW_LINE def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n // 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether N is a Factorion or not | Python3 implementation of the approach ; Function that returns true if n is a Factorion ; fact [ i ] will store i ! ; A copy of the given integer ; To store the sum of factorials of the digits of n ; Get the last digit ; Add the factorial of the current digit to the sum ; Remove the last digit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11183-11183",
        "Code": "def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n //= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reduce N to 1 with minimum number of given operations | Function to return the minimum number of given operations required to reduce n to 1 ; To store the count of operations ; To store the digit ; If n is already then no operation is required ; Extract all the digits except the first digit ; Store the maximum of that digits ; for each digit ; First digit ; Add the value to count ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "11187-11187",
        "Code": "TEN = 10 NEW_LINE def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = 240 NEW_LINE b = 204 NEW_LINE if ( areAnagrams ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if two Integer are anagrams of each other | Python3 implementation of the approach ; Function to update the frequency array such that freq [ i ] stores the frequency of digit i in n ; While there are digits left to process ; Update the frequency of the current digit ; Remove the last digit ; Function that returns true if a and b are anagarams of each other ; To store the frequencies of the digits in a and b ; Update the frequency of the digits in a ; Update the frequency of the digits in b ; Match the frequencies of the common digits ; If frequency differs for any digit then the numbers are not anagrams of each other ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "11191-11191",
        "Code": "def convertToBinary ( num , a , n ) : NEW_LINE INDENT pointer = n - 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT a [ pointer ] = num % 2 NEW_LINE num = num // 2 NEW_LINE pointer -= 1 NEW_LINE DEDENT DEDENT def checkforsum ( a , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mid = n // 2 NEW_LINE for i in range ( mid ) : NEW_LINE INDENT sum1 = sum1 + a [ i ] NEW_LINE DEDENT for j in range ( mid , n ) : NEW_LINE INDENT sum2 = sum2 + a [ j ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def print_seq ( m ) : NEW_LINE INDENT n = ( 2 * m ) NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( pow ( 2 , n ) ) : NEW_LINE INDENT convertToBinary ( i , a , n ) NEW_LINE checkforsum ( a , n ) NEW_LINE DEDENT DEDENT m = 2 NEW_LINE print_seq ( m ) NEW_LINE",
        "Type": "py",
        "NL": "Find all even length binary sequences with same sum of first and second half bits | Iterative | Function to convert the number into binary and store the number into an array ; Function to check if the sum of the digits till the mid of the array and the sum of the digits from mid till n is the same , if they are same then print that binary ; Calculating the sum from 0 till mid and store in sum1 ; Calculating the sum from mid till n and store in sum2 ; If sum1 is same as sum2 print the binary ; Function to prsequence ; Creating the array ; '' Looping over powers of 2  ; Converting the number into binary first ; Checking if the sum of the first half of the array is same as the sum of the next half ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "11193-11193",
        "Code": "def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of occurrences of a given angle formed using 3 vertices of a n | Function that calculates occurrences of given angle that can be created using any 3 sides ; Maximum angle in a regular n - gon is equal to the interior angle If the given angle is greater than the interior angle then the given angle cannot be created ; The given angle times n should be divisible by 180 else it cannot be created ; Initialise answer ; Calculate the frequency of given angle for each vertex ; Multiply answer by frequency . ; Multiply answer by the number of vertices . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11200-11200",
        "Code": "def getArray ( n ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE p2 = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT ans . append ( p2 ) ; NEW_LINE DEDENT n >>= 1 ; NEW_LINE p2 *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 ; NEW_LINE ans = getArray ( n ) ; NEW_LINE for i in ans : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Array containing power of 2 whose XOR and Sum of elements equals X | Function to return the required array ; Store the power of 2 ; while n is greater than 0 ; if there is 1 in binary representation ; Divide n by 2 Multiply p2 by 2 ; Driver code ; Get the answer ; Printing the array",
        "Category": "Array"
    },
    {
        "ID": "11203-11203",
        "Code": "def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( \"4\" , end = \" \" ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( \"8\" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT holes = 3 NEW_LINE printNumber ( holes ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find the number from given holes | Function that will find out the number ; If number of holes equal 0 then return 1 ; If number of holes equal 0 then return 0 ; If number of holes is more than 0 or 1. ; If number of holes is odd ; Driver code ; Calling Function",
        "Category": "Math"
    },
    {
        "ID": "11212-11212",
        "Code": "def getCount ( A , B2 , C ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( i < A ) : NEW_LINE INDENT j = ( B2 // i ) + 1 NEW_LINE if ( C >= j ) : NEW_LINE INDENT count = count + C - j + 1 NEW_LINE DEDENT if ( A >= j and C >= i ) : NEW_LINE INDENT count = count + ( C - i + 1 ) * ( A - j + 1 ) NEW_LINE DEDENT if ( A >= j ) : NEW_LINE INDENT A = j - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT ans = ( ans + getCount ( A , i * i , C ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of triples ( A , B , C ) where A * C is greater than B * B | Counts the number of triplets for a given value of b ; Count all triples in which a = i ; Smallest value j such that i * j > B2 ; Count all ( i , B2 , x ) such that x >= j ; count all ( x , B2 , y ) such that x >= j this counts all such triples in which a >= j ; As all triples with a >= j have been counted reduce A to j - 1. ; Counts the number of triples that satisfy the given constraints ; GetCount of triples in which b = i ; Driver Code ; Function calling",
        "Category": "Math"
    },
    {
        "ID": "11213-11213",
        "Code": "def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 ; NEW_LINE cntNeg = negProdSubArr ( arr , n ) ; NEW_LINE return ( total - cntNeg ) ; NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of Subarrays with positive product | Function to return the count of subarrays with negative product ; Replace current element with 1 if it is positive else replace it with - 1 instead ; Take product with previous element to form the prefix product ; Count positive and negative elements in the prefix product array ; Return the required count of subarrays ; Function to return the count of subarrays with positive product ; Total subarrays possible ; Count to subarrays with negative product ; Return the count of subarrays with positive product ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "11223-11223",
        "Code": "def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sum += digit NEW_LINE n //= 10 NEW_LINE DEDENT n = temp NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( sum % digit != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 ; NEW_LINE DEDENT return True NEW_LINE DEDENT n = 123 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the sum of digits of number is divisible by all of its digits | Function that returns true if all the digits of n divide the sum of the digits of n ; Store a copy of the original number ; Find the sum of the digits of n ; Restore the original value ; Check if all the digits divide the calculated sum ; If current digit doesn 't  divide the sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11225-11225",
        "Code": "N = 100005 NEW_LINE lpf = [ 0 ] * N ; NEW_LINE def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( not lpf [ i ] ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( not lpf [ j ] ) : NEW_LINE INDENT lpf [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def Mobius ( n ) : NEW_LINE INDENT mobius = [ 0 ] * N ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT mobius [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( lpf [ i // lpf [ i ] ] == lpf [ i ] ) : NEW_LINE INDENT mobius [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT mobius [ i ] = - 1 * mobius [ i // lpf [ i ] ] ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( mobius [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE least_prime_factor ( ) ; NEW_LINE Mobius ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program for Mobius Function | Set 2 | Python3 implementation of the approach ; Function to calculate least prime factor of each number ; If it is a prime number ; For all multiples which are not visited yet . ; Function to find the value of Mobius function for all the numbers from 1 to n ; To store the values of Mobius function ; If number is one ; If number has a squared prime factor ; Multiply - 1 with the previous number ; Driver code ; Function to find least prime factor ; Function to find mobius function",
        "Category": "Math"
    },
    {
        "ID": "11227-11227",
        "Code": "COST = 3 ; NEW_LINE def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST ; NEW_LINE x %= COST ; NEW_LINE type2 = y // COST ; NEW_LINE y %= COST ; NEW_LINE type3 = z // COST ; NEW_LINE z %= COST ; NEW_LINE type4 = min ( x , min ( y , z ) ) ; NEW_LINE maxItems = type1 + type2 + type3 + type4 ; NEW_LINE return maxItems ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 4 ; y = 5 ; z = 6 ; NEW_LINE print ( maxItems ( x , y , z ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum items that can be bought with the given type of coins | Python3 implementation of the approach ; Function to find maximum fruits Can buy from given values of x , y , z . ; Items of type 1 that can be bought ; Update the coins ; Items of type 2 that can be bought ; Update the coins ; Items of type 3 that can be bought ; Update the coins ; Items of type 4 that can be bought To buy a type 4 item , a coin of each type is required ; Total items that can be bought ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "11229-11229",
        "Code": "def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r // val ; NEW_LINE b = ( l - 1 ) // val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 8 ; NEW_LINE p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count occurrences of a prime number in the prime factorization of every element from the given range | Function to return the count of times p appears in the prime factors of the elements from the range [ l , r ] ; To store the required count ; Number of values in the range [ 0 , r ] that are divisible by val ; Number of values in the range [ 0 , l - 1 ] that are divisible by val ; Increment the power of the val ; ( a - b ) is the count of numbers in the range [ l , r ] that are divisible by val ; No values that are divisible by val thus exiting from the loop ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11239-11239",
        "Code": "mod = 1000000007 NEW_LINE inv2 = 500000004 ; NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 ; NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) - 0 ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) ; NEW_LINE b = modulo ( R ) ; NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; NEW_LINE ret = ( r % mod - l % mod ) ; NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod ; NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = \"88949273204\" ; NEW_LINE R = \"98429729474298592\" ; NEW_LINE print ( findSum ( L , R ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all natural numbers from L to R ( for large values of L and R ) | Python3 implementation of the approach ; Value of inverse modulo 2 with 10 ^ 9 + 7 ; Function to return num % 1000000007 where num is a large number ; Initialize result ; One by one process all the digits of string 'num ; Function to return the sum of the integers from the given range modulo 1000000007 ; a stores the value of L modulo 10 ^ 9 + 7 ; b stores the value of R modulo 10 ^ 9 + 7 ; l stores the sum of natural numbers from 1 to ( a - 1 ) ; r stores the sum of natural numbers from 1 to b ; If the result is negative ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11241-11241",
        "Code": "from math import ceil NEW_LINE def cal_IST ( h , r ) : NEW_LINE INDENT IST = round ( ( h * r * 1.0 ) / 360 , 3 ) ; NEW_LINE int_IST = int ( IST ) ; NEW_LINE float_IST = ceil ( ( IST - int_IST ) * 60 ) ; NEW_LINE print ( int_IST , \" : \" , float_IST ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT h = 20 ; NEW_LINE r = 150 ; NEW_LINE cal_IST ( h , r ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Calculate the IST : Indian Standard Time | Python3 implementation of the approach ; Function to calculate Indian Standard Time ; Separate integer part ; Separate float part and return ceil value ; Driver code ; Number of hours ( 1 - 24 ) ; Rotations in degrees",
        "Category": "Math"
    },
    {
        "ID": "11255-11255",
        "Code": "def solve ( n ) : NEW_LINE INDENT n_2 = n // 2 ; NEW_LINE den = \"1\" ; NEW_LINE while ( n_2 ) : NEW_LINE INDENT den += '0' ; NEW_LINE n_2 -= 1 NEW_LINE DEDENT print ( str ( 1 ) + \" / \" + str ( den ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE solve ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability that a N digit number is palindrome | Find the probability that a n digit number is palindrome ; Denominator ; Assign 10 ^ ( floor ( n / 2 ) ) to denominator ; Display the answer ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11260-11260",
        "Code": "def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n // i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 ; NEW_LINE if ( Survives ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number is Flavius Number | Return the number is Flavious Number or not ; index i starts from 2 because at 1 st iteration every 2 nd element was remove and keep going for k - th iteration ; removing the elements which are already removed at kth iteration ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11267-11267",
        "Code": "def totalPay ( totalItems , priceOfOneItem , N , M ) : NEW_LINE INDENT freeItems = 0 NEW_LINE actual = 0 NEW_LINE freeItems = totalItems // ( N + M ) NEW_LINE actual = totalItems - freeItems NEW_LINE amount = actual * priceOfOneItem NEW_LINE return amount NEW_LINE DEDENT T = 12 NEW_LINE P = 8 NEW_LINE N = 2 NEW_LINE M = 1 NEW_LINE print ( \" Amount ▁ = ▁ \" , totalPay ( T , P , N , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize the cost of buying the Objects | Function that will calculate the price ; Calculate the number of items we can get for free ; Calculate the number of items we will have to pay the price for ; Calculate the price ; Driver code ; Calling function",
        "Category": "Math"
    },
    {
        "ID": "11270-11270",
        "Code": "def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT n = 5223 NEW_LINE findRemainder ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Find the remainder when First digit of a number is divided by its Last digit | Function to find the remainder ; Get the last digit ; Get the first digit ; Compute the remainder ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11271-11271",
        "Code": "def findBalance ( x , bal ) : NEW_LINE INDENT if ( x % 10 == 0 and ( x + 1.50 ) <= bal ) : NEW_LINE INDENT print ( round ( bal - x - 1.50 , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( round ( bal , 2 ) ) NEW_LINE DEDENT DEDENT x = 50 NEW_LINE bal = 100.50 NEW_LINE findBalance ( x , bal ) NEW_LINE",
        "Type": "py",
        "NL": "Find the remaining balance after the transaction | Function to find the balance ; Check if the transaction can be successful or not ; Transaction is successful ; Transaction is unsuccessful ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11272-11272",
        "Code": "def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT l = 50 NEW_LINE b = 20 NEW_LINE h = 10 NEW_LINE print ( increaseInVol ( l , b , h ) , \" % \" ) NEW_LINE",
        "Type": "py",
        "NL": "Percentage increase in the volume of cuboid if length , breadth and height are increased by fixed percentages | Function to return the percentage increase in the volume of the cuboid ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11273-11273",
        "Code": "def countOccurrances ( n , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == d ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT d = 2 NEW_LINE n = 214215421 NEW_LINE print ( countOccurrances ( n , d ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count the number of occurrences of a particular digit in a number | Function to count the occurrences of the digit D in N ; Loop to find the digits of N ; check if the digit is D ; return the count of the occurrences of D in N ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11278-11278",
        "Code": "from math import pow NEW_LINE def countDigits ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE num //= 10 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def sumFromStart ( num , n , rem ) : NEW_LINE INDENT num //= pow ( 10 , rem ) NEW_LINE sum = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def sumFromEnd ( num , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def getAverage ( n , k , l ) : NEW_LINE INDENT totalDigits = countDigits ( n ) NEW_LINE if ( totalDigits < ( k + l ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum1 = sumFromEnd ( n , l ) NEW_LINE sum2 = sumFromStart ( n , k , totalDigits - k ) NEW_LINE return ( sum1 + sum2 ) / ( k + l ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 123456 NEW_LINE k = 2 NEW_LINE l = 3 NEW_LINE print ( getAverage ( n , k , l ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the average of k digits from the beginning and l digits from the end of the given number | implementation of the approach ; Function to return the count of digits in num ; Function to return the sum of first n digits of num ; Remove the unnecessary digits ; Function to return the sum of the last n digits of num ; If the average can 't be calculated without  using the same digit more than once ; Sum of the last l digits of n ; Sum of the first k digits of n ( totalDigits - k ) must be removed from the end of the number to get the remaining k digits from the beginning ; Return the average ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11293-11293",
        "Code": "def Sum ( A , B , R ) : NEW_LINE INDENT ssum = 0 NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT ssum = ssum + ( i * A ) NEW_LINE A = A + B NEW_LINE DEDENT return ssum NEW_LINE DEDENT A , B , R = 5 , 3 , 3 NEW_LINE print ( Sum ( A , B , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the sum of elements of the Matrix generated by the given rules | Function to return the required ssum ; To store the ssum ; For every row ; Update the ssum as A appears i number of times in the current row ; Update A for the next row ; Return the ssum ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "11297-11297",
        "Code": "from math import pow NEW_LINE def Depreciation ( v , r , t ) : NEW_LINE INDENT D = v * pow ( ( 1 - r / 100 ) , t ) NEW_LINE return D NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V1 = 200 NEW_LINE R = 10 NEW_LINE T = 2 NEW_LINE print ( int ( Depreciation ( V1 , R , T ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Depreciation of Value | Python 3 program to find depreciation of the value initial value , rate and time are given ; Function to return the depreciation of value ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11299-11299",
        "Code": "from math import ceil , floor NEW_LINE def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) / 12 ) - floor ( _n / 4 ) * floor ( ( _n + 2 ) / 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE solve ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Alcuin 's Sequence | Python3 program for AlcuinaTMs Sequence ; find the nth term of Alcuin 's sequence ; return the ans ; print first n terms of Alcuin number ; display the number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "113-113",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def Sum ( t ) : NEW_LINE INDENT if ( t == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return t . key + Sum ( t . left ) + Sum ( t . right ) NEW_LINE DEDENT def uncoveredSumLeft ( t ) : NEW_LINE INDENT if ( t . left == None and t . right == None ) : NEW_LINE INDENT return t . key NEW_LINE DEDENT if ( t . left != None ) : NEW_LINE INDENT return t . key + uncoveredSumLeft ( t . left ) NEW_LINE DEDENT else : NEW_LINE INDENT return t . key + uncoveredSumLeft ( t . right ) NEW_LINE DEDENT DEDENT def uncoveredSumRight ( t ) : NEW_LINE INDENT if ( t . left == None and t . right == None ) : NEW_LINE INDENT return t . key NEW_LINE DEDENT if ( t . right != None ) : NEW_LINE INDENT return t . key + uncoveredSumRight ( t . right ) NEW_LINE DEDENT else : NEW_LINE INDENT return t . key + uncoveredSumRight ( t . left ) NEW_LINE DEDENT DEDENT def uncoverSum ( t ) : NEW_LINE INDENT lb = 0 NEW_LINE rb = 0 NEW_LINE if ( t . left != None ) : NEW_LINE INDENT lb = uncoveredSumLeft ( t . left ) NEW_LINE DEDENT if ( t . right != None ) : NEW_LINE INDENT rb = uncoveredSumRight ( t . right ) NEW_LINE DEDENT return t . key + lb + rb NEW_LINE DEDENT def isSumSame ( root ) : NEW_LINE INDENT sumUC = uncoverSum ( root ) NEW_LINE sumT = Sum ( root ) NEW_LINE return ( sumUC == ( sumT - sumUC ) ) NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 8 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 6 ) NEW_LINE root . left . right . left = newNode ( 4 ) NEW_LINE root . left . right . right = newNode ( 7 ) NEW_LINE root . right = newNode ( 10 ) NEW_LINE root . right . right = newNode ( 14 ) NEW_LINE root . right . right . left = newNode ( 13 ) NEW_LINE if ( isSumSame ( root ) ) : NEW_LINE INDENT print ( \" Sum ▁ of ▁ covered ▁ and ▁ uncovered ▁ is ▁ same \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Sum ▁ of ▁ covered ▁ and ▁ uncovered ▁ is ▁ not ▁ same \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check sum of Covered and Uncovered nodes of Binary Tree | To create a newNode of tree and return pointer ; Utility function to calculate sum of all node of tree ; Recursive function to calculate sum of left boundary elements ; If leaf node , then just return its key value ; If left is available then go left otherwise go right ; Recursive function to calculate sum of right boundary elements ; If leaf node , then just return its key value ; If right is available then go right otherwise go left ; Returns sum of uncovered elements ; Initializing with 0 in case we don 't have left or right boundary  ; returning sum of root node , left boundary and right boundary ; Returns true if sum of covered and uncovered elements is same . ; Sum of uncovered elements ; Sum of all elements ; Check if sum of covered and uncovered is same ; Helper function to prinorder traversal of binary tree ; Driver Code ; Making above given diagram 's   binary tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "11303-11303",
        "Code": "from math import ceil NEW_LINE def speedOfTrain ( X , Y ) : NEW_LINE INDENT Speed = 0 NEW_LINE Speed = 1188 * ( ( X - Y ) / Y ) NEW_LINE return Speed NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 8 NEW_LINE Y = 7.2 NEW_LINE print ( ceil ( speedOfTrain ( X , Y ) ) , end = \" ▁ km / hr \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Speed of train as per speed of sound | Python3 implementation of the approach ; Function to find the Speed of train ; Driver code ; calling Function",
        "Category": "Math"
    },
    {
        "ID": "11314-11314",
        "Code": "def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def NumberOfWays ( X , Y , M , N ) : NEW_LINE INDENT return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE Y = 2 NEW_LINE M = 3 NEW_LINE N = 3 NEW_LINE print ( NumberOfWays ( X , Y , M , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the number of words of X vowels and Y consonants that can be formed from M vowels and N consonants | Function to returns factorial of n ; Function to find nCr ; Function to find the number of words of X vowels and Y consonants can be formed from M vowels and N consonants ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11319-11319",
        "Code": "def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def prime_range ( start , end , a ) : NEW_LINE INDENT for i in range ( start , end ) : NEW_LINE INDENT if ( prime ( a [ i ] ) ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT def Print ( arr , n ) : NEW_LINE INDENT print ( \" Prime ▁ numbers ▁ in ▁ the \" , \" first ▁ half ▁ are ▁ \" , end = \" \" ) NEW_LINE prime_range ( 0 , n // 2 , arr ) NEW_LINE print ( ) NEW_LINE print ( \" Prime ▁ numbers ▁ in ▁ the \" , \" second ▁ half ▁ are ▁ \" , end = \" \" ) NEW_LINE prime_range ( n // 2 , n , arr ) NEW_LINE print ( ) NEW_LINE DEDENT arr = [ 2 , 5 , 10 , 15 , 17 , 21 , 23 ] NEW_LINE n = len ( arr ) NEW_LINE Print ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find prime numbers in the first half and second half of an array | Function to check if a number is prime or not ; Function to find whether elements are prime or not ; Traverse in the given range ; Check if a number is prime or not ; Function to print the prime numbers in the first half and second half of an array ; Driver Code ; Function call",
        "Category": "Array"
    },
    {
        "ID": "11324-11324",
        "Code": "MAX = 10000 NEW_LINE MAX_ELEMENT = 50 NEW_LINE dp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX_ELEMENT ) ] for k in range ( MAX_ELEMENT ) ] NEW_LINE def Max_Xor ( arr , i , j , mask , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT return mask NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ i ] [ j ] [ mask ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ mask ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( j > 0 ) : NEW_LINE INDENT ans = Max_Xor ( arr , i + 1 , j - 1 , mask ^ arr [ i ] , n ) NEW_LINE DEDENT ans = max ( ans , Max_Xor ( arr , i + 1 , j , mask , n ) ) NEW_LINE dp [ i ] [ j ] [ mask ] = ans NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 5 , 4 , 1 , 3 , 7 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( Max_Xor ( arr , 0 , k , 0 , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find maximum xor of k elements in an array | Python implementation of the approach ; Function to return the maximum xor for a subset of size j from the given array ; If the subset is complete then return the xor value of the selected elements ; Return if already calculated for some mask and j at the i 'th index ; Initialize answer to 0 ; If we can still include elements in our subset include the i 'th element ; Exclude the i 'th element  ans store the max of both operations ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "11326-11326",
        "Code": "def sum_of_elements ( arr , n ) : NEW_LINE INDENT sumfirst = 0 ; NEW_LINE sumsecond = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT sumfirst += arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sumsecond += arr [ i ] ; NEW_LINE DEDENT DEDENT print ( \" Sum ▁ of ▁ first ▁ half ▁ elements ▁ is \" , sumfirst , end =   \" \" ) ; NEW_LINE print ( \" Sum ▁ of ▁ second ▁ half ▁ elements ▁ is \" , sumsecond , end =   \" \" ) ; NEW_LINE DEDENT arr = [ 20 , 30 , 60 , 10 , 25 , 15 , 40 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sum_of_elements ( arr , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find the sum of the first half and second half elements of an array | Function to find the sum of the first half elements and second half elements of an array ; Add elements in first half sum ; Add elements in the second half sum ; Driver Code ; Function call",
        "Category": "Array"
    },
    {
        "ID": "11329-11329",
        "Code": "def fac ( num ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT fact = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def Tanx_expansion ( terms , x ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , terms + 1 ) : NEW_LINE INDENT B = 0 ; NEW_LINE Bn = 2 * i ; NEW_LINE for k in range ( Bn + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for r in range ( 0 , k + 1 ) : NEW_LINE INDENT temp = temp + pow ( - 1 , r ) * fac ( k ) * pow ( r , Bn ) / ( fac ( r ) * fac ( k - r ) ) ; NEW_LINE DEDENT B = B + temp / ( ( k + 1 ) ) ; NEW_LINE DEDENT sum = sum + pow ( - 4 , i ) * ( 1 - pow ( 4 , i ) ) * B * pow ( x , 2 * i - 1 ) / fac ( 2 * i ) ; NEW_LINE DEDENT print ( \" % .9f \" % ( sum ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , x = 6 , 1 ; NEW_LINE Tanx_expansion ( n , x ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of the Tan ( x ) expansion upto N terms | Function to find factorial of a number ; To store factorial of a number ; Return the factorial of a number ; Function to find tan ( x ) upto n terms ; To store value of the expansion ; This loops here calculate Bernoulli number which is further used to get the coefficient in the expansion of tan x ; Print the value of expansion ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11335-11335",
        "Code": "from math import sqrt NEW_LINE def checkcomposite ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def power ( x , y , mod ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def Check ( n , a ) : NEW_LINE INDENT if ( a > 1 and checkcomposite ( n ) and power ( a , n - 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 645 NEW_LINE a = 2 NEW_LINE print ( Check ( N , a ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is Fermat Pseudoprime | Python3 program to check if N is Fermat pseudoprime to the base A or not ; Function to check if the given number is composite ; Check if there is any divisor of n less than sqrt ( n ) ; Effectively calculate ( x ^ y ) modulo mod ; Initialize result ; If power is odd , then update the answer ; Square the number and reduce the power to its half ; Return the result ; Function to check for Fermat Pseudoprime ; If it is composite and satisfy Fermat criterion ; Else return 0 ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11336-11336",
        "Code": "def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT n = 2346 NEW_LINE Digits ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Largest and smallest digit of a number | Function to the largest and smallest digit of a number ; Find the largest digit ; Find the smallest digit ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11338-11338",
        "Code": "def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * factorial ( n - 1 ) ; NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ) ; NEW_LINE DEDENT def Probability ( M , N , X ) : NEW_LINE INDENT return float ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = 9 ; X = 3 ; N = 4 ; NEW_LINE print ( Probability ( M , N , X ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability of distributing M items among X bags such that first bag contains N items | Function to find factorial of a number ; Function to find nCr ; Function to find probability of first bag to contain N items such that M items are distributed among X bags ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11341-11341",
        "Code": "def countSetBits ( n ) : NEW_LINE INDENT n += 1 ; NEW_LINE powerOf2 = 2 ; NEW_LINE cnt = n // 2 ; NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 ; NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 ; NEW_LINE if ( totalPairs & 1 ) : NEW_LINE INDENT cnt += ( n % powerOf2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 0 NEW_LINE DEDENT powerOf2 <<= 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( countSetBits ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count total set bits in all numbers from 1 to n | Set 2 | Function to return the sum of the count of set bits in the integers from 1 to n ; Ignore 0 as all the bits are unset ; To store the powers of 2 ; To store the result , it is initialized with n / 2 because the count of set least significant bits in the integers from 1 to n is n / 2 ; Loop for every bit required to represent n ; Total count of pairs of 0 s and 1 s ; totalPairs / 2 gives the complete count of the pairs of 1 s Multiplying it with the current power of 2 will give the count of 1 s in the current bit ; If the count of pairs was odd then add the remaining 1 s which could not be groupped together ; Next power of 2 ; Return the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11344-11344",
        "Code": "def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the height of a right | Function to return the height of the right - angled triangle whose area is X times its base ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11346-11346",
        "Code": "def volumeRec ( a , b , e , h ) : NEW_LINE INDENT return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2 ; b = 5 ; e = 5 ; h = 6 ; NEW_LINE print ( \" Volume ▁ = ▁ \" , volumeRec ( a , b , e , h ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the volume of rectangular right wedge | Function to return the volume of the rectangular right wedge ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11358-11358",
        "Code": "def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , \"0\" , end = \" ▁ \" ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( \"0\" , val * y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find two vertices of an isosceles triangle in which there is rectangle with opposite corners ( 0 , 0 ) and ( X , Y ) | Function to find two vertices of an isosceles triangle in which there is rectangle with opposite side ( 0 , 0 ) and ( x , y ) ; Required value ; ; print x1 and y1 ; print x2 and y3 ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11359-11359",
        "Code": "def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = float ( Sum ) * 1.0 / float ( N ) ; NEW_LINE return round ( ans , 2 ) ; NEW_LINE DEDENT N = 9 ; NEW_LINE Sum = 13 ; NEW_LINE print SumofInverseDivisors ( N , Sum ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find sum of inverse of the divisors when sum of divisors and the number is given | Function to return the sum of inverse of divisors ; Calculating the answer ; Return the answer ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11368-11368",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def bitonic_point ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( node . next == None ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( node . data > node . next . data ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT while ( node . next != None ) : NEW_LINE INDENT if ( node . data > node . next . data ) : NEW_LINE INDENT break ; NEW_LINE DEDENT node = node . next ; NEW_LINE DEDENT bitonicPoint = node . data ; NEW_LINE while ( node . next != None ) : NEW_LINE INDENT if ( node . data < node . next . data ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT node = node . next ; NEW_LINE DEDENT return bitonicPoint ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None ; NEW_LINE head = push ( head , 100 ) ; NEW_LINE head = push ( head , 201 ) ; NEW_LINE head = push ( head , 399 ) ; NEW_LINE head = push ( head , 490 ) ; NEW_LINE head = push ( head , 377 ) ; NEW_LINE head = push ( head , 291 ) ; NEW_LINE head = push ( head , 100 ) ; NEW_LINE print ( bitonic_point ( head ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Bitonic point in the given linked list | Node for linked list ; Function to insert a node at the head of the linked list ; Function to return the bitonic of the given linked list ; If list is empty ; If list contains only a single node ; Invalid bitonic sequence ; If current node is the bitonic point ; Get to the next node in the list ; Nodes must be in descending starting from here ; Out of order node ; Get to the next node in the list ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "11369-11369",
        "Code": "from operator import xor NEW_LINE def findXOR ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT elif ( mod == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( mod == 2 ) : NEW_LINE INDENT return n + 1 ; NEW_LINE DEDENT elif ( mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def findXORFun ( l , r ) : NEW_LINE INDENT return ( xor ( findXOR ( l - 1 ) , findXOR ( r ) ) ) ; NEW_LINE DEDENT l = 4 ; r = 8 ; NEW_LINE print ( findXORFun ( l , r ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find XOR of numbers from the range [ L , R ] | Python3 implementation of the approach ; Function to return the XOR of elements from the range [ 1 , n ] ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Function to return the XOR of elements from the range [ l , r ] ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11372-11372",
        "Code": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return GCD ( b , a % b ) ; NEW_LINE DEDENT def findReachable ( arr , D , A , B , n ) : NEW_LINE INDENT gcd_AB = GCD ( A , B ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - D ) % gcd_AB == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE D = 4 ; A = 4 ; B = 6 ; NEW_LINE print ( findReachable ( arr , D , A , B , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Number of elements from the array which are reachable after performing given operations on D | Function to return the GCD of a and b ; Function to return the count of reachable integers from the given array ; GCD of A and B ; To store the count of reachable integers ; If current element can be reached ; Return the count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11374-11374",
        "Code": "from math import log2 , ceil , floor NEW_LINE def countNodes ( N , X ) : NEW_LINE INDENT height = floor ( log2 ( N ) ) NEW_LINE if ( X > height ) : NEW_LINE INDENT print ( \" 0 0 \" ) NEW_LINE return NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT print ( \" 1 1 \" ) NEW_LINE return NEW_LINE DEDENT max_total_nodes = ( 1 << ( height + 1 ) ) - 1 NEW_LINE nodes_last_level = ( 1 << height ) - ( max_total_nodes - N ) NEW_LINE from_root = 0 NEW_LINE from_leaf = 0 NEW_LINE if ( X == height ) : NEW_LINE INDENT from_root = nodes_last_level NEW_LINE DEDENT else : NEW_LINE INDENT from_root = 1 << X NEW_LINE DEDENT left_leaf_nodes = ( ( 1 << height ) - nodes_last_level ) // 2 NEW_LINE if ( X == 0 ) : NEW_LINE INDENT from_leaf = nodes_last_level + left_leaf_nodes NEW_LINE DEDENT else : NEW_LINE INDENT i = X NEW_LINE while ( nodes_last_level > 1 and i > 0 ) : NEW_LINE INDENT nodes_last_level = ceil ( nodes_last_level / 2 ) NEW_LINE i -= 1 NEW_LINE DEDENT from_leaf = nodes_last_level NEW_LINE i = X NEW_LINE while ( left_leaf_nodes > 1 and i > 0 ) : NEW_LINE INDENT left_leaf_nodes = ceil ( left_leaf_nodes / 2 ) NEW_LINE i -= 1 NEW_LINE DEDENT from_leaf += left_leaf_nodes NEW_LINE DEDENT print ( from_root ) NEW_LINE print ( from_leaf ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , X = 38 , 3 NEW_LINE countNodes ( N , X ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of nodes which are at a distance X from root and leaves | Python3 implementation of the approach ; Function to find the count of the required nodes ; Height of the complete binary tree with n nodes ; If X > height then no node can be present at that level ; Corner case ; Maximum total nodes that are possible in complete binary tree with height h ; Nodes at the last level ; To store the count of nodes x dist away from root ; To store the count of nodes x dist away from leaf ; If X = h then prnodes at last level else nodes at Xth level ; 2 ^ X ; Number of left leaf nodes at ( h - 1 ) th level observe that if nodes are not present at last level then there are a / 2 leaf nodes at ( h - 1 ) th level ; If X = h then prleaf nodes at the last h level + leaf nodes at ( h - 1 ) th level ; First calculate nodes for leaves present at height h ; Then calculate nodes for leaves present at height h - 1 ; Add both the resuls ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11389-11389",
        "Code": "def isMersenne ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT r = n % 2 ; NEW_LINE if ( r == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n //= 2 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def sumOfMersenne ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 and isMersenne ( arr [ i ] ) ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 17 , 6 , 7 , 63 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( sumOfMersenne ( arr , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all mersenne numbers present in an array | Function that returns true if n is a Mersenne number ; Function to return the sum of all the Mersenne numbers from the given array ; To store the required sum ; If current element is a Mersenne number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11396-11396",
        "Code": "def reverse ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE rev = rev * 10 + d ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) ; NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE c += 1 ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT arr = [ 121 , 56 , 434 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPalinDigits ( arr , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count the number of digits of palindrome numbers in an array | Function to return the reverse of n ; Function that returns true if n is a palindrome ; Function to return the count of digits of n ; Function to return the count of digits in all the palindromic numbers of arr [ ] ; If arr [ i ] is a one digit number or it is a palindrome ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11398-11398",
        "Code": "def reverse ( n ) : NEW_LINE INDENT d = 0 ; s = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) ; NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all palindrome numbers present in an Array | Function to reverse a number n ; Function to check if a number n is palindrome ; If n is equal to the reverse of n it is a palindrome ; Function to calculate sum of all array elements which are palindrome ; summation of all palindrome numbers present in array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "11410-11410",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def insert ( root , item ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = item NEW_LINE temp . next = None NEW_LINE if ( root == None ) : NEW_LINE INDENT root = temp NEW_LINE DEDENT else : NEW_LINE INDENT ptr = root NEW_LINE while ( ptr . next != None ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE DEDENT ptr . next = temp NEW_LINE DEDENT return root NEW_LINE DEDENT def newList ( root1 , root2 ) : NEW_LINE INDENT ptr1 = root1 NEW_LINE ptr2 = root2 NEW_LINE root = None NEW_LINE while ( ptr1 != None ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . next = None NEW_LINE if ( ptr1 . data < ptr2 . data ) : NEW_LINE INDENT temp . data = ptr2 . data NEW_LINE DEDENT else : NEW_LINE INDENT temp . data = ptr1 . data NEW_LINE DEDENT if ( root == None ) : NEW_LINE INDENT root = temp NEW_LINE DEDENT else : NEW_LINE INDENT ptr = root NEW_LINE while ( ptr . next != None ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE DEDENT ptr . next = temp NEW_LINE DEDENT ptr1 = ptr1 . next NEW_LINE ptr2 = ptr2 . next NEW_LINE DEDENT return root NEW_LINE DEDENT def display ( root ) : NEW_LINE INDENT while ( root != None ) : NEW_LINE INDENT print ( root . data , \" - > \" , end = \" ▁ \" ) NEW_LINE root = root . next NEW_LINE DEDENT print ( \" ▁ \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = None NEW_LINE root2 = None NEW_LINE root = None NEW_LINE root1 = insert ( root1 , 5 ) NEW_LINE root1 = insert ( root1 , 2 ) NEW_LINE root1 = insert ( root1 , 3 ) NEW_LINE root1 = insert ( root1 , 8 ) NEW_LINE print ( \" First ▁ List : ▁ \" , end = \" ▁ \" ) NEW_LINE display ( root1 ) NEW_LINE root2 = insert ( root2 , 1 ) NEW_LINE root2 = insert ( root2 , 7 ) NEW_LINE root2 = insert ( root2 , 4 ) NEW_LINE root2 = insert ( root2 , 5 ) NEW_LINE print ( \" Second ▁ List : ▁ \" , end = \" ▁ \" ) NEW_LINE display ( root2 ) NEW_LINE root = newList ( root1 , root2 ) NEW_LINE print ( \" New ▁ List : ▁ \" , end = \" ▁ \" ) NEW_LINE display ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Create new linked list from two given linked list with greater element at each node | Node class ; Function to insert node in a linked list ; Function which returns new linked list ; Compare for greater node ; Driver Code ; First linked list ; Second linked list",
        "Category": "Linked List"
    },
    {
        "ID": "11414-11414",
        "Code": "def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 ; num = 1 ; NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num ; NEW_LINE num *= k ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) ; NEW_LINE sumAll = ( n * ( n + 1 ) ) / 2 ; NEW_LINE return ( sumAll - pwrK ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; k = 3 ; NEW_LINE print ( getSum ( n , k ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the sum of numbers from 1 to n excluding those which are powers of K | Function to return the sum of all the powers of k from the range [ 1 , n ] ; To store the sum of the series ; While current power of k <= n ; Add current power to the sum ; Next power of k ; Return the sum of the series ; Find to return the sum of the elements from the range [ 1 , n ] excluding those which are powers of k ; Sum of all the powers of k from [ 1 , n ] ; Sum of all the elements from [ 1 , n ] ; Return the required sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11416-11416",
        "Code": "kN = 1000000 ; NEW_LINE def maxPeople ( p ) : NEW_LINE INDENT sums = [ 0 ] * kN ; NEW_LINE sums [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , kN ) : NEW_LINE INDENT sums [ i ] = ( i * i ) + sums [ i - 1 ] ; NEW_LINE DEDENT it = lower_bound ( sums , 0 , kN , p ) ; NEW_LINE if ( it > p ) : NEW_LINE INDENT it -= 1 ; NEW_LINE DEDENT return it ; NEW_LINE DEDENT def lower_bound ( a , low , high , element ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT middle = int ( low + ( high - low ) / 2 ) ; NEW_LINE if ( element > a [ middle ] ) : NEW_LINE INDENT low = middle + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = middle ; NEW_LINE DEDENT DEDENT return low ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 14 ; NEW_LINE print ( maxPeople ( p ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of people that can be killed with strength P | Python3 implementation of the approach ; Function to return the maximum number of people that can be killed ; Storing the sum beforehand so that it can be used in each query ; lower_bound returns an iterator pointing to the first element greater than or equal to your val ; Previous value ; Returns the index in array upto which killing is possible with strength P ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "11417-11417",
        "Code": "def squareSeries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE DEDENT def maxPeople ( n ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1000000000000000 NEW_LINE while low <= high : NEW_LINE INDENT mid = low + ( ( high - low ) // 2 ) NEW_LINE value = squareSeries ( mid ) NEW_LINE if value <= n : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 14 NEW_LINE print ( maxPeople ( p ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of people that can be killed with strength P | helper function which returns the sum of series ( 1 ^ 2 + 2 ^ 2 + ... + n ^ 2 ) ; maxPeople function which returns appropriate value using Binary Search in O ( logn ) ; Set the lower and higher values ; calculate the mid using low and high ; compare value with n ; return the ans",
        "Category": "Binary Search"
    },
    {
        "ID": "11419-11419",
        "Code": "def getfactor ( n , p ) : NEW_LINE INDENT pw = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n //= p ; NEW_LINE pw += n ; NEW_LINE DEDENT return pw ; NEW_LINE DEDENT def isDivisible ( n , r , p ) : NEW_LINE INDENT x1 = getfactor ( n , p ) ; NEW_LINE x2 = getfactor ( r , p ) ; NEW_LINE x3 = getfactor ( n - r , p ) ; NEW_LINE if ( x1 > x2 + x3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 ; r = 2 ; p = 7 ; NEW_LINE if ( isDivisible ( n , r , p ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find if nCr is divisible by the given prime | Function to return the highest power of p that divides n ! implementing Legendre Formula ; Return the highest power of p which divides n ! ; Function that returns true if nCr is divisible by p ; Find the highest powers of p that divide n ! , r ! and ( n - r ) ! ; If nCr is divisible by p ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11421-11421",
        "Code": "MAXN = 60 NEW_LINE def solveQuery ( L , X ) : NEW_LINE INDENT res = 0 NEW_LINE a = [ 0 for i in range ( MAXN ) ] NEW_LINE b = [ 0 for i in range ( MAXN ) ] NEW_LINE ref = X NEW_LINE size_a = 0 NEW_LINE while ( ref > 0 ) : NEW_LINE INDENT a [ size_a ] = ref % 2 NEW_LINE ref //= 2 NEW_LINE size_a += 1 NEW_LINE DEDENT for i in range ( min ( size_a , L ) ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT b [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( min ( size_a , L ) , L ) : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT b [ L - 1 ] = 1 NEW_LINE temp = 0 NEW_LINE p = 1 NEW_LINE for i in range ( L ) : NEW_LINE INDENT temp += b [ i ] * p NEW_LINE p *= 2 NEW_LINE DEDENT res = temp ^ X NEW_LINE return res NEW_LINE DEDENT queries = [ [ 2 , 5 ] , [ 3 , 15 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( solveQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to find the maximum Xor value between X and the nodes of a given level of a perfect binary tree | Python3 implementation of the approach ; Function to solve queries of the maximum xor value between the nodes in a given level L of a perfect binary tree and a given value X ; Initialize result ; Initialize array to store bits ; Initialize a copy of X and size of array ; Storing the bits of X in the array a [ ] ; Filling the array b [ ] ; Initializing variable which gives maximum xor ; Getting the maximum xor value ; Return the result ; Driver code ; Perform queries",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11425-11425",
        "Code": "def solve ( a , b ) : NEW_LINE INDENT if ( a > 0 and b > 0 ) : NEW_LINE INDENT print ( \" Positive \" ) NEW_LINE DEDENT elif ( a <= 0 and b >= 0 ) : NEW_LINE INDENT print ( \" Zero \" ) NEW_LINE DEDENT else : NEW_LINE INDENT n = abs ( a - b ) + 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Positive \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Negative \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = - 10 NEW_LINE b = - 2 NEW_LINE solve ( a , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether product of integers from a to b is positive , negative or zero | Function to check whether the product of integers of the range [ a , b ] is positive , negative or zero ; If both a and b are positive then the product will be positive ; If a is negative and b is positive then the product will be zero ; If both a and b are negative then we have to find the count of integers in the range ; Total integers in the range ; If n is even then the resultant product is positive ; If n is odd then the resultant product is negative ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11429-11429",
        "Code": "from math import gcd NEW_LINE def countQuadruplets ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for u in range ( l , r + 1 , 1 ) : NEW_LINE INDENT for v in range ( l , r + 1 , 1 ) : NEW_LINE INDENT for w in range ( l , r + 1 , 1 ) : NEW_LINE INDENT for x in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( gcd ( gcd ( u , v ) , gcd ( w , x ) ) == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE k = 2 NEW_LINE print ( countQuadruplets ( l , r , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of quadruplets from range [ L , R ] having GCD equal to K | Python 3 implementation of the approach ; Function to return the count of quadruplets having gcd = k ; To store the required count ; Check every quadruplet pair whether its gcd is k ; Return the required count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11432-11432",
        "Code": "def Rate ( N1 , N2 ) : NEW_LINE INDENT rate = ( N2 - N1 ) * 100 // ( N1 ) ; NEW_LINE return rate NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N1 = 100 NEW_LINE N2 = 120 NEW_LINE print ( Rate ( N1 , N2 ) , \" ▁ % \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the rate percentage from compound interest of consecutive years | Function to return the required rate percentage ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11437-11437",
        "Code": "def CreateArray ( N , even , odd ) : NEW_LINE INDENT temp = - 1 NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT if ( i * ( ( N + 1 ) - i ) == odd ) : NEW_LINE INDENT temp = 0 NEW_LINE OddPreSums = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( temp == - 1 ) : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT EvenPreSums = ( N + 1 ) - OddPreSums NEW_LINE e = 1 NEW_LINE o = 0 NEW_LINE CurrSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( CurrSum % 2 == 0 ) : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( \"0 ▁ \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( \"1 ▁ \" , end = \" \" ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( \"1 ▁ \" ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( \"0 ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE even = 60 NEW_LINE odd = 60 NEW_LINE CreateArray ( N , even , odd ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate an Array in which count of even and odd sum sub | Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11442-11442",
        "Code": "def findX ( A , B ) : NEW_LINE INDENT return A & B NEW_LINE DEDENT def findSum ( A , B ) : NEW_LINE INDENT return A ^ B NEW_LINE DEDENT A , B = 2 , 3 NEW_LINE print ( \" X ▁ = \" , findX ( A , B ) , \" , ▁ Sum ▁ = \" , findSum ( A , B ) ) NEW_LINE",
        "Type": "py",
        "NL": "Choose X such that ( A xor X ) + ( B xor X ) is minimized | finding X ; finding Sum ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11443-11443",
        "Code": "def isSafe ( N , M , str ) : NEW_LINE INDENT coll = 0 NEW_LINE colr = 0 NEW_LINE rowu = 0 NEW_LINE rowd = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' L ' ) : NEW_LINE INDENT coll += 1 NEW_LINE if ( colr > 0 ) : NEW_LINE INDENT colr -= 1 NEW_LINE DEDENT if ( coll == M ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' R ' ) : NEW_LINE INDENT colr += 1 NEW_LINE if ( coll > 0 ) : NEW_LINE INDENT coll -= 1 NEW_LINE DEDENT if ( colr == M ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' U ' ) : NEW_LINE INDENT rowu += 1 NEW_LINE if ( rowd > 0 ) : NEW_LINE INDENT rowd -= 1 NEW_LINE DEDENT if ( rowu == N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' D ' ) : NEW_LINE INDENT rowd += 1 NEW_LINE if ( rowu > 0 ) : NEW_LINE INDENT rowu -= 1 NEW_LINE DEDENT if ( rowd == N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( abs ( rowd ) < N and abs ( rowu ) < N and abs ( coll ) < M and abs ( colr ) < M ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 1 NEW_LINE M = 1 NEW_LINE str = \" R \" NEW_LINE if ( isSafe ( N , M , str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if the robot is within the bounds of the grid after given moves | Function that returns true if the robot is safe ; If current move is \" L \" then increase the counter of coll ; If value of coll is equal to column then break ; If current move is \" R \" then increase the counter of colr ; If value of colr is equal to column then break ; If current move is \" U \" then increase the counter of rowu ; If value of rowu is equal to row then break ; If current move is \" D \" then increase the counter of rowd ; If value of rowd is equal to row then break ; If robot is within the bounds of the grid ; Unsafe ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11446-11446",
        "Code": "def findIndex ( a , n ) : NEW_LINE INDENT res , min_diff = None , float ( ' inf ' ) NEW_LINE prod = [ None ] * n NEW_LINE prod [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prod [ i ] = prod [ i - 1 ] * a [ i ] NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT curr_diff = abs ( ( prod [ n - 1 ] // prod [ i ] ) - prod [ i ] ) NEW_LINE if curr_diff < min_diff : NEW_LINE INDENT min_diff = curr_diff NEW_LINE res = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 2 , 5 , 7 , 2 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findIndex ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find an index such that difference between product of elements before and after it is minimum | Function to return the index i such that the absolute difference between product of elements up to that index and the product of rest of the elements of the array is minimum ; To store the required index ; Prefix product array ; Compute the product array ; Iterate the product array to find the index ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11447-11447",
        "Code": "import math NEW_LINE def solve ( Array , N ) : NEW_LINE INDENT Arraynew = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT Arraynew [ i ] = math . log ( Array [ i ] ) NEW_LINE DEDENT prefixsum = [ 0 ] * N NEW_LINE prefixsum [ 0 ] = Arraynew [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT prefixsum [ i ] = prefixsum [ i - 1 ] + Arraynew [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE minabs = abs ( prefixsum [ N - 1 ] - 2 * prefixsum [ 0 ] ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT ans1 = abs ( prefixsum [ N - 1 ] - 2 * prefixsum [ i ] ) NEW_LINE if ( ans1 < minabs ) : NEW_LINE INDENT minabs = ans1 NEW_LINE answer = i NEW_LINE DEDENT DEDENT print ( \" Index ▁ is : ▁ \" , answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Array = [ 1 , 4 , 12 , 2 , 6 ] NEW_LINE N = 5 NEW_LINE solve ( Array , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find an index such that difference between product of elements before and after it is minimum |  ; Function to find index ; Array to store log values of elements ; Prefix Array to Maintain Sum of log values till index i ; Answer Index ; Find minimum absolute value ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "11458-11458",
        "Code": "def find_leftmost_unsetbit ( n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE i = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n % 2 ) != 1 ) : NEW_LINE INDENT ind = i ; NEW_LINE DEDENT i += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return ind ; NEW_LINE DEDENT def perform_steps ( n ) : NEW_LINE INDENT left = find_leftmost_unsetbit ( n ) ; NEW_LINE if ( left == - 1 ) : NEW_LINE INDENT print ( \" No ▁ steps ▁ required \" ) ; NEW_LINE return ; NEW_LINE DEDENT step = 1 ; NEW_LINE while ( find_leftmost_unsetbit ( n ) != - 1 ) : NEW_LINE INDENT if ( step % 2 == 0 ) : NEW_LINE INDENT n += 1 ; NEW_LINE print ( \" Step \" , step ,   \" : Increase by 1 \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT m = find_leftmost_unsetbit ( n ) ; NEW_LINE num = ( 2 ** m ) - 1 ; NEW_LINE n = n ^ num ; NEW_LINE print ( \" Step \" , step , \" : ▁ Xor ▁ with \" , num ) ; NEW_LINE DEDENT step += 1 ; NEW_LINE DEDENT DEDENT n = 39 ; NEW_LINE perform_steps ( n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Print steps to make a number in form of 2 ^ X | Function to find the leftmost unset bit in a number . ; Function that perform the step ; Find the leftmost unset bit ; If the number has no bit unset , it means it is in form 2 ^ x - 1 ; Count the steps ; Iterate till number is of form 2 ^ x - 1 ; At even step increase by 1 ; Odd step xor with any 2 ^ m - 1 ; Find the leftmost unset bit ; 2 ^ m - 1 ; Perform the step ; Increase the steps ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11460-11460",
        "Code": "import bisect NEW_LINE def printPosition ( A , B , sizeOfA , sizeOfB ) : NEW_LINE INDENT for i in range ( 1 , sizeOfA ) : NEW_LINE INDENT A [ i ] += A [ i - 1 ] NEW_LINE DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT row = bisect . bisect_left ( A , B [ i ] ) NEW_LINE if row >= 1 : NEW_LINE INDENT boxNumber = B [ i ] - A [ row - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT boxNumber = B [ i ] NEW_LINE DEDENT print ( row + 1 , \" , \" , boxNumber ) NEW_LINE DEDENT DEDENT A = [ 2 , 2 , 2 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 4 ] NEW_LINE sizeOfA = len ( A ) NEW_LINE sizeOfB = len ( B ) NEW_LINE printPosition ( A , B , sizeOfA , sizeOfB ) NEW_LINE",
        "Type": "py",
        "NL": "Find the position of box which occupies the given ball | Python3 implementation of the approach ; Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A [ ] ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "11464-11464",
        "Code": "mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangements ( N , K , mod ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of ways to arrange K different objects taking N objects at a time | Python3 implementation of the approach ; Function to return n ! % p ; res = 1 Initialize result ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; Returns n ^ ( - 1 ) mod p ; Returns nCr % p using Fermat 's little theorem. ; Base case ; Fifactorial array so that we can find afactorial of r , n and n - r ; Function to return the number of ways to arrange K different objects taking N objects at a time ; Drivers Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11467-11467",
        "Code": "def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find maximum product of digits among numbers less than or equal to N | Function that returns the maximum product of digits among numbers less than or equal to N ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "11469-11469",
        "Code": "from math import gcd NEW_LINE def printNumbers ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE g = gcd ( num , x ) NEW_LINE while ( g != 1 ) : NEW_LINE INDENT num //= g NEW_LINE g = gcd ( num , x ) NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT flag = True ; NEW_LINE print ( a [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( \" There ▁ are ▁ no ▁ such ▁ numbers \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 60 NEW_LINE a = [ 2 , 5 , 10 , 7 , 17 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n , x ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all numbers whose set of prime factors is a subset of the set of the prime factors of X | Python3 program to implement the above approach ; Function to print all the numbers ; Iterate for every element in the array ; Find the gcd ; Iterate till gcd is 1 of number and x ; Divide the number by gcd ; Find the new gcdg ; If the number is 1 at the end then print the number ; If no numbers have been there ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11471-11471",
        "Code": "def sumodd ( n ) : NEW_LINE INDENT return ( n * n ) NEW_LINE DEDENT def sumeven ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) NEW_LINE DEDENT def findSum ( num ) : NEW_LINE INDENT sumo = 0 NEW_LINE sume = 0 NEW_LINE x = 1 NEW_LINE cur = 0 NEW_LINE ans = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT inc = min ( x , num ) NEW_LINE num -= inc NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) NEW_LINE sumo += inc NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) NEW_LINE sume += inc NEW_LINE DEDENT x *= 2 NEW_LINE cur ^= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE print ( findSum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of the series 1 , 2 , 4 , 3 , 5 , 7 , 9 , 6 , 8 , 10 , 11 , 13. . till N | Function to find the sum of first N odd numbers ; Function to find the sum of first N even numbers ; Function to overall find the sum of series ; Initial odd numbers ; Initial even numbers ; First power of 2 ; Check for parity for odd / even ; Counts the sum ; Get the minimum out of remaining num or power of 2 ; Decrease that much numbers from num ; If the segment has odd numbers ; Summate the odd numbers By exclusion ; Increase number of odd numbers ; If the segment has even numbers ; Summate the even numbers By exclusion ; Increase number of even numbers ; Next set of numbers ; Change parity for odd / even ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11472-11472",
        "Code": "def printf ( rStation , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( rStation [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" , ▁ end ▁ = ▁ \"   \" ) NEW_LINE DEDENT def radiated_Station ( station , n ) : NEW_LINE INDENT rStation = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT li = i - 1 NEW_LINE ri = i + 1 NEW_LINE lRad = station [ i ] - 1 NEW_LINE rRad = station [ i ] - 1 NEW_LINE rStation [ i ] += station [ i ] NEW_LINE while ( li >= 1 and lRad >= 1 ) : NEW_LINE INDENT rStation [ li ] += lRad NEW_LINE lRad -= 1 NEW_LINE li -= 1 NEW_LINE DEDENT while ( ri <= n and rRad >= 1 ) : NEW_LINE INDENT rStation [ ri ] += rRad NEW_LINE rRad -= 1 NEW_LINE ri += 1 NEW_LINE DEDENT DEDENT printf ( rStation , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT station = [ 0 , 7 , 9 , 12 , 2 , 5 ] NEW_LINE n = len ( station ) - 1 NEW_LINE radiated_Station ( station , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the final radiations of each Radiated Stations | Function to print the final radiations ; Function to create the array of the resultant radiations ; Resultant radiations ; Declaring index counter for left and right radiation ; Effective radiation for left and right case ; Radiation for i - th station ; Radiation increment for left stations ; Radiation increment for right stations ; Print the resultant radiation for each of the stations ; Driver code ; 1 - based indexing",
        "Category": "Array"
    },
    {
        "ID": "11475-11475",
        "Code": "def idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( a1 // a2 == b1 // b2 ) and ( a1 // a2 == c1 // c2 ) and ( b1 // b2 == c1 // c2 ) ) : NEW_LINE INDENT print ( \" The ▁ given ▁ straight ▁ lines \" , \" are ▁ identical \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ given ▁ straight ▁ lines \" , \" are ▁ not ▁ identical \" ) ; NEW_LINE DEDENT DEDENT a1 , b1 = - 2 , 4 NEW_LINE c1 , a2 = 3 , - 6 NEW_LINE b2 , c2 = 12 , 9 NEW_LINE idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) NEW_LINE",
        "Type": "py",
        "NL": "Check if given two straight lines are identical or not | Function to check if they are identical ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11477-11477",
        "Code": "from math import sqrt NEW_LINE MAXN = 100001 NEW_LINE mod = 1000000007 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE cnt = { i : 0 for i in range ( 10 ) } NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( MAXN ) ) + 1 , 1 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def factorize ( f ) : NEW_LINE INDENT while ( f > 1 ) : NEW_LINE INDENT x = spf [ f ] NEW_LINE while ( f % x == 0 ) : NEW_LINE INDENT cnt [ x ] += 1 NEW_LINE f = int ( f / x ) NEW_LINE DEDENT DEDENT DEDENT def factorial ( n , p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrays ( arr , N , K , P ) : NEW_LINE INDENT res = 1 NEW_LINE sieve ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT factorize ( arr [ i ] ) NEW_LINE DEDENT for key , value in cnt . items ( ) : NEW_LINE INDENT ci = value NEW_LINE res = ( res * nCrModP ( ci + K - 1 , K - 1 , P ) ) % P NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 2 ] NEW_LINE K = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( countArrays ( arr , N , K , mod ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count arrays of length K whose product of elements is same as that of given array | Python 3 implementation of the approach ; To store the smallest prime factor for every number ; Initialize map to store count of prime factors ; Function to calculate SPF ( Smallest Prime Factor ) for every number till MAXN ; Marking smallest prime factor for every number to be itself ; Separately marking spf for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function to factorize using spf and store in cnt ; Function to return n ! % p ; Initialize result ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is >= p ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Function that returns n ^ ( - 1 ) mod p ; Function that returns nCr % p using Fermat 's little theorem ; Base case ; Fill factorial array so that we can find all factorial of r , n and n - r ; Function to return the count the number of possible arrays mod P of length K such that the product of all elements of that array is equal to the product of all elements of the given array of length N ; Initialize result ; Call sieve to get spf ; Factorize arr [ i ] , count and store its factors in cnt ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11479-11479",
        "Code": "def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , \" x \" , \" + \" , x0 , \" y = \" , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Equation of straight line passing through a given point which bisects it into two equal line segments | Function to print the equation of the required line ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11482-11482",
        "Code": "def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x ; NEW_LINE p /= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; NEW_LINE DEDENT return round ( loss , 2 ) ; NEW_LINE DEDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE quantity = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , quantity , X , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Calculate the loss incurred in selling the given items at discounted price | Function to return the x % of n ; Function to return the total loss ; To store the total loss ; Original price of the item ; The price at which the item will be sold ; The discounted price of the item ; Loss incurred ; Driver code ; Total items",
        "Category": "Math"
    },
    {
        "ID": "11485-11485",
        "Code": "def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n // 10 ) % 10 NEW_LINE c = n // 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 132 NEW_LINE if isOsiris ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "3 | Function that returns true if n is an Osiris number ; 3 rd digit ; 2 nd digit ; 1 st digit ; Check the required condition ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11486-11486",
        "Code": "def isDudeney ( n ) : NEW_LINE INDENT cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) NEW_LINE if cube_rt * cube_rt * cube_rt != n : NEW_LINE INDENT return False NEW_LINE DEDENT dig_sum = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT rem = temp % 10 NEW_LINE dig_sum += rem NEW_LINE temp //= 10 NEW_LINE DEDENT if cube_rt != dig_sum : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 17576 NEW_LINE if isDudeney ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Dudeney Numbers | Function that returns true if n is a Dudeney number ; If n is not a perfect cube ; Last digit ; Update the digit sum ; Remove the last digit ; If cube root of n is not equal to the sum of its digits ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11490-11490",
        "Code": "N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N ; NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N // i ) : NEW_LINE INDENT cnt [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 ; NEW_LINE Divisors ( ) ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k ; NEW_LINE sum += cnt [ x ] ; NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 5 ; B = 6 ; C = 7 ; NEW_LINE print ( Sumofdivisors ( A , B , C ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the sum of the number of divisors | Python3 code for above given approach ; To store the number of divisors ; Function to find the number of divisors of all numbers in the range 1 to n ; For every number 1 to n ; Increase divisors count for every number ; Function to find the sum of divisors ; To store sum ; Count the divisors ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "11491-11491",
        "Code": "def getHCF ( x , y ) : NEW_LINE INDENT minimum = min ( x , y ) NEW_LINE if ( x % minimum == 0 and y % minimum == 0 ) : NEW_LINE INDENT return minimum NEW_LINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT x , y = 16 , 32 NEW_LINE print ( getHCF ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find HCF of two numbers without using recursion or Euclidean algorithm | Function to return the HCF of x and y ; Minimum of the two numbers ; If both the numbers are divisible by the minimum of these two then the HCF is equal to the minimum ; Highest number between 2 and minimum / 2 which can divide both the numbers is the required HCF ; If both the numbers are divisible by i ; 1 divides every number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11498-11498",
        "Code": "def oddDays ( N ) : NEW_LINE INDENT hund1 = N // 100 NEW_LINE hund4 = N // 400 NEW_LINE leap = N >> 2 NEW_LINE ordd = N - leap NEW_LINE if ( hund1 ) : NEW_LINE INDENT ordd += hund1 NEW_LINE leap -= hund1 NEW_LINE DEDENT if ( hund4 ) : NEW_LINE INDENT ordd -= hund4 NEW_LINE leap += hund4 NEW_LINE DEDENT days = ordd + leap * 2 NEW_LINE odd = days % 7 NEW_LINE return odd NEW_LINE DEDENT N = 100 NEW_LINE print ( oddDays ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate the number of odd days in given number of years | Function to return the count of odd days ; Count of years divisible by 100 and 400 ; Every 4 th year is a leap year ; Every 100 th year is divisible by 4 but is not a leap year ; Every 400 th year is divisible by 100 but is a leap year ; Total number of extra days ; modulo ( 7 ) for final answer ; Number of days",
        "Category": "Math"
    },
    {
        "ID": "115-115",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def checkUtil ( root , level ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return True NEW_LINE DEDENT if root . left is None and root . right is None : NEW_LINE INDENT if check . leafLevel == 0 : NEW_LINE INDENT check . leafLevel = level NEW_LINE return True NEW_LINE DEDENT return level == check . leafLevel NEW_LINE DEDENT return ( checkUtil ( root . left , level + 1 ) and checkUtil ( root . right , level + 1 ) ) NEW_LINE DEDENT def check ( root ) : NEW_LINE INDENT level = 0 NEW_LINE check . leafLevel = 0 NEW_LINE return ( checkUtil ( root , level ) ) NEW_LINE DEDENT root = Node ( 12 ) NEW_LINE root . left = Node ( 5 ) NEW_LINE root . left . left = Node ( 3 ) NEW_LINE root . left . right = Node ( 9 ) NEW_LINE root . left . left . left = Node ( 1 ) NEW_LINE root . left . right . left = Node ( 2 ) NEW_LINE if ( check ( root ) ) : NEW_LINE INDENT print \" Leaves ▁ are ▁ at ▁ same ▁ level \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Leaves ▁ are ▁ not ▁ at ▁ same ▁ level \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if all leaves are at same level | A binary tree node ; Recursive function which check whether all leaves are at same level ; Base Case ; If a tree node is encountered ; When a leaf node is found first time ; Set first leaf found ; If this is not first leaf node , compare its level with first leaf 's level ; If this is not first leaf node , compare its level with first leaf 's level ; The main function to check if all leafs are at same level . It mainly uses checkUtil ( ) ; Let us create the tree as shown in the example",
        "Category": "Binary Tree"
    },
    {
        "ID": "11511-11511",
        "Code": "def A_mod_B ( N , a ) : NEW_LINE INDENT Len = len ( N ) NEW_LINE ans = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT ans = ( ans * 10 + int ( N [ i ] ) ) % a NEW_LINE DEDENT return ans % a NEW_LINE DEDENT def findMod ( N ) : NEW_LINE INDENT mod = A_mod_B ( N , 4 ) NEW_LINE ans = ( 1 + pow ( 2 , mod ) + pow ( 3 , mod ) + pow ( 4 , mod ) ) NEW_LINE return ans % 5 NEW_LINE DEDENT N = \"4\" NEW_LINE print ( findMod ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find ( 1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n ) mod 5 | Set 2 | Function to return A mod B ; length of the string ; to store required answer ; Function to return ( 1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n ) % 5 ; Calculate and return ans ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11517-11517",
        "Code": "def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEW_LINE return years NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T1 , N1 , T2 = 3 , 5 , 6 NEW_LINE print ( noOfYears ( T1 , N1 , T2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Times required by Simple interest for the Principal to become Y times itself | Function to return the no . of years ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11520-11520",
        "Code": "max_Element = 100005 NEW_LINE sum1 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum2 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum3 = [ 0 for i in range ( max_Element ) ] NEW_LINE def precomputation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum1 [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum2 [ j ] += ( sum1 [ j ] - i ) * i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum2 [ i ] = int ( sum2 [ i ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum3 [ i ] = int ( sum3 [ i ] / 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum3 [ arr [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE precomputation ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of multiplication of triplet of divisors of a number | Global array declaration global max_Element ; Function to find the sum of multiplication of every triplet in the divisors of a number ; global max_Element sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing",
        "Category": "Math"
    },
    {
        "ID": "11528-11528",
        "Code": "mod = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findCount ( N ) : NEW_LINE INDENT count = power ( 2 , N , mod ) NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( findCount ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count number of binary strings of length N having only 0 ' s ▁ and ▁ 1' s | Python 3 implementation of the approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; Function to count the number of binary strings of length N having only 0 ' s ▁ and ▁ 1' s ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11529-11529",
        "Code": "def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret = ret + 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE DEDENT zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( ( l % 2 == 1 ) and ( r % 2 == 1 ) ) : NEW_LINE INDENT zero_bit_cnt = zero_bit_cnt + 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE",
        "Type": "py",
        "NL": "XOR of all the elements in the given range [ L , R ] | Function to return the most significant bit ; Function to return the required XOR ; Finding the MSB ; Value of the current bit to be added ; To store the final answer ; Loop for case 1 ; Edge case when both the integers lie in the same segment of continuous 1 s ; To store whether parity of count is odd ; Updating the answer if parity is odd ; Updating the number to be added ; Case 2 ; Driver code ; Final answer",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11546-11546",
        "Code": "import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 ; NEW_LINE return int ( round ( pow ( phi , n ) / math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Sum of Fibonacci Numbers in a range | Python3 implementation of the approach ; Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11547-11547",
        "Code": "def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find amount of water wasted after filling the tank | Function to calculate amount of wasted water ; filled amount of water in one minute ; total time taken to fill the tank because of leakage ; wasted amount of water ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11555-11555",
        "Code": "def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N // 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N // 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a pair from the given array with maximum nCr value | Function to print the pair that gives maximum nCr ; This gives the value of N in nCr ; Case 1 : When N is odd ; Case 2 : When N is even ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11556-11556",
        "Code": "def Permutations ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE if k >= 2 : NEW_LINE INDENT ans += ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if k >= 3 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 ) NEW_LINE DEDENT if k >= 4 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE print ( Permutations ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the number of good permutations | Function to return the count of good permutations ; For m = 0 , ans is 1 ; If k is greater than 1 ; If k is greater than 2 ; If k is greater than 3 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11564-11564",
        "Code": "def lastDigit ( a , b ) : NEW_LINE INDENT lastDig = ( ( int ( a [ len ( a ) - 1 ] ) - int ( '0' ) ) * ( int ( b [ len ( b ) - 1 ] ) - int ( '0' ) ) ) NEW_LINE print ( lastDig % 10 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = \"1234567891233\" , \"1234567891233156\" NEW_LINE lastDigit ( a , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Last digit of Product of two Large or Small numbers ( a * b ) | Function to print the last digit of product a * b ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11567-11567",
        "Code": "def printSum ( a , b ) : NEW_LINE INDENT res , temp1 , temp2 = 0 , 0 , 0 NEW_LINE while a > 0 : NEW_LINE INDENT temp1 = temp1 * 10 + ( a % 10 ) NEW_LINE a //= 10 NEW_LINE DEDENT a = temp1 NEW_LINE while b > 0 : NEW_LINE INDENT temp2 = temp2 * 10 + ( b % 10 ) NEW_LINE b //= 10 NEW_LINE DEDENT b = temp2 NEW_LINE while a : NEW_LINE INDENT Sum = a % 10 + b % 10 NEW_LINE if Sum // 10 == 0 : NEW_LINE INDENT res = res * 10 + Sum NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = 0 NEW_LINE while Sum > 0 : NEW_LINE INDENT temp1 = temp1 * 10 + ( Sum % 10 ) NEW_LINE Sum //= 10 NEW_LINE DEDENT Sum = temp1 NEW_LINE while Sum > 0 : NEW_LINE INDENT res = res * 10 + ( Sum % 10 ) NEW_LINE Sum //= 10 NEW_LINE DEDENT DEDENT a //= 10 NEW_LINE b //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = 7752 , 8834 NEW_LINE print ( printSum ( a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Addition of two numbers without propagating Carry | Function to prsum of 2 numbers without propagating carry ; Reverse a ; Reverse b ; Generate sum Since length of both a and b are same , take any one of them . ; Extract digits from a and b and add ; If sum is single digit ; If sum is not single digit reverse sum ; Extract digits from sum and append to result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11578-11578",
        "Code": "def factorial ( f ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , f + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def findPermuatation ( N , M ) : NEW_LINE INDENT permutation = ( factorial ( N + M - 1 ) // ( factorial ( N ) * factorial ( M - 1 ) ) ) NEW_LINE return permutation NEW_LINE DEDENT N = 3 ; M = 3 NEW_LINE print ( findPermuatation ( N , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros | Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11580-11580",
        "Code": "def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find last five digits of a given five digit number raised to power five | Function to find the last five digits of a five digit number raised to power five ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11585-11585",
        "Code": "def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count of numbers having only 1 set bit in the range [ 0 , n ] | Function to return the required count ; To store the count of numbers ; Every power of 2 contains only 1 set bit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11592-11592",
        "Code": "def countNumbers ( n ) : NEW_LINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Numbers that are not divisible by any number in the range [ 2 , 10 ] | Function to return the count of numbers from 1 to N which are not divisible by any number in the range [ 2 , 10 ] ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11612-11612",
        "Code": "def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinRemoval ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize sum of adjacent difference with removal of one element from array | Function to find the element ; Value variable for storing the total value ; Declaring maximum value as zero ; If array contains on element ; Storing the maximum value in temp variable ; Adding the adjacent difference modulus values of removed element . Removing adjacent difference modulus value after removing element ; Returning total value - maximum value ; Drivers code",
        "Category": "Array"
    },
    {
        "ID": "11614-11614",
        "Code": "def getTime ( u , v , x ) : NEW_LINE INDENT speed = u + v NEW_LINE time = x / speed NEW_LINE return time NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT u , v , x = 3 , 3 , 3 NEW_LINE print ( getTime ( u , v , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Time until distance gets equal to X between two objects moving in opposite direction | Function to return the time for which the two policemen can communicate ; time = distance / speed ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11623-11623",
        "Code": "def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT N = 20 NEW_LINE print ( LucasSum ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of numbers from 1 to N which are in Lucas Sequence | Function to return the required Sum ; Generate lucas number and keep on adding them ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11624-11624",
        "Code": "def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 1000 ; r = 6000 NEW_LINE print ( countNumbers ( l , r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11625-11625",
        "Code": "def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 6 ) - ( l - 1 ) // 6 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1000 ; r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Function to return the count of required numbers ; Count of numbers in range which are divisible by 6 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11632-11632",
        "Code": "import sys NEW_LINE def findPowerOfP ( N , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= N ) : NEW_LINE INDENT count += int ( N / r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofB ( B ) : NEW_LINE ' NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while ( B != 1 ) : NEW_LINE INDENT if ( B % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( B % i == 0 ) : NEW_LINE INDENT B = int ( B / i ) NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( ( i , count ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfB ( N , B ) : NEW_LINE INDENT vec = [ ] NEW_LINE vec = primeFactorsofB ( B ) NEW_LINE ans = sys . maxsize NEW_LINE ans = min ( ans , int ( findPowerOfP ( N , vec [ 0 ] [ 0 ] ) / vec [ 0 ] [ 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( largestPowerOfB ( 5 , 2 ) ) NEW_LINE print ( largestPowerOfB ( 6 , 9 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of trailing zeroes in base B representation of N ! | Python 3 program to find the number of trailing zeroes in base B representation of N ! ; To find the power of a prime p in factorial N ; calculating floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of B ; Returns largest power of B that divides N ! ; calculating minimum power of all the prime factors of B ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11641-11641",
        "Code": "def findPrefixCount ( p_arr , arr ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT if j != n - 1 : NEW_LINE INDENT p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] NEW_LINE DEDENT p_arr [ i ] [ j ] += int ( not arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def matrixOrValueOne ( arr ) : NEW_LINE INDENT p_arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE findPrefixCount ( p_arr , arr ) NEW_LINE count_zero_submatrices = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE q = [ ] NEW_LINE to_sum = 0 NEW_LINE while i >= 0 : NEW_LINE INDENT c = 0 NEW_LINE while ( len ( q ) != 0 and q [ - 1 ] [ 0 ] > p_arr [ i ] [ j ] ) : NEW_LINE INDENT to_sum -= ( ( q [ - 1 ] [ 1 ] + 1 ) * ( q [ - 1 ] [ 0 ] - p_arr [ i ] [ j ] ) ) NEW_LINE c += q . pop ( ) [ 1 ] + 1 NEW_LINE DEDENT to_sum += p_arr [ i ] [ j ] NEW_LINE count_zero_submatrices += to_sum NEW_LINE q . append ( ( p_arr [ i ] [ j ] , c ) ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return ( ( n * ( n + 1 ) * n * ( n + 1 ) ) // 4 - count_zero_submatrices ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ [ 0 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE print ( matrixOrValueOne ( arr ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of submatrices with OR value 1 | Function to find required prefix - count for each row from right to left ; Function to find the count of submatrices with OR value 1 ; Array to store prefix count of zeros from right to left for boolean array ; Variable to store the count of submatrices with OR value 0 ; Loop to evaluate each column of the prefix matrix uniquely . For each index of a column we will try to determine the number of sub - matrices starting from that index and has all 1 s ; First part of pair will be the value of inserted element . Second part will be the count of the number of elements pushed before with a greater value ; Variable to store the number of submatrices with all 0 s ; Return the final answer ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "11646-11646",
        "Code": "n = 3 NEW_LINE def preComputeXor ( arr , prefix_xor ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT prefix_xor [ i ] [ j ] = arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT def ansQuerie ( prefix_xor , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT xor_1 , xor_2 , xor_3 = 0 , 0 , 0 NEW_LINE if ( x1 != 0 ) : NEW_LINE INDENT xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 != 0 ) : NEW_LINE INDENT xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 != 0 and y1 != 0 ) : NEW_LINE INDENT xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) NEW_LINE DEDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE prefix_xor = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE preComputeXor ( arr , prefix_xor ) NEW_LINE print ( ansQuerie ( prefix_xor , 1 , 1 , 2 , 2 ) ) NEW_LINE print ( ansQuerie ( prefix_xor , 1 , 2 , 2 , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "XOR of a submatrix queries | Python implementation of the approach ; Function to pre - compute the xor ; Left to right prefix xor for each row ; Top to bottom prefix xor for each column ; Function to process the queries x1 , x2 , y1 , y2 represent the positions of the top - left and bottom right corners ; To store the xor values ; Finding the values we need to xor with value at ( x2 , y2 ) in prefix - xor matrix ; Return the required prefix xor ; Driver code ; To store pre - computed xor ; Pre - computing xor ; Queries",
        "Category": "Matrix"
    },
    {
        "ID": "11647-11647",
        "Code": "def count ( N , K , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % K == R ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE K = 4 NEW_LINE R = 3 NEW_LINE print ( count ( N , K , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of the natural numbers ( up to N ) whose modulo with K yield R | Function to return the sum ; If current number gives R as the remainder on dividing by K ; Update the sum ; Return the sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11649-11649",
        "Code": "def getCount ( a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT cr = b * pow ( i , a ) + c NEW_LINE tmp = cr NEW_LINE sm = 0 NEW_LINE while ( tmp ) : NEW_LINE INDENT sm += tmp % 10 NEW_LINE tmp //= 10 NEW_LINE DEDENT if ( sm == i and cr < 10 ** 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a , b , c = 3 , 2 , 8 NEW_LINE print ( getCount ( a , b , c ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number of solutions to the given equation | Function to return the count of valid values of X ; Iterate through all possible sum of digits of X ; Get current value of X for sum of digits i ; Find sum of digits of cr ; If cr is a valid choice for X ; Return the count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11653-11653",
        "Code": "def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum Bitwise AND pair from given range | Function to return the maximum bitwise AND possible among all the possible pairs ; Maximum among all ( i , j ) pairs ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11667-11667",
        "Code": "import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of bitwise AND of all subarrays | Python3 program to find Sum of bitwise AND of all subarrays ; Function to find the Sum of bitwise AND of all subarrays ; variable to store the final Sum ; multiplier ; variable to check if counting is on ; variable to store the length of the subarrays ; loop to find the contiguous segments ; updating the multiplier ; returning the Sum ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "1167-1167",
        "Code": "from queue import Queue NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . child = [ ] NEW_LINE self . key = data NEW_LINE DEDENT DEDENT def numberOfSiblings ( root , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( root ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT p = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE for i in range ( len ( p . child ) ) : NEW_LINE INDENT if ( p . child [ i ] . key == x ) : NEW_LINE INDENT return len ( p . child ) - 1 NEW_LINE DEDENT q . put ( p . child [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 50 ) NEW_LINE ( root . child ) . append ( newNode ( 2 ) ) NEW_LINE ( root . child ) . append ( newNode ( 30 ) ) NEW_LINE ( root . child ) . append ( newNode ( 14 ) ) NEW_LINE ( root . child ) . append ( newNode ( 60 ) ) NEW_LINE ( root . child [ 0 ] . child ) . append ( newNode ( 15 ) ) NEW_LINE ( root . child [ 0 ] . child ) . append ( newNode ( 25 ) ) NEW_LINE ( root . child [ 0 ] . child [ 1 ] . child ) . append ( newNode ( 70 ) ) NEW_LINE ( root . child [ 0 ] . child [ 1 ] . child ) . append ( newNode ( 100 ) ) NEW_LINE ( root . child [ 1 ] . child ) . append ( newNode ( 6 ) ) NEW_LINE ( root . child [ 1 ] . child ) . append ( newNode ( 1 ) ) NEW_LINE ( root . child [ 2 ] . child ) . append ( newNode ( 7 ) ) NEW_LINE ( root . child [ 2 ] . child [ 0 ] . child ) . append ( newNode ( 17 ) ) NEW_LINE ( root . child [ 2 ] . child [ 0 ] . child ) . append ( newNode ( 99 ) ) NEW_LINE ( root . child [ 2 ] . child [ 0 ] . child ) . append ( newNode ( 27 ) ) NEW_LINE ( root . child [ 3 ] . child ) . append ( newNode ( 16 ) ) NEW_LINE x = 100 NEW_LINE print ( numberOfSiblings ( root , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of siblings of a given Node in n | Python3 program to find number of siblings of a given node ; Represents a node of an n - ary tree ; Function to calculate number of siblings of a given node ; Creating a queue and pushing the root ; Dequeue an item from queue and check if it is equal to x If YES , then return number of children ; Enqueue all children of the dequeued item ; If the value of children is equal to x , then return the number of siblings ; Driver Code ; Creating a generic tree as shown in above figure ; Node whose number of siblings is to be calculated ; Function calling",
        "Category": "Graph Theory"
    },
    {
        "ID": "11673-11673",
        "Code": "import math NEW_LINE def isDigitSumOne ( nm ) : NEW_LINE INDENT if ( nm % 9 == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printValidNums ( n ) : NEW_LINE INDENT cbrt_n = math . ceil ( n ** ( 1. / 3. ) ) NEW_LINE for i in range ( 1 , cbrt_n + 1 ) : NEW_LINE INDENT cube = i * i * i NEW_LINE if ( cube >= 1 and cube <= n and isDigitSumOne ( cube ) ) : NEW_LINE INDENT print ( cube , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT n = 1000 NEW_LINE printValidNums ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Numbers less than N that are perfect cubes and the sum of their digits reduced to a single digit is 1 | Python3 implementation of the approach ; Function that returns true if the eventual digit sum of number nm is 1 ; if reminder will 1 then eventual sum is 1 ; Function to print the required numbers less than n ; If it is the required perfect cube ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11674-11674",
        "Code": "def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT def isDigitSumOne ( nm ) : NEW_LINE INDENT while ( nm > 9 ) : NEW_LINE INDENT sum_digit = 0 NEW_LINE while ( nm != 0 ) : NEW_LINE INDENT digit = nm % 10 NEW_LINE sum_digit = sum_digit + digit NEW_LINE nm = nm // 10 NEW_LINE DEDENT nm = sum_digit NEW_LINE DEDENT if ( nm == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printValidNums ( m , n ) : NEW_LINE INDENT for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( isComposite ( i ) and isDigitSumOne ( i ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT l = 10 NEW_LINE r = 100 NEW_LINE printValidNums ( m , n ) NEW_LINE",
        "Type": "py",
        "NL": "Composite numbers with digit sum 1 | Function that returns true if number n is a composite number ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if the eventual digit sum of number nm is 1 ; Loop till the sum is not single digit number ; Intitialize the sum as zero ; Find the sum of digits ; If sum is eventually 1 ; Function to print the required numbers from the given range ; If i is one of the required numbers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11680-11680",
        "Code": "def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE print ( countSquares ( row , column ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count the total number of squares that can be visited by Bishop in one move | Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Bishop 's Position",
        "Category": "Math"
    },
    {
        "ID": "11681-11681",
        "Code": "mod = 1000000007 NEW_LINE arr = [ 0 ] * ( 1000001 ) NEW_LINE def cal_factorial ( ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1000001 ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] * i ) % mod NEW_LINE DEDENT DEDENT def mod_exponent ( num , p ) : NEW_LINE INDENT if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p & 1 ) : NEW_LINE INDENT return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p // 2 ) ) % mod ) % mod NEW_LINE DEDENT elif ( not ( p & 1 ) ) : NEW_LINE INDENT return ( mod_exponent ( ( num * num ) % mod , p // 2 ) ) % mod NEW_LINE DEDENT DEDENT def getCount ( x , y ) : NEW_LINE INDENT ans = arr [ x + y - 1 ] NEW_LINE ans *= mod_exponent ( arr [ x ] , mod - 2 ) NEW_LINE ans %= mod NEW_LINE ans *= mod_exponent ( arr [ y ] , mod - 2 ) NEW_LINE ans %= mod NEW_LINE ans *= ( x - y ) NEW_LINE ans %= mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT cal_factorial ( ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE print ( getCount ( x , y ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "An application on Bertrand 's ballot theorem | Python3 implementation of the approach ; Function to calculate factorial of a number mod 1000000007 ; Factorial of i = factorial of ( i - 1 ) * i ; Taking mod along with calculation . ; Function for modular exponentiation ; If p is odd ; If p is even ; Function to return the count of required permutations ; Calculating multiplicative modular inverse for x ! and multiplying with ans ; Calculating multiplicative modular inverse for y ! and multiplying with ans ; Driver Code ; Pre - compute factorials",
        "Category": "Math"
    },
    {
        "ID": "11683-11683",
        "Code": "def calculateArea ( x , y ) : NEW_LINE INDENT pi = 3.1415926536 NEW_LINE arx = pi * x * x NEW_LINE ary = pi * y * y NEW_LINE return arx - ary NEW_LINE DEDENT x = 2 NEW_LINE y = 1 NEW_LINE print ( calculateArea ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate the area between two Concentric Circles | Function to find area between the two given concentric circles ; Declare value of pi ; Calculate area of outer circle ; Calculate area of inner circle ; Difference in areas ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11686-11686",
        "Code": "class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def inv_interpolate ( d : list , n : int , y : float ) -> float : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi = d [ i ] . x NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT xi = ( xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ) NEW_LINE DEDENT DEDENT x += xi NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = [ Data ( 1.27 , 2.3 ) , Data ( 2.25 , 2.95 ) , Data ( 2.5 , 3.5 ) , Data ( 3.6 , 5.1 ) ] NEW_LINE n = 4 NEW_LINE y = 4.5 NEW_LINE print ( \" Value ▁ of ▁ x ▁ at ▁ y ▁ = ▁ 4.5 ▁ : \" , round ( inv_interpolate ( d , n , y ) , 5 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to implement Inverse Interpolation using Lagrange Formula | Consider a structure to keep each pair of x and y together ; Function to calculate the inverse interpolation ; Initialize final x ; Calculate each term of the given formula ; Add term to final result ; Driver Code ; Sample dataset of 4 points Here we find the value of x when y = 4.5 ; Size of dataset ; Sample y value ; Using the Inverse Interpolation function to find the value of x when y = 4.5",
        "Category": "Math"
    },
    {
        "ID": "11694-11694",
        "Code": "MAX = 100005 ; NEW_LINE MOD = 1000000007 NEW_LINE def check ( num , a , b ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num = int ( num / 10 ) NEW_LINE if ( rem != a and rem != b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( y ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT ans = ( ans * x ) % MOD NEW_LINE DEDENT y >>= 1 NEW_LINE x = ( x * x ) % MOD NEW_LINE DEDENT return ans % MOD NEW_LINE DEDENT def modInverse ( x ) : NEW_LINE INDENT return power ( x , MOD - 2 ) NEW_LINE DEDENT def countNumbers ( n , a , b ) : NEW_LINE INDENT fact = [ 0 for i in range ( MAX ) ] NEW_LINE inv = [ 0 for i in range ( MAX ) ] NEW_LINE ans = 0 NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT fact [ i ] = ( 1 * fact [ i - 1 ] * i ) NEW_LINE fact [ i ] %= MOD NEW_LINE DEDENT inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) NEW_LINE i = MAX - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) NEW_LINE inv [ i ] %= MOD NEW_LINE i -= 1 NEW_LINE DEDENT if ( a < b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT for s in range ( n , 9 * n + 1 , 1 ) : NEW_LINE INDENT if ( check ( s , a , b ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s < n * b or ( s - n * b ) % ( a - b ) != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT numDig = int ( ( s - n * b ) / ( a - b ) ) NEW_LINE if ( numDig > n ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = fact [ n ] NEW_LINE curr = ( curr * inv [ numDig ] ) % MOD NEW_LINE curr = ( curr * inv [ n - numDig ] ) % MOD NEW_LINE ans = ( ans + curr ) % MOD NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE a = 1 NEW_LINE b = 3 NEW_LINE print ( countNumbers ( n , a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Numbers of Length N having digits A and B and whose sum of digits contain only digits A and B | Python 3 implementation of the approach ; Function that returns true if the num contains a and b digits only ; Modular Exponentiation ; Function to return the modular inverse of x modulo MOD ; Function to return the required count of numbers ; Generating factorials of all numbers ; Generating inverse of factorials modulo MOD of all numbers ; Keeping a as largest number ; Iterate over all possible values of s and if it is a valid S then proceed further ; Check for invalid cases in the equation ; Find answer using combinatorics ; Add this result to final answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11700-11700",
        "Code": "from math import * NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize the value of x + y + z such that ax + by + cz = n | Python3 implementation of the approach ; Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "11701-11701",
        "Code": "def digitsCount ( n ) : NEW_LINE INDENT length = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT length += 1 ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT def absoluteFirstLast ( n , x ) : NEW_LINE INDENT i = 0 ; NEW_LINE mod = 1 ; NEW_LINE while ( i < x ) : NEW_LINE INDENT mod *= 10 ; NEW_LINE i += 1 ; NEW_LINE DEDENT last = n % mod ; NEW_LINE length = digitsCount ( n ) ; NEW_LINE while ( length != x ) : NEW_LINE INDENT n //= 10 ; NEW_LINE length -= 1 ; NEW_LINE DEDENT first = n ; NEW_LINE return abs ( first - last ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 21546 ; NEW_LINE x = 2 ; NEW_LINE print ( absoluteFirstLast ( n , x ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Absolute difference between the first X and last X Digits of N | Function to find the number of digits in the integer ; Function to find the absolute difference ; Store the last x digits in last ; Count the no . of digits in N ; Remove the digits except the first x ; Store the first x digits in first ; Return the absolute difference between the first and last ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11721-11721",
        "Code": "def midptellipse ( rx , ry , xc , yc ) : NEW_LINE INDENT x = 0 ; NEW_LINE y = ry ; NEW_LINE d1 = ( ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ) ; NEW_LINE dx = 2 * ry * ry * x ; NEW_LINE dy = 2 * rx * rx * y ; NEW_LINE while ( dx < dy ) : NEW_LINE INDENT print ( \" ( \" , x + xc , \" , \" , y + yc , \" ) \" ) ; NEW_LINE print ( \" ( \" , - x + xc , \" , \" , y + yc , \" ) \" ) ; NEW_LINE print ( \" ( \" , x + xc , \" , \" , - y + yc , \" ) \" ) ; NEW_LINE print ( \" ( \" , - x + xc , \" , \" , - y + yc , \" ) \" ) ; NEW_LINE if ( d1 < 0 ) : NEW_LINE INDENT x += 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE d1 = d1 + dx + ( ry * ry ) ; NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 ; NEW_LINE y -= 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d1 = d1 + dx - dy + ( ry * ry ) ; NEW_LINE DEDENT DEDENT d2 = ( ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ) ; NEW_LINE while ( y >= 0 ) : NEW_LINE INDENT print ( \" ( \" , x + xc , \" , \" , y + yc , \" ) \" ) ; NEW_LINE print ( \" ( \" , - x + xc , \" , \" , y + yc , \" ) \" ) ; NEW_LINE print ( \" ( \" , x + xc , \" , \" , - y + yc , \" ) \" ) ; NEW_LINE print ( \" ( \" , - x + xc , \" , \" , - y + yc , \" ) \" ) ; NEW_LINE if ( d2 > 0 ) : NEW_LINE INDENT y -= 1 ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d2 = d2 + ( rx * rx ) - dy ; NEW_LINE DEDENT else : NEW_LINE INDENT y -= 1 ; NEW_LINE x += 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d2 = d2 + dx - dy + ( rx * rx ) ; NEW_LINE DEDENT DEDENT DEDENT midptellipse ( 10 , 15 , 50 , 50 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Midpoint ellipse drawing algorithm | Python3 program for implementing Mid - Point Ellipse Drawing Algorithm ; Initial decision parameter of region 1 ; For region 1 ; Print points based on 4 - way symmetry ; Checking and updating value of decision parameter based on algorithm ; Decision parameter of region 2 ; Plotting points of region 2 ; printing points based on 4 - way symmetry ; Checking and updating parameter value based on algorithm ; To draw a ellipse of major and minor radius 15 , 10 centred at ( 50 , 50 )",
        "Category": "Math"
    },
    {
        "ID": "11728-11728",
        "Code": "def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return \" Not ▁ Possible \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Angle = 45 NEW_LINE print ( secondary_polygon ( Angle ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of sides of largest and smallest child polygons possible from a given polygon | Function to find the sum of largest and smallest secondary polygons if possible ; Count edges of primary polygon ; Calculate edges present in the largest secondary polygon ; Driver Code ; Given Exterior Angle",
        "Category": "Math"
    },
    {
        "ID": "11732-11732",
        "Code": "import math as mt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def coPrime ( n1 , n2 ) : NEW_LINE INDENT if ( gcd ( n1 , n2 ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def largestCoprime ( N ) : NEW_LINE INDENT half = mt . floor ( N / 2 ) NEW_LINE while ( coPrime ( N , half ) == False ) : NEW_LINE INDENT half -= 1 NEW_LINE DEDENT return half NEW_LINE DEDENT n = 50 NEW_LINE print ( largestCoprime ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest number less than or equal to N / 2 which is coprime to N | Python3 implementation of the above approacdh ; Function to calculate gcd of two number ; Function to check if two numbers are coprime or not ; two numbers are coprime if their gcd is 1 ; Function to find largest integer less than or equal to N / 2 and coprime with N ; Check one by one a numbers less than or equal to N / 2 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11739-11739",
        "Code": "def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( sum ( 8 ) ) NEW_LINE print ( sum ( 10 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find sum of harmonic series | Python program to find sum of harmonic series using recursion ; Base condition ; Driven Code",
        "Category": "Recursion is used to calculate the sum of the harmonic series, where each term is defined as `1/n` and the sum is computed by successively adding terms from `n` down to `1`. The function calls itself with a decremented"
    },
    {
        "ID": "11740-11740",
        "Code": "import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) / abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of P terms of an AP if Mth and Nth terms are given | Python3 implementation of the above approach ; Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the Sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11753-11753",
        "Code": "def CPwithProfit ( sellingPrice , profit ) : NEW_LINE INDENT costPrice = ( ( sellingPrice * 100.0 ) / ( 100 + profit ) ) NEW_LINE return costPrice NEW_LINE DEDENT def CPwithLoss ( sellingPrice , loss ) : NEW_LINE INDENT costPrice = ( ( sellingPrice * 100.0 ) / ( 100 - loss ) ) NEW_LINE return costPrice NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT SP = 1020 NEW_LINE profit = 20 NEW_LINE print ( \" Cost ▁ Price ▁ = \" , CPwithProfit ( SP , profit ) ) NEW_LINE SP = 900 NEW_LINE loss = 10 NEW_LINE print ( \" Cost ▁ Price ▁ = \" , CPwithLoss ( SP , loss ) ) NEW_LINE SP = 42039 NEW_LINE profit = 8 NEW_LINE print ( \" Cost ▁ Price ▁ = \" , int ( CPwithProfit ( SP , profit ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find cost price from given selling price and profit or loss percentage | Function to calculate cost price with profit ; required formula to calculate CP with profit ; Function to calculate cost price with loss ; required formula to calculate CP with loss ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11755-11755",
        "Code": "def updateMatrix ( n , q , mat ) : NEW_LINE INDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT X1 = q [ i ] [ 0 ] ; NEW_LINE Y1 = q [ i ] [ 1 ] ; NEW_LINE X2 = q [ i ] [ 2 ] ; NEW_LINE Y2 = q [ i ] [ 3 ] ; NEW_LINE mat [ X1 ] [ Y1 ] = mat [ X1 ] [ Y1 ] + 1 ; NEW_LINE if ( Y2 + 1 < n ) : NEW_LINE INDENT mat [ X2 ] [ Y2 + 1 ] = mat [ X2 ] [ Y2 + 1 ] - 1 ; NEW_LINE DEDENT elif ( X2 + 1 < n ) : NEW_LINE INDENT mat [ X2 + 1 ] [ 0 ] = mat [ X2 + 1 ] [ 0 ] - 1 ; NEW_LINE DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mat [ i ] [ j ] ; NEW_LINE print ( sum , end = ' ▁ ' ) ; NEW_LINE DEDENT print ( \" ▁ \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE mat = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] ; NEW_LINE q = [ [ 0 , 0 , 1 , 2 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 4 , 3 , 4 ] ] ; NEW_LINE updateMatrix ( n , q , mat ) ; NEW_LINE",
        "Type": "py",
        "NL": "Print matrix after applying increment operations in M ranges | Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Size of the matrix ; Queries",
        "Category": "Matrix"
    },
    {
        "ID": "11756-11756",
        "Code": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def replaceMax ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE ranges = max_element - min_element NEW_LINE coeffOfRange = ranges / ( max_element + min_element ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT arr [ i ] = coeffOfRange NEW_LINE break NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE replaceMax ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Replace the maximum element in the array by coefficient of range | Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the array ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinct . Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11757-11757",
        "Code": "from math import sqrt NEW_LINE def isNonHypotenuse ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( i - 1 ) % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 and ( n - 1 ) % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def test ( n ) : NEW_LINE INDENT print ( \" Testing ▁ for \" , n , \" : \" , end = \" ▁ \" ) NEW_LINE if ( isNonHypotenuse ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 11 NEW_LINE test ( n ) NEW_LINE n = 10 NEW_LINE test ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a number is Non | Python3 program to check if a given number is Non - Hypotenuse number or not . ; Function to find prime factor and check if it is of the form 4 k + 1 or not ; 2 is a prime number but not of the form 4 k + 1 so , keep Dividing n by 2 until n is divisible by 2 ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; if i divides n check if i is of the form 4 k + 1 or not ; while i divides n divide n by i and update n ; This condition is to handle the case when n is a prime number greater than 2 ; Test function ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11759-11759",
        "Code": "def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B = 10 , 15 NEW_LINE divide ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Divide the two given numbers by their common divisors | print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors",
        "Category": "Math"
    },
    {
        "ID": "11760-11760",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a // n NEW_LINE b = b // n NEW_LINE print ( \" A ▁ = \" , a , \" , ▁ B ▁ = \" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Divide the two given numbers by their common divisors | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input eger numbers ; find gcd of a , b ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11765-11765",
        "Code": "def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) ; NEW_LINE return round ( ans , 9 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p , q , r , s = 1 , 2 , 1 , 2 NEW_LINE print ( find_probability ( p , q , r , s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find probability that a player wins when probabilities of hitting the target are given | Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point",
        "Category": "Math"
    },
    {
        "ID": "11768-11768",
        "Code": "def FindAllElements ( n , k ) : NEW_LINE INDENT sum = k NEW_LINE A = [ 1 for i in range ( k ) ] NEW_LINE i = k - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( sum + A [ i ] <= n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE A [ i ] *= 2 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , k , 1 ) : NEW_LINE INDENT print ( A [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 6 NEW_LINE FindAllElements ( n , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Represent n as the sum of exactly k powers of two | Set 2 | Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "11771-11771",
        "Code": "def isPerfectSquare ( x ) : NEW_LINE INDENT left = 1 NEW_LINE right = x NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) >> 1 NEW_LINE if ( ( mid * mid ) == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( mid * mid < x ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 2500 NEW_LINE if ( isPerfectSquare ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number is perfect square without finding square root | Program to find if x is a perfect square . ; Check if mid is perfect square ; Mid is small -> go right to increase mid ; Mid is large -> to left to decrease mid ; Driver code ; Function Call",
        "Category": "Binary Search"
    },
    {
        "ID": "11780-11780",
        "Code": "n = 100002 ; NEW_LINE phi = [ 0 ] * ( n + 2 ) ; NEW_LINE ans = [ 0 ] * ( n + 2 ) ; NEW_LINE def ETF ( ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ i ] == i ) : NEW_LINE INDENT phi [ i ] = i - 1 ; NEW_LINE for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT phi [ j ] = ( phi [ j ] * ( i - 1 ) ) // i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def LcmSum ( m ) : NEW_LINE INDENT ETF ( ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT ans [ j ] += ( i * phi [ i ] ) ; NEW_LINE DEDENT DEDENT answer = ans [ m ] ; NEW_LINE answer = ( answer + 1 ) * m ; NEW_LINE answer = answer // 2 ; NEW_LINE return answer ; NEW_LINE DEDENT m = 5 ; NEW_LINE print ( LcmSum ( m ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Sum of LCM ( 1 , n ) , LCM ( 2 , n ) , LCM ( 3 , n ) , ... , LCM ( n , n ) | Python3 implementation of the approach ; Euler totient Function ; Function to return the required LCM sum ; Summation of d * ETF ( d ) where d belongs to set of divisors of n ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11784-11784",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findPossibleDerivables ( arr , n , D , A , B ) : NEW_LINE INDENT gcdAB = gcd ( A , B ) NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE D , A , B = 5 , 4 , 2 NEW_LINE print ( findPossibleDerivables ( arr , n , D , A , B ) ) NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE D , A , B = 6 , 3 , 2 NEW_LINE print ( findPossibleDerivables ( a , n , D , A , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of array elements derivable from D after performing certain operations | Function to return gcd of a and b ; Function to Return the number of elements of arr [ ] which can be derived from D by performing ( + A , - A , + B , - B ) ; find the gcd of A and B ; counter stores the number of array elements which can be derived from D ; arr [ i ] can be derived from D only if | arr [ i ] - D | is divisible by gcd of A and B ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11794-11794",
        "Code": "def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the sum of distinct digits of two integers are equal | Function to return the sum of distinct digits of a number ; Take last digit ; If digit has not been used before ; Set digit as used ; Remove last digit ; Function to check whether the sum of distinct digits of two numbers are equal ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11799-11799",
        "Code": "from collections import defaultdict NEW_LINE MAXN = 1000001 NEW_LINE MAXN_sqrt = int ( MAXN ** ( 0.5 ) ) NEW_LINE spf = [ None ] * ( MAXN ) NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN_sqrt ) : NEW_LINE INDENT if spf [ i ] == i : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if spf [ j ] == j : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def sumFactors ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE Map = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Map [ arr [ i ] ] = 1 NEW_LINE DEDENT Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE while num != 1 and Map [ spf [ num ] ] == 1 : NEW_LINE INDENT num = num // spf [ num ] NEW_LINE DEDENT if num == 1 : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 11 , 55 , 25 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumFactors ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of element whose prime factors are present in array | Python program to find the sum of the elements of an array whose prime factors are present in the same array ; Stores smallest prime factor for every number ; Function to calculate SPF ( Smallest Prime Factor ) for every number till MAXN ; Marking smallest prime factor for every number to be itself . ; Separately marking spf for every even number as 2 ; If i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function to return the sum of the elements of an array whose prime factors are present in the same array ; Function call to calculate smallest prime factors of all the numbers upto MAXN ; Create map for each element ; If smallest prime factor of num is present in array ; Each factor of arr [ i ] is present in the array ; Driver Code ; Function call to print required answer",
        "Category": "Math"
    },
    {
        "ID": "11802-11802",
        "Code": "from math import pow NEW_LINE def doubleFactorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def hermiteNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT number = ( ( pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ) NEW_LINE if ( ( n / 2 ) % 2 == 1 ) : NEW_LINE INDENT number = number * - 1 NEW_LINE DEDENT return number NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( int ( hermiteNumber ( n ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find nth Hermite number | Python 3 program to find nth Hermite number ; Utility function to calculate double factorial of a number ; Function to return nth Hermite number ; If n is even then return 0 ; If n is odd ; Calculate double factorial of ( n - 1 ) and multiply it with 2 ^ ( n / 2 ) ; If n / 2 is odd then nth Hermite number will be negative ; Return nth Hermite number ; Driver Code ; Print nth Hermite number",
        "Category": "Math"
    },
    {
        "ID": "11803-11803",
        "Code": "from bisect import bisect as upper_bound NEW_LINE from bisect import bisect_left as lower_bound NEW_LINE from math import floor NEW_LINE N = 1000005 NEW_LINE MAX = 10 ** 18 NEW_LINE powers = [ ] NEW_LINE squares = dict ( ) NEW_LINE s = dict ( ) NEW_LINE def powersPrecomputation ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT squares [ i * i ] = 1 NEW_LINE if ( i not in squares . keys ( ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = i NEW_LINE while ( i * i <= ( MAX // temp ) ) : NEW_LINE INDENT temp *= ( i * i ) NEW_LINE s [ temp ] = 1 NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT powers . append ( x ) NEW_LINE DEDENT DEDENT def calculateAnswer ( L , R ) : NEW_LINE INDENT powersPrecomputation ( ) NEW_LINE perfectSquares = floor ( ( R ) ** ( .5 ) ) - floor ( ( L - 1 ) ** ( .5 ) ) NEW_LINE high = upper_bound ( powers , R ) NEW_LINE low = lower_bound ( powers , L ) NEW_LINE perfectPowers = perfectSquares + ( high - low ) NEW_LINE ans = ( R - L + 1 ) - perfectPowers NEW_LINE return ans NEW_LINE DEDENT L = 13 NEW_LINE R = 20 NEW_LINE print ( calculateAnswer ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers in a range having GCD of powers of prime factors equal to 1 | Python3 implementation of the approach ; Vector to store powers greater than 3 ; Set to store perfect squares ; Set to store powers other than perfect squares ; Pushing squares ; if the values is already a perfect square means present in the set ; Run loop until some power of current number doesn 't exceed MAX ; Pushing only odd powers as even power of a number can always be expressed as a perfect square which is already present in set squares ; Inserting those sorted values of set into a vector ; Precompute the powers ; Calculate perfect squares in range using sqrtl function ; Calculate upper value of R in vector using binary search ; Calculate lower value of L in vector using binary search ; Calculate perfect powers ; Compute final answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11808-11808",
        "Code": "def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of integers upto N with given unit digit | Function to return the required sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11809-11809",
        "Code": "from math import sqrt , floor NEW_LINE def isPerfect ( N ) : NEW_LINE INDENT if ( sqrt ( N ) - floor ( sqrt ( N ) ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def getClosestPerfectSquare ( N ) : NEW_LINE INDENT if ( isPerfect ( N ) ) : NEW_LINE INDENT print ( N , \"0\" ) NEW_LINE return NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = 0 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE if ( diff1 > diff2 ) : NEW_LINE INDENT print ( belowN , diff2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( aboveN , diff1 ) NEW_LINE DEDENT DEDENT N = 1500 NEW_LINE getClosestPerfectSquare ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Closest perfect square and its distance | Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11812-11812",
        "Code": "def printThreeParts ( N ) : NEW_LINE INDENT if ( N % 3 == 0 ) : NEW_LINE INDENT print ( \" ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ \" , N - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ \" , N - 3 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE printThreeParts ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split a number into 3 parts such that none of the parts is divisible by 3 | Python3 program to split a number into three parts such than none of them is divisible by 3. ; Print x = 1 , y = 1 and z = N - 2 ; Otherwise , print x = 1 , y = 2 and z = N - 3 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11820-11820",
        "Code": "from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT k = int ( sqrt ( N ) ) + 1 NEW_LINE for i in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def getDifference ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( isPrime ( N ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( getDifference ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum absolute difference of a number and its closest prime | Python 3 program to find the minimum absolute difference between a number and its closest prime ; Function to check if a number is prime or not ; Function to find the minimum absolute difference between a number and its closest prime ; Variables to store first prime above and below N ; Finding first prime number greater than N ; Finding first prime number less than N ; Variables to store the differences ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11834-11834",
        "Code": "from collections import defaultdict NEW_LINE def NCR ( n , r ) : NEW_LINE INDENT numerator = 1 NEW_LINE denominator = 1 NEW_LINE while ( r > 0 ) : NEW_LINE INDENT numerator *= n NEW_LINE denominator *= r NEW_LINE n -= 1 NEW_LINE r -= 1 NEW_LINE DEDENT return ( numerator // denominator ) NEW_LINE DEDENT def findWays ( arr , n ) : NEW_LINE INDENT count = defaultdict ( int ) NEW_LINE if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT remaining_choices = 4 NEW_LINE ans = 1 NEW_LINE for it in reversed ( sorted ( count . keys ( ) ) ) : NEW_LINE INDENT number = it NEW_LINE frequency = count [ it ] NEW_LINE toSelect = min ( remaining_choices , frequency ) NEW_LINE ans = ans * NCR ( frequency , toSelect ) NEW_LINE remaining_choices -= toSelect NEW_LINE if ( not remaining_choices ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE maxQuadrupleWays = findWays ( arr , n ) NEW_LINE print ( maxQuadrupleWays ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Number of Maximum Product Quadruples | Python3 program to find the number of Quadruples having maximum product ; Returns the number of ways to select r objects out of available n choices ; ncr = ( n * ( n - 1 ) * ( n - 2 ) * ... . . ... ( n - r + 1 ) ) / ( r * ( r - 1 ) * ... * 1 ) ; Returns the number of quadruples having maximum product ; stores the frequency of each element ; remaining_choices denotes the remaining elements to select inorder to form quadruple ; traverse the elements of the map in reverse order ; If Frequency of element < remaining choices , select all of these elements , else select only the number of elements required ; Decrement remaining_choices acc to the number of the current elements selected ; if the quadruple is formed stop the algorithm ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "11841-11841",
        "Code": "import math NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * ( math . log ( b ) ) ; NEW_LINE y = b * ( math . log ( a ) ) ; NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( \" a ^ b ▁ is ▁ greater \" ) ; NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( \" b ^ a ▁ is ▁ greater \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Both ▁ are ▁ equal \" ) ; NEW_LINE DEDENT DEDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE c = 2 ; NEW_LINE d = 4 ; NEW_LINE findGreater ( a , b ) ; NEW_LINE findGreater ( c , d ) ; NEW_LINE",
        "Type": "py",
        "NL": "Larger of a ^ b or b ^ a ( a raised to power b or b raised to power a ) | Python 3 code for finding greater between the a ^ b and b ^ a ; Function to find the greater value ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11846-11846",
        "Code": "from math import gcd NEW_LINE def startingPoint ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result1 = 0 NEW_LINE result2 = 0 NEW_LINE time1 = Length // Speed1 NEW_LINE time2 = Length // Speed2 NEW_LINE result1 = gcd ( time1 , time2 ) NEW_LINE result2 = time1 * time2 // ( result1 ) NEW_LINE return result2 NEW_LINE DEDENT def firstTime ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result = 0 NEW_LINE relativeSpeed = abs ( Speed1 - Speed2 ) NEW_LINE result = Length / relativeSpeed NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 30 NEW_LINE S1 = 5 NEW_LINE S2 = 2 NEW_LINE first_Time = firstTime ( L , S1 , S2 ) NEW_LINE starting_Point = startingPoint ( L , S1 , S2 ) NEW_LINE print ( \" Met ▁ first ▁ time ▁ after \" , first_Time , \" hrs \" ) NEW_LINE print ( \" Met ▁ at ▁ starting ▁ point ▁ after \" , starting_Point , \" hrs \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Time taken by two persons to meet on a circular track | Python 3 implementation of above approach ; Function to return the time when both the persons will meet at the starting point ; Time to cover 1 round by both ; Finding LCM to get the meeting point ; Function to return the time when both the persons will meet for the first time ; Driver Code ; Calling function",
        "Category": "Math"
    },
    {
        "ID": "11847-11847",
        "Code": "def sumOfDigits ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT res += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findNumber ( n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 824 ; NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest number less than N with digit sum greater than the digit sum of N | Function to return the sum of the digits of n ; Loop for each digit of the number ; Function to return the greatest number less than n such that the sum of its digits is greater than the sum of the digits of n ; Starting from n - 1 ; Check until 1 ; If i satisfies the given condition ; If the condition is not satisfied ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11852-11852",
        "Code": "def getNumber ( s ) : NEW_LINE INDENT number_of_digits = len ( s ) ; NEW_LINE freq = [ 0 ] * 10 ; NEW_LINE for i in range ( number_of_digits ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '2' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '4' ) : NEW_LINE INDENT freq [ 2 ] += 2 ; NEW_LINE freq [ 3 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '6' ) : NEW_LINE INDENT freq [ 5 ] += 1 ; NEW_LINE freq [ 3 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '8' ) : NEW_LINE INDENT freq [ 7 ] += 1 ; NEW_LINE freq [ 2 ] += 3 ; NEW_LINE DEDENT if ( s [ i ] == '9' ) : NEW_LINE INDENT freq [ 7 ] += 1 ; NEW_LINE freq [ 3 ] += 2 ; NEW_LINE freq [ 2 ] += 1 ; NEW_LINE DEDENT DEDENT t = \" \" ; NEW_LINE if ( freq [ 1 ] == number_of_digits or freq [ 0 ] == number_of_digits or ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) : NEW_LINE INDENT return s ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT ctr = freq [ i ] ; NEW_LINE while ( ctr > 0 ) : NEW_LINE INDENT t += chr ( i + 48 ) ; NEW_LINE ctr -= 1 ; NEW_LINE DEDENT DEDENT return t ; NEW_LINE DEDENT DEDENT s = \"1280\" ; NEW_LINE print ( getNumber ( s ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Maximum number with same digit factorial product | Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "11853-11853",
        "Code": "def reversedigit ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def icanobifNumbers ( N ) : NEW_LINE INDENT first = 0 NEW_LINE second = 1 NEW_LINE if N == 1 : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT print ( first , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( first , second , end = \" ▁ \" ) NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT x = reversedigit ( first ) NEW_LINE y = reversedigit ( second ) NEW_LINE print ( x + y , end = \" ▁ \" ) NEW_LINE temp = second NEW_LINE second = x + y NEW_LINE first = temp NEW_LINE DEDENT DEDENT DEDENT N = 12 NEW_LINE icanobifNumbers ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find first N Iccanobif Numbers | Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11856-11856",
        "Code": "N = 4 NEW_LINE def predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i > 0 and arr [ i - 1 ] [ j ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j > 0 and arr [ i ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i > 0 and j > 0 and arr [ i - 1 ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and arr [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j < N - 1 and arr [ i ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and j < N - 1 and arr [ i + 1 ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and j > 0 and arr [ i + 1 ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i > 0 and j < N - 1 and arr [ i - 1 ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT if ( c >= range1a and c <= range1b ) : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT if ( c >= range0a and c <= range0b ) : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT K -= 1 NEW_LINE for k in range ( N ) : NEW_LINE INDENT for m in range ( N ) : NEW_LINE INDENT arr [ k ] [ m ] = b [ k ] [ m ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 ] ] NEW_LINE range1a = 2 NEW_LINE range1b = 2 NEW_LINE range0a = 2 NEW_LINE range0b = 3 NEW_LINE K = 3 NEW_LINE b = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT print ( b [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Problem of 8 Neighbours of an element in a 2 | Dimension of Array ; Count of 1 s ; Counting all neighbouring 1 s ; Comparing the number of neighbouring 1 s with given ranges ; Copying changes to the main matrix ; Driver code ; Function call to calculate the resultant matrix after ' K ' iterations . ; Printing Result",
        "Category": "Matrix"
    },
    {
        "ID": "11862-11862",
        "Code": "from math import floor NEW_LINE def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum = sum + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE N = floor ( n / 2 ) NEW_LINE for base in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT sum = sum + solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of the digits of a number N written in all bases from 2 to N / 2 | Python 3 implementation of the approach ; Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in bases from 2 to n / 2 ; to store digit sum in all base ; function call for multiple bases ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "11872-11872",
        "Code": "def isDivisibleRec ( x , a , b , n ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( isDivisibleRec ( x * 10 + a , a , b , n ) or isDivisibleRec ( x * 10 + b , a , b , n ) ) NEW_LINE DEDENT def isDivisible ( a , b , n ) : NEW_LINE ' NEW_LINE INDENT return ( isDivisibleRec ( a , a , b , n ) or isDivisibleRec ( b , a , b , n ) ) NEW_LINE DEDENT a = 3 ; b = 5 ; n = 53 ; NEW_LINE if ( isDivisible ( a , b , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if N is divisible by a number which is composed of the digits from the set { A , B } | Function to check whether n is divisible by a number whose digits are either a or b ; base condition ; recursive call ; Check for all numbers beginning with ' a ' or 'b ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "11874-11874",
        "Code": "def MinSteps ( SourceX , SourceY , DestX , DestY ) : NEW_LINE INDENT print ( max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) ) NEW_LINE while ( ( SourceX != DestX ) or ( SourceY != DestY ) ) : NEW_LINE INDENT if ( SourceX < DestX ) : NEW_LINE INDENT print ( ' U ' , end = \" \" ) NEW_LINE SourceX += 1 NEW_LINE DEDENT if ( SourceX > DestX ) : NEW_LINE INDENT print ( ' D ' , end = \" \" ) NEW_LINE SourceX -= 1 NEW_LINE DEDENT if ( SourceY > DestY ) : NEW_LINE INDENT print ( ' L ' ) NEW_LINE SourceY -= 1 NEW_LINE DEDENT if ( SourceY < DestY ) : NEW_LINE INDENT print ( ' R ' , end = \" \" ) NEW_LINE SourceY += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sourceX = 4 NEW_LINE sourceY = 4 NEW_LINE destinationX = 7 NEW_LINE destinationY = 0 NEW_LINE MinSteps ( sourceX , sourceY , destinationX , destinationY ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of moves required to reach the destination by the king in a chess board | function to Find the minimum number of moves required to reach the destination by the king in a chess board ; minimum number of steps ; while the king is not in the same row or column as the destination ; Go up ; Go down ; Go left ; Go right ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11892-11892",
        "Code": "import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE if res != 0 : NEW_LINE res = math . ceil ( exp / earn ) NEW_LINE else : NEW_LINE res = float ( ' inf ' ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Break Even Point | Python 3 program to find Break Even Point ; Function to calculate Break Even Point ; Calculating number of articles to be sold ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "119-119",
        "Code": "preIndex = 0 NEW_LINE class node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def search ( arr , strt , end , value ) : NEW_LINE INDENT for i in range ( strt , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == value ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT def buildTree ( inn , pre , inStrt , inEnd ) : NEW_LINE INDENT global preIndex NEW_LINE if ( inStrt > inEnd ) : NEW_LINE INDENT return None NEW_LINE DEDENT tNode = node ( pre [ preIndex ] ) NEW_LINE preIndex += 1 NEW_LINE if ( inStrt == inEnd ) : NEW_LINE INDENT return tNode NEW_LINE DEDENT inIndex = search ( inn , inStrt , inEnd , tNode . data ) NEW_LINE tNode . left = buildTree ( inn , pre , inStrt , inIndex - 1 ) NEW_LINE tNode . right = buildTree ( inn , pre , inIndex + 1 , inEnd ) NEW_LINE return tNode NEW_LINE DEDENT def checkPostorder ( node , postOrder , index ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return index NEW_LINE DEDENT index = checkPostorder ( node . left , postOrder , index ) NEW_LINE index = checkPostorder ( node . right , postOrder , index ) NEW_LINE if ( node . data == postOrder [ index ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return index NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inOrder = [ 4 , 2 , 5 , 1 , 3 ] NEW_LINE preOrder = [ 1 , 2 , 4 , 5 , 3 ] NEW_LINE postOrder = [ 4 , 5 , 2 , 3 , 1 ] NEW_LINE lenn = len ( inOrder ) NEW_LINE root = buildTree ( inOrder , preOrder , 0 , lenn - 1 ) NEW_LINE index = checkPostorder ( root , postOrder , 0 ) NEW_LINE if ( index == lenn ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given Preorder , Inorder and Postorder traversals are of same tree | Python3 program to check if all three given traversals are of the same tree ; A Binary Tree Node ; Function to find index of value in arr [ start ... end ] . The function assumes that value is present in in ; Recursive function to construct binary tree of size lenn from Inorder traversal in and Preorder traversal pre [ ] . Initial values of inStrt and inEnd should be 0 and lenn - 1. The function doesn 't do any error checking for cases where inorder and preorder do not form a tree ; Pick current node from Preorder traversal using preIndex and increment preIndex ; If this node has no children then return ; Else find the index of this node in Inorder traversal ; Using index in Inorder traversal , construct left and right subtress ; function to compare Postorder traversal on constructed tree and given Postorder ; first recur on left child ; now recur on right child ; Compare if data at current index in both Postorder traversals are same ; Driver code ; build tree from given Inorder and Preorder traversals ; compare postorder traversal on constructed tree with given Postorder traversal ; If both postorder traversals are same",
        "Category": "Binary Tree"
    },
    {
        "ID": "11900-11900",
        "Code": "from math import gcd , sqrt NEW_LINE def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * d / 2 NEW_LINE DEDENT def sumMultiples ( A , B , n ) : NEW_LINE INDENT n -= 1 NEW_LINE common = int ( ( A * B ) / gcd ( A , B ) ) NEW_LINE return ( sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 NEW_LINE A = 5 NEW_LINE B = 10 NEW_LINE print ( \" Sum ▁ = \" , int ( sumMultiples ( A , B , n ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of multiples of A and B less than N | Python 3 program to find the sum of all multiples of A and B below N ; Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of A and B below N ; Since , we need the sum of multiples less than N ; common factors of A and B ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11903-11903",
        "Code": "from math import sqrt NEW_LINE def contiguousPerfectSquare ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT b = sqrt ( arr [ i ] ) NEW_LINE a = int ( b ) NEW_LINE if ( a == b ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 75 , 4 , 64 , 121 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( contiguousPerfectSquare ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest sub | Python 3 program to find the length of the largest sub - array of an array every element of whose is a perfect square ; function to return the length of the largest sub - array of an array every element of whose is a perfect square ; if both a and b are equal then arr [ i ] is a perfect square ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "11904-11904",
        "Code": "def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp /= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp /= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp /= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Check if a number is formed by Concatenation of 1 , 14 or 144 only | Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "11907-11907",
        "Code": "def getIndex ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ptrL = 0 NEW_LINE ptrR = n - 1 NEW_LINE sumL = a [ 0 ] NEW_LINE sumR = a [ n - 1 ] NEW_LINE while ( ptrR - ptrL > 1 ) : NEW_LINE INDENT if ( sumL < sumR ) : NEW_LINE INDENT ptrL += 1 NEW_LINE sumL += a [ ptrL ] NEW_LINE DEDENT elif ( sumL > sumR ) : NEW_LINE INDENT ptrR -= 1 NEW_LINE sumR += a [ ptrR ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ptrL NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 7 , 9 , 8 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( getIndex ( a , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the index of the left pointer after possible moves in the array | Function that returns the index of the left pointer ; there 's only one element  in the array ; initially both are at end ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "11910-11910",
        "Code": "def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( \"1 / \" , end = \" \" ) NEW_LINE print ( calcFunction ( n , r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the value of f ( n ) / f ( r ) * f ( n | Function to find value of given F ( n ) ; iterate over n ; calculate result ; return the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11916-11916",
        "Code": "from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( \" a ▁ = \" , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( \" b ▁ = \" , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find two numbers with sum and product both same as N | Python 3 program to find a and b such that a * b = N and a + b = N ; Function to return the smallest string ; Not possible ; find a and b ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11919-11919",
        "Code": "def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m // 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last // divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) // first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Steps to reduce N to zero by subtracting its most significant digit at every step | Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11922-11922",
        "Code": "def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( \" No ▁ Profit ▁ nor ▁ Loss \" ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0.0 NEW_LINE result = float ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( \" Loss ▁ = ▁ - \" , ' { 0 : . 6 } ' . format ( result * 100 ) , \" % \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Profit ▁ = ▁ \" , ' { 0 : . 6 } ' . format ( result * 100 ) , \" % \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE M = 9 NEW_LINE profitLoss ( N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the profit or loss when CP of N items is equal to SP of M items | Function to calculate Profit or loss ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11927-11927",
        "Code": "def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Selling Price from given Profit Percentage and Cost | Function to calculate the Selling Price ; Decimal Equivalent of Profit Percentage ; Find the Selling Price ; return the calculated Selling Price ; Driver code ; Get the CP and Profit % ; Printing the returned value",
        "Category": "Math"
    },
    {
        "ID": "11928-11928",
        "Code": "def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) ; NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 ; NEW_LINE return int ( sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ) ; NEW_LINE DEDENT n = 24 ; NEW_LINE print ( sumMultiples ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Sum of all the multiples of 3 and 7 below N | Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 3 and 7 below N ; Since , we need the sum of multiples less than N ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11934-11934",
        "Code": "def allOddDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( allOddDigits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 23 NEW_LINE print ( largestNumber ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest number not greater than N all the digits of which are odd | Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "11939-11939",
        "Code": "def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE product = 1 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 ) : NEW_LINE INDENT sum += d NEW_LINE product *= d NEW_LINE DEDENT DEDENT print ( \" Sum ▁ = \" , sum ) NEW_LINE print ( \" Product ▁ = \" , product ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1012 NEW_LINE countDigit ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum and Product of digits in a number that divide the number | Print the sum and product of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11941-11941",
        "Code": "def isDivisiblePalindrome ( n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE digitSum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digitSum += n % 10 NEW_LINE hash [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT if ( digitSum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT oddCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 34734 NEW_LINE if ( isDivisiblePalindrome ( n ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if any permutation of a number is divisible by 3 and is Palindromic | Function to check if any permutation of a number is divisible by 3 and is Palindromic ; Hash array to store frequency of digits of n ; traverse the digits of integer and store their frequency ; Calculate the sum of digits simultaneously ; Check if number is not divisible by 3 ; If more than one digits have odd frequency , palindromic permutation not possible ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "11947-11947",
        "Code": "def hasConsecutiveZeroes ( N , K ) : NEW_LINE INDENT z = toK ( N , K ) NEW_LINE if ( check ( z ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT def toK ( N , K ) : NEW_LINE INDENT w = 1 NEW_LINE s = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT r = N % K NEW_LINE N = N // K NEW_LINE s = r * w + s NEW_LINE w * = 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def check ( N ) : NEW_LINE INDENT fl = False NEW_LINE while ( N != 0 ) : NEW_LINE INDENT r = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( fl == True and r == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( r > 0 ) : NEW_LINE INDENT fl = False NEW_LINE continue NEW_LINE DEDENT fl = True NEW_LINE DEDENT return True NEW_LINE DEDENT N , K = 15 , 8 NEW_LINE hasConsecutiveZeroes ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether a number has consecutive 0 's in the given base or not | We first convert to given base , then check if the converted number has two consecutive 0 s or not ; Function to convert N into base K ; Weight of each digit ; Function to check for consecutive 0 ; Flag to check if there are consecutive zero or not ; If there are two consecutive zero then returning False ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11955-11955",
        "Code": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT class Node : NEW_LINE INDENT def __init__ ( self , data , next ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data , self . head ) NEW_LINE self . head = new_node NEW_LINE DEDENT def countPrime ( self ) : NEW_LINE INDENT count = 0 NEW_LINE ptr = self . head NEW_LINE while ptr != None : NEW_LINE INDENT if isPrime ( ptr . data ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT linkedlist = LinkedList ( ) NEW_LINE linkedlist . push ( 17 ) NEW_LINE linkedlist . push ( 10 ) NEW_LINE linkedlist . push ( 6 ) NEW_LINE linkedlist . push ( 5 ) NEW_LINE linkedlist . push ( 15 ) NEW_LINE print ( \" Count ▁ of ▁ prime ▁ nodes ▁ = \" , linkedlist . countPrime ( ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Prime Nodes of a Singly Linked List | Function to check if a number is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Link list node ; Push a new node on the front of the list . ; Function to find count of prime nodes in a linked list ; If current node is prime ; Update count ; Driver Code ; Start with the empty list ; create the linked list 15 -> 5 -> 6 -> 10 -> 17 ; Function call to print require answer",
        "Category": "Linked List"
    },
    {
        "ID": "11963-11963",
        "Code": "def countRabbits ( Heads , Legs ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( Legs ) - 2 * ( Heads ) NEW_LINE count = count / 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Heads = 100 NEW_LINE Legs = 300 NEW_LINE Rabbits = countRabbits ( Heads , Legs ) NEW_LINE print ( \" Rabbits ▁ = \" , Rabbits ) NEW_LINE print ( \" Pigeons ▁ = \" , Heads - Rabbits ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count Number of animals in a zoo from given number of head and legs | Function that calculates Rabbits ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "11966-11966",
        "Code": "def markingScheme ( N , answerKey , studentAnswer ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE notattempt = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( studentAnswer [ i ] == 0 ) : NEW_LINE INDENT notattempt += 1 NEW_LINE DEDENT elif ( answerKey [ i ] == studentAnswer [ i ] ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT elif ( answerKey [ i ] != studentAnswer [ i ] ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * 3 ) + ( negative * - 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT answerKey = [ 1 , 2 , 3 , 4 , 1 ] NEW_LINE studentAnswer = [ 1 , 2 , 3 , 4 , 0 ] NEW_LINE N = 5 NEW_LINE print ( markingScheme ( N , answerKey , studentAnswer ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the total marks obtained according to given marking scheme | Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "11972-11972",
        "Code": "import math NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( math . sqrt ( k ) ) + 1 NEW_LINE i = 2 NEW_LINE while i <= m and k > 1 : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT u = 0 NEW_LINE v = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k //= i NEW_LINE v += 1 NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find maximum value of x such that n ! % ( k ^ x ) = 0 | Python 3 program to maximize the value of x such that n ! % ( k ^ x ) = 0 ; Function to maximize the value of x such that n ! % ( k ^ x ) = 0 ; Find square root of k and add 1 to it ; Run the loop from 2 to m and k should be greater than 1 ; optimize the value of k ; Minimum store ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11976-11976",
        "Code": "import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE DEDENT print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to evaluate the expression ( ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒ ¢ Ã ¢ â ‚¬ Å ¾¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â € š ¬ Ã …¡¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â € š ¬ Ã …¾¢¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒ ¢ Ã ¢ â ‚¬ Å ¾¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒâ €¦¡¬¹ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â € š ¬ Ã …¡¬ ÃƒÆ ’ Ã ¢ â ‚¬¦¡¬ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒ ¢ Ã ¢ â ‚¬ Å ¾¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒâ €¦¡¬¦¡ X + 1 ) ^ 6 + ( ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒ ¢ Ã ¢ â ‚¬ Å ¾¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â € š ¬ Ã …¡¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â € š ¬ Ã …¾¢¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒ ¢ Ã ¢ â ‚¬ Å ¾¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒâ €¦¡¬¹ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â € š ¬ Ã …¡¬ ÃƒÆ ’ Ã ¢ â ‚¬¦¡¬ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢ ÃƒÆ ’ Ã ¢ â ‚¬ Ãƒ ¢ Ã ¢ â € š ¬ Ã ¢ â € ž ¢ ÃƒÆ ’ Ã † â €™ Ãƒ ¢ Ã ¢ â € š ¬ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒ ¢ Ã ¢ â ‚¬ Å ¾¢ ÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒâ €¦¡¬¦¡ X | ''Python3 program to evaluate the given expression ; ''Function to find the sum ; ''Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11985-11985",
        "Code": "def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 32 ; NEW_LINE print ( \" Minimum ▁ value ▁ of ▁ K ▁ is ▁ = \" , countBits ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Minimum numbers needed to express every integer below N as a sum | function to count length of binary expression of n ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "11987-11987",
        "Code": "from math import sqrt , log NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT p = int ( sqrt ( n ) ) + 1 NEW_LINE for factor in range ( 3 , p , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n / factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT def isPower ( a ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = int ( sqrt ( a ) ) + 1 NEW_LINE for i in range ( 2 , a , 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( ( val - int ( val ) ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isAchillesNumber ( n ) : NEW_LINE INDENT if ( isPowerful ( n ) == True and isPower ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 72 NEW_LINE if ( isAchillesNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 36 NEW_LINE if ( isAchillesNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number is an Achilles number or not | Program to check if the given number is an Achilles Number ; function to check if the number is powerful number ; First divide the number repeatedly by 2 ; If only 2 ^ 1 divides n ( not higher powers ) , then return false ; if n is not a power of 2 then this loop will execute repeat above process ; Find highest power of \" factor \" that divides n ; If only factor ^ 1 divides n ( not higher powers ) , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Utility function to check if number is a perfect power or not ; Function to check Achilles Number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "11992-11992",
        "Code": "def isValid ( N , K ) : NEW_LINE INDENT m1 = [ ] NEW_LINE m2 = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT m1 . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT while ( K > 0 ) : NEW_LINE INDENT m2 . append ( K % 10 ) NEW_LINE K //= 10 NEW_LINE DEDENT if ( m1 == m2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def anyPermutation ( N , K ) : NEW_LINE INDENT powK = [ 0 ] * 100 NEW_LINE Limit = pow ( 10 , 18 ) NEW_LINE powK [ 0 ] = K NEW_LINE i = 1 NEW_LINE while ( powK [ i - 1 ] * K < Limit ) : NEW_LINE INDENT powK [ i ] = powK [ i - 1 ] * K NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( isValid ( N , powK [ j ] ) ) : NEW_LINE INDENT return \" True \" NEW_LINE DEDENT DEDENT return \" False \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 96889010407 NEW_LINE K = 7 NEW_LINE print ( anyPermutation ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if any permutation of N equals any power of K | function to check if N and K are anagrams ; Function to check if any permutation of N exist such that it is some power of K ; generate all power of K under 10 ^ 18 ; check if any power of K is valid ; Driver Code ; function call to print required answer",
        "Category": "Hash Table"
    },
    {
        "ID": "1200-1200",
        "Code": "def isChangeable ( notes , n ) : NEW_LINE INDENT fiveCount = 0 NEW_LINE tenCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fiveCount += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fiveCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( fiveCount > 0 and tenCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount -= 1 NEW_LINE DEDENT elif ( fiveCount >= 3 ) : NEW_LINE INDENT fiveCount -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT a = [ 5 , 5 , 5 , 10 , 20 ] NEW_LINE n = len ( a ) NEW_LINE if ( isChangeable ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if X can give change to every person in the Queue | Function to check if every person will get the change from X ; To count the 5 $ and 10 & notes ; Serve the customer in order ; Increase the number of 5 $ note by one ; decrease the number of note 5 $ and increase 10 $ note by one ; decrease 5 $ and 10 $ note by one ; decrease 5 $ note by three ; queue of customers with available notes . ; Calling function",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "12000-12000",
        "Code": "def sumSubarrayMins ( A , n ) : NEW_LINE INDENT left , right = [ None ] * n , [ None ] * n NEW_LINE s1 , s2 = [ ] , [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s1 ) > 0 and s1 [ - 1 ] [ 0 ] > A [ i ] : NEW_LINE INDENT cnt += s1 [ - 1 ] [ 1 ] NEW_LINE s1 . pop ( ) NEW_LINE DEDENT s1 . append ( [ A [ i ] , cnt ] ) NEW_LINE left [ i ] = cnt NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] >= A [ i ] : NEW_LINE INDENT cnt += s2 [ - 1 ] [ 1 ] NEW_LINE s2 . pop ( ) NEW_LINE DEDENT s2 . append ( [ A [ i ] , cnt ] ) NEW_LINE right [ i ] = cnt NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += A [ i ] * left [ i ] * right [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 1 , 2 , 4 ] NEW_LINE n = len ( A ) NEW_LINE print ( sumSubarrayMins ( A , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of minimum elements of all subarrays | Function to return required minimum sum ; getting number of element strictly larger than A [ i ] on Left . ; get elements from stack until element greater than A [ i ] found ; getting number of element larger than A [ i ] on Right . ; get elements from stack until element greater or equal to A [ i ] found ; calculating required resultult ; Driver Code ; function call to get required resultult",
        "Category": "Stack"
    },
    {
        "ID": "12014-12014",
        "Code": "def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_odd_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( \" Even ▁ Sum ▁ Pairs ▁ = \" , even_sum_pairs ) NEW_LINE print ( \" Odd ▁ Sum ▁ Pairs = \" , odd_sum_pairs ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of ordered pairs with Even and Odd Sums | function to count odd sum pair ; if number is even ; if number is odd ; count of ordered pairs ; function to count even sum pair ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12019-12019",
        "Code": "def HexToBin ( hexdec ) : NEW_LINE INDENT for i in hexdec : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT print ( '0000' , end = ' ' ) NEW_LINE DEDENT elif i == '1' : NEW_LINE INDENT print ( '0001' , end = ' ' ) NEW_LINE DEDENT elif i == '2' : NEW_LINE INDENT print ( '0010' , end = ' ' ) NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT print ( '0011' , end = ' ' ) NEW_LINE DEDENT elif i == '4' : NEW_LINE INDENT print ( '0100' , end = ' ' ) NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT print ( '0101' , end = ' ' ) NEW_LINE DEDENT elif i == '6' : NEW_LINE INDENT print ( '0110' , end = ' ' ) NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT print ( '0111' , end = ' ' ) NEW_LINE DEDENT elif i == '8' : NEW_LINE INDENT print ( '1000' , end = ' ' ) NEW_LINE DEDENT elif i == '9' : NEW_LINE INDENT print ( '1001' , end = ' ' ) NEW_LINE DEDENT elif i == ' A ' or i == ' a ' : NEW_LINE INDENT print ( '1010' , end = ' ' ) NEW_LINE DEDENT elif i == ' B ' or i == ' b ' : NEW_LINE INDENT print ( '1011' , end = ' ' ) NEW_LINE DEDENT elif i == ' C ' or i == ' c ' : NEW_LINE INDENT print ( '1100' , end = ' ' ) NEW_LINE DEDENT elif i == ' D ' or i == ' d ' : NEW_LINE INDENT print ( '1101' , end = ' ' ) NEW_LINE DEDENT elif i == ' E ' or i == ' e ' : NEW_LINE INDENT print ( '1110' , end = ' ' ) NEW_LINE DEDENT elif i == ' F ' or i == ' f ' : NEW_LINE INDENT print ( '1111' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid hexadecimal digit   \" + str ( hexdec [ i ] ) , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT hexdec = \"1AC5\" ; NEW_LINE print ( \" Equivalent ▁ Binary ▁ value ▁ is ▁ : ▁ \" , end = ' ' ) NEW_LINE HexToBin ( hexdec ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to Convert Hexadecimal Number to Binary | Function to convert Hexadecimal to Binary Number ; Driver code ; Get the Hexadecimal number ; Convert HexaDecimal to Binary",
        "Category": "Math"
    },
    {
        "ID": "12024-12024",
        "Code": "def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT def Count_pairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPowerOfTwo ( a [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = ( count * ( count - 1 ) ) / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 8 , 16 , 128 ] NEW_LINE n = len ( a ) NEW_LINE Count_pairs ( a , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count unordered pairs ( i , j ) such that product of a [ i ] and a [ j ] is power of two | Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Function to Count unordered pairs ; is a number can be expressed as power of two ; count total number of unordered pairs ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "12029-12029",
        "Code": "def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( n ** ( 0.5 ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE i = 2 NEW_LINE while i * i <= limit : NEW_LINE INDENT if prime [ i ] == i : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if prime [ j ] == j : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if p * q == i and q != 1 and p != q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif prime [ i ] == i : NEW_LINE INDENT if i ** 8 <= n : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count number of integers less than or equal to N which has exactly 9 divisors | Function to count numbers having exactly 9 divisors ; Sieve array , initially prime [ i ] = i ; use sieve concept to store the first prime factor of every number ; mark all factors of i ; check for all numbers if they can be expressed in form p * q ; p prime factor ; q prime factor ; if both prime factors are different if p * q <= n and q != ; Check if it can be expressed as p ^ 8 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12036-12036",
        "Code": "import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE AC = a NEW_LINE CE = 2 * a NEW_LINE shortestDistace = math . sqrt ( AC * AC + CE * CE ) NEW_LINE print ( shortestDistace ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Puzzle | Minimum distance for Lizard | Python3 program to find minimum distance to be travelled by lizard ; side of cube ; understand from diagram ; understand from diagram ; minimum distance",
        "Category": "Math"
    },
    {
        "ID": "12050-12050",
        "Code": "import math NEW_LINE def isSemiPrime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num /= i NEW_LINE DEDENT cnt += 1 NEW_LINE if cnt >= 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT return cnt == 2 NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isChenPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) and ( isSemiPrime ( n + 2 ) or isPrime ( n + 2 ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 7 NEW_LINE if ( isChenPrime ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Chen Prime Number | Python3 program to check Chen Prime number ; Utility function to Check Semi - prime number ; Increment count of prime number ; If count is greater than 2 , break loop ; If number is greater than 1 , add it to the count variable as it indicates the number remain is prime number ; Return '1' if count is equal to '2' else return '0 ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the Given number is Chen prime number or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12060-12060",
        "Code": "def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def isThabitNumber ( n ) : NEW_LINE INDENT n = n + 1 ; NEW_LINE if ( n % 3 == 0 ) : NEW_LINE INDENT n = n // 3 ; NEW_LINE DEDENT else : NEW_LINE return False NEW_LINE if ( isPowerOfTwo ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 47 NEW_LINE if ( isThabitNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Thabit number | Utility function to Check power of two ; function to check if the given number is Thabit Number ; Add 1 to the number ; Divide the number by 3 ; Check if the given number is power of 2 ; Driver Program ; Check if number is thabit number",
        "Category": "Math"
    },
    {
        "ID": "12061-12061",
        "Code": "def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT ans = ans % 100 NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 11 ) : NEW_LINE INDENT print ( \" For ▁ N ▁ = ▁ \" , N , \" : ▁ \" , get_last_two_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find last two digits of sum of N factorials | Function to find the unit ' s ▁ and ▁ ten ' s place digit ; Let us write for cases when N is smaller than or equal to 10 ; We know following ( 1 ! + 2 ! + 3 ! + 4 ! ... + 10 ! ) % 100 = 13 ( N >= 10 ) ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12072-12072",
        "Code": "def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( not isPrime ( k ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count all the numbers in a range with smallest factor as K | Function to check if k is a prime number or not ; Corner case ; Check from 2 to n - 1 ; Function to check if a number is not divisible by any number between 2 and K - 1 ; to check if the num is divisible by any numbers between 2 and k - 1 ; if not divisible by any number between 2 and k - 1 but divisible by k ; Function to find count of numbers in range [ a , b ] with smallest factor as K ; a number can be divisible only by k and not by any number less than k only if k is a prime ; to check if a number has smallest factor as K ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12082-12082",
        "Code": "MAX = 10000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( n ) : NEW_LINE INDENT count = 0 NEW_LINE num = 1 NEW_LINE total = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT total = total + num NEW_LINE count = count + 1 NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return total NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE print ( \" Sum ▁ of ▁ 1st ▁ N ▁ prime ▁ \" + \" numbers ▁ are ▁ : \" , solve ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of the first N Prime numbers | Python3 implementation of above solution ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; find the sum of 1 st N prime numbers ; count of prime numbers ; sum of prime numbers ; if the number is prime add it ; increase the count ; get to next number ; create the sieve ; find the value of 1 st n prime numbers",
        "Category": "Math"
    },
    {
        "ID": "12083-12083",
        "Code": "def fact ( p ) : NEW_LINE INDENT if ( p <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return p * fact ( p - 1 ) NEW_LINE DEDENT def isPrime ( p ) : NEW_LINE INDENT if ( p == 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( fact ( p >> 1 ) % p ) NEW_LINE DEDENT if ( isPrime ( 127 ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Implementation of Wilson Primality test | Function to calculate the factorial ; Function to check if the number is prime or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12091-12091",
        "Code": "import math as ma NEW_LINE m , n , x , h = 50 , 5 , 67 , 2927 NEW_LINE z = int ( ma . ceil ( h / 60 ) ) NEW_LINE if ( z <= n ) : NEW_LINE INDENT print ( z * m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n * m + ( z - n ) * x ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Total money to be paid after traveling the given number of hours | Python3 implementation of the above approach ; calculating hours travelled",
        "Category": "Math"
    },
    {
        "ID": "12094-12094",
        "Code": "def findNumber ( n , d ) : NEW_LINE INDENT ans = \" \" NEW_LINE if ( d != 10 ) : NEW_LINE INDENT ans += str ( d ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT ans += \" Impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += '1' NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE d = 3 NEW_LINE print ( findNumber ( n , d ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find N digits number which is divisible by D | Function to return N digits number which is divisible by D ; to store answer ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "121-121",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = self . right = None NEW_LINE DEDENT def isLeaf ( self ) : NEW_LINE INDENT return ( self . left == None and self . right == None ) NEW_LINE DEDENT DEDENT def isSame ( root1 , root2 ) : NEW_LINE INDENT s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE s1 . append ( root1 ) NEW_LINE s2 . append ( root2 ) NEW_LINE while ( len ( s1 ) != 0 or len ( s2 ) != 0 ) : NEW_LINE INDENT if ( len ( s1 ) == 0 or len ( s2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp1 = s1 . pop ( - 1 ) NEW_LINE while ( temp1 != None and not temp1 . isLeaf ( ) ) : NEW_LINE INDENT if ( temp1 . right != None ) : NEW_LINE INDENT s1 . append ( temp1 . right ) NEW_LINE DEDENT if ( temp1 . left != None ) : NEW_LINE INDENT s1 . append ( temp1 . left ) NEW_LINE temp1 = s1 . pop ( - 1 ) NEW_LINE DEDENT DEDENT temp2 = s2 . pop ( - 1 ) NEW_LINE while ( temp2 != None and not temp2 . isLeaf ( ) ) : NEW_LINE INDENT if ( temp2 . right != None ) : NEW_LINE INDENT s2 . append ( temp2 . right ) NEW_LINE DEDENT if ( temp2 . left != None ) : NEW_LINE INDENT s2 . append ( temp2 . left ) NEW_LINE DEDENT temp2 = s2 . pop ( - 1 ) NEW_LINE DEDENT if ( temp1 == None and temp2 != None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( temp1 != None and temp2 == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( temp1 != None and temp2 != None ) : NEW_LINE INDENT if ( temp1 . data != temp2 . data ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = Node ( 1 ) NEW_LINE root1 . left = Node ( 2 ) NEW_LINE root1 . right = Node ( 3 ) NEW_LINE root1 . left . left = Node ( 4 ) NEW_LINE root1 . right . left = Node ( 6 ) NEW_LINE root1 . right . right = Node ( 7 ) NEW_LINE root2 = Node ( 0 ) NEW_LINE root2 . left = Node ( 1 ) NEW_LINE root2 . right = Node ( 5 ) NEW_LINE root2 . left . right = Node ( 4 ) NEW_LINE root2 . right . left = Node ( 6 ) NEW_LINE root2 . right . right = Node ( 7 ) NEW_LINE if ( isSame ( root1 , root2 ) ) : NEW_LINE INDENT print ( \" Same \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Same \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if leaf traversal of two Binary Trees is same ? | Binary Tree node ; checks if a given node is leaf or not . ; Returns true of leaf traversal of two trees is same , else false ; Create empty stacks . These stacks are going to be used for iterative traversals . ; Loop until either of two stacks is not empty ; If one of the stacks is empty means other stack has extra leaves so return false ; append right and left children of temp1 . Note that right child is inserted before left ; same for tree2 ; If one is None and other is not , then return false ; If both are not None and data is not same return false ; If control reaches this point , all leaves are matched ; Driver Code ; Let us create trees in above example 1",
        "Category": "Binary Tree"
    },
    {
        "ID": "12112-12112",
        "Code": "MAX = 10000 NEW_LINE arr = [ ] NEW_LINE sprime = [ False ] * ( MAX ) NEW_LINE def computeSemiPrime ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT cnt , num , j = 0 , i , 2 NEW_LINE while cnt < 2 and j * j <= num : NEW_LINE INDENT while num % j == 0 : NEW_LINE INDENT num /= j NEW_LINE cnt += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == 2 : NEW_LINE INDENT sprime [ i ] = True NEW_LINE arr . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def checkSemiPrime ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while arr [ i ] <= n // 2 : NEW_LINE INDENT if sprime [ n - arr [ i ] ] == True : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT computeSemiPrime ( ) NEW_LINE n = 30 NEW_LINE if checkSemiPrime ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if an integer can be expressed as a sum of two semi | Python3 Code to check if an integer can be expressed as sum of two semi - primes ; Utility function to compute semi - primes in a range ; Increment count of prime numbers ; If number is greater than 1 , add it to the count variable as it indicates the number remain is prime number ; if count is equal to '2' then number is semi - prime ; Utility function to check if a number sum of two semi - primes ; arr [ i ] is already a semi - prime if n - arr [ i ] is also a semi - prime then a number can be expressed as sum of two semi - primes ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12119-12119",
        "Code": "def sumProductDifference ( a , b , c , d , e ) : NEW_LINE INDENT rootSum = ( - 1 * b ) / a NEW_LINE rootProduct = e / a NEW_LINE return abs ( rootSum - rootProduct ) NEW_LINE DEDENT print ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Absolute difference between sum and product of roots of a quartic equation | Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12121-12121",
        "Code": "from math import sqrt NEW_LINE def heightCalculate ( H , n , m ) : NEW_LINE INDENT N = n * 1.0 NEW_LINE M = m * 1.0 NEW_LINE h = H * sqrt ( N / ( N + M ) ) NEW_LINE return h NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H = 10 NEW_LINE n = 3 NEW_LINE m = 4 NEW_LINE print ( \" { 0 : . 6 } \" . format ( heightCalculate ( H , n , m ) ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Divide an isosceles triangle in two parts with ratio of areas as n : m | Python 3 program , to find height h which divide isosceles triangle into ratio n : m ; Function to return the height ; type cast the n , m into float ; calculate the height for cut ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12124-12124",
        "Code": "def findNumber ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE x = i NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count [ x % 10 ] += 1 NEW_LINE x = int ( x / 10 ) NEW_LINE count1 += 1 NEW_LINE DEDENT for j in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( count [ j ] == 1 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 == count2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8490 NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print a number strictly less than a given number such that all its digits are distinct . | Function to find a number less than n such that all its digits are distinct ; looping through numbers less than n ; initializing a hash array ; creating a copy of i ; initializing variables to compare lengths of digits ; counting frequency of the digits ; checking if each digit is present once ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "12125-12125",
        "Code": "def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , math . sqrt ( x ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def isNSqMinusnMSqPrime ( m , n ) : NEW_LINE INDENT if ( n - m == 1 and isprime ( m + n ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT m = 13 ; NEW_LINE n = 16 ; NEW_LINE if ( isNSqMinusnMSqPrime ( m , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check n ^ 2 | Check a number is prime or not ; run a loop upto square of given number ; Check if n ^ 2 - m ^ 2 is prime ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12127-12127",
        "Code": "import math NEW_LINE def minimumLecture ( m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( n < math . ceil ( 0.75 * m ) ) : NEW_LINE INDENT ans = math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT M = 9 NEW_LINE N = 1 NEW_LINE print ( minimumLecture ( M , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find minimum number of lectures to attend to maintain 75 % | Python Program to find minimum number of lectures to attend to maintain 75 % attendance ; Function to compute minimum lecture ; Formula to compute ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12129-12129",
        "Code": "def findsolution ( n , x , y ) : NEW_LINE INDENT if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) : NEW_LINE INDENT print ( \" No ▁ solution \" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( y - n + 1 ) ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT print ( 1 ) ; NEW_LINE n -= 1 ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE x = 15 ; NEW_LINE y = 15 ; NEW_LINE findsolution ( n , x , y ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find ' N ' number of solutions with the given inequality equations | Function to calculate all the solutions ; there is no solutions ; print first element as y - n + 1 ; print rest n - 1 elements as 1 ; initialize the number of elements and the value of x an y",
        "Category": "Math"
    },
    {
        "ID": "12136-12136",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def isPermutation ( first , second ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 1 NEW_LINE mul2 = 1 NEW_LINE temp1 = first NEW_LINE while ( temp1 != None ) : NEW_LINE INDENT sum1 += temp1 . data NEW_LINE mul1 *= temp1 . data NEW_LINE temp1 = temp1 . next NEW_LINE DEDENT temp2 = second NEW_LINE while ( temp2 != None ) : NEW_LINE INDENT sum2 += temp2 . data NEW_LINE mul2 *= temp2 . data NEW_LINE temp2 = temp2 . next NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT first = None NEW_LINE first = push ( first , 1 ) NEW_LINE first = push ( first , 34 ) NEW_LINE first = push ( first , 10 ) NEW_LINE first = push ( first , 1 ) NEW_LINE first = push ( first , 35 ) NEW_LINE first = push ( first , 12 ) NEW_LINE second = None NEW_LINE second = push ( second , 35 ) NEW_LINE second = push ( second , 1 ) NEW_LINE second = push ( second , 12 ) NEW_LINE second = push ( second , 1 ) NEW_LINE second = push ( second , 10 ) NEW_LINE second = push ( second , 34 ) NEW_LINE if ( isPermutation ( first , second ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if two Linked Lists are permutations of each other | A linked list node ; Function to check if two linked lists are permutations of each other first : reference to head of first linked list second : reference to head of second linked list ; Variables to keep track of sum and multiplication ; Traversing through linked list and calculating sum and multiply ; Traversing through linked list and calculating sum and multiply ; Function to add a node at the beginning of Linked List ; Allocate node ; Put in the data ; Link the old list off the new node ; Move the head to point to the new node ; Driver Code ; First constructed linked list is : 12 . 35 . 1 . 10 . 34 . 1 ; Second constructed linked list is : 35 . 1 . 12 . 1 . 10 . 34",
        "Category": "Linked List"
    },
    {
        "ID": "12140-12140",
        "Code": "import math NEW_LINE def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A // gcd1 ) + \" : \" + str ( B // gcd1 ) + \" : \" + str ( C // gcd1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the common ratio of three numbers | Python 3 implementation of above approach ; Function to print a : b : c ; To print the given proportion in simplest form . ; Driver code ; Get ratio a : b1 ; Get ratio b2 : c ; Find the ratio a : b : c",
        "Category": "Math"
    },
    {
        "ID": "12149-12149",
        "Code": "import math NEW_LINE PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) NEW_LINE return A * 180 / PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) NEW_LINE return B * 180 / PI NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( \" Angles ▁ are ▁ A ▁ = ▁ \" , A , \" , ▁ B ▁ = ▁ \" , B , \" , ▁ C ▁ = ▁ \" , \"90 ▁ \" ) NEW_LINE DEDENT def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 ; NEW_LINE c = n * n // 4 + 1 ; NEW_LINE print ( \" Side ▁ b ▁ = ▁ \" , b , \" , ▁ Side ▁ c ▁ = ▁ \" , c ) NEW_LINE DEDENT DEDENT printAngles ( n , b , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE printOtherSides ( a ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find other two sides and angles of a right angle triangle | Python 3 program to print all sides and angles of right angle triangle given one side ; Function to find angle A Angle in front of side a ; applied cosine rule ; convert into degrees ; Function to find angle B Angle in front of side b ; applied cosine rule ; convert into degrees and return ; Function to print all angles of the right angled triangle ; for calculate angle A ; for calculate angle B ; Function to find other two sides of the right angled triangle ; if n is odd ; case of n = 1 handled separately ; case of n = 2 handled separately ; Print angles of the triangle ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12158-12158",
        "Code": "import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , h ) : NEW_LINE INDENT return ( 1 / 3 ) * pi * r * r * h NEW_LINE DEDENT def surfacearea ( r , s ) : NEW_LINE INDENT return pi * r * s + pi * r * r NEW_LINE DEDENT radius = float ( 5 ) NEW_LINE height = float ( 12 ) NEW_LINE slat_height = float ( 13 ) NEW_LINE print ( \" Volume ▁ Of ▁ Cone ▁ : ▁ \" , volume ( radius , height ) ) NEW_LINE print ( \" Surface ▁ Area ▁ Of ▁ Cone ▁ : ▁ \" , surfacearea ( radius , slat_height ) ) NEW_LINE",
        "Type": "py",
        "NL": "Calculate volume and surface area of a cone | Python3 program to calculate Volume and Surface area of Cone ; Function to calculate Volume of Cone ; Function To Calculate Surface Area of Cone ; Driver Code ; Printing value of volume and surface area",
        "Category": "Math"
    },
    {
        "ID": "12166-12166",
        "Code": "def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( \"2 ▁ solutions \" ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( \"1 ▁ solution \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ solutions \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 2 , 5 , 2 NEW_LINE checkSolution ( a , b , c ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find number of solutions in Quadratic Equation | function to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal 0 , then 1 solutions ; Else no solutions ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12168-12168",
        "Code": "def Bits ( kilobytes ) : NEW_LINE INDENT Bits = kilobytes * 8192 NEW_LINE return Bits NEW_LINE DEDENT def Bytes ( kilobytes ) : NEW_LINE INDENT Bytes = kilobytes * 1024 NEW_LINE return Bytes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT kilobytes = 1 NEW_LINE print ( kilobytes , \" Kilobytes ▁ = \" , Bytes ( kilobytes ) , \" Bytes ▁ and \" , Bits ( kilobytes ) , \" Bits \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to convert KiloBytes to Bytes and Bits | Function to calculates the bits ; calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; calculates Bytes 1 KB = 1024 bytes ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12188-12188",
        "Code": "MOD = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def sumProd ( n , t ) : NEW_LINE INDENT dino = power ( t + 1 , MOD - 2 , MOD ) NEW_LINE ans = 1 NEW_LINE for i in range ( n + t + 1 , n , - 1 ) : NEW_LINE INDENT ans = ( ans % MOD * i % MOD ) % MOD NEW_LINE DEDENT tfact = 1 NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT tfact = ( tfact * i ) % MOD NEW_LINE DEDENT ans = ans * dino - tfact + MOD NEW_LINE return ans % MOD NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , t = 3 , 2 NEW_LINE print ( sumProd ( n , t ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find sum of product of number in given series | Python 3 program to find sum of product of number in given series ; function to calculate ( a ^ b ) % p ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; function to return required answer ; modulo inverse of denominator ; calculating commentator part ; calculating t ! ; accumulating the final answer ; Driver Code ; function call to print required sum",
        "Category": "Math"
    },
    {
        "ID": "12200-12200",
        "Code": "def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find sum of the series 1 + 22 + 333 + 4444 + ... ... upto n terms | Function to calculate sum ; Return sum ; driver code",
        "Category": "Math"
    },
    {
        "ID": "12208-12208",
        "Code": "def printPair ( g , l ) : NEW_LINE INDENT print ( g , l ) NEW_LINE DEDENT g = 3 ; l = 12 ; NEW_LINE printPair ( g , l ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find any pair with given GCD and LCM | Function to print the pairs ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12212-12212",
        "Code": "mod = 1000000007 NEW_LINE def power ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res *= a NEW_LINE res %= mod NEW_LINE DEDENT b //= 2 NEW_LINE a *= a NEW_LINE a %= mod NEW_LINE DEDENT return res NEW_LINE DEDENT def minPlayer ( n , k ) : NEW_LINE INDENT num = ( ( power ( k , n ) - 1 ) + mod ) % mod NEW_LINE den = ( power ( k - 1 , mod - 2 ) + mod ) % mod NEW_LINE ans = ( ( ( num * den ) % mod ) * k ) % mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 3 , 3 NEW_LINE print ( minPlayer ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum Players required to win the game | Python 3 Program to find minimum players required to win the game anyhow ; function to calculate ( a ^ b ) % ( 10 ^ 9 + 7 ) . ; function to find the minimum required player ; computing the nenomenator ; computing modulo inverse of denominator ; final result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12216-12216",
        "Code": "def coin ( totalRupees , X , Y , Z ) : NEW_LINE INDENT one = X * 1 NEW_LINE fifty = ( ( Y * 1 ) / 2.0 ) NEW_LINE twentyfive = ( ( Z * 1 ) / 4.0 ) NEW_LINE total = one + fifty + twentyfive NEW_LINE result = ( ( totalRupees ) / total ) NEW_LINE return int ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT totalRupees = 1800 NEW_LINE X , Y , Z = 1 , 2 , 4 NEW_LINE Rupees = coin ( totalRupees , X , Y , Z ) NEW_LINE print ( \"1 ▁ rupess ▁ coins ▁ = ▁ \" , Rupees * 1 ) NEW_LINE print ( \"50 ▁ paisa ▁ coins ▁ = ▁ \" , Rupees * 2 ) NEW_LINE print ( \"25 ▁ paisa ▁ coins ▁ = ▁ \" , Rupees * 4 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the count of coins of each type from the given ratio | function to calculate coin . ; Converting each of them in rupees . As we are given totalRupees = 1800 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12221-12221",
        "Code": "import math NEW_LINE class Optimum_distance : NEW_LINE INDENT class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT class Line : NEW_LINE INDENT def __init__ ( self , a , b , c ) : NEW_LINE INDENT self . a = a NEW_LINE self . b = b NEW_LINE self . c = c NEW_LINE DEDENT DEDENT def dist ( self , x , y , p ) : NEW_LINE INDENT return math . sqrt ( ( x - p . x ) ** 2 + ( y - p . y ) ** 2 ) NEW_LINE DEDENT def compute ( self , p , n , l , x ) : NEW_LINE INDENT res = 0 NEW_LINE y = - 1 * ( l . a * x + l . c ) / l . b NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += self . dist ( x , y , p [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def find_Optimum_cost_untill ( self , p , n , l ) : NEW_LINE INDENT low = - 1e6 NEW_LINE high = 1e6 NEW_LINE eps = 1e-6 + 1 NEW_LINE while ( ( high - low ) > eps ) : NEW_LINE INDENT mid1 = low + ( high - low ) / 3 NEW_LINE mid2 = high - ( high - low ) / 3 NEW_LINE dist1 = self . compute ( p , n , l , mid1 ) NEW_LINE dist2 = self . compute ( p , n , l , mid2 ) NEW_LINE if ( dist1 < dist2 ) : NEW_LINE INDENT high = mid2 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid1 NEW_LINE DEDENT DEDENT return self . compute ( p , n , l , ( low + high ) / 2 ) NEW_LINE DEDENT def find_Optimum_cost ( self , p , l ) : NEW_LINE INDENT n = len ( p ) NEW_LINE p_arr = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT p_obj = self . Point ( p [ i ] [ 0 ] , p [ i ] [ 1 ] ) NEW_LINE p_arr [ i ] = p_obj NEW_LINE DEDENT return self . find_Optimum_cost_untill ( p_arr , n , l ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT obj = Optimum_distance ( ) NEW_LINE l = obj . Line ( 1 , - 1 , - 3 ) NEW_LINE p = [ [ - 3 , - 2 ] , [ - 1 , 0 ] , [ - 1 , 2 ] , [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE print ( obj . find_Optimum_cost ( p , l ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Optimum location of point to minimize total distance | A Python3 program to find optimum location and total cost ; Class defining a point ; Class defining a line of ax + by + c = 0 form ; Method to get distance of point ( x , y ) from point p ; Utility method to compute total distance all points when choose point on given line has x - coordinate value as X ; Calculating Y of chosen point by line equation ; Utility method to find minimum total distance ; Loop until difference between low and high become less than EPS ; mid1 and mid2 are representative x co - ordiantes of search space ; If mid2 point gives more total distance , skip third part ; If mid1 point gives more total distance , skip first part ; Compute optimum distance cost by sending average of low and high as X ; Method to find optimum cost ; Converting 2D array input to point array ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12223-12223",
        "Code": "def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , ( N + 1 ) // i , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def findSum ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE ans = 1 NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N //= s [ N ] NEW_LINE if currFactor == s [ N ] : NEW_LINE INDENT power += 1 NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( power + 1 ) : NEW_LINE INDENT sum += pow ( currFactor , i ) NEW_LINE DEDENT ans *= sum NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( \" Sum ▁ of ▁ the ▁ factors ▁ is ▁ : \" , end = \" ▁ \" ) NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of Factors of a Number using Prime Factorization | Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if N is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7 ; Create a boolean list \" prime [ 0 . . n ] \" and initialize all entries in it as false . ; Initializing smallest factor equal to 2 for all the even numbers ; For odd numbers less then equal to n ; s [ i ] for a prime is the number itself ; For all multiples of current prime number ; i is the smallest prime factor for number \" i * j \" . ; Function to find sum of all prime factors ; Declaring list to store smallest prime factor of i at i - th index ; Filling values in s [ ] using sieve function calling ; Current prime factor of N ; Power of current prime factor ; N is now Ns [ N ] . If new N also has smallest prime factor as currFactor , increment power ; Update current prime factor as s [ N ] and initializing power of factor as 1. ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12226-12226",
        "Code": "def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 19877658 NEW_LINE if isDivisible ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if any large number is divisible by 17 or not | Function to check if the number is divisible by 17 or not ; Extracting the last digit ; Truncating the number ; Subtracting the five times the last digit from the remaining number ; Return n is divisible by 17 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12246-12246",
        "Code": "def printCombination ( n ) : NEW_LINE INDENT print ( \"1 ▁ \" , end = \" \" ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( \"2\" , n - 3 , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" , ( n - 2 ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Triplet with no element divisible by 3 and sum N | Function to print a , b and c ; check if n - 2 is divisible by 3 or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12249-12249",
        "Code": "def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT costPrice , sellingPrice = 1500 , 2000 NEW_LINE if sellingPrice == costPrice : NEW_LINE INDENT print ( \" No ▁ profit ▁ nor ▁ Loss \" ) NEW_LINE DEDENT elif sellingPrice > costPrice : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , \" Profit \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , \" Loss \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Program to calculate Profit Or Loss | Function to calculate Profit . ; Function to calculate Loss . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12252-12252",
        "Code": "def isPalindrome ( n ) : NEW_LINE INDENT if n % 11 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 123321 NEW_LINE if isPalindrome ( n ) : NEW_LINE INDENT print ( \" Palindrome \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Palindrome \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number with even number of digits is palindrome or not | Function to check if the number is palindrome ; if divisible by 11 then return True ; if not divisible by 11 then return False ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12255-12255",
        "Code": "target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ▁ ' , totalCount ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of triplets with product equal to given number with duplicates allowed | The target value for which we have to find the solution ; This variable contains the total count of triplets found ; Loop from the first to the third last integer in the list ; Check if arr [ i ] is a factor of target or not . If not , skip to the next element ; Check if the pair ( arr [ i ] , arr [ j ] ) can be a part of triplet whose product is equal to the target ; Find the remaining element of the triplet ; If element is found . increment the total count of the triplets",
        "Category": "Array"
    },
    {
        "ID": "12258-12258",
        "Code": "import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectSquare ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Next perfect square greater than a given number | Python3 implementation of above approach ; Function to find the next perfect square ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12259-12259",
        "Code": "MAXN = 100005 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE sum_digits = [ 0 ] * MAXN NEW_LINE isValid = [ 0 ] * MAXN NEW_LINE ans = [ 0 ] * MAXN NEW_LINE def Smallest_prime_factor ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= MAXN : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 2 NEW_LINE DEDENT DEDENT def Digit_Sum ( copy ) : NEW_LINE INDENT d = 0 NEW_LINE while ( copy ) : NEW_LINE INDENT d += copy % 10 NEW_LINE copy //= 10 NEW_LINE DEDENT return d NEW_LINE DEDENT def Sum_Of_All_Digits ( ) : NEW_LINE INDENT for n in range ( 2 , MAXN ) : NEW_LINE INDENT sum_digits [ n ] = ( sum_digits [ n // spf [ n ] ] + Digit_Sum ( spf [ n ] ) ) NEW_LINE if ( Digit_Sum ( n ) == sum_digits [ n ] ) : NEW_LINE INDENT isValid [ n ] = True NEW_LINE DEDENT DEDENT for n in range ( 2 , MAXN ) : NEW_LINE INDENT if ( isValid [ n ] ) : NEW_LINE INDENT ans [ n ] = 1 NEW_LINE DEDENT ans [ n ] += ans [ n - 1 ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Smallest_prime_factor ( ) NEW_LINE Sum_Of_All_Digits ( ) NEW_LINE l = 2 NEW_LINE r = 3 NEW_LINE print ( \" Valid ▁ numbers ▁ in ▁ the ▁ range \" , l , r , \" are \" , ans [ r ] - ans [ l - 1 ] ) NEW_LINE l = 2 NEW_LINE r = 10 NEW_LINE print ( \" Valid ▁ numbers ▁ in ▁ the ▁ range \" , l , r , \" are \" , ans [ r ] - ans [ l - 1 ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Numbers with sum of digits equal to the sum of digits of its all prime factor | maximum size of number ; array to store smallest prime factor of number ; array to store sum of digits of a number ; boolean array to check given number is countable for required answer or not . ; prefix array to store answer ; Calculating SPF ( Smallest Prime Factor ) for every number till MAXN . ; marking smallest prime factor for every number to be itself . ; separately marking spf for every even number as 2 ; checking if i is prime ; marking SPF for all numbers divisible by i ; marking spf [ j ] if it is not previously marked ; Function to find sum of digits in a number ; find sum of digits of all numbers up to MAXN ; add sum of digits of least prime factor and n / spf [ n ] ; if it is valid make isValid true ; prefix sum to compute answer ; Driver code ; print answer for required range ; print answer for required range",
        "Category": "Math"
    },
    {
        "ID": "12262-12262",
        "Code": "import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 123 ; NEW_LINE printSubstrings ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all substring of a number without any conversion | Python3 implementation of above approach ; Function to print the substrings of a number ; Calculate the total number of digits ; 0.5 has been added because of it will return double value like 99.556 ; Print all the numbers from starting position ; Update the no . ; Update the no . of digits ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "12263-12263",
        "Code": "def prevComplement ( n , b ) : NEW_LINE INDENT maxNum , digits , num = 0 , 0 , n NEW_LINE while n > 1 : NEW_LINE INDENT digits += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT maxDigit = b - 1 NEW_LINE while digits : NEW_LINE INDENT maxNum = maxNum * 10 + maxDigit NEW_LINE digits -= 1 NEW_LINE DEDENT return maxNum - num NEW_LINE DEDENT def complement ( n , b ) : NEW_LINE INDENT return prevComplement ( n , b ) + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "Type": "py",
        "NL": "Complement of a number with any base b | Function to find ( b - 1 ) 's complement ; Calculate number of digits in the given number ; Largest digit in the number system with base b ; Largest number in the number system with base b ; return Complement ; Function to find b 's complement ; b ' s ▁ complement ▁ = ▁ ( b - 1 ) ' s complement + 1 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12269-12269",
        "Code": "MOD = 1000000007 ; NEW_LINE def powerLL ( x , n ) : NEW_LINE INDENT result = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT result = result * x % MOD ; NEW_LINE DEDENT n = int ( n / 2 ) ; NEW_LINE x = x * x % MOD ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def powerStrings ( sa , sb ) : NEW_LINE INDENT a = 0 ; NEW_LINE b = 0 ; NEW_LINE for i in range ( len ( sa ) ) : NEW_LINE INDENT a = ( a * 10 + ( ord ( sa [ i ] ) - ord ( '0' ) ) ) % MOD ; NEW_LINE DEDENT for i in range ( len ( sb ) ) : NEW_LINE INDENT b = ( b * 10 + ( ord ( sb [ i ] ) - ord ( '0' ) ) ) % ( MOD - 1 ) ; NEW_LINE DEDENT return powerLL ( a , b ) ; NEW_LINE DEDENT sa = \"2\" ; NEW_LINE sb = \"3\" ; NEW_LINE print ( powerStrings ( sa , sb ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Modulo power for large numbers represented as strings | Python3 program to find ( a ^ b ) % MOD where a and b may be very large and represented as strings . ; Returns modulo exponentiation for two numbers represented as long long int . It is used by powerStrings ( ) . Its complexity is log ( n ) ; Returns modulo exponentiation for two numbers represented as strings . It is used by powerStrings ( ) ; We convert strings to number ; calculating a % MOD ; calculating b % ( MOD - 1 ) ; Now a and b are long long int . We calculate a ^ b using modulo exponentiation ; As numbers are very large that is it may contains upto 10 ^ 6 digits . So , we use string .",
        "Category": "Math"
    },
    {
        "ID": "12270-12270",
        "Code": "N = 100005 NEW_LINE phi = [ 0 ] * N NEW_LINE S = [ 0 ] * N NEW_LINE def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def CoPrimes ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S [ i ] = S [ i - 1 ] + phi [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT CoPrimes ( ) NEW_LINE q = [ 3 , 4 ] NEW_LINE n = len ( q ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( \" Number of unordered coprime \" ▁ + ▁ \" pairs of integers from 1 to \" , ▁ q [ i ] , ▁ \" are   \" , S [ q [ i ] ] ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Queries to count the number of unordered co | Python3 program to find number of unordered coprime pairs of integers from 1 to N ; to store euler 's totient function ; to store required answer ; Computes and prints totient of all numbers smaller than or equal to N . ; Initialise the phi [ ] with 1 ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; function to compute number coprime pairs ; function call to compute euler totient function ; prefix sum of all euler totient function values ; Driver code ; function call",
        "Category": "Math"
    },
    {
        "ID": "12275-12275",
        "Code": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def NearestElement ( A , D , P ) : NEW_LINE INDENT if A == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif D == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT X = power ( D , P - 2 , P ) NEW_LINE return ( X * ( P - A ) ) % P NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , D , P = 4 , 9 , 11 NEW_LINE A %= P NEW_LINE D %= P NEW_LINE print ( NearestElement ( A , D , P ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find First element in AP which is multiple of given prime | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; function to find nearest element in common ; base conditions ; Driver Code ; module both A and D ; function call",
        "Category": "Math"
    },
    {
        "ID": "12278-12278",
        "Code": "import math NEW_LINE def complement ( num ) : NEW_LINE INDENT i = 0 ; NEW_LINE len = 0 ; NEW_LINE comp = 0 ; NEW_LINE temp = num ; NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = math . pow ( 10 , len ) - num ; NEW_LINE return int ( comp ) ; NEW_LINE DEDENT print ( complement ( 25 ) ) ; NEW_LINE print ( complement ( 456 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "10 's Complement of a decimal number | Python3 program to find 10 's complement ; Function to find 10 's complement ; Calculating total digits in num ; restore num ; calculate 10 's complement ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12283-12283",
        "Code": "def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT x = 4 ; NEW_LINE y = 9 ; NEW_LINE if ( findGreater ( x , y ) ) : NEW_LINE INDENT print ( \"1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"2\" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find maximum among x ^ ( y ^ 2 ) or y ^ ( x ^ 2 ) where x and y are given | Function to find maximum ; Case 1 ; Case 2 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12287-12287",
        "Code": "def binomialCoeff ( x , n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE term = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( i <= n and sum < k ) : NEW_LINE INDENT term *= x - i + 1 ; NEW_LINE term /= i ; NEW_LINE sum += term ; NEW_LINE i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def minTrials ( n , k ) : NEW_LINE INDENT low = 1 ; NEW_LINE high = k ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) ; NEW_LINE if ( binomialCoeff ( mid , n , k ) < k ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT print ( minTrials ( 2 , 10 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Eggs dropping puzzle ( Binomial Coefficient and Binary Search Solution ) | Find sum of binomial coefficients xCi ( where i varies from 1 to n ) . If the sum becomes more than K ; Do binary search to find minimum number of trials in worst case . ; Initialize low and high as 1 st and last floors ; Do binary search , for every mid , find sum of binomial coefficients and check if the sum is greater than k or not . ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "12296-12296",
        "Code": "mod = ( int ) ( 1e9 + 7 ) NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT n = n - 1 NEW_LINE ans = n * n NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT ans += n + 2 NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT ans = ( pow ( 2 , n , mod ) % mod * ans % mod ) % mod NEW_LINE ans = ( ans - 1 + mod ) % mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( check ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of sum of all subsets of a set formed by first N natural numbers | modulo value ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with the result ; y must be even now y = y >> 1 y = y / 2 ; function to find ff ( n ) ; In formula n is starting from zero ; calculate answer using formula 2 ^ n * ( n ^ 2 + n + 2 ) - 1 ; whenever answer is greater than or equals to mod then modulo it . ; adding modulo while subtraction is very necessary otherwise it will cause wrong answer ; Driver code ; function call",
        "Category": "Math"
    },
    {
        "ID": "12303-12303",
        "Code": "def LastTwoDigit ( num ) : NEW_LINE INDENT one = num % 10 NEW_LINE num //= 10 NEW_LINE tens = num % 10 NEW_LINE tens *= 10 NEW_LINE num = tens + one NEW_LINE return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE num = 1 NEW_LINE num = pow ( 2 , n ) ; NEW_LINE print ( \" Last ▁ \" + str ( 2 ) + \" ▁ digits ▁ of ▁ \" + str ( 2 ) + \" ^ \" + str ( n ) + \" ▁ = ▁ \" , end = \" \" ) NEW_LINE print ( LastTwoDigit ( num ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find last two digits of 2 ^ n | Find the first digit ; Get the last digit from the number ; Remove last digit from number ; Get the last digit from the number ( last second of num ) ; Take last digit to ten 's position  i.e. last second digit ; Add the value of ones and tens to make it complete 2 digit number ; return the first digit ; Driver Code ; pow function used",
        "Category": "Math"
    },
    {
        "ID": "12304-12304",
        "Code": "def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def numberOfDigits ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x //= 10 NEW_LINE i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT def LastTwoDigit ( n ) : NEW_LINE INDENT print ( \" Last ▁ \" + str ( 2 ) + \" ▁ digits ▁ of ▁ \" + str ( 2 ) , end = \" \" ) NEW_LINE print ( \" ^ \" + str ( n ) + \" ▁ = ▁ \" , end = \" \" ) NEW_LINE temp = 1 NEW_LINE for i in range ( 1 , 3 ) : NEW_LINE INDENT temp *= 10 NEW_LINE DEDENT temp = power ( 2 , n , temp ) NEW_LINE for i in range ( 2 - numberOfDigits ( temp ) ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT if temp : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 72 NEW_LINE LastTwoDigit ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find last two digits of 2 ^ n | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; function to calculate number of digits in x ; function to print last 2 digits of 2 ^ n ; Generating 10 ^ 2 ; Calling modular exponentiation ; Printing leftmost zeros . Since ( 2 ^ n ) % 2 can have digits less then 2. In that case we need to print zeros ; If temp is not zero then print temp If temp is zero then already printed ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12310-12310",
        "Code": "def findNthRoot ( x , n ) : NEW_LINE INDENT x = float ( x ) NEW_LINE n = int ( n ) NEW_LINE if ( x >= 0 and x <= 1 ) : NEW_LINE INDENT low = x NEW_LINE high = 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = 1 NEW_LINE high = x NEW_LINE DEDENT epsilon = 0.00000001 NEW_LINE guess = ( low + high ) / 2 NEW_LINE while abs ( guess ** n - x ) >= epsilon : NEW_LINE INDENT if guess ** n > x : NEW_LINE INDENT high = guess NEW_LINE DEDENT else : NEW_LINE INDENT low = guess NEW_LINE DEDENT guess = ( low + high ) / 2 NEW_LINE DEDENT print ( guess ) NEW_LINE DEDENT x = 5 NEW_LINE n = 2 NEW_LINE findNthRoot ( x , n ) NEW_LINE",
        "Type": "py",
        "NL": "Calculating n | Python Program to find n - th real root of x ; Initialize boundary values ; used for taking approximations of the answer ; Do binary search ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "12318-12318",
        "Code": "def sumeven ( n , l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE mid = n // 2 NEW_LINE if ( r <= mid ) : NEW_LINE INDENT first = ( 2 * l - 1 ) NEW_LINE last = ( 2 * r - 1 ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 NEW_LINE DEDENT elif ( l >= mid ) : NEW_LINE INDENT first = ( 2 * ( l - n // 2 ) ) NEW_LINE last = ( 2 * ( r - n // 2 ) ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT sumleft , sumright = 0 , 0 NEW_LINE first_term1 = ( 2 * l - 1 ) NEW_LINE last_term1 = ( 2 * ( n // 2 ) - 1 ) NEW_LINE no_of_terms1 = n // 2 - l + 1 NEW_LINE sumleft = ( ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) // 2 ) NEW_LINE first_term2 = 2 NEW_LINE last_term2 = ( 2 * ( r - n // 2 ) ) NEW_LINE no_of_terms2 = r - mid NEW_LINE sumright = ( ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) // 2 ) NEW_LINE sum = ( sumleft + sumright ) ; NEW_LINE DEDENT return sum NEW_LINE DEDENT def sumodd ( n , l , r ) : NEW_LINE INDENT mid = n // 2 + 1 ; NEW_LINE sum = 0 NEW_LINE if ( r <= mid ) : NEW_LINE INDENT first = ( 2 * l - 1 ) NEW_LINE last = ( 2 * r - 1 ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 ) NEW_LINE DEDENT elif ( l > mid ) : NEW_LINE INDENT first = ( 2 * ( l - mid ) ) NEW_LINE last = ( 2 * ( r - mid ) ) NEW_LINE no_of_terms = r - l + 1 NEW_LINE sum = ( ( ( no_of_terms ) * ( ( first + last ) ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT sumleft , sumright = 0 , 0 NEW_LINE first_term1 = ( 2 * l - 1 ) NEW_LINE last_term1 = ( 2 * mid - 1 ) NEW_LINE no_of_terms1 = mid - l + 1 NEW_LINE sumleft = ( ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) // 2 ) NEW_LINE first_term2 = 2 NEW_LINE last_term2 = ( 2 * ( r - mid ) ) NEW_LINE no_of_terms2 = r - mid NEW_LINE sumright = ( ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) // 2 ) NEW_LINE sum = ( sumleft + sumright ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def rangesum ( n , l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return sumeven ( n , l , r ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return sumodd ( n , l , r ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE l = 1 NEW_LINE r = 11 ; NEW_LINE print ( rangesum ( n , l , r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of elements in range L | Function to calculate the sum if n is even ; Both l and r are to the left of mid ; First and last element ; Total number of terms in the sequence is r - l + 1 ; Use of formula derived ; Both l and r are to the right of mid ; First and last element ; Use of formula derived ; Left is to the left of mid and right is to the right of mid ; Take two sums i . e left and right differently and add ; First and last element ; total terms ; no of terms ; The first even number is 2 ; The last element is ; formula applied ; Function to calculate the sum if n is odd ; Take ceil value if n is odd ; Both l and r are to the left of mid ; First and last element ; number of terms ; formula ; both l and r are to the right of mid ; first and last term , ; no of terms ; formula used ; If l is on left and r on right ; calculate separate sums ; first half ; calculate terms ; second half ; add both halves ; Function to find the sum between L and R ; If n is even ; If n is odd ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12319-12319",
        "Code": "def findAngle ( n ) : NEW_LINE INDENT interiorAngle = int ( ( n - 2 ) * 180 / n ) NEW_LINE exteriorAngle = int ( 360 / n ) NEW_LINE print ( \" Interior ▁ angle : ▁ \" , interiorAngle ) NEW_LINE print ( \" Exterior ▁ angle : ▁ \" , exteriorAngle ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find the Interior and Exterior Angle of a Regular Polygon | function to find the interior and exterior angle ; formula to find the interior angle ; formula to find the exterior angle ; Displaying the output ; Driver code ; Function calling",
        "Category": "Math"
    },
    {
        "ID": "12321-12321",
        "Code": "import math NEW_LINE def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT d = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) + math . pow ( z2 - z1 , 2 ) * 1.0 ) NEW_LINE print ( \" Distance ▁ is ▁ \" ) NEW_LINE print ( d ) NEW_LINE DEDENT x1 = 2 NEW_LINE y1 = - 5 NEW_LINE z1 = 7 NEW_LINE x2 = 3 NEW_LINE y2 = 4 NEW_LINE z2 = 5 NEW_LINE distance ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate distance between two points in 3 D | Python program to find distance between two points in 3 D . ; Function to find distance ; Driver Code ; function call for distance",
        "Category": "Math"
    },
    {
        "ID": "12322-12322",
        "Code": "import math as mt NEW_LINE def twoEggDrop ( k ) : NEW_LINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEW_LINE DEDENT k = 100 NEW_LINE print ( twoEggDrop ( k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Egg Dropping Puzzle with 2 Eggs and K Floors | Python3 program to find optimal number of trials for k floors and 2 eggs . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12332-12332",
        "Code": "from math import sqrt NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = 5 * sqrt ( 3 ) * a * a NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( ( 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a ) NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( \" Area : ▁ \" , findArea ( a ) ) NEW_LINE print ( \" Volume : ▁ \" , findVolume ( a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find the Area and Volume of Icosahedron | Python3 program to find the Area and volume of Icosahedron ; Function to find area of Icosahedron ; Formula to calculate area ; Function to find volume of Icosahedron ; Formula to calculate volume ; Driver Code ; Function call to find area of Icosahedron . ; Function call to find volume of Icosahedron .",
        "Category": "Math"
    },
    {
        "ID": "12334-12334",
        "Code": "def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE aeven = False NEW_LINE n = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if ( not ( aeven or a & 1 ) ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif ( not ( a & 1 ) ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT print ( \" even ▁ = ▁ \" , even , \" , ▁ odd ▁ = ▁ \" , odd , sep = \" \" ) NEW_LINE DEDENT min = 1 NEW_LINE max = 4 NEW_LINE steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE count_even_odd ( min , max , steps ) NEW_LINE",
        "Type": "py",
        "NL": "Number of odd and even results for every value of x in range [ min , max ] after performing N steps | Function that prints the number of odd and even results ; If constant at layer i is even , beven is True , otherwise False . If the coefficient of x at layer i is even , aeven is True , otherwise False . ; If any of the coefficients at any layer is found to be even , then the product of all the coefficients will always be even . ; Checking whether the constant added after all layers is even or odd . ; Assuming input x is even . ; Assuming input x is odd . ; Displaying the counts . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12344-12344",
        "Code": "import math NEW_LINE def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEW_LINE return m ; NEW_LINE DEDENT N = 4 ; NEW_LINE K = 9 ; NEW_LINE X = 2 ; NEW_LINE print ( MinimumMail ( N , K , X ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of mails required to distribute all the questions | Python3 code to find the minimum number of mails ; Function returns the min no of mails required ; Using the formula derived above ; no of questions ; no of students ; maximum no of questions a mail can hold ; Calling function",
        "Category": "Math"
    },
    {
        "ID": "12346-12346",
        "Code": "def findArea ( a , b ) : NEW_LINE INDENT Area = 3.142 * a * b ; NEW_LINE print ( \" Area : \" , round ( Area , 2 ) ) ; NEW_LINE DEDENT a = 5 ; NEW_LINE b = 4 ; NEW_LINE findArea ( a , b ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to find the Area of an Ellipse | Function to find area of an ellipse . ; formula to find the area of an Ellipse . ; Display the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12347-12347",
        "Code": "import math NEW_LINE def calculate ( x , k , m ) : NEW_LINE INDENT result = x ; NEW_LINE k = k - 1 ; NEW_LINE while ( k ) : NEW_LINE INDENT result = math . pow ( result , x ) ; NEW_LINE if ( result > m ) : NEW_LINE INDENT result = result % m ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE DEDENT return int ( result ) ; NEW_LINE DEDENT x = 5 ; NEW_LINE k = 2 ; NEW_LINE m = 3 ; NEW_LINE print ( calculate ( x , k , m ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Compute power of power k times % m | Python3 program for computing x ^ x ^ x ^ x . . % m ; Function to compute the given value ; compute power k times ; Driver Code ; Calling function",
        "Category": "Math"
    },
    {
        "ID": "12348-12348",
        "Code": "N = 1000000 NEW_LINE phi = [ 0 for i in range ( N + 5 ) ] NEW_LINE def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def calculate ( x , k , mod ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE count = 0 NEW_LINE while ( mod > 1 ) : NEW_LINE INDENT arr [ count ] = mod NEW_LINE count += 1 NEW_LINE mod = phi [ mod ] NEW_LINE DEDENT result = 1 NEW_LINE loop = count + 1 NEW_LINE arr [ count ] = 1 NEW_LINE for i in range ( min ( k , loop ) , - 1 , - 1 ) : NEW_LINE INDENT result = power ( x , result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT computeTotient ( ) NEW_LINE x = 3 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Compute power of power k times % m | Python3 program to compute x ^ x ^ x ^ x . . % m ; Create an array to store phi or totient values ; Function to calculate Euler Totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; Function to calculate ( x ^ x ^ x ^ x ... k times ) % m ; to store different mod values ; run loop in reverse to calculate result ; compute euler totient function values ; Calling function to compute answer",
        "Category": "Math"
    },
    {
        "ID": "12349-12349",
        "Code": "def rev ( n , temp ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return temp ; NEW_LINE DEDENT temp = ( temp * 10 ) + ( n % 10 ) ; NEW_LINE return rev ( n / 10 , temp ) ; NEW_LINE DEDENT n = 121 ; NEW_LINE temp = rev ( n , 0 ) ; NEW_LINE if ( temp != n ) : NEW_LINE INDENT print ( \" yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Recursive program to check if number is palindrome or not | Recursive function that returns the reverse of digits ; base case ; stores the reverse of a number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12353-12353",
        "Code": "import math NEW_LINE def findGreater ( a , b , n ) : NEW_LINE INDENT if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT a = abs ( a ) ; NEW_LINE b = abs ( b ) ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( \" a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n \" ) ; NEW_LINE DEDENT elif ( a > b ) : NEW_LINE INDENT print ( \" a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n \" ) ; NEW_LINE DEDENT DEDENT a = 12 ; NEW_LINE b = 24 ; NEW_LINE n = 5 ; NEW_LINE findGreater ( a , b , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to find greater value between a ^ n and b ^ n | Python3 code for finding greater between the a ^ n and b ^ n ; Function to find the greater value ; If n is even ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12354-12354",
        "Code": "import math NEW_LINE def Divide ( a , b ) : NEW_LINE INDENT dividend = a ; NEW_LINE divisor = b ; NEW_LINE sign = - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE if ( divisor == 0 ) : NEW_LINE INDENT print ( \" Cannot ▁ Divide ▁ by ▁ 0\" ) ; NEW_LINE DEDENT if ( dividend == 0 ) : NEW_LINE INDENT print ( a , \" / \" , b , \" is ▁ equal ▁ to ▁ : \" , 0 ) ; NEW_LINE DEDENT if ( divisor == 1 ) : NEW_LINE INDENT print ( a , \" / \" , b , \" is ▁ equal ▁ to ▁ : \" , ( sign * dividend ) ) ; NEW_LINE DEDENT print ( a , \" / \" , b , \" is ▁ equal ▁ to ▁ : \" , math . floor ( sign * math . exp ( math . log ( dividend ) - math . log ( divisor ) ) ) ) ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 5 ; NEW_LINE Divide ( a , b ) ; NEW_LINE a = 49 ; NEW_LINE b = - 7 ; NEW_LINE Divide ( a , b ) ; NEW_LINE",
        "Type": "py",
        "NL": "Divide two integers without using multiplication , division and mod operator | Set2 | Python3 program for above approach ; Returns the quotient of dividend / divisor . ; Calculate sign of divisor i . e . , sign will be negative only if either one of them is negative otherwise it will be positive ; Remove signs of dividend and divisor ; Zero division Exception . ; Using Formula derived above . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12356-12356",
        "Code": "import sys NEW_LINE def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE i = lar NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += lar NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 7 NEW_LINE print ( \" LCM ▁ of ▁ \" , a , \" ▁ and ▁ \" , b , \" ▁ is ▁ \" , findLCM ( a , b ) , sep = \" \" ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find LCM of 2 numbers without using GCD | Python 3 program to find LCM of 2 numbers without using GCD ; Function to return LCM of two numbers ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12364-12364",
        "Code": "import math NEW_LINE def check ( m , n ) : NEW_LINE INDENT RHS = m * math . log ( n ) ; NEW_LINE LHS = n * math . log ( m ) ; NEW_LINE if ( LHS > RHS ) : NEW_LINE INDENT print ( \" m ^ n ▁ > ▁ n ^ m \" ) ; NEW_LINE DEDENT elif ( LHS < RHS ) : NEW_LINE INDENT print ( \" m ^ n ▁ < ▁ n ^ m \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" m ^ n ▁ = ▁ n ^ m \" ) ; NEW_LINE DEDENT DEDENT m = 987654321 ; NEW_LINE n = 123456987 ; NEW_LINE check ( m , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to compare m ^ n and n ^ m | Python3 program to compare which is greater m ^ n or n ^ m ; function to compare m ^ n and n ^ m ; m ^ n ; n ^ m ; Driver Code ; function call to compare m ^ n and n ^ m",
        "Category": "Math"
    },
    {
        "ID": "12366-12366",
        "Code": "from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N /= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is \" , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of Square Free Divisors | Python 3 Program to find the minimum number of square free divisors ; Initializing MAX with SQRT ( 10 ^ 6 ) ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers ; This function returns the minimum number of Square Free divisors ; Precomputing Prime Factors ; holds max of max power of all prime factors ; holds the max power of current prime factor ; If number itself is prime , it will be included as answer and thus minimum required answer is 1 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12373-12373",
        "Code": "from __future__ import print_function NEW_LINE def primes ( n ) : NEW_LINE INDENT i , j = 2 , 0 NEW_LINE result = [ ] NEW_LINE while j < n : NEW_LINE INDENT flag = True NEW_LINE for item in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if i % item == 0 and i != item : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT result . append ( i ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def smar_wln ( n ) : NEW_LINE INDENT arr = primes ( n ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( arr [ j ] , end = ' ' ) NEW_LINE DEDENT print ( end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( ' First { } terms of the Sequence are ' . format ( n ) ) NEW_LINE smar_wln ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smarandache | Python program to print the first ' n ' terms of the Smarandache - Wellin Sequence ; Function to collect first ' n ' prime numbers ; List to store first ' n ' primes ; Function to generate Smarandache - Wellin Sequence ; Storing the first ' n ' prime numbers in a list ; Driver Method",
        "Category": "Math"
    },
    {
        "ID": "12377-12377",
        "Code": "def Log2n ( n ) : NEW_LINE INDENT return ( 1 + Log2n ( n / 2 ) ) if ( n > 1 ) else 0 ; NEW_LINE DEDENT def isPowerOfd ( n , d ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT return ( count % ( Log2n ( d ) ) == 0 ) ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 64 ; NEW_LINE d = 8 ; NEW_LINE if ( isPowerOfd ( n , d ) ) : NEW_LINE INDENT print ( n , \" is ▁ a ▁ power ▁ of \" , d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ a ▁ power ▁ of \" , d ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if given number is a power of d where d is a power of 2 | Python3 program to find if a number is power of d where d is power of 2. ; Function to count the number of ways to paint N * 3 grid based on given conditions ; Check if there is only one bit set in n ; count 0 bits before set bit ; If count is a multiple of log2 ( d ) then return true else false ; If there are more than 1 bit set then n is not a power of 4 ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "12379-12379",
        "Code": "def determinantOfMatrix ( mat ) : NEW_LINE INDENT ans = ( mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ) NEW_LINE return ans NEW_LINE DEDENT def findSolution ( coeff ) : NEW_LINE INDENT d = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] ] ] NEW_LINE d1 = [ [ coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] ] ] NEW_LINE d2 = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 2 ] ] ] NEW_LINE d3 = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 3 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 3 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 3 ] ] ] NEW_LINE D = determinantOfMatrix ( d ) NEW_LINE D1 = determinantOfMatrix ( d1 ) NEW_LINE D2 = determinantOfMatrix ( d2 ) NEW_LINE D3 = determinantOfMatrix ( d3 ) NEW_LINE print ( \" D ▁ is ▁ : ▁ \" , D ) NEW_LINE print ( \" D1 ▁ is ▁ : ▁ \" , D1 ) NEW_LINE print ( \" D2 ▁ is ▁ : ▁ \" , D2 ) NEW_LINE print ( \" D3 ▁ is ▁ : ▁ \" , D3 ) NEW_LINE if ( D != 0 ) : NEW_LINE INDENT x = D1 / D NEW_LINE y = D2 / D NEW_LINE z = D3 / D NEW_LINE print ( \" Value ▁ of ▁ x ▁ is ▁ : ▁ \" , x ) NEW_LINE print ( \" Value ▁ of ▁ y ▁ is ▁ : ▁ \" , y ) NEW_LINE print ( \" Value ▁ of ▁ z ▁ is ▁ : ▁ \" , z ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( D1 == 0 and D2 == 0 and D3 == 0 ) : NEW_LINE INDENT print ( \" Infinite ▁ solutions \" ) NEW_LINE DEDENT elif ( D1 != 0 or D2 != 0 or D3 != 0 ) : NEW_LINE INDENT print ( \" No ▁ solutions \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT coeff = [ [ 2 , - 1 , 3 , 9 ] , [ 1 , 1 , 1 , 6 ] , [ 1 , - 1 , 1 , 2 ] ] NEW_LINE findSolution ( coeff ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "System of Linear Equations in three variables using Cramer 's Rule | This functions finds the determinant of Matrix ; This function finds the solution of system of linear equations using cramer 's rule ; Matrix d using coeff as given in cramer 's rule ; Matrix d1 using coeff as given in cramer 's rule ; Matrix d2 using coeff as given in cramer 's rule ; Matrix d3 using coeff as given in cramer 's rule ; Calculating Determinant of Matrices d , d1 , d2 , d3 ; Case 1 ; Coeff have a unique solution . Apply Cramer 's Rule ; calculating z using cramer 's rule ; Case 2 ; Driver Code ; storing coefficients of linear equations in coeff matrix",
        "Category": "Matrix"
    },
    {
        "ID": "12383-12383",
        "Code": "import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find larger of x ^ y and y ^ x | Python3 program to print greater of x ^ y and y ^ x ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12386-12386",
        "Code": "cm = 1000 ; NEW_LINE meter = cm / 100.0 ; NEW_LINE kilometer = cm / 100000.0 ; NEW_LINE print ( \" Length ▁ in ▁ meter ▁ = ▁ \" , meter , \" m \" ) ; NEW_LINE print ( \" Length ▁ in ▁ Kilometer ▁ = ▁ \" , kilometer , \" km \" ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to convert centimeter into meter and kilometer | Python3 program to convert centimeter into meter and kilometer ; Converting centimeter into meter and kilometer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12390-12390",
        "Code": "def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 ; NEW_LINE DEDENT DEDENT N = 4 ; NEW_LINE print ( \" Number ▁ of ▁ unmarked ▁ elements : \" , int ( countUnmarked ( N ) ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Number of unmarked integers in a special sieve | Python3 Program to determine the number of unmarked integers in a special sieve ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12396-12396",
        "Code": "def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( ( n ) ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if not n % i : NEW_LINE if n // i == i : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += i NEW_LINE sum += ( n // i ) NEW_LINE DEDENT DEDENT return sum - n NEW_LINE DEDENT def getAliquot ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE s . add ( n ) NEW_LINE next = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n not in s : NEW_LINE return n NEW_LINE s . add ( n ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( ( n ** ( 1 / 2 ) ) ) + 1 ) : NEW_LINE INDENT if not n % i : NEW_LINE sum += ( i + n // i ) NEW_LINE DEDENT if sum == n and n != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isAspiring ( n ) : NEW_LINE INDENT alq = getAliquot ( n ) NEW_LINE if ( isPerfect ( alq ) and not isPerfect ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 25 NEW_LINE if ( isAspiring ( n ) ) : NEW_LINE INDENT print ( \" Aspiring \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Aspiring \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Aspiring Number | Function to calculate sum of all proper divisors ; 1 is a proper divisor ; Note that this loop runs till square root of n ; If divisors are equal , take only one of them ; Otherwise take both ; Calculate sum of all proper divisors only ; Function to get last number of Aliquot Sequence . ; Calculate next term from previous term ; Returns true if n is perfect ; To store sum of divisors ; Find all divisors and add them ; If sum of divisors is equal to n , then n is a perfect number ; Returns true if n is aspiring else returns false ; Checking condition for aspiring ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12406-12406",
        "Code": "def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( \" % sth ▁ Centered ▁ square ▁ number : ▁ \" % n , centered_square_num ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Centered Square Number | Function to calculate Centered square number function ; Formula to calculate nth Centered square number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12411-12411",
        "Code": "def swap ( a , b , c , d ) : NEW_LINE INDENT a = a + b NEW_LINE b = a - b NEW_LINE a = a - b NEW_LINE b = b + c NEW_LINE c = b - c NEW_LINE b = b - c NEW_LINE c = c + d NEW_LINE d = c - d NEW_LINE c = c - d NEW_LINE print ( \" values ▁ after ▁ swapping ▁ are ▁ : ▁ \" ) NEW_LINE print ( \" a ▁ = ▁ \" , a ) NEW_LINE print ( \" b ▁ = ▁ \" , b ) NEW_LINE print ( \" c ▁ = ▁ \" , c ) NEW_LINE print ( \" d ▁ = ▁ \" , d ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE print ( \" values ▁ before ▁ swapping ▁ are ▁ : ▁ \" ) NEW_LINE print ( \" a ▁ = ▁ \" , a ) NEW_LINE print ( \" b ▁ = ▁ \" , b ) NEW_LINE print ( \" c ▁ = ▁ \" , c ) NEW_LINE print ( \" d ▁ = ▁ \" , d ) NEW_LINE print ( \" \" ) NEW_LINE swap ( a , b , c , d ) NEW_LINE",
        "Type": "py",
        "NL": "Swapping four variables without temporary variable | Python 3 program to swap 4 variables without using temporary variable . ; swapping a and b variables ; swapping b and c variables ; swapping c and d variables ; initialising variables ; Function call",
        "Category": "Math"
    },
    {
        "ID": "12424-12424",
        "Code": "N = 100 NEW_LINE digitSum = [ 0 ] * N NEW_LINE factorDigitSum = [ 0 ] * N NEW_LINE def sumOddDigit ( ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT digitSum [ i ] = ( digitSum [ int ( i / 10 ) ] + int ( i & 1 ) * ( i % 10 ) ) NEW_LINE DEDENT DEDENT def sumFactor ( ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE j = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i NEW_LINE while ( j < N ) : NEW_LINE INDENT factorDigitSum [ j ] = ( factorDigitSum [ j ] + digitSum [ i ] ) NEW_LINE j = j + i NEW_LINE DEDENT DEDENT DEDENT def wrapper ( q , n ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT digitSum [ i ] = 0 NEW_LINE factorDigitSum [ i ] = 0 NEW_LINE DEDENT sumOddDigit ( ) NEW_LINE sumFactor ( ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( \" { } ▁ \" . format ( factorDigitSum [ n [ i ] ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT q = 2 NEW_LINE n = [ 10 , 36 ] NEW_LINE wrapper ( q , n ) NEW_LINE",
        "Type": "py",
        "NL": "Queries on sum of odd number digit sums of all the factors of a number | Python Program to answer queries on sum of sum of odd number digits of all the factors of a number ; finding sum of odd digit number in each integer . ; for each number ; using previous number sum , finding the current number num of odd digit also , adding last digit if it is odd . ; finding sum of sum of odd digit of all the factors of a number . ; for each possible factor ; adding the contribution . ; Wrapper def ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12431-12431",
        "Code": "def number_of_digits ( n ) : NEW_LINE INDENT i = 4 NEW_LINE res = 1 NEW_LINE sum = 0 NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 NEW_LINE res += 1 NEW_LINE sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 21 NEW_LINE print ( number_of_digits ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of digits in the nth number made of given four digits | Efficient function to calculate number of digits in the nth number constructed by using 6 , 1 , 4 and 9 as digits in the ascending order . ; Number of digits increase after every i - th number where i increases in powers of 4. ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12440-12440",
        "Code": "def checkVantieghemsTheorem ( limit ) : NEW_LINE INDENT prod = 1 NEW_LINE for n in range ( 2 , limit ) : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT print ( 2 , \" is ▁ prime \" ) NEW_LINE DEDENT if ( ( ( prod - n ) % ( ( 1 << n ) - 1 ) ) == 0 ) : NEW_LINE INDENT print ( n , \" is ▁ prime \" ) NEW_LINE DEDENT prod *= ( ( 1 << n ) - 1 ) NEW_LINE DEDENT DEDENT checkVantieghemsTheorem ( 10 ) NEW_LINE",
        "Type": "py",
        "NL": "Vantieghems Theorem for Primality Test | Python3 code to verify Vantieghem 's Theorem ; Check if above condition is satisfied ; Product of previous powers of 2 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12441-12441",
        "Code": "import math NEW_LINE def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False ; NEW_LINE DEDENT prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT j = 0 ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT a [ j ] = p ; NEW_LINE primesquare [ p * p ] = True ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) ; NEW_LINE primesquare = [ False ] * ( n * n + 3 ) ; NEW_LINE a = [ 0 ] * n ; NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) ; NEW_LINE ans = 1 ; NEW_LINE for i in range ( 0 , True ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT cnt = 1 ; NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n //= a [ i ] ; NEW_LINE cnt = cnt + 1 ; NEW_LINE DEDENT ans = ans * cnt ; NEW_LINE DEDENT if ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 2 ; NEW_LINE DEDENT elif ( primesquare [ n ] ) : NEW_LINE INDENT ans = ans * 3 ; NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 ; NEW_LINE DEDENT DEDENT def sumofFactors ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr_sum = 1 ; NEW_LINE curr_term = 1 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n //= i ; NEW_LINE curr_term *= i ; NEW_LINE curr_sum += curr_term ; NEW_LINE DEDENT res *= curr_sum ; NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def checkArithmetic ( n ) : NEW_LINE INDENT count = countDivisors ( n ) ; NEW_LINE sum = sumofFactors ( n ) ; NEW_LINE return ( sum % count == 0 ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE if ( checkArithmetic ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Arithmetic Number | Python3 program to check if a number is Arithmetic number or not ; Sieve Of Eratosthenes ; 1 is not a prime number ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Storing primes in an array ; Update value in primesquare [ p * p ] , if p is prime . ; Function to count divisors ; If number is 1 , then it will have only 1 as a factor . So , total factors will be 1. ; for storing primes upto n ; Calling SieveOfEratosthenes to store prime factors of n and to store square of prime factors of n ; ans will contain total number of distinct divisors ; Loop for counting factors of n ; a [ i ] is not less than cube root n ; Calculating power of a [ i ] in n . cnt is power of prime a [ i ] in n . ; if a [ i ] is a factor of n ; incrementing power ; Calculating number of divisors . If n = a ^ p * b ^ q then total divisors of n are ( p + 1 ) * ( q + 1 ) ; First case ; Second case ; Third casse ; Returns sum of all factors of n . ; Traversing through all prime factors . ; This condition is to handle the case when n is a prime number greater than 2. ; Check if number is Arithmetic Number or not . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12443-12443",
        "Code": "mod = 1000000007 NEW_LINE N = 1000005 NEW_LINE fact = [ 0 ] * N NEW_LINE invfact = [ 0 ] * N NEW_LINE def check ( x , a , b ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( x ) : NEW_LINE INDENT if ( x % 10 != a and x % 10 != b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x += m0 NEW_LINE DEDENT return x NEW_LINE DEDENT def pregenFact ( ) : NEW_LINE INDENT fact [ 0 ] = fact [ 1 ] = 1 NEW_LINE for i in range ( 1 , 1000001 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i % mod NEW_LINE DEDENT DEDENT def pregenInverse ( ) : NEW_LINE INDENT invfact [ 0 ] = invfact [ 1 ] = 1 NEW_LINE invfact [ 1000000 ] = modInverse ( fact [ 1000000 ] , mod ) NEW_LINE for i in range ( 999999 , 0 , - 1 ) : NEW_LINE INDENT invfact [ i ] = ( ( invfact [ i + 1 ] * ( i + 1 ) ) % mod ) NEW_LINE DEDENT DEDENT def comb ( big , small ) : NEW_LINE INDENT return ( fact [ big ] * invfact [ small ] % mod * invfact [ big - small ] % mod ) NEW_LINE DEDENT def count ( a , b , n ) : NEW_LINE INDENT pregenFact ( ) NEW_LINE pregenInverse ( ) NEW_LINE if ( a == b ) : NEW_LINE INDENT return ( check ( a * n , a , b ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( check ( i * a + ( n - i ) * b , a , b ) ) : NEW_LINE INDENT ans = ( ans + comb ( n , i ) ) % mod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 4 NEW_LINE n = 11028 NEW_LINE print ( count ( a , b , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers formed by given two digit with sum having given digits | Python 3 program to count the number of numbers formed by digits a and b exactly of a length N such that the sum of the digits of the number thus formed is of digits a and b . ; function to check if sum of digits is made of a and b ; sum of digits is 0 ; if any of digits in sum is other than a and b ; calculate the modInverse V of a number in O ( log n ) ; q is quotient ; m is remainder now , process same as Euclid 's algo ; Update y and x ; Make x positive ; function to pregenerate factorials ; function to pre calculate the modInverse of factorials ; calculates the modInverse of the last factorial ; precalculates the modInverse of all factorials by formulae ; function that returns the value of nCi ; function that returns the count of numbers ; function call to pre - calculate the factorials and modInverse of factorials ; if a and b are same ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12447-12447",
        "Code": "import math NEW_LINE def sumTillX ( x , n ) : NEW_LINE INDENT odd = math . ceil ( n / 2.0 ) NEW_LINE if ( x <= odd ) : NEW_LINE INDENT return x * x ; NEW_LINE DEDENT even = x - odd ; NEW_LINE return ( ( odd * odd ) + ( even * even ) + even ) ; NEW_LINE DEDENT def rangeSum ( N , L , R ) : NEW_LINE INDENT return ( sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ) ; NEW_LINE DEDENT N = 10 NEW_LINE L = 1 NEW_LINE R = 6 NEW_LINE print ( rangeSum ( N , L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of range in a series of first odd then even natural numbers | Python 3 program to find sum in the given range in the sequence 1 3 5 7 ... . . N 2 4 6. . . N - 1 ; Function that returns sum in the range 1 to x in the sequence 1 3 5 7. ... . N 2 4 6. . . N - 1 ; number of odd numbers ; number of extra even numbers required ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12451-12451",
        "Code": "def __gcd ( a , b ) : NEW_LINE INDENT return a if ( b == 0 ) else __gcd ( b , a % b ) ; NEW_LINE DEDENT def isSplittable ( n , m ) : NEW_LINE INDENT total_sum = ( int ) ( ( n * ( n + 1 ) ) / 2 ) ; NEW_LINE sum_s1 = int ( ( total_sum + m ) / 2 ) ; NEW_LINE sum_s2 = total_sum - sum_s1 ; NEW_LINE if ( total_sum < m ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( sum_s1 + sum_s2 == total_sum and sum_s1 - sum_s2 == m ) : NEW_LINE INDENT return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 5 ; NEW_LINE m = 7 ; NEW_LINE if ( isSplittable ( n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "First N natural can be divided into two sets with given difference and co | Python3 code to determine whether numbers 1 to N can be divided into two sets such that absolute difference between sum of these two sets is M and these two sum are co - prime ; function that returns boolean value on the basis of whether it is possible to divide 1 to N numbers into two sets that satisfy given conditions . ; initializing total sum of 1 to n numbers ; since ( 1 ) total_sum = sum_s1 + sum_s2 and ( 2 ) m = sum_s1 - sum_s2 assuming sum_s1 > sum_s2 . solving these 2 equations to get sum_s1 and sum_s2 ; total_sum = sum_s1 + sum_s2 and therefore ; if total sum is less than the absolute difference then there is no way we can split n numbers into two sets so return false ; check if these two sums are integers and they add up to total sum and also if their absolute difference is m . ; Now if two sum are co - prime then return true , else return false . ; if two sums don 't add up to total  sum or if their absolute difference  is not m, then there is no way to  split n numbers, hence return false ; Driver code ; function call to determine answer",
        "Category": "Math"
    },
    {
        "ID": "12455-12455",
        "Code": "PI = 3.142 ; NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) ; NEW_LINE res = 1 ; NEW_LINE sign = 1 ; NEW_LINE fact = 1 ; NEW_LINE pow = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * ( - 1 ) ; NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; NEW_LINE pow = pow * x * x ; NEW_LINE res = res + sign * pow / fact ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT x = 50 ; NEW_LINE n = 5 ; NEW_LINE print ( round ( cosXSertiesSum ( x , 5 ) , 6 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program for sum of cos ( x ) series | Python3 program to find the sum of cos ( x ) series ; here x is in degree . we have to convert it to radian for using it with series formula , as in series expansion angle is in radian ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12461-12461",
        "Code": "import math NEW_LINE def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT n = 100 NEW_LINE print ( \" The ▁ sum ▁ of ▁ n ▁ term ▁ is : ▁ \" , summingSeries ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to print the sum of the given nth term | Python3 program to illustrate ... Summation of series ; function to calculate sum of series ; Sum of n terms is n ^ 2 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12463-12463",
        "Code": "def solve ( n , base ) : NEW_LINE INDENT result = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE result = result + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return result NEW_LINE DEDENT def printSumsOfDigits ( n ) : NEW_LINE INDENT for base in range ( 2 , n ) : NEW_LINE INDENT print ( solve ( n , base ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 8 NEW_LINE printSumsOfDigits ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of digits written in different bases from 2 to n | def to calculate sum of digit for a given base ; Sum of digits ; Calculating the number ( n ) by taking mod with the base and adding remainder to the result and parallelly reducing the num value . ; returning the result ; def calling for multiple bases ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12464-12464",
        "Code": "def check ( N , D ) : NEW_LINE INDENT temp = N * ( N + 1 ) // 2 + D NEW_LINE return ( bool ( temp % 2 == 0 ) ) NEW_LINE DEDENT N = 5 NEW_LINE M = 7 NEW_LINE if check ( N , M ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Possible two sets from first N natural numbers difference of sums as D | Function returns true if it is possible to split into two sets otherwise returns false ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12465-12465",
        "Code": "import math NEW_LINE def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( \" The ▁ Number ▁ of ▁ digits ▁ of \" . format ( n , base , dig ) ) DEDENT n = 1446 NEW_LINE base = 7 NEW_LINE findNumberOfDigits ( n , base ) NEW_LINE",
        "Type": "py",
        "NL": "Given a number N in decimal base , find number of its digits in any base ( base b ) | Python3 program to Find Number of digits in base b . ; function to print number of digits ; Calculating log using base changing property and then taking it floor and then adding 1. ; printing output ; taking inputs ; calling the method",
        "Category": "Math"
    },
    {
        "ID": "12467-12467",
        "Code": "def isValidNesbitt ( a , b , c ) : NEW_LINE INDENT A = a / ( b + c ) ; NEW_LINE B = b / ( a + c ) ; NEW_LINE C = c / ( a + b ) ; NEW_LINE inequality = A + B + C ; NEW_LINE return ( inequality >= 1.5 ) ; NEW_LINE DEDENT a = 1.0 ; NEW_LINE b = 2.0 ; NEW_LINE c = 3.0 ; NEW_LINE if ( isValidNesbitt ( a , b , c ) ) : NEW_LINE INDENT print ( \" Nesbitt ' s ▁ inequality ▁ satisfied . \" , \" ▁ for ▁ real ▁ numbers ▁ \" , a , \" , ▁ \" , b , \" , ▁ \" , c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ satisfied \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Nesbitt 's Inequality | Python3 code to verify Nesbitt 's Inequality ; 3 parts of the inequality sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12469-12469",
        "Code": "import math NEW_LINE def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i <= int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 51242183 NEW_LINE print ( \" The ▁ number ▁ of ▁ distinct ▁ prime ▁ factors ▁ is / are ▁ { } \" . format ( exactPrimeFactorCount ( n ) , end =   \" \" ) ) NEW_LINE print ( \" The ▁ value ▁ of ▁ log ( log ( n ) ) ▁ is ▁ { 0 : . 4f } \" . format ( math . log ( math . log ( n ) ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Hardy | Python3 program to count all prime factors ; A function to count prime factors of a given number n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; This condition is to handle the case when n is a prime number greater than 2 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12470-12470",
        "Code": "import math NEW_LINE def no_of_digit ( a , b ) : NEW_LINE INDENT return ( ( int ) ( b * math . log10 ( a ) ) + 1 ) NEW_LINE DEDENT a = 2 NEW_LINE b = 100 NEW_LINE print ( \" no ▁ of ▁ digits ▁ = ▁ \" , no_of_digit ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of Digits in a ^ b | Python Program to calculate no . of digits in a ^ b ; function to calculate number of digits in a ^ b ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "12476-12476",
        "Code": "def gen ( n , r ) : NEW_LINE INDENT a = r [ - 1 ] NEW_LINE a += 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT r . append ( a ) NEW_LINE a += 2 NEW_LINE DEDENT return r NEW_LINE DEDENT def conell ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE k = 1 NEW_LINE res . append ( 0 ) NEW_LINE while 1 : NEW_LINE INDENT res = gen ( k , res ) NEW_LINE k += 1 NEW_LINE j = len ( res ) - 1 NEW_LINE while j != n and j + k > n : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if j >= n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res . remove ( res [ 0 ] ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE print ( \" The ▁ first ▁ % d ▁ terms ▁ are \" % n ) NEW_LINE res = conell ( n ) NEW_LINE for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Connell Sequence | Function to generate a fixed number of even or odd terms . The size of r decides whether numbers to be generated even or odd . ; Generating the first ' n ' terms of Connell Sequence ; A dummy 0 is inserted at the beginning for consistency ; Calling function gen ( ) to generate ' k ' number of terms ; Checking if ' n ' terms are already generated ; Removing the previously inserted dummy 0 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12492-12492",
        "Code": "import math NEW_LINE def calculateDivisors ( A , B ) : NEW_LINE INDENT N = A - B NEW_LINE noOfDivisors = 0 NEW_LINE a = math . sqrt ( N ) NEW_LINE for i in range ( 1 , int ( a + 1 ) ) : NEW_LINE INDENT if ( ( N % i == 0 ) ) : NEW_LINE INDENT if ( i > B ) : NEW_LINE INDENT noOfDivisors += 1 NEW_LINE DEDENT if ( ( N / i ) != i and ( N / i ) > B ) : NEW_LINE INDENT noOfDivisors += 1 ; NEW_LINE DEDENT DEDENT DEDENT return noOfDivisors NEW_LINE DEDENT def numberOfPossibleWaysUtil ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( A < B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT noOfDivisors = 0 NEW_LINE noOfDivisors = calculateDivisors ; NEW_LINE return noOfDivisors NEW_LINE DEDENT def numberOfPossibleWays ( A , B ) : NEW_LINE INDENT noOfSolutions = numberOfPossibleWaysUtil ( A , B ) NEW_LINE if ( noOfSolutions == - 1 ) : NEW_LINE INDENT print ( \" For ▁ A ▁ = ▁ \" , A , \" ▁ and ▁ B ▁ = ▁ \" , B , \" , ▁ X ▁ can ▁ take ▁ Infinitely ▁ many ▁ values \" , \" ▁ greater ▁ than ▁ \" , A ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" For ▁ A ▁ = ▁ \" , A , \" ▁ and ▁ B ▁ = ▁ \" , B , \" , ▁ X ▁ can ▁ take ▁ \" , noOfSolutions , \" ▁ values \" ) NEW_LINE DEDENT DEDENT A = 26 NEW_LINE B = 2 NEW_LINE numberOfPossibleWays ( A , B ) NEW_LINE A = 21 NEW_LINE B = 5 NEW_LINE numberOfPossibleWays ( A , B ) NEW_LINE",
        "Type": "py",
        "NL": "Number of solutions to Modular Equations | Python Program to find number of possible values of X to satisfy A mod X = B ; Returns the number of divisors of ( A - B ) greater than B ; if N is divisible by i ; count only the divisors greater than B ; checking if a divisor isnt counted twice ; Utility function to calculate number of all possible values of X for which the modular equation holds true ; if A = B there are infinitely many solutions to equation or we say X can take infinitely many values > A . We return - 1 in this case ; if A < B , there are no possible values of X satisfying the equation ; the last case is when A > B , here we calculate the number of divisors of ( A - B ) , which are greater than B ; Wrapper function for numberOfPossibleWaysUtil ( ) ; if infinitely many solutions available ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12494-12494",
        "Code": "power = [ ] NEW_LINE def nextPower ( N ) : NEW_LINE INDENT global power NEW_LINE carry = 0 NEW_LINE for i in range ( 0 , len ( power ) ) : NEW_LINE INDENT prod = ( power [ i ] * N ) + carry NEW_LINE power [ i ] = prod % 10 NEW_LINE carry = ( int ) ( prod / 10 ) NEW_LINE DEDENT while ( carry ) : NEW_LINE INDENT power . append ( carry % 10 ) NEW_LINE carry = ( int ) ( carry / 10 ) NEW_LINE DEDENT DEDENT def printPowerNumber ( X , N ) : NEW_LINE INDENT global power NEW_LINE power . append ( 1 ) NEW_LINE res = [ ] NEW_LINE for i in range ( 1 , X + 1 ) : NEW_LINE INDENT nextPower ( N ) NEW_LINE res . append ( power [ - 1 ] ) NEW_LINE res . append ( power [ 0 ] ) NEW_LINE DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT N = 19 NEW_LINE X = 4 NEW_LINE printPowerNumber ( X , N ) NEW_LINE",
        "Type": "py",
        "NL": "Form a number using corner digits of powers | Storing N raised to power 0 ; Find next power by multiplying N with current power ; Store digits of Power one by one . ; Calculate carry . ; Store carry in Power array . ; Prints number formed by corner digits of powers of N . ; Initializing empty result ; One by one compute next powers and add their corner digits . ; Call Function that store power in Power array . ; Store unit and last digits of power in res . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "125-125",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isFullTree ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return True NEW_LINE DEDENT if root . left is None and root . right is None : NEW_LINE INDENT return True NEW_LINE DEDENT if root . left is not None and root . right is not None : NEW_LINE INDENT return ( isFullTree ( root . left ) and isFullTree ( root . right ) ) NEW_LINE DEDENT return False NEW_LINE DEDENT root = Node ( 10 ) ; NEW_LINE root . left = Node ( 20 ) ; NEW_LINE root . right = Node ( 30 ) ; NEW_LINE root . left . right = Node ( 40 ) ; NEW_LINE root . left . left = Node ( 50 ) ; NEW_LINE root . right . left = Node ( 60 ) ; NEW_LINE root . right . right = Node ( 70 ) ; NEW_LINE root . left . left . left = Node ( 80 ) ; NEW_LINE root . left . left . right = Node ( 90 ) ; NEW_LINE root . left . right . left = Node ( 80 ) ; NEW_LINE root . left . right . right = Node ( 90 ) ; NEW_LINE root . right . left . left = Node ( 80 ) ; NEW_LINE root . right . left . right = Node ( 90 ) ; NEW_LINE root . right . right . left = Node ( 80 ) ; NEW_LINE root . right . right . right = Node ( 90 ) ; NEW_LINE if isFullTree ( root ) : NEW_LINE INDENT print \" The ▁ Binary ▁ tree ▁ is ▁ full \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Binary ▁ tree ▁ is ▁ not ▁ full \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a binary tree is a full binary tree or not | Constructor of the node class for creating the node ; Checks if the binary tree is full or not ; If empty tree ; If leaf node ; If both left and right subtress are not None and left and right subtress are full ; We reach here when none of the above if condiitions work ; Driver Program",
        "Category": "Binary Tree"
    },
    {
        "ID": "12502-12502",
        "Code": "import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT c = ( - 2 * num ) ; NEW_LINE b = 1 ; NEW_LINE a = 1 ; NEW_LINE d = ( b * b ) - ( 4 * a * c ) ; NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) // ( 2 * a ) ; NEW_LINE root2 = ( - b - math . sqrt ( d ) ) // ( 2 * a ) ; NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return root1 ; NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return root2 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) ; NEW_LINE if ( ( sr - math . floor ( sr ) ) == 0 ) : NEW_LINE INDENT return math . floor ( sr ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT def findS ( s ) : NEW_LINE INDENT sr = isPerfectSquare ( s ) ; NEW_LINE if ( sr == - 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return int ( isTriangular ( sr ) ) ; NEW_LINE DEDENT s = 9 ; NEW_LINE n = findS ( s ) ; NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Squared triangular number ( Sum of cubes ) | Python3 program to check if a given number is sum of cubes of natural numbers . ; Returns root of n ( n + 1 ) / 2 = num if num is triangular ( or integerroot exists ) . Else returns - 1. ; Considering the equation n * ( n + 1 ) / 2 = num . The equation is : a ( n ^ 2 ) + bn + c = 0 \"; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Returns square root of x if it is perfect square . Else returns - 1. ; Find floating point value of square root of x . ; If square root is an integer ; Function to find if the given number is sum of the cubes of first n natural numbers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12504-12504",
        "Code": "def findKthGoodNo ( n ) : NEW_LINE INDENT lastDig = n % 10 NEW_LINE if ( lastDig >= 0 and lastDig <= 4 ) : NEW_LINE INDENT return n << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n << 1 ) + 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( findKthGoodNo ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number with even sum of digits | Function to find kth good number . ; Find the last digit of n . ; If last digit is between 0 to 4 then return 2 * n . ; If last digit is between 5 to 9 then return 2 * n + 1. ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12508-12508",
        "Code": "def checkDigits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def largestNumber ( n ) : NEW_LINE INDENT for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if ( checkDigits ( i ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT N = 23 ; NEW_LINE print ( largestNumber ( N ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Largest even digit number not greater than N | function to check if all digits are even of a given number ; iterate for all digits ; if digit is odd ; all digits are even ; function to return the largest number with all digits even ; Iterate till we find a number with all digits even ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "1251-1251",
        "Code": "from math import sqrt NEW_LINE def findGreatest ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if ( result != arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif ( result == arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 17 , 2 , 1 , 15 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGreatest ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find pair with greatest product in array | Python3 program to find the largest product number ; Function to find greatest number ; Store occurrences of all elements in hash array ; Sort the array and traverse all elements from end . ; For every element , check if there is another element which divides it . ; Check if the result value exists in array or not if yes the return arr [ i ] ; To handle the case like arr [ i ] = 4 and arr [ j ] = 2 ; Drivers code",
        "Category": "Hash Table"
    },
    {
        "ID": "12518-12518",
        "Code": "MAX = 50002 ; NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while ( x >= z ) : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT return count NEW_LINE DEDENT def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def countWays ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) NEW_LINE if ( powers == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ( ( ans - 1 ) % m ) < 0 ) : NEW_LINE INDENT return ( ans - 1 + m ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 4 NEW_LINE m = 7 NEW_LINE print ( countWays ( n , m ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Expressing factorial n as sum of consecutive numbers | Python 3 program to count number of ways we can express a factorial as sum of consecutive numbers ; sieve of Eratosthenes to compute the prime numbers ; Store all prime numbers ; function to calculate the largest power of a prime in a number ; Modular multiplication to avoid the overflow of multiplication Please see below for details https : www . geeksforgeeks . org / how - to - avoid - overflow - in - modular - multiplication / ; Returns count of ways to express n ! as sum of consecutives . ; We skip 2 ( First prime ) as we need to consider only odd primes ; compute the largest power of prime ; if the power of current prime number is zero in N ! , power of primes greater than current prime number will also be zero , so break out from the loop ; multiply the result at every step ; subtract 1 to exclude the case of 1 being an odd divisor ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12519-12519",
        "Code": "def calculateProbability ( N ) : NEW_LINE INDENT probability = N / ( N + 1 ) NEW_LINE return probability NEW_LINE DEDENT N = 1 NEW_LINE probabilityMax = calculateProbability ( N ) NEW_LINE print ( \" Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ \" , N , \" is , ▁ % .4f \" % probabilityMax ) NEW_LINE N = 2 NEW_LINE probabilityMax = calculateProbability ( N ) ; NEW_LINE print ( \" Maximum ▁ Probability ▁ for ▁ N ▁ = \" , N , \" is , ▁ % .4f \" % probabilityMax ) NEW_LINE N = 10 NEW_LINE probabilityMax = calculateProbability ( N ) ; NEW_LINE print ( \" Maximum ▁ Probability ▁ for ▁ N ▁ = \" , N , \" is , ▁ % .4f \" % probabilityMax ) NEW_LINE",
        "Type": "py",
        "NL": "Maximizing Probability of one type from N containers | Returns the Maximum probability for Drawing 1 copy of number A from N containers with N copies each of numbers A and B ; Pmax = N / ( N + 1 ) ; 1. N = 1 ; 2. N = 2 ; 3. N = 10",
        "Category": "Math"
    },
    {
        "ID": "12524-12524",
        "Code": "import math NEW_LINE def sumofFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; curr_sum = 1 ; curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def checkFriendly ( n , m ) : NEW_LINE INDENT sumFactors_n = sumofFactors ( n ) NEW_LINE sumFactors_m = sumofFactors ( m ) NEW_LINE gcd_n = gcd ( n , sumFactors_n ) NEW_LINE gcd_m = gcd ( m , sumFactors_m ) NEW_LINE if ( n // gcd_n == m // gcd_m and sumFactors_n // gcd_n == sumFactors_m // gcd_m ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 6 ; m = 28 NEW_LINE if ( checkFriendly ( n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the given two numbers are friendly pair or not | Check if the given two number are friendly pair or not . ; Returns sum of all factors of n . ; Traversing through all prime factors . ; THE BELOW STATEMENT MAKES IT BETTER THAN ABOVE METHOD AS WE REDUCE VALUE OF n . ; This condition is to handle the case when n is a prime number greater than 2. ; Function to return gcd of a and b ; Function to check if the given two number are friendly pair or not . ; Finding the sum of factors of n and m ; Finding gcd of n and sum of its factors . ; Finding gcd of m and sum of its factors . ; checking is numerator and denominator of abundancy index of both number are equal or not . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12530-12530",
        "Code": "def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = pow ( a , n ) + pow ( b , n ) NEW_LINE c = pow ( pow_sum , 1.0 / n ) NEW_LINE c_pow = pow ( int ( c ) , n ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( \" Count ▁ example ▁ found \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" No ▁ counter ▁ example ▁ within ▁ given ▁ range ▁ and ▁ data \" ) NEW_LINE DEDENT testSomeNumbers ( 10 , 3 ) NEW_LINE",
        "Type": "py",
        "NL": "Fermat 's Last Theorem | Python3 program to verify fermat 's last theorem for a given range and n. ; Check if there exists a triplet such that a ^ n + b ^ n = c ^ n ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12540-12540",
        "Code": "def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT digit = 3 ; num = 7 NEW_LINE print ( totalSumDivisibleByNum ( digit , num ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of n digit numbers divisible by a given number | find the Sum of having n digit and divisible by the number ; compute the first and last term ; first number which is divisible by given number ; last number which is divisible by given number ; total divisible number ; return the total sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12551-12551",
        "Code": "import math NEW_LINE def isValid ( i , m ) : NEW_LINE INDENT sq_i = math . sqrt ( i ) NEW_LINE sq = min ( m , sq_i ) NEW_LINE for j in range ( 2 , sq + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findLargestNum ( n , m ) : NEW_LINE INDENT for i in range ( n , m , - 1 ) : NEW_LINE INDENT if ( isValid ( i , m ) ) : NEW_LINE INDENT print ( \" { } \" . format ( i ) ) ; NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Number Doesn ' t Exists \" ) NEW_LINE DEDENT n = 16 NEW_LINE m = 3 NEW_LINE findLargestNum ( n , m ) NEW_LINE",
        "Type": "py",
        "NL": "Largest number in [ 2 , 3 , . . n ] which is co | Python3 code to find Largest number in [ 2 , 3 , . . n ] which is co - prime with numbers in [ 2 , 3 , . . m ] ; Returns true if i is co - prime with numbers in set [ 2 , 3 , ... m ] ; Running the loop till square root of n to reduce the time complexity from n ; Find the minimum of square root of n and m to run the loop until the smaller one ; Check from 2 to min ( m , sqrt ( n ) ) ; def to find the largest number less than n which is Co - prime with all numbers from 2 to m ; Iterating from n to m + 1 to find the number ; checking every number for the given conditions ; The first number which satisfy the conditions is the answer ; If there is no number which satisfy the conditions , then print number does not exist . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12552-12552",
        "Code": "def georgeCantor ( n ) : NEW_LINE INDENT i = 1 NEW_LINE j = 1 NEW_LINE k = 1 NEW_LINE while k < n : NEW_LINE INDENT j += 1 NEW_LINE k += 1 NEW_LINE if k == n : NEW_LINE INDENT break NEW_LINE DEDENT while j > 1 and k < n : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT if k == n : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE if k == n : NEW_LINE INDENT break NEW_LINE DEDENT while i > 1 and k < n : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT print ( \" N - th ▁ term ▁ : ▁ % d / % d \" % ( i , j ) ) NEW_LINE DEDENT n = 15 NEW_LINE georgeCantor ( n ) NEW_LINE",
        "Type": "py",
        "NL": "N | Python3 program to find N - th term in George Cantor set of rational numbers ; let i = numerator ; let j = denominator ; to keep the check of no . of terms ; loop till k is not equal to n ; check if k is already equal to N then the first term is the required rational number ; loop for traversing from right to left downwards diagonally ; loop for traversing from left to right upwards diagonally ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12560-12560",
        "Code": "import math NEW_LINE def pronic_check ( n ) : NEW_LINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 56 NEW_LINE if ( pronic_check ( n ) == True ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given number is Pronic | Efficient Approach | Python program to check if a number is pronic or not ; function to check Pronic Number ; Checking Pronic Number by multiplying consecutive numbers ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12568-12568",
        "Code": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT if ( x >= 0 ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr * sr ) == float ( x ) ) NEW_LINE DEDENT return false NEW_LINE DEDENT x = 2502 NEW_LINE if ( isPerfectSquare ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if given number is perfect square | Python program to find if x is a perfect square . ; Find floating point value of square root of x . ; sqrt function returns floating value so we have to convert it into integer return boolean T / F ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12569-12569",
        "Code": "import math NEW_LINE def checkperfectsquare ( x ) : NEW_LINE INDENT if ( math . ceil ( math . sqrt ( n ) ) == math . floor ( math . sqrt ( n ) ) ) : NEW_LINE INDENT print ( \" perfect ▁ square \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" not ▁ a ▁ perfect ▁ square \" ) NEW_LINE DEDENT DEDENT n = 49 NEW_LINE checkperfectsquare ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Check if given number is perfect square | Python3 program for the above approach ; If ceil and floor are equal the number is a perfect square ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12572-12572",
        "Code": "def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( checkFibinnary ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Fibbinary Numbers ( No consecutive 1 s in binary ) | function to check if binary representation of an integer has consecutive 1 s ; stores the previous last bit initially as 0 ; if current last bit and previous last bit is 1 ; stores the last bit ; right shift the number ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "12573-12573",
        "Code": "MAX = 100000 NEW_LINE def multiply ( x , res , res_size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( res_size ) : NEW_LINE INDENT prod = res [ i ] * x + carry NEW_LINE res [ i ] = prod % 10 NEW_LINE carry = prod // 10 NEW_LINE DEDENT while ( carry ) : NEW_LINE INDENT res [ res_size ] = carry % 10 NEW_LINE carry = carry // 10 NEW_LINE res_size += 1 NEW_LINE DEDENT return res_size NEW_LINE DEDENT def power ( x , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE return NEW_LINE DEDENT res = [ 0 for i in range ( MAX ) ] NEW_LINE res_size = 0 NEW_LINE temp = x NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT res [ res_size ] = temp % 10 ; NEW_LINE res_size += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res_size = multiply ( x , res , res_size ) NEW_LINE DEDENT print ( x , \" ^ \" , n , \" ▁ = ▁ \" , end = \" \" ) NEW_LINE for i in range ( res_size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( res [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT exponent = 100 NEW_LINE base = 2 NEW_LINE power ( base , exponent ) NEW_LINE",
        "Type": "py",
        "NL": "Writing power function for large numbers | Maximum number of digits in output ; This function multiplies x with the number represented by res [ ] . res_size is size of res [ ] or number of digits in the number represented by res [ ] . This function uses simple school mathematics for multiplication . This function may value of res_size and returns the new value of res_size ; Initialize carry ; One by one multiply n with individual digits of res [ ] ; Store last digit of ' prod ' in res [ ] ; Put rest in carry ; Put carry in res and increase result size ; This function finds power of a number x ; printing value \"1\" for power = 0 ; Initialize result ; Multiply x n times ( x ^ n = x * x * x ... . n times ) ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "12574-12574",
        "Code": "import math NEW_LINE def check ( n , p ) : NEW_LINE INDENT maximum = - 1 NEW_LINE while ( not ( n % 2 ) ) : NEW_LINE INDENT maximum = max ( maximum , 2 ) NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maximum = max ( maximum , i ) NEW_LINE n = int ( n / i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maximum = max ( maximum , n ) NEW_LINE DEDENT return ( maximum <= p ) NEW_LINE DEDENT n = 24 NEW_LINE p = 7 NEW_LINE if ( check ( n , p ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "P | Python 3 program to check if a number is a p - smooth number or not ; function to check if number n is a P - smooth number or not ; prime factorise it by 2 ; if the number is divisible by 2 ; check for all the possible numbers that can divide it ; prime factorize it by i ; stores the maximum if maximum and i , if i divides the number ; if n at the end is a prime number , then it a divisor itself ; Driver program to test above function",
        "Category": "Math"
    },
    {
        "ID": "12581-12581",
        "Code": "from math import gcd NEW_LINE def findHcf ( arr , size ) : NEW_LINE INDENT ans = arr [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , size , 1 ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] [ 0 ] ) NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def findLcm ( arr , size ) : NEW_LINE INDENT ans = arr [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , size , 1 ) : NEW_LINE INDENT ans = int ( ( ( ( arr [ i ] [ 1 ] * ans ) ) / ( gcd ( arr [ i ] [ 1 ] , ans ) ) ) ) NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def hcfOfFraction ( arr , size ) : NEW_LINE INDENT hcf_of_num = findHcf ( arr , size ) NEW_LINE lcm_of_deno = findLcm ( arr , size ) NEW_LINE result = [ 0 for i in range ( 2 ) ] NEW_LINE result [ 0 ] = hcf_of_num NEW_LINE result [ 1 ] = lcm_of_deno NEW_LINE i = int ( result [ 0 ] / 2 ) NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( ( result [ 1 ] % i == 0 ) and ( result [ 0 ] % i == 0 ) ) : NEW_LINE INDENT result [ 1 ] = int ( result [ 1 ] / i ) NEW_LINE result [ 0 ] = ( result [ 0 ] / i ) NEW_LINE DEDENT DEDENT return ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT size = 4 NEW_LINE arr = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr [ i ] = [ 0 for i in range ( 2 ) ] NEW_LINE DEDENT arr [ 0 ] [ 0 ] = 9 NEW_LINE arr [ 0 ] [ 1 ] = 10 NEW_LINE arr [ 1 ] [ 0 ] = 12 NEW_LINE arr [ 1 ] [ 1 ] = 25 NEW_LINE arr [ 2 ] [ 0 ] = 18 NEW_LINE arr [ 2 ] [ 1 ] = 35 NEW_LINE arr [ 3 ] [ 0 ] = 21 NEW_LINE arr [ 3 ] [ 1 ] = 40 NEW_LINE result = hcfOfFraction ( arr , size ) NEW_LINE print ( result [ 0 ] , \" , \" , result [ 1 ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "HCF of array of fractions ( or rational numbers ) | Python 3 program to find HCF of array of ; find hcf of numerator series ; return hcf of numerator ; find lcm of denominator series ; ans contains LCM of arr [ 0 ] [ 1 ] , . . arr [ i ] [ 1 ] ; return lcm of denominator ; Core Function ; found hcf of numerator ; found lcm of denominator ; return result ; Driver Code ; Initialize the every row with size 2 ( 1 for numerator and 2 for denominator ) ; function for calculate the result ; print the result",
        "Category": "Math"
    },
    {
        "ID": "12583-12583",
        "Code": "import math NEW_LINE def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplusperfect ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check Plus Perfect Number | Python 3 implementation to check if the number is plus perfect or not ; function to check plus perfect number ; calculating number of digits ; calculating plus perfect number ; checking whether number is plus perfect or not ; driver program",
        "Category": "Math"
    },
    {
        "ID": "12586-12586",
        "Code": "def day_of_the_week ( y , m , d ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE if ( m < 3 ) : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT day = 13 NEW_LINE month = 7 NEW_LINE year = 2017 NEW_LINE print ( day_of_the_week ( year , month , day ) ) NEW_LINE",
        "Type": "py",
        "NL": "Tomohiko Sakamoto 's Algorithm | function to implement tomohiko sakamoto algorithm ; array with leading number of days values ; if month is less than 3 reduce year by 1 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12588-12588",
        "Code": "import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return sum / freqSum NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ [ 0 ] for i in range ( 0 , n ) ] NEW_LINE sum = 0 NEW_LINE freqSum = 0 NEW_LINE sd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( groupedSD ( lower_limit , upper_limit , freq , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to implement standard deviation of grouped data | Python Program to implement standard deviation of grouped data . ; Function to find mean of grouped data . ; Function to find standard deviation of grouped data . ; Formula to find standard deviation of grouped data . ; Declare and initialize the lower limit of interval . ; Declare and initialize the upper limit of interval . ; Calculating the size of array .",
        "Category": "Math"
    },
    {
        "ID": "12598-12598",
        "Code": "import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm / n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return ( math . sqrt ( sm / ( n - 1 ) ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) / ( math . sqrt ( n ) ) NEW_LINE DEDENT arr = [ 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to implement standard error of mean | Python 3 Program to implement standard error of mean . ; Function to find sample mean . ; loop to calculate sum of array elements . ; Function to calculate sample standard deviation . ; Function to calculate sample error . ; Formula to find sample error . ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "12599-12599",
        "Code": "import math NEW_LINE def StepstoReachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE n = math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8.0 * target ) ) / 2 ) NEW_LINE sum = n * ( n + 1 ) / 2 NEW_LINE if ( sum == target ) : NEW_LINE INDENT return n NEW_LINE DEDENT d = sum - target NEW_LINE if ( ( int ( d ) & 1 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( int ( d ) & 1 ) : NEW_LINE INDENT return n + 2 NEW_LINE DEDENT return n + 1 NEW_LINE DEDENT DEDENT target = 5 NEW_LINE print ( StepstoReachTarget ( target ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum moves to reach target on a infinite line | Set 2 | Python code to find minimum moves to reach target ; Function to find minimum steps to reach target ; Handling negatives by symmetry ; Keep moving while sum is smaller i . e calculating n ; case 1 : d is even ; d is odd ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "12600-12600",
        "Code": "def Calculate_GST ( org_cost , N_price ) : NEW_LINE INDENT return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; NEW_LINE DEDENT org_cost = 100 NEW_LINE N_price = 120 NEW_LINE print ( \" GST ▁ = ▁ \" , end = ' ' ) NEW_LINE print ( round ( Calculate_GST ( org_cost , N_price ) ) , end = ' ' ) NEW_LINE print ( \" % \" ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate GST from original and net prices | Python3 Program to compute GST from original and net prices . ; return value after calculate GST % ; Driver program to test above functions",
        "Category": "Math"
    },
    {
        "ID": "12618-12618",
        "Code": "def Mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm // n NEW_LINE DEDENT def meanAbsoluteDeviation ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsoluteDeviation ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Mean Absolute Deviation | Function to find mean of the array elements . ; Calculate sum of all elements . ; Function to find mean absolute deviation of given elements . ; Calculate the sum of absolute deviation about mean . ; Return mean absolute deviation about mean . ; Driver function .",
        "Category": "Array"
    },
    {
        "ID": "12621-12621",
        "Code": "def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 ; upCost = 30 NEW_LINE lowQuant = 5 ; upQuant = 12 ; r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if it is possible to get a ratio from given ranges of costs and quantities | Returns true if it is possible to get ratio r from given cost and quantity ranges . ; Calculating cost corresponding to value of i ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12623-12623",
        "Code": "def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE ' NEW_LINE",
        "Type": "py",
        "NL": "Find N integers with given difference between product and sum | Function to implement calculation ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12629-12629",
        "Code": "import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Program to print non square numbers | Python 3 program to print first n non - square numbers . ; Returns n - th non - square number . ; loop to print non squares below n ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12633-12633",
        "Code": "def trailingZero ( x ) : NEW_LINE INDENT i = 5 NEW_LINE count = 0 NEW_LINE while ( x > i ) : NEW_LINE INDENT count = count + x // i NEW_LINE i = i * 5 NEW_LINE DEDENT return count NEW_LINE DEDENT def countProductTrailing ( M , N ) : NEW_LINE INDENT return trailingZero ( N ) + trailingZero ( M ) NEW_LINE DEDENT N = 67 NEW_LINE M = 98 NEW_LINE print ( countProductTrailing ( N , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Trailing number of 0 s in product of two factorials | Returns number of zeros in factorial n ; Dividing x by powers of 5 and update count ; Returns count of trailing zeros in M ! x N ! ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "12634-12634",
        "Code": "def countZeros ( a , n ) : NEW_LINE INDENT count2 = 0 NEW_LINE count5 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 2 NEW_LINE count2 = count2 + 1 NEW_LINE DEDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 5 NEW_LINE count5 = count5 + 1 NEW_LINE DEDENT DEDENT if ( count2 < count5 ) : NEW_LINE INDENT return count2 NEW_LINE DEDENT else : NEW_LINE INDENT return count5 NEW_LINE DEDENT DEDENT a = [ 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ] NEW_LINE n = len ( a ) NEW_LINE print ( countZeros ( a , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of trailing zeros in product of array | Returns count of zeros in product of array ; count number of 2 s in each element ; count number of 5 s in each element ; return the minimum ; Driven Program",
        "Category": "Math"
    },
    {
        "ID": "12636-12636",
        "Code": "import sys NEW_LINE def checkTrimorphic ( num ) : NEW_LINE INDENT cube = num * num * num NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num % 10 != cube % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num / 10 ) NEW_LINE cube = int ( cube / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def nthTrimorphic ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( sys . maxsize ) : NEW_LINE INDENT if ( checkTrimorphic ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( nthTrimorphic ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Trimorphic Number | Python3 program to find nth Trimorphic number ; Functions to find nth Trimorphic number ; Comparing the digits ; Return false , if any digit of num doesn ' t ▁ match ▁ with ▁ ▁ its ▁ cube ' s digits from last ; Reduce num and cube ; Check in max int size ; check number is Trimorphic or not ; if counter is equal to the n then return nth number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12637-12637",
        "Code": "def reachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE sum = 0 NEW_LINE step = 0 NEW_LINE while ( sum < target or ( sum - target ) % 2 != 0 ) : NEW_LINE INDENT step = step + 1 NEW_LINE sum = sum + step NEW_LINE DEDENT return step NEW_LINE DEDENT target = 5 NEW_LINE print ( reachTarget ( target ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find minimum moves to reach target on an infinite line | Python 3 program to find minimum moves to reach target if we can move i steps in i - th move . ; Handling negatives by symmetry ; Keep moving while sum is smaller or difference is odd . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12641-12641",
        "Code": "def sieve ( n , prime ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def printPrimeTriplets ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE sieve ( n , prime ) NEW_LINE print ( \" The ▁ prime ▁ triplets ▁ from ▁ 1 ▁ to ▁ \" , n , \" are ▁ : \" ) NEW_LINE for i in range ( 2 , n - 6 + 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] ) : NEW_LINE INDENT print ( i , ( i + 2 ) , ( i + 6 ) ) NEW_LINE DEDENT elif ( prime [ i ] and prime [ i + 4 ] and prime [ i + 6 ] ) : NEW_LINE INDENT print ( i , ( i + 4 ) , ( i + 6 ) ) NEW_LINE DEDENT DEDENT DEDENT n = 25 NEW_LINE printPrimeTriplets ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Prime Triplet | function to detect prime number using sieve method https : www . geeksforgeeks . org / sieve - of - eratosthenes / to detect prime number ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; function to print prime triplets ; Finding all primes from 1 to n ; triplets of form ( p , p + 2 , p + 6 ) ; triplets of form ( p , p + 4 , p + 6 ) ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "12649-12649",
        "Code": "def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT first = ( 3 , 2 ) NEW_LINE sec = ( 3 , 4 ) NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( str ( res [ 0 ] ) + \" / \" + str ( res [ 1 ] ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to compare two fractions | Get max of the two fractions ; Declare nume1 and nume2 for get the value of first numerator and second numerator ; Compute ad - bc ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12657-12657",
        "Code": "import math NEW_LINE pwr = [ 0 ] * 10 NEW_LINE def isMunchhausen ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE temp = n NEW_LINE while ( temp ) : NEW_LINE INDENT sm = sm + pwr [ ( temp % 10 ) ] NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sm == n ) NEW_LINE DEDENT def printMunchhausenNumbers ( n ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT pwr [ i ] = math . pow ( ( float ) ( i ) , ( float ) ( i ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( isMunchhausen ( i ) ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT n = 10000 NEW_LINE printMunchhausenNumbers ( n ) NEW_LINE",
        "Type": "py",
        "NL": "MÃ ¼ nchhausen Number | Python 3 code for MA14nchhausen Number ; pwr [ i ] is going to store i raised to power i . ; Function to check out whether the number is MA14nchhausen Number or not ; Precompute i raised to power i for every i ; The input here is fixed i . e . it will check up to n ; check the integer for MA14nchhausen Number , if yes then print out the number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12658-12658",
        "Code": "def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 ; NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 2 NEW_LINE k = 1 NEW_LINE ans = kthdigit ( a , b , k ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "K | Python3 code to compute k - th digit in a ^ b ; computin a ^ b in python ; getting last digit ; increasing count by 1 ; if current number is required digit ; remove last digit ; driver code",
        "Category": "Math"
    },
    {
        "ID": "12659-12659",
        "Code": "import math NEW_LINE def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT N = 12 NEW_LINE if ( isPentagonal ( N ) ) : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( \" is ▁ pentagonal ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( \" is ▁ not ▁ pentagonal \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check if N is a Pentagonal Number | python3 program to check pentagonal numbers . ; Function to determine if N is pentagonal or not . ; Substitute values of i in the formula . ; Driver method",
        "Category": "Math"
    },
    {
        "ID": "12663-12663",
        "Code": "def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find unit digit of x raised to power y | Returns unit digit of x raised to power y ; Initialize result as 1 to handle case when y is 0. ; One by one multiply with x mod 10 to avoid overflow . ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "12669-12669",
        "Code": "def findDivisor ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return y NEW_LINE DEDENT return 2 NEW_LINE DEDENT x = 3 NEW_LINE y = 16 NEW_LINE print ( findDivisor ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Max occurring divisor in an interval | function to find max occurring divisor interval [ x , y ] ; if there is only one number in the in the interval , return that number ; otherwise , 2 is max occurring divisor ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "12676-12676",
        "Code": "def func ( x ) : NEW_LINE INDENT return ( float ( 1 ) / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT interval_size = ( float ( upper_limit - lower_limit ) / interval_limit ) NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) ; NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( ( float ( 3 * interval_size ) / 8 ) * sum ) NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( round ( integral_res , 6 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to implement Simpson 's 3/8 rule | Given function to be integrated ; Function to perform calculations ; Calculates value till integral limit ; driver function",
        "Category": "Math"
    },
    {
        "ID": "12678-12678",
        "Code": "def maxArea ( A ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( A ) - 1 NEW_LINE area = 0 NEW_LINE while l < r : NEW_LINE INDENT area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) NEW_LINE if A [ l ] < A [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return area NEW_LINE DEDENT a = [ 1 , 5 , 4 , 3 ] NEW_LINE b = [ 3 , 1 , 2 , 4 , 5 ] NEW_LINE print ( maxArea ( a ) ) NEW_LINE print ( maxArea ( b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Container with Most Water | Python3 code for Max Water Container ; Calculating the max area ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "12679-12679",
        "Code": "import math NEW_LINE def LCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( math . gcd ( a , b ) ) NEW_LINE DEDENT def lcmOfNumerator ( vect ) : NEW_LINE INDENT lcm = vect [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , len ( vect ) ) : NEW_LINE INDENT lcm = LCM ( vect [ i ] [ 0 ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def gcdOfDemoninators ( vect ) : NEW_LINE INDENT gcd = vect [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , len ( vect ) ) : NEW_LINE INDENT gcd = math . gcd ( vect [ i ] [ 1 ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT def lcmOfRationals ( vect ) : NEW_LINE INDENT print ( lcmOfNumerator ( vect ) , \" / \" , gcdOfDemoninators ( vect ) , sep = \" \" ) NEW_LINE DEDENT vect = [ ] NEW_LINE vect . append ( ( 2 , 7 ) ) NEW_LINE vect . append ( ( 3 , 14 ) ) NEW_LINE vect . append ( ( 5 , 3 ) ) NEW_LINE lcmOfRationals ( vect ) NEW_LINE",
        "Type": "py",
        "NL": "Find LCM of rational numbers | Python program to find LCM of given array ; get lcm of two numbers ; Finds LCM of numerators ; calculate the lcm of all numerators ; return all numerator lcm ; Get GCD of all the denominators ; calculate the gcd of all the denominators ; return all denominator gcd ; find lcm of all the rational number ; return the LCM of all numerator / GCD of all denominator ; Driver code ; give rational number 2 / 7 , 3 / 14 , 5 / 3 make pair as a numerator and denominator",
        "Category": "Math"
    },
    {
        "ID": "12680-12680",
        "Code": "def focal_length_concave ( R ) : NEW_LINE INDENT return R / 2 NEW_LINE DEDENT def focal_length_convex ( R ) : NEW_LINE INDENT return - ( R / 2 ) NEW_LINE DEDENT R = 30 ; NEW_LINE print ( \" Focal ▁ length ▁ of ▁ spherical ▁ concave ▁ mirror ▁ is ▁ : \" , focal_length_concave ( R ) , \" ▁ units \" ) NEW_LINE print ( \" Focal ▁ length ▁ of ▁ spherical ▁ convex ▁ mirror ▁ is ▁ : ▁ \" , focal_length_convex ( R ) , \" ▁ units \" ) NEW_LINE",
        "Type": "py",
        "NL": "Program to determine focal length of a spherical mirror | Determines focal length of a spherical concave mirror ; Determines focal length of a spherical convex mirror ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "12681-12681",
        "Code": "def focal_length ( image_distance , object_distance ) NEW_LINE INDENT : return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) NEW_LINE DEDENT image_distance = 2 NEW_LINE object_distance = 50 NEW_LINE result = focal_length ( image_distance , object_distance ) NEW_LINE print ( \" Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ \" , result , \" ▁ units . \" ) NEW_LINE",
        "Type": "py",
        "NL": "Program for focal length of a lens | Function to determine the focal length of a lens ; Variable to store the distance between the lens and the image ; Variable to store the distance between the lens and the object",
        "Category": "Math"
    },
    {
        "ID": "12687-12687",
        "Code": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def twinPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and abs ( n1 - n2 ) == 2 ) NEW_LINE DEDENT n1 = 137 NEW_LINE n2 = 139 NEW_LINE if twinPrime ( n1 , n2 ) : NEW_LINE INDENT print ( \" Twin ▁ Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Twin ▁ Prime \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Twin Prime Numbers | Python3 code to check twin prime ; Function to check whether a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Returns true if n1 and n2 are twin primes ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12691-12691",
        "Code": "N = 6 ; NEW_LINE def fib ( f , n ) : NEW_LINE INDENT f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT DEDENT def fibcoef ( fc , f , n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT fc [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT k = j ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE fc [ i ] [ j ] *= f [ k ] ; NEW_LINE DEDENT k = 1 ; NEW_LINE while ( ( j + 1 ) != k ) : NEW_LINE INDENT fc [ i ] [ j ] /= f [ k ] ; NEW_LINE k += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def printFibonomialTriangle ( n ) : NEW_LINE INDENT f = [ 0 ] * ( N + 1 ) ; NEW_LINE fib ( f , n ) ; NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 ; NEW_LINE dp [ i ] [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT dp [ i ] [ j ] = ( f [ i - j + 1 ] * dp [ i - 1 ] [ j - 1 ] + f [ j - 1 ] * dp [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT DEDENT n = 6 ; NEW_LINE printFibonomialTriangle ( n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Fibonomial coefficient and Fibonomial triangle | Python3 Program to print Fibonomial Triangle of height n . ; Function to produce Fibonacci Series . ; 0 th and 1 st number of the series are 0 and 1 ; Add the previous 2 numbers in the series and store it ; Function to produce fibonomial coefficient ; Function to print Fibonomial Triangle . ; Finding the fibonacci series . ; to store triangle value . ; initialising the 0 th element of each row and diagonal element equal to 0. ; for each row . ; for each column . ; finding each element using recurrence relation . ; printing the Fibonomial Triangle . ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "12721-12721",
        "Code": "def two_factor ( n ) : NEW_LINE INDENT twocount = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT twocount += 1 NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT return twocount NEW_LINE DEDENT def five_factor ( n ) : NEW_LINE INDENT fivecount = 0 NEW_LINE while n % 5 == 0 : NEW_LINE INDENT fivecount += 1 NEW_LINE n = int ( n / 5 ) NEW_LINE DEDENT return fivecount NEW_LINE DEDENT def find_con_zero ( arr , n ) : NEW_LINE INDENT twocount = 0 NEW_LINE fivecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twocount += two_factor ( arr [ i ] ) NEW_LINE fivecount += five_factor ( arr [ i ] ) NEW_LINE DEDENT if twocount < fivecount : NEW_LINE INDENT return twocount NEW_LINE DEDENT else : NEW_LINE INDENT return fivecount NEW_LINE DEDENT DEDENT arr = [ 100 , 10 , 5 , 25 , 35 , 14 ] NEW_LINE n = 6 NEW_LINE print ( find_con_zero ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number of consecutive zero at the end after multiplying n numbers | Function to count two 's factor ; Count number of 2 s present in n ; Function to count five 's factor ; Function to count number of zeros ; Count the two 's factor of n number ; Count the five 's factor of n number ; Return the minimum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12726-12726",
        "Code": "def func ( x , y ) : NEW_LINE INDENT return ( x + y + x * y ) NEW_LINE DEDENT def euler ( x0 , y , h , x ) : NEW_LINE INDENT temp = - 0 NEW_LINE while x0 < x : NEW_LINE INDENT temp = y NEW_LINE y = y + h * func ( x0 , y ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT print ( \" Approximate ▁ solution ▁ at ▁ x ▁ = ▁ \" , x , \" ▁ is ▁ \" , \" % .6f \" % y ) NEW_LINE DEDENT x0 = 0 NEW_LINE y0 = 1 NEW_LINE h = 0.025 NEW_LINE x = 0.1 NEW_LINE euler ( x0 , y0 , h , x ) NEW_LINE",
        "Type": "py",
        "NL": "Euler Method for solving differential equation | Consider a differential equation dy / dx = ( x + y + xy ) ; Function for euler formula ; Iterating till the point at which we need approximation ; Printing approximation ; Initial Values ; Value of x at which we need approximation",
        "Category": "Math"
    },
    {
        "ID": "12727-12727",
        "Code": "def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 ; NEW_LINE time = s / V ; NEW_LINE print ( time ) ; NEW_LINE DEDENT s = 25 ; NEW_LINE v = 56 ; NEW_LINE timeToMeet ( s , v ) ; NEW_LINE",
        "Type": "py",
        "NL": "Time required to meet in equilateral triangle | function to calculate time to meet ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12746-12746",
        "Code": "def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Binomial Coefficients table | Function to print binomial table ; B ( m , x ) is 1 if either m or x is is 0. ; Otherwise using recursive formula B ( m , x ) = B ( m , x - 1 ) * ( m - x + 1 ) / x ; Driver Function",
        "Category": "Math"
    },
    {
        "ID": "12755-12755",
        "Code": "def precisionCompute ( x , y , n ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT print ( \" Infinite \" ) ; NEW_LINE return ; NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) ; NEW_LINE return ; NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x / y ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( \" - \" , end = \" \" ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y = - y ; NEW_LINE DEDENT DEDENT d = x / y ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( d ) ; NEW_LINE x = x - ( y * d ) ; NEW_LINE if x == 0 : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x / y ; NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( \" . \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT x = 22 ; NEW_LINE y = 7 ; NEW_LINE n = 15 ; NEW_LINE precisionCompute ( x , y , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to compute division upto n decimal places | Python3 program to compute division upto n decimal places . ; Base cases ; Since n <= 0 , don 't  compute after the decimal ; Handling negative numbers ; Integral division ; Now one by print digits after dot using school division method . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12760-12760",
        "Code": "def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( \" lies ▁ in ▁ First ▁ quadrant \" ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( \" lies ▁ in ▁ Second ▁ quadrant \" ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( \" lies ▁ in ▁ Third ▁ quadrant \" ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( \" lies ▁ in ▁ Fourth ▁ quadrant \" ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( \" lies ▁ at ▁ positive ▁ y ▁ axis \" ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( \" lies ▁ at ▁ negative ▁ y ▁ axis \" ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( \" lies ▁ at ▁ negative ▁ x ▁ axis \" ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( \" lies ▁ at ▁ positive ▁ x ▁ axis \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" lies ▁ at ▁ origin \" ) NEW_LINE DEDENT DEDENT x = 1 NEW_LINE y = 1 NEW_LINE quadrant ( x , y ) NEW_LINE",
        "Type": "py",
        "NL": "Program to determine the quadrant of the cartesian plane | Function to check quadrant ; Driver code ; Function Calling",
        "Category": "Math"
    },
    {
        "ID": "12767-12767",
        "Code": "def firstDigit ( n ) : NEW_LINE INDENT while n >= 10 : NEW_LINE INDENT n = n / 10 ; NEW_LINE DEDENT return int ( n ) NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 ; NEW_LINE print ( firstDigit ( n ) , end = \" ▁ \" ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find first and last digits of a number | Find the first digit ; Remove last digit from number till only one digit is left ; return the first digit ; Find the last digit ; return the last digit ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12768-12768",
        "Code": "import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = ( int ) ( math . log10 ( n ) ) NEW_LINE n = ( int ) ( n / pow ( 10 , digits ) ) NEW_LINE return n ; NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 ; NEW_LINE print ( firstDigit ( n ) , end = \" ▁ \" ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find first and last digits of a number | Python3 program to find first and last digits of a number ; Find the first digit ; Find total number of digits - 1 ; Find first digit ; Return first digit ; Find the last digit ; return the last digit ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12778-12778",
        "Code": "def countDigit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countDigit ( n // 10 ) ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT l = countDigit ( n ) NEW_LINE dup = n ; sm = 0 NEW_LINE while ( dup ) : NEW_LINE INDENT sm = sm + pow ( dup % 10 , l ) NEW_LINE dup = dup // 10 NEW_LINE DEDENT return ( n == sm ) NEW_LINE DEDENT n = 1634 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Narcissistic number | function to count digits ; Returns true if n is Narcissistic number ; Count the number of digits ; Calculates the sum of digits raised to power ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12781-12781",
        "Code": "def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT T = 15 NEW_LINE ans = solve ( 1 , T , 2 * T ) NEW_LINE if ans != - 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( \" Number ▁ of ▁ stair ▁ steps ▁ = ▁ \" , ans ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number of stair steps | Modified Binary search function to solve the equation ; if mid is solution to equation ; if our solution to equation lies between mid and mid - 1 ; if solution to equation is greater than mid ; if solution to equation is less than mid ; driver code ; call binary search method to solve for limits 1 to T ; Because our pattern starts from 2 , 3 , 4 , 5. . . so , we subtract 1 from ans",
        "Category": "Binary Search"
    },
    {
        "ID": "12788-12788",
        "Code": "def evensum ( n ) : NEW_LINE INDENT curr = 2 NEW_LINE sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += curr NEW_LINE curr += 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE print ( \" sum ▁ of ▁ first ▁ \" , n , \" even ▁ number ▁ is : ▁ \" , evensum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of first n even numbers | function to find sum of first n even numbers ; sum of first n even numbers ; next even number ; required sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12789-12789",
        "Code": "def evensum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT n = 20 NEW_LINE print ( \" sum ▁ of ▁ first \" , n , \" even ▁ number ▁ is : ▁ \" , evensum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of first n even numbers | function to find sum of first n even numbers ; required sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12790-12790",
        "Code": "def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( kthgroupsum ( k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Nicomachusâ €™ s Theorem ( Sum of k | Return the sum of k - th group of positive odd integers . ; Finding first element of kth group . ; Finding the sum . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12791-12791",
        "Code": "def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT k = 3 NEW_LINE print ( kthgroupsum ( k ) ) NEW_LINE",
        "Type": "py",
        "NL": "NicomachusÃƒÆ ’ Ã † â €™ Ãƒâ € Ã ¢ â ‚¬ â „¢¢ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒâ €¦¡¬ ÃƒÆ ’ Ã † â €™¢ ÃƒÆ ’¢ Ãƒ ¢ Ã ¢ â ‚¬ Å ¡¬ Ãƒâ €¦¾¢ s Theorem ( Sum of k | Return the sum of kth group of positive odd integer . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12792-12792",
        "Code": "def oddSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE curr = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + curr NEW_LINE curr = curr + 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE print ( \" ▁ Sum ▁ of ▁ first \" , n , \" Odd ▁ Numbers ▁ is : ▁ \" , oddSum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of first n odd numbers in O ( 1 ) Complexity | Python3 program to find sum of first n odd numbers ; Returns the sum of first n odd numbers ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12793-12793",
        "Code": "def oddSum ( n ) : NEW_LINE INDENT return ( n * n ) ; NEW_LINE DEDENT n = 20 NEW_LINE print ( \" ▁ Sum ▁ of ▁ first \" , n , \" Odd ▁ Numbers ▁ is : ▁ \" , oddSum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of first n odd numbers in O ( 1 ) Complexity | Returns the sum of first n odd numbers ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12795-12795",
        "Code": "def kmphTOmph ( kmph ) : NEW_LINE INDENT mph = 0.6214 * kmph NEW_LINE return mph NEW_LINE DEDENT def mphTOkmph ( mph ) : NEW_LINE INDENT kmph = ( float ) ( mph * 1.60934 ) NEW_LINE return kmph NEW_LINE DEDENT / * Driver code to check the above function * / NEW_LINE kmph = 150 NEW_LINE mph = 100 NEW_LINE print \" speed ▁ in ▁ miles ▁ / ▁ hr ▁ is ▁ \" , kmphTOmph ( kmph ) NEW_LINE print \" speed ▁ in ▁ km ▁ / ▁ hr ▁ is ▁ \" , mphTOkmph ( mph ) NEW_LINE",
        "Type": "py",
        "NL": "Program to Convert Km / hr to miles / hr and vice versa | Function to convert kmph to mph ; Function to convert mph to kmph ;",
        "Category": "Math"
    },
    {
        "ID": "12797-12797",
        "Code": "def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] = p_factors [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE",
        "Type": "py",
        "NL": "K | Returns the sum of first n odd numbers ; Count prime factors of all numbers till B . ; Print all numbers with k prime factors ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "128-128",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isBalancedUtil ( root , maxh , minh ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT maxh = minh = 0 NEW_LINE return True NEW_LINE DEDENT lmxh = 0 NEW_LINE lmnh = 0 NEW_LINE rmxh , rmnh = 0 , 0 NEW_LINE if ( isBalancedUtil ( root . left , lmxh , lmnh ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isBalancedUtil ( root . right , rmxh , rmnh ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT maxh = max ( lmxh , rmxh ) + 1 NEW_LINE minh = min ( lmnh , rmnh ) + 1 NEW_LINE if ( maxh <= 2 * minh ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isBalanced ( root ) : NEW_LINE INDENT maxh , minh = 0 , 0 NEW_LINE return isBalancedUtil ( root , maxh , minh ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( 100 ) NEW_LINE root . right . left = newNode ( 50 ) NEW_LINE root . right . right = newNode ( 150 ) NEW_LINE root . right . left . left = newNode ( 40 ) NEW_LINE if ( isBalanced ( root ) ) : NEW_LINE INDENT print ( \" Balanced \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Balanced \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a given Binary Tree is height balanced like a Red | Helper function that allocates a new node with the given data and None left and right poers . ; Returns returns tree if the Binary tree is balanced like a Red - Black tree . This function also sets value in maxh and minh ( passed by reference ) . maxh and minh are set as maximum and minimum heights of root . ; Base case ; To store max and min heights of left subtree ; To store max and min heights of right subtree ; Check if left subtree is balanced , also set lmxh and lmnh ; Check if right subtree is balanced , also set rmxh and rmnh ; Set the max and min heights of this node for the parent call ; See if this node is balanced ; A wrapper over isBalancedUtil ( ) ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "12803-12803",
        "Code": "def printXYZ ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" x ▁ is ▁ \" , n ) NEW_LINE print ( \" y ▁ is ▁ \" , n + 1 ) NEW_LINE print ( \" z ▁ is ▁ \" , n * ( n + 1 ) ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE printXYZ ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Find x , y , z that satisfy 2 / n = 1 / x + 1 / y + 1 / z | function to find x y and z that satisfy given equation . ; driver code to test the above function",
        "Category": "Math"
    },
    {
        "ID": "12806-12806",
        "Code": "def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE return dist / time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( \" ▁ Time ( hr ) ▁ : \" , time ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ / ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( \" ▁ Distance ( km ) ▁ : \" , dist ) ; NEW_LINE print ( \" ▁ Speed ( km ▁ / ▁ hr ) ▁ : \" , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( \" ▁ The ▁ calculated ▁ Speed ( km ▁ / ▁ hr ) ▁ is ▁ : \" , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Distance ( km ) ▁ : \" , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" ▁ The ▁ calculated ▁ Time ( hr ) ▁ : \" , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Calculate speed , distance and time | Function to calculate speed ; Function to calculate distance traveled ; Function to calculate time taken ; Calling function cal_speed ( ) ; Calling function cal_dis ( ) ; Calling function cal_time ( )",
        "Category": "Math"
    },
    {
        "ID": "12817-12817",
        "Code": "import math NEW_LINE def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT a = 5 NEW_LINE b = 15 NEW_LINE HM = compute ( a , b ) NEW_LINE print ( \" Harmonic ▁ Mean ▁ between ▁ \" , a , \" ▁ and ▁ \" , b , \" ▁ is ▁ \" , HM ) NEW_LINE",
        "Type": "py",
        "NL": "Find Harmonic mean using Arithmetic mean and Geometric mean | Python 3 implementation of compution of arithmetic mean , geometric mean and harmonic mean ; Function to calculate arithmetic mean , geometric mean and harmonic mean ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "12818-12818",
        "Code": "def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 135 NEW_LINE if ( isDeserium ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Deserium Number | Returns count of digits in n . ; Returns true if x is Diserium ; Compute powers of digits from right to left . ; If sum of powers is same as given number . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1282-1282",
        "Code": "arr = [ 10 , 2 , - 2 , - 20 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = - 10 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT summ += arr [ j ] NEW_LINE if summ == k : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE",
        "Type": "py",
        "NL": "Number of subarrays having sum exactly equal to k | Python3 program for the above approach ; Calculate all subarrays ; Calculate required sum ; Check if sum is equal to required sum",
        "Category": "Substring"
    },
    {
        "ID": "12821-12821",
        "Code": "from collections import defaultdict NEW_LINE def subsequences ( a , n , r ) : NEW_LINE INDENT left = defaultdict ( lambda : 0 ) NEW_LINE right = defaultdict ( lambda : 0 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c1 , c2 = 0 , 0 NEW_LINE if a [ i ] % r == 0 : NEW_LINE INDENT c1 = left [ a [ i ] // r ] NEW_LINE DEDENT right [ a [ i ] ] -= 1 NEW_LINE c2 = right [ a [ i ] * r ] NEW_LINE ans += c1 * c2 NEW_LINE left [ a [ i ] ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 6 , 2 , 3 , 6 , 9 , 18 , 3 , 9 ] NEW_LINE n = len ( a ) NEW_LINE r = 3 NEW_LINE print ( subsequences ( a , n , r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of GP ( Geometric Progression ) subsequences of size 3 | Python3 program to count GP subsequences of size 3. ; Returns count of G . P . subsequences with length 3 and common ratio r ; hashing to maintain left and right array elements to the main count ; stores the answer ; traverse through the elements ; traverse through all elements and find out the number of elements as k1 * k2 ; keep the count of left and right elements left is a [ i ] / r and right a [ i ] * r ; if the current element is divisible by k , count elements in left hash . ; decrease the count in right hash ; number of right elements ; calculate the answer ; left count of a [ i ] ; Returns answer ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "12823-12823",
        "Code": "def mean ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE DEDENT mean = sum / n ; NEW_LINE return mean ; NEW_LINE DEDENT def sd ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ) ; NEW_LINE DEDENT sdd = sum / n ; NEW_LINE return sdd ; NEW_LINE DEDENT def combinedVariance ( arr1 , arr2 , n , m ) : NEW_LINE INDENT mean1 = mean ( arr1 , n ) ; NEW_LINE mean2 = mean ( arr2 , m ) ; NEW_LINE print ( \" Mean1 : ▁ \" , round ( mean1 , 2 ) , \" ▁ mean2 : ▁ \" , round ( mean2 , 2 ) ) ; NEW_LINE sd1 = sd ( arr1 , n ) ; NEW_LINE sd2 = sd ( arr2 , m ) ; NEW_LINE print ( \" StandardDeviation1 : ▁ \" , round ( sd1 , 2 ) , \" ▁ StandardDeviation2 : ▁ \" , round ( sd2 , 2 ) ) ; NEW_LINE combinedMean = ( n * mean1 + m * mean2 ) / ( n + m ) ; NEW_LINE print ( \" Combined ▁ Mean : ▁ \" , round ( combinedMean , 2 ) ) ; NEW_LINE d1_square = ( ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ) ; NEW_LINE d2_square = ( ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ) ; NEW_LINE print ( \" d1 ▁ square : ▁ \" , round ( d1_square , 2 ) , \" ▁ d2 _ square : ▁ \" , round ( d2_square , 2 ) ) ; NEW_LINE combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; NEW_LINE print ( \" Combined ▁ Variance : ▁ \" , round ( combinedVar , 2 ) ) ; NEW_LINE DEDENT arr1 = [ 23 , 45 , 34 , 78 , 12 , 76 , 34 ] ; NEW_LINE arr2 = [ 65 , 67 , 34 , 23 , 45 ] ; NEW_LINE n = len ( arr1 ) ; NEW_LINE m = len ( arr2 ) ; NEW_LINE combinedVariance ( arr1 , arr2 , n , m ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find combined mean and variance of two series | Function to find mean of series . ; Function to find the standard deviation of series . ; Function to find combined variance of two different series . ; mean1 and mean2 are the mean of two arrays . ; sd1 and sd2 are the standard deviation of two array . ; combinedMean is variable to store the combined mean of both array . ; d1_square and d2_square are the combined mean deviation . ; combinedVar is variable to store combined variance of both array . ; Driver Code ; Function call to combined mean .",
        "Category": "Math"
    },
    {
        "ID": "12825-12825",
        "Code": "def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + \"00\" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + \"0\" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = \"83959092724\" NEW_LINE if ( checkDivisibility ( number ) ) : NEW_LINE INDENT print ( number , \" is ▁ divisible ▁ by ▁ 13 . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( number , \" is ▁ not ▁ divisible ▁ by ▁ 13 . \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a large number is divisible by 13 or not | Returns true if number is divisible by 13 else returns false ; Append required 0 s at the beginning . ; Same as strcat ( num , \"00\" ) ; in c . ; Same as strcat ( num , \"0\" ) ; in c . ; Alternatively add / subtract digits in group of three to result . ; Store group of three numbers in group variable . ; Generate alternate series of plus and minus ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12827-12827",
        "Code": "import math NEW_LINE def modularEquation ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT print ( \" No ▁ solution ▁ possible ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( \" Infinite ▁ Solution ▁ possible ▁ \" ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) ( math . sqrt ( a - b ) ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT a = 21 NEW_LINE b = 5 NEW_LINE modularEquation ( a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Given two numbers a and b find all x such that a % x = b | Python3 program to find x such that a % x is equal to b . ; if a is less than b then no solution ; if a is equal to b then every number greater than a will be the solution so its infinity ; count variable store the number of values possible ; checking for both divisor and quotient whether they divide ( a - b ) completely and greater than b . ; Here y is added twice in the last iteration so 1 y should be decremented to get correct solution ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12828-12828",
        "Code": "primes = [ ] ; NEW_LINE def SieveofEratosthenes ( n ) : NEW_LINE INDENT visited = [ False ] * ( n + 2 ) ; NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT for j in range ( i * i , n + 2 , i ) : NEW_LINE INDENT visited [ j ] = True ; NEW_LINE DEDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT DEDENT def specialPrimeNumbers ( n , k ) : NEW_LINE INDENT SieveofEratosthenes ( n ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT n = 27 ; NEW_LINE k = 2 ; NEW_LINE if ( specialPrimeNumbers ( n , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Special prime numbers | Python3 program to check whether there exist at least k or not in range [ 2. . n ] ; Generating all the prime numbers from 2 to n . ; If a prime number is Special prime number , then we increments the value of k . ; If at least k Special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12840-12840",
        "Code": "def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return n % 4 != 3 ; NEW_LINE DEDENT n = 17 ; NEW_LINE if ( judgeSquareSum ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a number can be represented by sum of two squares | Check whether a number can be represented by sum of two squares using Fermat Theorem . ; Count all the prime factors . ; Ifany prime factor of the form ( 4 k + 3 ) ( 4 k + 3 ) occurs an odd number of times . ; If n itself is a x prime number and can be expressed in the form of 4 k + 3 we return false . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12843-12843",
        "Code": "M = 6 NEW_LINE N = 7 NEW_LINE def preCompute ( mat , prefixCnt ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT prefixCnt [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefixCnt [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT prefixCnt [ i ] [ j ] += prefixCnt [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT prefixCnt [ i ] [ j ] += prefixCnt [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return prefixCnt NEW_LINE DEDENT def countQuery ( prefixCnt , pi , pj , qi , qj ) : NEW_LINE INDENT cnt = prefixCnt [ qi ] [ qj ] NEW_LINE if ( pi > 0 ) : NEW_LINE INDENT cnt -= prefixCnt [ pi - 1 ] [ qj ] NEW_LINE DEDENT if ( pj > 0 ) : NEW_LINE INDENT cnt -= prefixCnt [ qi ] [ pj - 1 ] NEW_LINE DEDENT if ( pi > 0 and pj > 0 ) : NEW_LINE INDENT cnt += prefixCnt [ pi - 1 ] [ pj - 1 ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT def count0s ( mat , Q , sizeQ ) : NEW_LINE INDENT prefixCnt = [ [ 0 for i in range ( N ) ] for i in range ( M ) ] NEW_LINE prefixCnt = preCompute ( mat , prefixCnt ) NEW_LINE for i in range ( sizeQ ) : NEW_LINE INDENT print ( countQuery ( prefixCnt , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , Q [ i ] [ 3 ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 0 , 1 , 1 , 0 ] , [ 1 , 1 , 1 , 1 , 1 , 0 , 1 ] , [ 0 , 0 , 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 1 , 0 , 1 ] ] NEW_LINE Q = [ [ 0 , 1 , 3 , 2 ] , [ 2 , 2 , 4 , 5 ] , [ 4 , 3 , 5 , 6 ] ] NEW_LINE sizeQ = len ( Q ) NEW_LINE count0s ( mat , Q , sizeQ ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to count minimum flips required to fill a binary submatrix with 0 s only | Python3 program for the above approach ; Function to compute the matrix prefixCnt [ M ] [ N ] from mat [ M ] [ N ] such that prefixCnt [ i ] [ j ] stores the count of 0 's from (0, 0) to (i, j) ; Initialize prefixCnt [ i ] [ j ] with 1 if mat [ i ] [ j ] is 0 ; Otherwise , assign with 0 ; Calculate prefix sum for each row ; Calculate prefix sum for each column ; Function to compute count of 0 's in submatrix from (pi, pj) to (qi, qj) from prefixCnt[M][N] ; Initialize that count of 0 's  in the sub-matrix within  indices (0, 0) to (qi, qj) ; Subtract count of 0 's within  indices (0, 0) and (pi-1, qj) ; Subtract count of 0 's within  indices (0, 0) and (qi, pj-1) ; Add prefixCnt [ pi - 1 ] [ pj - 1 ] because its value has been added once but subtracted twice ; Function to count the 0 s in the each given submatrix ; Stores the prefix sum of each row and column ; Compute matrix prefixCnt [ ] [ ] ; Function Call for each query ; Driver Code ; Given matrix ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "12845-12845",
        "Code": "import math NEW_LINE def series ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( \"0\" , end = ' ▁ ' ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( \" % .5f \" % ( ( math . pow ( - 1 , i ) * d ) ) , end = ' ▁ ' ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m = n NEW_LINE r = ( m / ( m - 1 ) ) NEW_LINE g = ( float ) ( d * float ( math . sqrt ( r ) ) ) NEW_LINE print ( \"0 ▁ \" , end = ' ▁ ' ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT print ( \" % .5f \" % ( math . pow ( - 1 , i ) * g ) , end = ' ▁ ' ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT n = 3 NEW_LINE d = 3 NEW_LINE series ( n , d ) NEW_LINE",
        "Type": "py",
        "NL": "Given N and Standard Deviation , find N elements | Python program to find n elements ; function to print series of n elements ; if S . D . is 0 then print all elements as 0. ; print n 0 's ; if S . D . is even ; print - SD , + SD , - SD , + SD ; if odd ; if odd convert n to a float integer ; print one element to be 0 ; print ( n - 1 ) elements as xi derived from the formula ; driver code to test the above function",
        "Category": "Math"
    },
    {
        "ID": "12846-12846",
        "Code": "def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str1 = str ( i ) ; NEW_LINE countr += str1 . count ( \"1\" ) ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 131 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 159 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Total no of 1 's in numbers | Python3 code to count the frequency of 1 in numbers less than or equal to the given number . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12851-12851",
        "Code": "import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 ; NEW_LINE a = int ( a / 10 ) ; NEW_LINE DEDENT return True if ( c == b ) else False ; NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False ; NEW_LINE mx = 1000000000000000001 ; NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n ; NEW_LINE sq = int ( math . sqrt ( s ) ) ; NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) / 2 ) , i ) ) : NEW_LINE INDENT found = True ; NEW_LINE mx = min ( mx , int ( ( sq - i ) / 2 ) ) ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT n = 110 ; NEW_LINE print ( root ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Smallest root of the equation x ^ 2 + s ( x ) * x | Python3 program to find smallest value of root of an equation under given constraints . ; function to check if the sum of digits is equal to the summation assumed ; calculate the sum of digit ; function to find the largest root possible . ; iterate for all possible sum of digits . ; check if discriminent is a perfect square . ; check if discriminent is a perfect square and if it as perefect root of the equation ; function returns answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12853-12853",
        "Code": "N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp / 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE",
        "Type": "py",
        "NL": "Exponential Squaring ( Fast Modulo Multiplication ) | prime modulo value ; for cases where exponent is not an even value ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12856-12856",
        "Code": "import math NEW_LINE def gcdOfFactorial ( m , n ) : NEW_LINE INDENT return math . factorial ( min ( m , n ) ) NEW_LINE DEDENT m = 5 NEW_LINE n = 9 NEW_LINE print ( gcdOfFactorial ( m , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "GCD of factorials of two numbers | Python code to find GCD of factorials of two numbers . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12864-12864",
        "Code": "def calculate ( n , power ) : NEW_LINE INDENT return sum ( [ int ( i ) for i in str ( pow ( n , power ) ) ] ) NEW_LINE DEDENT n = 5 NEW_LINE power = 4 NEW_LINE print ( calculate ( n , power ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of digits of a given number to a given power | Function to calculate sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12867-12867",
        "Code": "MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp // factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of steps to convert to prime factors | Python 3 program to count number of steps required to convert an integer array to array of factors . ; array to store prime factors ; function to generate all prime factors of numbers from 1 to 10 ^ 6 ; Initializes all the positions with their value . ; Initializes all multiples of 2 with 2 ; A modified version of Sieve of Eratosthenes to store the smallest prime factor that divides every number . ; check if it has no prime factor . ; Initializes of j starting from i * i ; if it has no prime factor before , then stores the smallest prime divisor ; function to calculate the number of representations ; keep an count of prime factors ; traverse for every element ; count the no of factors ; subtract 1 if Ai is not 1 as the last step wont be taken into count ; Driver Code ; call sieve to calculate the factors",
        "Category": "Math"
    },
    {
        "ID": "12879-12879",
        "Code": "import math NEW_LINE def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / NEW_LINE INDENT ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE DEDENT return corr NEW_LINE DEDENT X = [ 15 , 18 , 21 , 24 , 27 ] NEW_LINE Y = [ 25 , 25 , 27 , 31 , 32 ] NEW_LINE n = len ( X ) NEW_LINE print ( ' { 0 : . 6f } ' . format ( correlationCoefficient ( X , Y , n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find correlation coefficient | Python Program to find correlation coefficient . ; function that returns correlation coefficient . ; sum of elements of array X . ; sum of elements of array Y . ; sum of X [ i ] * Y [ i ] . ; sum of square of array elements . ; use formula for calculating correlation coefficient . ; Driver function ; Find the size of array . ; Function call to correlationCoefficient .",
        "Category": "Math"
    },
    {
        "ID": "12880-12880",
        "Code": "def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number of spectators standing in the stadium at time t | Python program to find number of spectators standing at a time ; If the time is less than k then we can print directly t time . ; If the time is n then k spectators are standing . ; Otherwise we calculate the spectators standing . ; Stores the value of n , k and t t is time n & k is the number of specators",
        "Category": "Math"
    },
    {
        "ID": "12885-12885",
        "Code": "import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT a = 1.20 NEW_LINE b = 22.5 NEW_LINE print ( ' { 0 : . 1f } ' . format ( gcd ( a , b ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find GCD of floating point numbers | Python code for finding the GCD of two floating numbers . ; Recursive function to return gcd of a and b ; base case ; Driver Function .",
        "Category": "Math"
    },
    {
        "ID": "12886-12886",
        "Code": "def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) / arr [ i ] ; NEW_LINE DEDENT return n / sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for harmonic mean of numbers | Function that returns harmonic mean . ; Declare sum variables and initialize with zero . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12889-12889",
        "Code": "def modBigNumber ( num , m ) : NEW_LINE INDENT vec = [ ] NEW_LINE mod = 0 NEW_LINE for i in range ( 0 , len ( num ) , 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE mod = mod * 10 + digit NEW_LINE quo = int ( mod / m ) NEW_LINE vec . append ( quo ) NEW_LINE mod = mod % m NEW_LINE DEDENT print ( \" Remainder ▁ : \" , mod ) NEW_LINE print ( \" Quotient ▁ : \" , end = \" ▁ \" ) NEW_LINE zeroflag = 0 ; NEW_LINE for i in range ( 0 , len ( vec ) , 1 ) : NEW_LINE INDENT if ( vec [ i ] == 0 and zeroflag == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT zeroflag = 1 NEW_LINE print ( vec [ i ] , end = \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = \"14598499948265358486\" NEW_LINE m = 487 NEW_LINE modBigNumber ( num , m ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program for quotient and remainder of big number | Function to calculate the modulus ; Store the modulus of big number ; Do step by step division ; Update modulo by concatenating current digit . ; Update quotient ; Update mod for next iteration . ; Flag used to remove starting zeros ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12890-12890",
        "Code": "import sys NEW_LINE def findPowerOfP ( n , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= n ) : NEW_LINE INDENT count += ( n // r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofK ( k ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while k != 1 : NEW_LINE INDENT if k % i == 0 : NEW_LINE INDENT count = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k = k // i NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( [ i , count ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfK ( n , k ) : NEW_LINE INDENT vec = primeFactorsofK ( k ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerOfP ( n , vec [ i ] [ 0 ] ) // vec [ i ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( largestPowerOfK ( 7 , 2 ) ) NEW_LINE print ( largestPowerOfK ( 10 , 9 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest power of k in n ! ( factorial ) where k may not be prime | Python3 program to find the largest power of k that divides n ! ; To find the power of a prime p in factorial N ; calculating floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of k ; Returns largest power of k that divides n ! ; calculating minimum power of all the prime factors of k ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12900-12900",
        "Code": "import math NEW_LINE def findArmstrong ( low , high ) : NEW_LINE INDENT for i in range ( low + 1 , high ) : NEW_LINE INDENT x = i NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x / 10 NEW_LINE n = n + 1 NEW_LINE DEDENT pow_sum = 0 NEW_LINE x = i NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE pow_sum = pow_sum + math . pow ( digit , n ) NEW_LINE x = x / 10 NEW_LINE DEDENT if ( pow_sum == i ) : NEW_LINE INDENT print ( str ( i ) + \" ▁ \" ) , NEW_LINE DEDENT DEDENT DEDENT num1 = 100 NEW_LINE num2 = 400 NEW_LINE findArmstrong ( num1 , num2 ) NEW_LINE print ( \" \" ) NEW_LINE",
        "Type": "py",
        "NL": "Armstrong Numbers between two integers | PYTHON program to find Armstrong numbers in a range ; Prints Armstrong Numbers in given range ; number of digits calculation ; compute sum of nth power of ; checks if number i is equal to the sum of nth power of its digits ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12902-12902",
        "Code": "def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( first [ i ] > 0 and second [ i ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( str ( first [ i ] ) + \" ▁ \" + str ( second [ i ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 1 , 4 , 2 , 8 ] NEW_LINE b = [ 5 , 2 , 12 , 8 , 3 ] NEW_LINE n = len ( a ) NEW_LINE N = 20 NEW_LINE gcdMax ( a , b , n , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Pair with maximum GCD from two arrays | Find the maximum GCD pair with maximum sum ; array to keep a count of existing elements ; first [ i ] and second [ i ] are going to store maximum multiples of i in a [ ] and b [ ] respectively . ; traverse through the first array to mark the elements in cnt ; Find maximum multiple of every number in first array ; Find maximum multiple of every number in second array We re - initialise cnt [ ] and traverse through the second array to mark the elements in cnt ; if the multiple is present in the second array then store the max of number or the pre - existing element ; traverse for every elements and checks the maximum N that is present in both the arrays ; driver program to test the above function ; Maximum possible value of elements in both arrays .",
        "Category": "Math"
    },
    {
        "ID": "12909-12909",
        "Code": "import random NEW_LINE import math NEW_LINE e = 2.71828 ; NEW_LINE def roundNo ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return ( num - 0.5 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( num + 0.5 ) ; NEW_LINE DEDENT DEDENT def printBestCandidate ( candidate , n ) : NEW_LINE INDENT sample_size = roundNo ( n / e ) ; NEW_LINE print ( \" Sample size is \" , math . floor ( sample_size ) ) ; NEW_LINE best = 0 ; NEW_LINE for i in range ( 1 , int ( sample_size ) ) : NEW_LINE INDENT if ( candidate [ i ] > candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE DEDENT DEDENT for i in range ( int ( sample_size ) , n ) : NEW_LINE INDENT if ( candidate [ i ] >= candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( best >= int ( sample_size ) ) : NEW_LINE INDENT print ( \" Best candidate found is \" , math . floor ( best + 1 ) , \" with ▁ talent \" , math . floor ( candidate [ best ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Couldn ' t ▁ find ▁ a ▁ best ▁ candidate \" ) ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE candidate = [ 0 ] * ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT candidate [ i ] = 1 + random . randint ( 1 , 8 ) ; NEW_LINE DEDENT print ( \" Candidate ▁ : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ( i + 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" Talents : \" , ▁ end ▁ = ▁ \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( candidate [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT printBestCandidate ( candidate , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Secretary Problem ( A Optimal Stopping Problem ) | Python3 Program to test 1 / e law for Secretary Problem ; To find closest integer of num . ; Finds best candidate using n / e rule . candidate [ ] represents talents of n candidates . ; Calculating sample size for benchmarking . ; Finding best candidate in sample size ; Finding the first best candidate that is better than benchmark set . ; Driver code ; n = 8 candidates and candidate array contains talents of n candidate where the largest number means highest talented candidate . ; generating random numbers between 1 to 8 for talent of candidate",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "12920-12920",
        "Code": "def complement ( number ) : NEW_LINE INDENT for i in range ( 0 , len ( number ) ) : NEW_LINE INDENT if ( number [ i ] != ' . ' ) : NEW_LINE INDENT a = 9 - int ( number [ i ] ) NEW_LINE number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] ) NEW_LINE DEDENT DEDENT print ( \"9 ' s ▁ complement ▁ is ▁ : ▁ \" , number ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number = \"345.45\" NEW_LINE complement ( number ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "9 's complement of a decimal number | Python3 program to find 9 's complement of a number. ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12923-12923",
        "Code": "import math NEW_LINE MAX = 100 ; NEW_LINE def Cholesky_Decomposition ( matrix , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE if ( j == i ) : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT sum1 += pow ( lower [ j ] [ k ] , 2 ) ; NEW_LINE DEDENT lower [ j ] [ j ] = int ( math . sqrt ( matrix [ j ] [ j ] - sum1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT sum1 += ( lower [ i ] [ k ] * lower [ j ] [ k ] ) ; NEW_LINE DEDENT if ( lower [ j ] [ j ] > 0 ) : NEW_LINE INDENT lower [ i ] [ j ] = int ( ( matrix [ i ] [ j ] - sum1 ) / lower [ j ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Lower ▁ Triangular TABSYMBOL TABSYMBOL Transpose \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = \" TABSYMBOL \" ) ; NEW_LINE DEDENT print ( \" \" , end = \" TABSYMBOL \" ) ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( lower [ j ] [ i ] , end = \" TABSYMBOL \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT DEDENT n = 3 ; NEW_LINE matrix = [ [ 4 , 12 , - 16 ] , [ 12 , 37 , - 43 ] , [ - 16 , - 43 , 98 ] ] ; NEW_LINE Cholesky_Decomposition ( matrix , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Cholesky Decomposition : Matrix Decomposition | Python3 program to decompose a matrix using Cholesky Decomposition ; Decomposing a matrix into Lower Triangular ; summation for diagonals ; Evaluating L ( i , j ) using L ( j , j ) ; Displaying Lower Triangular and its Transpose ; Lower Triangular ; Transpose of Lower Triangular ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "12926-12926",
        "Code": "MAX = 100 NEW_LINE def luDecomposition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - sum NEW_LINE DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE else : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) NEW_LINE DEDENT lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( \" Lower ▁ Triangular TABSYMBOL TABSYMBOL Upper ▁ Triangular \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = \" TABSYMBOL \" ) NEW_LINE DEDENT print ( \" \" , end = \" TABSYMBOL \" ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( upper [ i ] [ j ] , end = \" TABSYMBOL \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT mat = [ [ 2 , - 1 , - 2 ] , [ - 4 , 6 , 3 ] , [ - 4 , - 2 , 8 ] ] NEW_LINE luDecomposition ( mat , 3 ) NEW_LINE",
        "Type": "py",
        "NL": "Doolittle Algorithm : LU Decomposition | Python3 Program to decompose a matrix into lower and upper triangular matrix ; Decomposing matrix into Upper and Lower triangular matrix ; Upper Triangular ; Summation of L ( i , j ) * U ( j , k ) ; Evaluating U ( i , k ) ; Lower Triangular ; lower [ i ] [ i ] = 1 Diagonal as 1 ; Summation of L ( k , j ) * U ( j , i ) ; Evaluating L ( k , i ) ; setw is for displaying nicely ; Displaying the result : ; Lower ; Upper ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "12933-12933",
        "Code": "MAX_DIGITS = 20 ; NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == False ) else 10 NEW_LINE octal = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal . append ( n % divide ) NEW_LINE n = int ( n / divide ) NEW_LINE DEDENT j = len ( octal ) - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 97 ; NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if number is palindrome or not in Octal | Python3 program to check if octal representation of a number is prime ; Function to Check no is in octal or not ; Function To check no is palindrome or not ; If number is already in octal , we traverse digits using repeated division with 10. Else we traverse digits using repeated division with 8 ; To store individual digits ; Traversing all digits ; checking if octal no is palindrome ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12934-12934",
        "Code": "def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = \" ▁ \" ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT n = 100 NEW_LINE printFactorialNums ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Find all factorial numbers less than or equal to n | Python3 program to find all factorial numbers smaller than or equal to n . ; Compute next factorial using previous ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "12939-12939",
        "Code": "def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT n = 20 NEW_LINE print ( int ( Cel_To_Fah ( n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Celsius To Fahrenheit conversion | Python code to convert Celsius scale to Fahrenheit scale ; Used the formula ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "12948-12948",
        "Code": "def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for sum of arithmetic series | Function to find sum of series . ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "12959-12959",
        "Code": "M = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % M NEW_LINE DEDENT y = ( y >> 1 ) % M NEW_LINE x = ( x * x ) % M NEW_LINE DEDENT return res NEW_LINE DEDENT def countFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def multiplyFactors ( n ) : NEW_LINE INDENT numFactor = countFactors ( n ) NEW_LINE product = power ( n , numFactor / 2 ) NEW_LINE if ( numFactor % 2 == 1 ) : NEW_LINE INDENT product = ( product * ( int ) ( math . sqrt ( n ) ) ) % M NEW_LINE DEDENT return product NEW_LINE DEDENT n = 12 NEW_LINE print multiplyFactors ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Product of factors of number | Python program to calculate product of factors of number ; Iterative Function to calculate ( x ^ y ) in O ( log y ) ; function to count the factors ; If factors are equal , count only once ; Otherwise count both ; Calculate product of factors ; If numFactor is odd return power ( n , numFactor / 2 ) * sqrt ( n ) ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "1297-1297",
        "Code": "ASCII_SIZE = 256 NEW_LINE def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE for i in str : NEW_LINE INDENT count [ ord ( i ) ] += 1 ; NEW_LINE DEDENT max = - 1 NEW_LINE c = ' ' NEW_LINE for i in str : NEW_LINE INDENT if max < count [ ord ( i ) ] : NEW_LINE INDENT max = count [ ord ( i ) ] NEW_LINE c = i NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT str = \" sample ▁ string \" NEW_LINE print \" Max ▁ occurring ▁ character ▁ is ▁ \" + getMaxOccuringChar ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Return maximum occurring character in an input string | Python program to return the maximum occurring character in the input string ; Create array to keep the count of individual characters Initialize the count array to zero ; Construct character count array from the input string . ; Initialize max count ; Initialize result ; Traversing through the string and maintaining the count of each character ; Driver program to test the above function",
        "Category": "Hash Table"
    },
    {
        "ID": "12980-12980",
        "Code": "import math as mt NEW_LINE def smallestNumber ( n ) : NEW_LINE INDENT if ( n >= 0 and n <= 9 ) : NEW_LINE INDENT return n NEW_LINE DEDENT digits = list ( ) NEW_LINE for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT digits . append ( i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT k = 0 NEW_LINE while ( len ( digits ) != 0 ) : NEW_LINE INDENT k = k * 10 + digits [ - 1 ] NEW_LINE digits . pop ( ) NEW_LINE DEDENT return k NEW_LINE DEDENT n = 100 NEW_LINE print ( smallestNumber ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number k such that the product of digits of k is equal to n | Python3 implementation to find smallest number k such that the product of digits of k is equal to n ; function to find smallest number k such that the product of digits of k is equal to n ; if ' n ' is a single digit number , then it is the required number ; stack the store the digits ; repeatedly divide ' n ' by the numbers from 9 to 2 until all the numbers are used or ' n ' > 1 ; save the digit ' i ' that divides ' n ' onto the stack ; if true , then no number ' k ' can be formed ; pop digits from the stack ' digits ' and add them to 'k ; required smallest number ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "12985-12985",
        "Code": "x = 1234 NEW_LINE if ( x % 9 == 1 ) : NEW_LINE INDENT print ( \" Magic ▁ Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Magic ▁ Number \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is magic ( Recursive sum of digits is 1 ) | Accepting sample input ; Condition to check Magic number",
        "Category": "Math"
    },
    {
        "ID": "12986-12986",
        "Code": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkCircular ( N ) : NEW_LINE INDENT count = 0 NEW_LINE temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE temp = temp / 10 NEW_LINE DEDENT num = N ; NEW_LINE while ( isPrime ( num ) ) : NEW_LINE INDENT rem = num % 10 NEW_LINE div = num / 10 NEW_LINE num = ( int ) ( ( math . pow ( 10 , count - 1 ) ) * rem ) + div NEW_LINE if ( num == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 1193 ; NEW_LINE if ( checkCircular ( N ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a number is circular prime or not | Python Program to check if a number is circular prime or not . ; Function to check if a number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is circular prime or not . ; Count digits . ; Following three lines generate the next circular permutation of a number . We move last digit to first position . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "12998-12998",
        "Code": "def count ( x , y ) : NEW_LINE INDENT m = dict ( ) NEW_LINE while x % y != 0 : NEW_LINE INDENT x %= y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT res = count ( 1 , 2 ) NEW_LINE print ( \" INF \" ) if res == - 1 else print ( res ) NEW_LINE res = count ( 5 , 3 ) NEW_LINE print ( \" INF \" ) if res == - 1 else print ( res ) NEW_LINE res = count ( 3 , 5 ) NEW_LINE print ( \" INF \" ) if res == - 1 else print ( res ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count number of digits after decimal on dividing a number | Python3 program to count digits after dot when a number is divided by another . ; ans = 0 Initialize result ; calculating remainder ; if this remainder appeared before then the numbers are irrational and would not converge to a solution the digits after decimal will be infinite ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "130-130",
        "Code": "MARKER = ' $ ' NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . key = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT subtrees = { } NEW_LINE def dupSubUtil ( root ) : NEW_LINE INDENT global subtrees NEW_LINE s = \" \" NEW_LINE if ( root == None ) : NEW_LINE INDENT return s + MARKER NEW_LINE DEDENT lStr = dupSubUtil ( root . left ) NEW_LINE if ( s in lStr ) : NEW_LINE return s NEW_LINE rStr = dupSubUtil ( root . right ) NEW_LINE if ( s in rStr ) : NEW_LINE return s NEW_LINE s = s + root . key + lStr + rStr NEW_LINE if ( len ( s ) > 3 and s in subtrees ) : NEW_LINE return \" \" NEW_LINE subtrees [ s ] = 1 NEW_LINE return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( ' A ' ) NEW_LINE root . left = Node ( ' B ' ) NEW_LINE root . right = Node ( ' C ' ) NEW_LINE root . left . left = Node ( ' D ' ) NEW_LINE root . left . right = Node ( ' E ' ) NEW_LINE root . right . right = Node ( ' B ' ) NEW_LINE root . right . right . right = Node ( ' E ' ) NEW_LINE root . right . right . left = Node ( ' D ' ) NEW_LINE str = dupSubUtil ( root ) NEW_LINE if \" \" in str : NEW_LINE INDENT print ( \" ▁ Yes ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ No ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a Binary Tree contains duplicate subtrees of size 2 or more | Python3 program to find if there is a duplicate sub - tree of size 2 or more Separator node ; Structure for a binary tree node ; This function returns empty if tree contains a duplicate subtree of size 2 or more . ; If current node is None , return marker ; If left subtree has a duplicate subtree . ; Do same for right subtree ; Serialize current subtree ; If current subtree already exists in hash table . [ Note that size of a serialized tree with single node is 3 as it has two marker nodes . ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "13005-13005",
        "Code": "P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) / 100 NEW_LINE print ( \" simple ▁ interest ▁ is \" , SI ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find simple interest | We can change values here for different inputs ; Calculates simple interest ; Print the resultant value of SI",
        "Category": "Math"
    },
    {
        "ID": "13021-13021",
        "Code": "import math NEW_LINE def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( \"1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" ) ; NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) ; NEW_LINE ans = int ( mul / x ) ; NEW_LINE ans1 = x * ans ; NEW_LINE ans2 = x * ( ans + 1 ) ; NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) ; NEW_LINE DEDENT DEDENT a = 349 ; NEW_LINE b = 1 ; NEW_LINE x = 4 ; NEW_LINE multiple ( a , b , x ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find multiple of x closest to or a ^ b ( a raised to power b ) | Python3 Program to find closest multiple of x to a ^ b ; function to find closest multiple of x to a ^ b ; calculate a ^ b / x ; Answer is either ( ans * x ) or ( ans + 1 ) * x ; Printing nearest answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13024-13024",
        "Code": "def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor / 100 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isPalindrome ( 1001 ) ) : NEW_LINE INDENT print ( ' Yes , ▁ it ▁ is ▁ palindrome ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No , ▁ not ▁ palindrome ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "To check a number is palindrome or not without using any extra space | Function to check if given number is palindrome or not without using the extra space ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13031-13031",
        "Code": "def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT n = 9 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find whether a given integer is a power of 3 or not | Returns true if n is power of 3 , else false ; The maximum power of 3 value that integer can hold is 1162261467 ( 3 ^ 19 ) . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13033-13033",
        "Code": "import math NEW_LINE EPS = 1e-9 NEW_LINE def productPuzzle ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print int ( ( EPS + pow ( 10.00 , sum - math . log10 ( a [ i ] ) ) ) ) , NEW_LINE DEDENT return NEW_LINE DEDENT a = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print \" The ▁ product ▁ array ▁ is : ▁ \" NEW_LINE productPuzzle ( a , n ) NEW_LINE",
        "Type": "py",
        "NL": "A product array puzzle | Set 2 ( O ( 1 ) Space ) | Python program for product array puzzle with O ( n ) time and O ( 1 ) space . ; epsilon value to maintain precision ; to hold sum of all values ; output product for each index antilog to find original product value ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13035-13035",
        "Code": "def changeEvenBits ( n ) : NEW_LINE INDENT to_subtract = 0 NEW_LINE m = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT to_subtract += ( 1 << m ) NEW_LINE DEDENT m += 2 NEW_LINE x >>= 2 NEW_LINE DEDENT return n - to_subtract NEW_LINE DEDENT n = 30 NEW_LINE print changeEvenBits ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Change all even bits in a number to 0 | Returns modified number with all even bits 0. ; To store sum of bits at even positions . ; To store bits to shift ; One by one put all even bits to end ; If current last bit is set , add it to ans ; Next shift position ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13038-13038",
        "Code": "def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT n = 13 ; m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 ; m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 ; m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 ; m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number closest to n and divisible by m | Function to find the number closest to n and divisible by m ; Find the quotient ; 1 st possible closest number ; 2 nd possible closest number ; if true , then n1 is the required closest number ; else n2 is the required closest number ; Driver program to test above",
        "Category": "Math"
    },
    {
        "ID": "13052-13052",
        "Code": "def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT num = - 1234 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print \" True ▁ \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" False \" NEW_LINE DEDENT num = - 1247 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print \" True ▁ \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" False \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is jumbled or not | Function to check if a number is jumbled or not ; Single digit number ; Checking every digit through a loop ; All digits were checked ; Digit at index i ; Digit at index i - 1 ; If difference is greater than 1 ; Number checked ; - 1234 to be checked ; - 1247 to be checked",
        "Category": "Math"
    },
    {
        "ID": "13056-13056",
        "Code": "def nCr ( n , r ) : NEW_LINE INDENT if ( r > n / 2 ) : NEW_LINE INDENT r = n - r ; NEW_LINE DEDENT answer = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT answer *= ( n - r + i ) ; NEW_LINE answer /= i ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT def binomialProbability ( n , k , p ) : NEW_LINE INDENT return ( nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE k = 5 ; NEW_LINE p = 1.0 / 3 ; NEW_LINE probability = binomialProbability ( n , k , p ) ; NEW_LINE print ( \" Probability ▁ of \" , k , \" heads ▁ when ▁ a ▁ coin ▁ is ▁ tossed \" , end = \" ▁ \" ) ; NEW_LINE print ( n , \" times ▁ where ▁ probability ▁ of ▁ each ▁ head ▁ is \" , round ( p , 6 ) ) ; NEW_LINE print ( \" is ▁ = ▁ \" , round ( probability , 6 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Binomial Random Variables | function to calculate nCr i . e . , number of ways to choose r out of n objects ; Since nCr is same as nC ( n - r ) To decrease number of iterations ; function to calculate binomial r . v . probability ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13061-13061",
        "Code": "def count_one ( n ) : NEW_LINE INDENT c_one = 0 NEW_LINE while n != 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem == 1 : NEW_LINE INDENT c_one = c_one + 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return c_one NEW_LINE DEDENT def checkEvil ( n ) : NEW_LINE INDENT i = 0 NEW_LINE binary = 0 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 2 NEW_LINE binary = binary + r * ( int ( 10 ** i ) ) NEW_LINE n = n / 2 NEW_LINE DEDENT n_one = count_one ( binary ) NEW_LINE if n_one % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 32 NEW_LINE check = checkEvil ( num ) NEW_LINE if check : NEW_LINE INDENT print num , \" is ▁ Evil ▁ Number \" NEW_LINE DEDENT else : NEW_LINE INDENT print num , \" is ▁ Odious ▁ Number \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Evil Number | returns number of 1 s from the binary number ; Counting 1 s ; Check if number is evil or not ; Converting n to binary form ; Calculating Remainder Storing the remainders in binary form as a number ; Calling the count_one function to count and return number of 1 s in bin ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13067-13067",
        "Code": "def msbPos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while n != 0 : NEW_LINE INDENT pos += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT def josephify ( n ) : NEW_LINE INDENT position = msbPos ( n ) NEW_LINE DEDENT ' NEW_LINE INDENT j = 1 << ( position - 1 ) NEW_LINE n = n ^ j NEW_LINE n = n << 1 NEW_LINE n = n | 1 NEW_LINE return n NEW_LINE DEDENT n = 41 NEW_LINE print ( josephify ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Josephus Problem Using Bit Magic | Function to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; Function to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000 ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13070-13070",
        "Code": "def powermod ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) > 0 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT m0 = m ; NEW_LINE x0 = 0 ; NEW_LINE x1 = 1 ; NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = int ( a / m ) ; NEW_LINE t = m ; NEW_LINE m = a % m ; NEW_LINE a = t ; NEW_LINE t = x0 ; NEW_LINE x0 = x1 - q * x0 ; NEW_LINE x1 = t ; NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 ; NEW_LINE DEDENT return x1 ; NEW_LINE DEDENT def evaluteExpression ( n ) : NEW_LINE INDENT firstsum = 0 ; NEW_LINE mod = 10 ; NEW_LINE i = 2 ; NEW_LINE j = 0 ; NEW_LINE while ( ( 1 << j ) <= n ) : NEW_LINE INDENT firstsum = ( firstsum + i ) % mod ; NEW_LINE i *= i ; NEW_LINE j += 1 ; NEW_LINE DEDENT secondsum = ( powermod ( 4 , n + 1 , mod ) - 1 ) * modInverse ( 3 , mod ) ; NEW_LINE return ( firstsum * secondsum ) % mod ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( evaluteExpression ( n ) ) ; NEW_LINE n = 10 ; NEW_LINE print ( evaluteExpression ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find the last digit of given series | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Returns modulo inverse of a with respect to m using extended Euclid Algorithm ; q is quotient ; m is remainder now , process same as Euclid 's algo  ; Make x1 positive ; Function to calculate the above expression ; Initialize the result ; Compute first part of expression ; Compute second part of expression i . e . , ( ( 4 ^ ( n + 1 ) - 1 ) / 3 ) mod 10 Since division of 3 in modulo can ' t ▁ ▁ ▁ be ▁ performed ▁ directly ▁ therefore ▁ we ▁ ▁ ▁ need ▁ to ▁ find ▁ it ' s modulo Inverse ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13074-13074",
        "Code": "def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT print ( PowerOFPINnfactorial ( 4 , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Finding power of prime number p in n ! | Returns power of p in n ! ; initializing answer ; initializing ; loop until temp <= n ; add number of numbers divisible by n ; each time multiply temp by p ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13078-13078",
        "Code": "def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( \" Numbers ▁ with ▁ 3 ▁ divisors ▁ : \" ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = \" ▁ \" ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Numbers with exactly 3 divisors | Generates all primes upto n and prints their squares ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; print squares of primes upto n . ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "13080-13080",
        "Code": "def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = \" \" ) NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT n = 2545 NEW_LINE decToHexa ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Program for decimal to hexadecimal conversion | function to convert decimal to hexadecimal ; char array to store hexadecimal number ; counter for hexadecimal number array ; temporary variable to store remainder ; storing remainder in temp variable . ; check if temp < 10 ; printing hexadecimal number array in reverse order ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13086-13086",
        "Code": "def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT N = 17 NEW_LINE print ( decimalToBinary ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Decimal to Binary Conversion | Function to return the binary equivalent of decimal value N ; To store the binary number ; Count used to store exponent value ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13087-13087",
        "Code": "def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_value += last_digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = 10101001 ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program for Binary To Decimal Conversion | Function to convert binary to decimal ; Initializing base value to 1 , i . e 2 ^ 0 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13096-13096",
        "Code": "MAX_ITERATIONS = 20 ; NEW_LINE def isLychrel ( number ) : NEW_LINE INDENT for i in range ( MAX_ITERATIONS ) : NEW_LINE INDENT number = number + reverse ( number ) ; NEW_LINE if ( isPalindrome ( number ) ) : NEW_LINE INDENT return \" false \" ; NEW_LINE DEDENT DEDENT return \" true \" ; NEW_LINE DEDENT def isPalindrome ( number ) : NEW_LINE INDENT return number == reverse ( number ) ; NEW_LINE DEDENT def reverse ( number ) : NEW_LINE INDENT reverse = 0 ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT remainder = number % 10 ; NEW_LINE reverse = ( reverse * 10 ) + remainder ; NEW_LINE number = int ( number / 10 ) ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 295 ; NEW_LINE print ( number , \" ▁ is ▁ lychrel ? ▁ \" , isLychrel ( number ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Lychrel Number Implementation | Max Iterations ; Function to check whether number is Lychrel Number ; Function to check whether the number is Palindrome ; Function to reverse the number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13097-13097",
        "Code": "def flipSign ( a ) : NEW_LINE INDENT neg = 0 ; NEW_LINE tmp = 1 if a < 0 else - 1 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += tmp ; NEW_LINE a += tmp ; NEW_LINE DEDENT return neg ; NEW_LINE DEDENT def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) ; NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipSign ( b ) ; NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return mul ( b , a ) ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( abs ( b ) , 0 , - 1 ) : NEW_LINE INDENT sum += a ; NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT sum = flipSign ( sum ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT quotient = 0 ; NEW_LINE divisor = flipSign ( abs ( b ) ) ; NEW_LINE for dividend in range ( abs ( a ) , abs ( divisor ) + divisor , divisor ) : NEW_LINE INDENT quotient += 1 ; NEW_LINE DEDENT if ( areDifferentSign ( a , b ) ) : NEW_LINE INDENT quotient = flipSign ( quotient ) ; NEW_LINE DEDENT return quotient ; NEW_LINE DEDENT print ( \" Subtraction ▁ is \" , sub ( 4 , - 2 ) ) ; NEW_LINE print ( \" Product ▁ is \" , mul ( - 9 , 6 ) ) ; NEW_LINE a , b = 8 , 2 ; NEW_LINE if ( b ) : NEW_LINE INDENT print ( \" Division ▁ is \" , division ( a , b ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Exception ▁ : - ▁ Divide ▁ by ▁ 0\" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Implement * , | Function to flip the sign using only \" + \" operator ( It is simple with ' * ' allowed . We need to do a = ( - 1 ) * a ; If sign is + ve turn it - ve and vice - versa ; Check if a and b are of different signs ; Function to subtract two numbers by negating b and adding them ; Negating b ; Function to multiply a by b by adding a to itself b times ; because algo is faster if b < a ; Adding a to itself b times ; Check if final sign must be - ve or + ve ; Function to divide a by b by counting how many times ' b ' can be subtracted from ' a ' before getting 0 ; Negating b to subtract from a ; Subtracting divisor from dividend ; Check if a and b are of similar symbols or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13101-13101",
        "Code": "def numOfCombinations ( arr , N ) : NEW_LINE INDENT C = [ 0 , 0 , 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ arr [ i ] % 3 ] = C [ arr [ i ] % 3 ] + 1 NEW_LINE DEDENT return ( C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ) NEW_LINE DEDENT arr1 = [ 1 , 5 , 7 , 2 , 9 , 14 ] NEW_LINE print ( int ( numOfCombinations ( arr1 , 6 ) ) ) NEW_LINE arr2 = [ 3 , 6 , 9 , 12 ] NEW_LINE print ( int ( numOfCombinations ( arr2 , 4 ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of Groups of Sizes Two Or Three Divisible By 3 | Program to find groups of 2 or 3 whose sum is divisible by 3 ; Initialize groups to 0 ; Increment group with specified remainder ; Return groups using the formula ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13106-13106",
        "Code": "import math ; NEW_LINE MAX_ITERATIONS = 10000 ; NEW_LINE def f ( x ) : NEW_LINE INDENT return ( 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ) ; NEW_LINE DEDENT def Muller ( a , b , c ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT f1 = f ( a ) ; f2 = f ( b ) ; f3 = f ( c ) ; NEW_LINE d1 = f1 - f3 ; NEW_LINE d2 = f2 - f3 ; NEW_LINE h1 = a - c ; NEW_LINE h2 = b - c ; NEW_LINE a0 = f3 ; NEW_LINE a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; NEW_LINE a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; NEW_LINE x = ( ( - 2 * a0 ) / ( a1 + abs ( math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; NEW_LINE y = ( ( - 2 * a0 ) / ( a1 - abs ( math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; NEW_LINE if ( x >= y ) : NEW_LINE INDENT res = x + c ; NEW_LINE DEDENT else : NEW_LINE INDENT res = y + c ; NEW_LINE DEDENT m = res * 100 ; NEW_LINE n = c * 100 ; NEW_LINE m = math . floor ( m ) ; NEW_LINE n = math . floor ( n ) ; NEW_LINE if ( m == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT a = b ; NEW_LINE b = c ; NEW_LINE c = res ; NEW_LINE if ( i > MAX_ITERATIONS ) : NEW_LINE INDENT print ( \" Root ▁ cannot ▁ be ▁ found ▁ using \" , \" Muller ' s ▁ method \" ) ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( i <= MAX_ITERATIONS ) : NEW_LINE INDENT print ( \" The ▁ value ▁ of ▁ the ▁ root ▁ is \" , round ( res , 4 ) ) ; NEW_LINE DEDENT DEDENT a = 0 ; NEW_LINE b = 1 ; NEW_LINE c = 2 ; NEW_LINE Muller ( a , b , c ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program for Muller Method | Python3 Program to find root of a function , f ( x ) ; Function to calculate f ( x ) ; Taking f ( x ) = x ^ 3 + 2 x ^ 2 + 10 x - 20 ; Calculating various constants required to calculate x3 ; Taking the root which is closer to x2 ; checking for resemblance of x3 with x2 till two decimal places ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13109-13109",
        "Code": "import math NEW_LINE def nthprimedigitsnumber ( n ) : NEW_LINE INDENT len = 1 ; NEW_LINE prev_count = 0 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_count = ( prev_count + math . pow ( 4 , len ) ) ; NEW_LINE if ( prev_count < n and curr_count >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT len += 1 ; NEW_LINE prev_count = curr_count ; NEW_LINE DEDENT for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if ( prev_count + pow ( 4 , len - i ) < n ) : NEW_LINE INDENT prev_count += pow ( 4 , len - i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( j == 1 ) : NEW_LINE INDENT print ( \"2\" , end = \" \" ) ; NEW_LINE DEDENT elif ( j == 2 ) : NEW_LINE INDENT print ( \"3\" , end = \" \" ) ; NEW_LINE DEDENT elif ( j == 3 ) : NEW_LINE INDENT print ( \"5\" , end = \" \" ) ; NEW_LINE DEDENT elif ( j == 4 ) : NEW_LINE INDENT print ( \"7\" , end = \" \" ) ; NEW_LINE DEDENT break ; NEW_LINE DEDENT DEDENT DEDENT print ( ) ; NEW_LINE DEDENT nthprimedigitsnumber ( 10 ) ; NEW_LINE nthprimedigitsnumber ( 21 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Finding n | Python3 implementation for finding nth number made of prime digits only ; Prints n - th number where each digit is a prime number ; Finding the length of n - th number ; Count of numbers with len - 1 digits ; Count of numbers with i digits ; if i is the length of such number then n < 4 * ( 4 ^ ( i - 1 ) - 1 ) / 3 and n >= 4 * ( 4 ^ i - 1 ) / 3 if a valid i is found break the loop ; check for i + 1 ; Finding ith digit at ith place ; j = 1 means 2 j = 2 means ... j = 4 means 7 ; if prev_count + 4 ^ ( len - i ) is less than n , increase prev_count by 4 ^ ( x - i ) ; else print the ith digit and break ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13110-13110",
        "Code": "def nthprimedigitsnumber ( number ) : NEW_LINE INDENT num = \" \" ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 4 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT num += '2' ; NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT num += '3' ; NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT num += '5' ; NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT num += '7' ; NEW_LINE DEDENT if ( number % 4 == 0 ) : NEW_LINE INDENT number = number - 1 NEW_LINE DEDENT number = number // 4 ; NEW_LINE DEDENT return num [ : : - 1 ] ; NEW_LINE DEDENT number = 21 ; NEW_LINE print ( nthprimedigitsnumber ( 10 ) ) ; NEW_LINE print ( nthprimedigitsnumber ( number ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Finding n | Python3 program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13120-13120",
        "Code": "from math import pow NEW_LINE def sumOfTermsInNthRow ( n ) : NEW_LINE INDENT sum = n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( \" Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = \" , int ( sumOfTermsInNthRow ( n ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the sum of all the terms in the n | Python 3 implementation to find the sum of all the terms in the nth row of the given series ; function to find the required sum ; sum = n * ( 2 * n ^ 2 + 1 ) ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13122-13122",
        "Code": "def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE",
        "Type": "py",
        "NL": "First digit in product of an array of numbers | Python implementation to find first digit of a single number ; Keep dividing by 10 until it is greater than equal to 10 ; driver function",
        "Category": "Math"
    },
    {
        "ID": "13123-13123",
        "Code": "import math NEW_LINE def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ( int ) ( FirstDigit ( arr , n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "First digit in product of an array of numbers | Python implementation of finding first digit of product of n numbers ; Returns the first digit of product of elements of arr [ ] ; stores the logarithm of product of elements of arr [ ] ; fractional ( s ) = s - floor ( s ) ; ans = 10 ^ fract_s ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "13128-13128",
        "Code": "def printUnique ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i ; NEW_LINE visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; NEW_LINE while ( num ) : NEW_LINE INDENT if visited [ num % 10 ] == 1 : NEW_LINE INDENT break ; NEW_LINE DEDENT visited [ num % 10 ] = 1 ; NEW_LINE num = ( int ) ( num / 10 ) ; NEW_LINE DEDENT if num == 0 : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT l = 1 ; NEW_LINE r = 20 ; NEW_LINE printUnique ( l , r ) ; NEW_LINE",
        "Type": "py",
        "NL": "Numbers having Unique ( or Distinct ) digits | Function to print unique digit numbers in range from l to r . ; Start traversing the numbers ; Find digits and maintain its hash ; if a digit occurs more than 1 time then break ; num will be 0 only when above loop doesn 't get  break that means the  number is unique so  print it. ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "13131-13131",
        "Code": "from math import fabs , cos NEW_LINE def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = cos ( n ) NEW_LINE i = 1 NEW_LINE denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE while ( accuracy <= fabs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT print ( ' { 0 : . 6 } ' . format ( cosx ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 30 NEW_LINE cal_cos ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate the value of sin ( x ) and cos ( x ) using Expansion | Python 3 code for implementing cos function ; Function for calculation ; Converting degrees to radian ; maps the sum along the series ; holds the actual value of sin ( n ) ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13133-13133",
        "Code": "def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE print ( \" Minimal ▁ zero ▁ is : \" , findMinZero ( p ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Fibonacci modulo p | Returns position of first Fibonacci number whose modulo p is 0. ; add previous two remainders and then take its modulo p . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13142-13142",
        "Code": "def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Multiple of x closest to n | Function to calculate the smallest multiple ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13147-13147",
        "Code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT MAX = 100 NEW_LINE arr = [ 0 for i in range ( MAX ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( \" Fibonacci ▁ numbers ▁ divisible ▁ by ▁ their ▁ indexes ▁ are ▁ : \" ) NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( arr [ i ] % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Interesting facts about Fibonacci numbers | Python3 program to demonstrate that Fibonacci numbers that are divisible by their indexes have indexes as either power of 5 or multiple of 12. ; storing Fibonacci numbers",
        "Category": "Array"
    },
    {
        "ID": "13152-13152",
        "Code": "def cbrt ( n ) : NEW_LINE INDENT return ( int ) ( n ** ( 1. / 3 ) ) NEW_LINE DEDENT def printCubes ( a , b ) : NEW_LINE INDENT acrt = cbrt ( a ) NEW_LINE bcrt = cbrt ( b ) NEW_LINE for i in range ( acrt , bcrt + 1 ) : NEW_LINE INDENT if ( i * i * i >= a and i * i * i <= b ) : NEW_LINE INDENT print ( i * i * i , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT a = 24 NEW_LINE b = 576 NEW_LINE print ( \" Perfect ▁ cubes ▁ in ▁ given ▁ range : \" ) NEW_LINE printCubes ( a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Perfect cubes in a range | Python3 code for Efficient method to print cubes between a and b ; An efficient solution to print perfect cubes between a and b ; Find cube root of both a and b ; Print cubes between acrt and bcrt ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13153-13153",
        "Code": "import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( math . sqrt ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Square root of a number using log | Python3 program to demonstrate finding square root of a number using sqrt ( )",
        "Category": "Math"
    },
    {
        "ID": "13156-13156",
        "Code": "def func ( a , k , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT a = [ 14 , 27 , 38 , 76 , 84 ] NEW_LINE k = 19 NEW_LINE res = func ( a , k , 5 ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if LCM of array elements is divisible by a prime number or not | Function to check any number of array is divisible by k or not ; If any array element is divisible by k , then LCM of whole array should also be divisible . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13159-13159",
        "Code": "def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT m = 2 ; n = 6 NEW_LINE print ( findCount ( m , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of m digit integers that are divisible by an integer n | Returns count of m digit numbers having n as divisor ; Generating largest number of m digit ; Generating largest number of m - 1 digit ; returning number of dividend ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13164-13164",
        "Code": "def toBinary ( n ) : NEW_LINE INDENT if ( n >= 1 or n <= 0 ) : NEW_LINE INDENT return \" ERROR \" ; NEW_LINE DEDENT frac = 0.5 ; NEW_LINE answer = \" . \" ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( len ( answer ) >= 32 ) : NEW_LINE INDENT return \" ERROR \" ; NEW_LINE DEDENT if ( n >= frac ) : NEW_LINE INDENT answer += \"1\" ; NEW_LINE n = n - frac ; NEW_LINE DEDENT else : NEW_LINE INDENT answer += \"0\" ; NEW_LINE DEDENT frac = ( frac / 2 ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT n = 0.625 ; NEW_LINE result = toBinary ( n ) ; NEW_LINE print ( \" ( ▁ 0\" , result , \" ) ▁ in ▁ base ▁ 2\" ) ; NEW_LINE m = 0.72 ; NEW_LINE result = toBinary ( m ) ; NEW_LINE print ( \" ( \" , result , \" ) \" ) ; NEW_LINE",
        "Type": "py",
        "NL": "Converting a Real Number ( between 0 and 1 ) to Binary String | Function to convert Binary real number to String ; Check if the number is Between 0 to 1 or Not ; Setting a limit on length : 32 characters . ; compare the number to .5 ; Now it become 0.25 ; Input value",
        "Category": "Math"
    },
    {
        "ID": "13170-13170",
        "Code": "def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 and n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( st [ n - 1 ] ) % 16 == 0 ) ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return ( ( ( int ) ( st [ n - 3 ] ) * 100 + ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) ) % 16 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE fourth_last = ( int ) ( st [ n - 4 ] ) NEW_LINE return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) NEW_LINE DEDENT st = \"769528\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check a large number is divisible by 16 or not | Function to find that number divisible by 16 or not ; Empty string ; If there is double digit ; If there is triple digit ; If number formed by last four digits is divisible by 16. ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13173-13173",
        "Code": "def isLeap ( y ) : NEW_LINE INDENT if ( y % 100 != 0 and y % 4 == 0 or y % 400 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def offsetDays ( d , m , y ) : NEW_LINE INDENT offset = d NEW_LINE switcher = { 10 : 30 , 9 : 31 , 8 : 30 , 7 : 31 , 6 : 31 , 5 : 30 , 4 : 31 , 3 : 30 , 2 : 31 , 1 : 28 , 0 : 31 } NEW_LINE if ( isLeap ( y ) and m > 1 ) : NEW_LINE INDENT offset += 1 NEW_LINE DEDENT offset += switcher . get ( m ) NEW_LINE return offset NEW_LINE DEDENT def revoffsetDays ( offset , y , d , m ) : NEW_LINE INDENT month = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE if ( isLeap ( y ) ) : NEW_LINE INDENT month [ 2 ] = 29 NEW_LINE DEDENT for i in range ( 1 , 13 ) : NEW_LINE INDENT if ( offset <= month [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT offset = offset - month [ i ] NEW_LINE DEDENT d [ 0 ] = offset NEW_LINE m [ 0 ] = i + 1 NEW_LINE DEDENT def addDays ( d1 , m1 , y1 , x ) : NEW_LINE INDENT offset1 = offsetDays ( d1 , m1 , y1 ) NEW_LINE if isLeap ( y1 ) : NEW_LINE INDENT remDays = 366 - offset1 NEW_LINE DEDENT else : NEW_LINE INDENT remDays = 365 - offset1 NEW_LINE DEDENT if ( x <= remDays ) : NEW_LINE INDENT y2 = y1 NEW_LINE offset2 = offset1 + x NEW_LINE DEDENT else : NEW_LINE INDENT x -= remDays NEW_LINE y2 = y1 + 1 NEW_LINE if isLeap ( y2 ) : NEW_LINE INDENT y2days = 366 NEW_LINE DEDENT else : NEW_LINE INDENT y2days = 365 NEW_LINE DEDENT while ( x >= y2days ) : NEW_LINE INDENT x -= y2days NEW_LINE y2 += 1 NEW_LINE if isLeap ( y2 ) : NEW_LINE INDENT y2days = 366 NEW_LINE DEDENT else : NEW_LINE INDENT y2days = 365 NEW_LINE DEDENT DEDENT offset2 = x NEW_LINE DEDENT m2 = [ 0 ] NEW_LINE d2 = [ 0 ] NEW_LINE revoffsetDays ( offset2 , y2 , d2 , m2 ) NEW_LINE print ( \" d2 ▁ = ▁ \" , * d2 , \" , ▁ m2 ▁ = ▁ \" , * m2 , \" , ▁ y2 ▁ = ▁ \" , y2 , sep = \" \" ) NEW_LINE DEDENT d = 14 NEW_LINE m = 3 NEW_LINE y = 2015 NEW_LINE x = 366 NEW_LINE addDays ( d , m , y , x ) NEW_LINE",
        "Type": "py",
        "NL": "Date after adding given number of days to the given date | Return if year is leap year or not . ; Given a date , returns number of days elapsed from the beginning of the current year ( 1 stjan ) . ; Given a year and days elapsed in it , finds date by storing results in d and m . ; Add x days to the given date . ; y2 is going to store result year and offset2 is going to store offset days in result year . ; x may store thousands of days . We find correct year and offset in the year . ; Find values of day and month from offset of result year . ; Driven Program",
        "Category": "Math"
    },
    {
        "ID": "13174-13174",
        "Code": "import math NEW_LINE def divisorSum ( N , K ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT Sum += ( i + int ( N / i ) ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isHyperPerfect ( N , K ) : NEW_LINE INDENT Sum = divisorSum ( N , K ) NEW_LINE if ( ( 1 + K * ( Sum ) ) == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT N1 = 1570153 NEW_LINE K1 = 12 NEW_LINE N2 = 321 NEW_LINE K2 = 3 NEW_LINE if ( isHyperPerfect ( N1 , K1 ) ) : NEW_LINE INDENT print ( N1 , \" ▁ is ▁ \" , K1 , \" - HyperPerfect \" , sep = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N1 , \" ▁ is ▁ not ▁ \" , K1 , \" - HyperPerfect \" , sep = \" \" ) NEW_LINE DEDENT if ( isHyperPerfect ( N2 , K2 ) ) : NEW_LINE INDENT print ( N2 , \" ▁ is ▁ \" , K2 , \" - HyperPerfect \" , sep = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N2 , \" ▁ is ▁ not ▁ \" , K2 , \" - HyperPerfect \" , sep = \" \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Determine whether a given number is a Hyperperfect Number | Python3 program to check whether a given number is k - hyperperfect ; Function to find the sum of all proper divisors ( excluding 1 and N ) ; Iterate only until sqrt N as we are going to generate pairs to produce divisors ; As divisors occur in pairs , we can take the values i and N / i as long as i divides N ; Function to check whether the given number is prime ; Base and corner cases ; Since integers can be represented as some 6 * k + y where y >= 0 , we can eliminate all integers that can be expressed in this form ; Start from 5 as this is the next prime number ; Returns true if N is a K - Hyperperfect number . Else returns false . ; Condition from the definition of hyperperfect ; Driver code ; First two statements test against the condition N = 1 + K * ( sum ( proper divisors ) )",
        "Category": "Math"
    },
    {
        "ID": "13175-13175",
        "Code": "def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Given a number n , find the first k digits of n ^ n | function that manually calculates n ^ n and then removes digits until k digits remain ; loop will terminate when there are only k digits left ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13189-13189",
        "Code": "def count2sinRangeAtDigit ( number , d ) : NEW_LINE INDENT powerOf10 = int ( pow ( 10 , d ) ) ; NEW_LINE nextPowerOf10 = powerOf10 * 10 ; NEW_LINE right = number % powerOf10 ; NEW_LINE roundDown = number - number % nextPowerOf10 ; NEW_LINE roundup = roundDown + nextPowerOf10 ; NEW_LINE digit = ( number // powerOf10 ) % 10 ; NEW_LINE if ( digit < 2 ) : NEW_LINE INDENT return roundDown // 10 ; NEW_LINE DEDENT if ( digit == 2 ) : NEW_LINE INDENT return roundDown // 10 + right + 1 ; NEW_LINE DEDENT return roundup // 10 ; NEW_LINE DEDENT def numberOf2sinRange ( number ) : NEW_LINE INDENT s = str ( number ) ; NEW_LINE len1 = len ( s ) ; NEW_LINE count = 0 ; NEW_LINE for digit in range ( len1 ) : NEW_LINE INDENT count += count2sinRangeAtDigit ( number , digit ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT print ( numberOf2sinRange ( 22 ) ) ; NEW_LINE print ( numberOf2sinRange ( 100 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Number of occurrences of 2 as a digit in numbers from 0 to n | Counts the number of 2 s in a number at d - th digit ; if the digit in spot digit is ; Counts the number of '2' digits between 0 and n ; Convert integer to String to find its length ; Traverse every digit and count for every digit ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13192-13192",
        "Code": "def mod ( a , m ) : NEW_LINE INDENT return ( a % m + m ) % m NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modulo 10 ^ 9 + 7 ( 1000000007 ) |",
        "Category": "Math"
    },
    {
        "ID": "13197-13197",
        "Code": "def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT num = 1556 NEW_LINE if isTidy ( num ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Tidy Number ( Digits in non | Returns true if num is Tidy ; To store previous digit ( Assigning initial value which is more than any digit ) ; Traverse all digits from right to left and check if any digit is smaller than previous . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13222-13222",
        "Code": "def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n // 2 ) * power ( num , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n // 2 ) * power ( num , n // 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : NEW_LINE INDENT results = 0 NEW_LINE DEDENT ' NEW_LINE INDENT p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num = curr_num + 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT results = results + 1 NEW_LINE DEDENT return results NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find ways an Integer can be expressed as sum of n | Function to calculate and return the power of any given number ; Function to check power representations recursively ; Initialize number of ways to express x as n - th powers of different natural numbers ; Calling power of ' i ' raised to 'n ; Recursively check all greater values of i ; If sum of powers is equal to x then increase the value of result . ; Return the final result ; Driver Code .",
        "Category": "Backtracking"
    },
    {
        "ID": "13223-13223",
        "Code": "def checkRecursive ( num , rem_num , next_int , n , ans = 0 ) : NEW_LINE INDENT if ( rem_num == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT r = int ( num ** ( 1 / n ) ) NEW_LINE for i in range ( next_int + 1 , r + 1 ) : NEW_LINE INDENT a = rem_num - int ( i ** n ) NEW_LINE if a >= 0 : NEW_LINE INDENT ans += checkRecursive ( num , rem_num - int ( i ** n ) , i , n , 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find ways an Integer can be expressed as sum of n | Python 3 program to find number of ways to express a number as sum of n - th powers of numbers . ; Wrapper over checkRecursive ( ) ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "13228-13228",
        "Code": "import math ; NEW_LINE def reverseNum ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE rev = ( rev * 10 ) + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalindrom ( num ) : NEW_LINE INDENT return num == reverseNum ( num ) ; NEW_LINE DEDENT def nthPalindrome ( n , k ) : NEW_LINE INDENT num = math . pow ( 10 , k - 1 ) ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPalindrom ( num ) ) : NEW_LINE INDENT n -= 1 ; NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return int ( num ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE k = 5 ; NEW_LINE print ( n , \" th ▁ palindrome ▁ of \" , k , \" digit ▁ = \" , nthPalindrome ( n , k ) ) ; NEW_LINE n = 10 ; NEW_LINE k = 6 ; NEW_LINE print ( n , \" th ▁ palindrome ▁ of \" , k , \" digit ▁ = \" , nthPalindrome ( n , k ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "N 'th palindrome of K digits | A naive approach of Python3 program of finding nth palindrome of k digit ; Utility function to reverse the number n ; Boolean Function to check for palindromic number ; Function for finding nth palindrome of k digits ; Get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found  break the loop ; Increment number for checking next palindrome ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "13229-13229",
        "Code": "def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = \" \" ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = \" \" ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , \" th ▁ palindrome ▁ of \" , k , \" ▁ digit ▁ = ▁ \" , end = \" ▁ \" ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , \" th ▁ palindrome ▁ of \" , k , \" digit ▁ = ▁ \" , end = \" ▁ \" ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "N 'th palindrome of K digits | Python3 program of finding nth palindrome of k digit ; Determine the first half digits ; Print the first half digits of palindrome ; If k is odd , truncate the last digit ; print the last half digits of palindrome ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1323-1323",
        "Code": "from collections import defaultdict NEW_LINE def canPairs ( arr , n , k ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ( ( arr [ i ] % k ) + k ) % k ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT rem = ( ( arr [ i ] % k ) + k ) % k NEW_LINE if ( 2 * rem == k ) : NEW_LINE INDENT if ( freq [ rem ] % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT elif ( rem == 0 ) : NEW_LINE INDENT if ( freq [ rem ] & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT elif ( freq [ rem ] != freq [ k - rem ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 92 , 75 , 65 , 48 , 45 , 35 ] NEW_LINE k = 10 NEW_LINE n = len ( arr ) NEW_LINE if ( canPairs ( arr , n , k ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if an array can be divided into pairs whose sum is divisible by k | Python3 program to check if arr [ 0. . n - 1 ] can be divided in pairs such that every pair is divisible by k . ; Returns true if arr [ 0. . n - 1 ] can be divided into pairs with sum divisible by k . ; An odd length array cannot be divided into pairs ; Create a frequency array to count occurrences of all remainders when divided by k . ; Count occurrences of all remainders ; Traverse input array and use freq [ ] to decide if given array can be divided in pairs ; Remainder of current element ; If remainder with current element divides k into two halves . ; Then there must be even occurrences of such remainder ; If remainder is 0 , then there must be two elements with 0 remainde ; Then there must be even occurrences of such remainder ; Else number of occurrences of remainder must be equal to number of occurrences of k - remainder ; Driver code ; Function call",
        "Category": "Hash Table"
    },
    {
        "ID": "13232-13232",
        "Code": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sq = ( int ) ( math . sqrt ( x ) ) NEW_LINE return ( x == sq * sq ) NEW_LINE DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if isPerfectSquare ( i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT if n / i != i and isPerfectSquare ( n / i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT print ( \" Total ▁ perfect ▁ divisor ▁ of ▁ 16 ▁ = ▁ \" , countPerfectDivisors ( 16 ) ) NEW_LINE print ( \" Total ▁ perfect ▁ divisor ▁ of ▁ 12 ▁ = ▁ \" , countPerfectDivisors ( 12 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count all perfect divisors of a number | Python3 implementation of Naive method to count all perfect divisors ; Utility function to check perfect square number ; function to count all perfect divisors ; Initialize result ; Consider every number that can be a divisor of n ; If i is a divisor ; Driver program to test above function",
        "Category": "Math"
    },
    {
        "ID": "13233-13233",
        "Code": "MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( \" Total ▁ perfect ▁ divisors ▁ of ▁ \" , n , \" ▁ = ▁ \" , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( \" Total ▁ perfect ▁ divisors ▁ of ▁ \" , n , \" ▁ = ▁ \" , countPerfectDivisors ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count all perfect divisors of a number | Below is Python3 code to count total perfect divisors ; Pre - compute counts of all perfect divisors of all numbers upto MAX . ; Iterate through all the multiples of i * i ; Increment all such multiples by 1 ; Returns count of perfect divisors of n . ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13234-13234",
        "Code": "MAX = 100001 NEW_LINE phi = [ 0 ] * MAX NEW_LINE result = [ 0 ] * MAX NEW_LINE def computeTotient ( ) : NEW_LINE INDENT phi [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if not phi [ i ] : NEW_LINE INDENT phi [ i ] = i - 1 NEW_LINE for j in range ( i << 1 , MAX , i ) : NEW_LINE INDENT if not phi [ j ] : NEW_LINE INDENT phi [ j ] = j NEW_LINE DEDENT phi [ j ] = ( ( phi [ j ] // i ) * ( i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumOfGcdPairs ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( 2 , MAX ) : NEW_LINE INDENT if i * j >= MAX : NEW_LINE INDENT break NEW_LINE DEDENT result [ i * j ] += i * phi [ j ] NEW_LINE DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT result [ i ] += result [ i - 1 ] NEW_LINE DEDENT DEDENT sumOfGcdPairs ( ) NEW_LINE N = 4 NEW_LINE print ( \" Summation ▁ of \" , N , \" = \" , result [ N ] ) NEW_LINE N = 12 NEW_LINE print ( \" Summation ▁ of \" , N , \" = \" , result [ N ] ) NEW_LINE N = 5000 NEW_LINE print ( \" Summation ▁ of \" , N , \" = \" , result [ N ] ) NEW_LINE",
        "Type": "py",
        "NL": "Summation of GCD of all the pairs up to N | Python approach of finding sum of GCD of all pairs ; phi [ i ] stores euler totient function for i result [ j ] stores result for value j ; Precomputation of phi [ ] numbers . Refer below link for details : https : goo . gl / LUqdtY ; Refer https : goo . gl / LUqdtY ; Precomputes result for all numbers till MAX ; Precompute all phi value ; Iterate throght all the divisors of i . ; Add summation of previous calculated sum ; Function to calculate sum of all the GCD pairs",
        "Category": "Math"
    },
    {
        "ID": "13235-13235",
        "Code": "import math as mt NEW_LINE MAXN = 100001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( MAXN ) ) ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT ret = list ( ) NEW_LINE while ( x != 1 ) : NEW_LINE INDENT ret . append ( spf [ x ] ) NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT return ret NEW_LINE DEDENT sieve ( ) NEW_LINE x = 12246 NEW_LINE print ( \" prime ▁ factorization ▁ for \" , x , \" : ▁ \" , end = \" \" ) NEW_LINE p = getFactorization ( x ) NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT print ( p [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Prime Factorization using Sieve O ( log n ) for multiple queries | Python3 program to find prime factorization of a number n in O ( Log n ) time with precomputation allowed . ; stores smallest prime factor for every number ; Calculating SPF ( Smallest Prime Factor ) for every number till MAXN . Time Complexity : O ( nloglogn ) ; marking smallest prime factor for every number to be itself . ; separately marking spf for every even number as 2 ; checking if i is prime ; marking SPF for all numbers divisible by i ; marking spf [ j ] if it is not previously marked ; A O ( log n ) function returning prime factorization by dividing by smallest prime factor at every step ; precalculating Smallest Prime Factor ; calling getFactorization function",
        "Category": "Math"
    },
    {
        "ID": "1324-1324",
        "Code": "def subarrayDivisibleByK ( arr , n , k ) : NEW_LINE INDENT mp = [ 0 ] * 1000 NEW_LINE s = 0 ; e = 0 ; maxs = 0 ; maxe = 0 ; NEW_LINE mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 NEW_LINE s = s + 1 NEW_LINE DEDENT mp [ mod ] = mp [ mod ] + 1 NEW_LINE e = e + 1 NEW_LINE if ( ( e - s ) > ( maxe - maxs ) ) : NEW_LINE INDENT maxe = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( \" The ▁ maximum ▁ size ▁ is ▁ { } ▁ and ▁ the ▁ \" . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs , maxe + 1 ) : NEW_LINE INDENT print ( \" { } ▁ \" . format ( arr [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT k = 3 NEW_LINE arr = [ 5 , 10 , 15 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE subarrayDivisibleByK ( arr , n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Subarray with no pair sum divisible by K | function to find the subarray with no pair sum divisible by k ; hash table to store the remainders obtained on dividing by K ; s : starting index of the current subarray , e : ending index of the current subarray , maxs : starting index of the maximum size subarray so far , maxe : ending index of the maximum size subarray so far ; insert the first element in the set ; Removing starting elements of current subarray while there is an element in set which makes a pair with mod [ i ] such that the pair sum is divisible . ; include the current element in the current subarray the ending index of the current subarray increments by one ; compare the size of the current subarray with the maximum size so far ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "13244-13244",
        "Code": "import math as mt NEW_LINE MAX = 100001 NEW_LINE prime = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE countdiv = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX + 1 ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] += 1 NEW_LINE ans = max ( ans , countdiv [ div ] ) NEW_LINE while ( element % div == 0 ) : NEW_LINE INDENT element = element // div NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 10 , 15 , 7 , 25 , 9 , 35 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest subsequence having GCD greater than 1 | Efficient Python3 program to find length of the largest subsequence with GCD greater than 1. ; prime [ ] for storing smallest prime divisor of element count [ ] for storing the number of times a particular divisor occurs in a subsequence ; Simple sieve to find smallest prime factors of numbers smaller than MAX ; Prime number will have same divisor ; Returns length of the largest subsequence with GCD more than 1. ; Fetch total unique prime divisor of element ; Increment count [ ] of Every unique divisor we get till now ; Find maximum frequency of divisor ; Pre - compute smallest divisor of all numbers",
        "Category": "Math"
    },
    {
        "ID": "13257-13257",
        "Code": "def checkReversible ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE flag = n NEW_LINE while ( flag != 0 ) : NEW_LINE INDENT rem = flag % 10 NEW_LINE rev *= 10 NEW_LINE rev += rem NEW_LINE flag //= 10 NEW_LINE DEDENT sum = rev + n NEW_LINE while ( sum and ( ( rem % 2 ) != 0 ) ) : NEW_LINE INDENT rem = sum % 10 NEW_LINE sum //= 10 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( \" Reversible ▁ Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Non - Reversible ▁ Number \" ) NEW_LINE DEDENT DEDENT n = 36 NEW_LINE checkReversible ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Reversible numbers | Function to check reversible number ; Calculate reverse of n ; Calculate sum of number and its reverse ; Check for reverse number reach digit must be odd ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13269-13269",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b , a % b ) if b > 0 else a NEW_LINE DEDENT def countGCD ( L , R , g ) : NEW_LINE INDENT L = ( L + g - 1 ) // g NEW_LINE R = R // g NEW_LINE ans = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT for j in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( i , j ) == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT L = 1 NEW_LINE R = 11 NEW_LINE g = 5 NEW_LINE print ( countGCD ( L , R , g ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count pairs of natural numbers with GCD equal to given number | Return the GCD of two numbers . ; Return the count of pairs having GCD equal to g . ; Setting the value of L , R . ; For each possible pair check if GCD is 1. ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13284-13284",
        "Code": "def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the first natural number whose factorial is divisible by x | Returns first number whose factorial divides x . ; i = 1 ; Result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13292-13292",
        "Code": "def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x //= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x // 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers with same first and last digits | Utility method to get first digit of x ; method to return count of numbers with same starting and ending digit from 1 upto x ; get ten - spans from 1 to x ; add 9 to consider all 1 digit numbers ; Find first and last digits ; If last digit is greater than first digit then decrease count by 1 ; Method to return count of numbers with same starting and ending digit between start and end ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13295-13295",
        "Code": "def countMaxChoco ( money , price , wrap ) : NEW_LINE INDENT if ( money < price ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT choc = int ( money / price ) NEW_LINE choc = choc + ( choc - 1 ) / ( wrap - 1 ) NEW_LINE return int ( choc ) NEW_LINE DEDENT money = 15 NEW_LINE price = 1 NEW_LINE wrap = 3 NEW_LINE print ( countMaxChoco ( money , price , wrap ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Chocolate and Wrapper Puzzle | Returns maximum number of chocolates we can eat with given money , price of chocolate and number of wrapprices required to get a chocolate . ; Corner case ; First find number of chocolates that can be purchased with the given amount ; Now just add number of chocolates with the chocolates gained by wrapprices ; total money ; cost of each candy ; no of wrappers needs to be ; exchanged for one chocolate .",
        "Category": "Math"
    },
    {
        "ID": "13298-13298",
        "Code": "def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT N = 10 ; NEW_LINE K = 2 ; NEW_LINE print ( findSum ( N , K ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find sum of modulo K of first N natural number | Return sum of modulo K of first N natural numbers . ; Counting the number of times 1 , 2 , . . , K - 1 , 0 sequence occurs . ; Finding the number of elements left which are incomplete of sequence Leads to Case 1 type . ; adding multiplication of number of times 1 , 2 , . . , K - 1 , 0 sequence occurs and sum of first k natural number and sequence from case 1. ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "133-133",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def areMirrors ( root1 , root2 ) : NEW_LINE INDENT st1 = [ ] NEW_LINE st2 = [ ] NEW_LINE while ( 1 ) : NEW_LINE INDENT while ( root1 and root2 ) : NEW_LINE INDENT if ( root1 . data != root2 . data ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT st1 . append ( root1 ) NEW_LINE st2 . append ( root2 ) NEW_LINE root1 = root1 . left NEW_LINE root2 = root2 . right NEW_LINE DEDENT if ( not ( root1 == None and root2 == None ) ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT if ( not len ( st1 ) == 0 and not len ( st2 ) == 0 ) : NEW_LINE INDENT root1 = st1 [ - 1 ] NEW_LINE root2 = st2 [ - 1 ] NEW_LINE st1 . pop ( - 1 ) NEW_LINE st2 . pop ( - 1 ) NEW_LINE root1 = root1 . right NEW_LINE root2 = root2 . left NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = newNode ( 1 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 2 ) NEW_LINE root1 . right . left = newNode ( 5 ) NEW_LINE root1 . right . right = newNode ( 4 ) NEW_LINE root2 = newNode ( 1 ) NEW_LINE root2 . left = newNode ( 2 ) NEW_LINE root2 . right = newNode ( 3 ) NEW_LINE root2 . left . left = newNode ( 4 ) NEW_LINE root2 . left . right = newNode ( 5 ) NEW_LINE print ( areMirrors ( root1 , root2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Iterative method to check if two trees are mirror of each other | Utility function to create and return a new node for a binary tree ; function to check whether the two binary trees are mirrors of each other or not ; iterative inorder traversal of 1 st tree and reverse inoder traversal of 2 nd tree ; if the corresponding nodes in the two traversal have different data values , then they are not mirrors of each other . ; if at any point one root becomes None and the other root is not None , then they are not mirrors . This condition verifies that structures of tree are mirrors of each other . ; we have visited the node and its left subtree . Now , it ' s ▁ right ▁ subtree ' s turn ; we have visited the node and its right subtree . Now , it ' s ▁ left ▁ subtree ' s turn ; both the trees have been completely traversed ; tress are mirrors of each other ; Driver Code ; 1 st binary tree formation 1 ; / \\ ; 3 2 ; / \\ ; 5 4 ; 2 nd binary tree formation 1 ; / \\ ; 2 3 ; / \\ ; 4 5 ; function cal",
        "Category": "Binary Tree"
    },
    {
        "ID": "1330-1330",
        "Code": "def maxLen ( arr ) : NEW_LINE INDENT hash_map = { } NEW_LINE curr_sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if arr [ i ] is 0 and max_len is 0 : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if curr_sum is 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if curr_sum in hash_map : NEW_LINE INDENT max_len = max ( max_len , i - hash_map [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ curr_sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 15 , - 2 , 2 , - 8 , 1 , 7 , 10 , 13 ] NEW_LINE print \" Length ▁ of ▁ the ▁ longest ▁ 0 ▁ sum ▁ subarray ▁ is ▁ % ▁ d \" % maxLen ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Find the length of largest subarray with 0 sum | Returns the maximum length ; NOTE : Dictonary in python in implemented as Hash Maps Create an empty hash map ( dictionary ) ; Initialize sum of elements ; Initialize result ; Traverse through the given array ; Add the current element to the sum ; NOTE : ' in ' operation in dictionary to search key takes O ( 1 ) . Look if current sum is seen before ; else put this sum in dictionary ; test array",
        "Category": "Hash Table"
    },
    {
        "ID": "13300-13300",
        "Code": "import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def findnum ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count_after_dot = 0 NEW_LINE dot_seen = 0 NEW_LINE num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] != ' . ' ) : NEW_LINE INDENT num = num * 10 + int ( str [ i ] ) NEW_LINE if ( dot_seen == 1 ) : NEW_LINE INDENT count_after_dot += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dot_seen = 1 NEW_LINE DEDENT DEDENT if ( dot_seen == 0 ) : NEW_LINE return 1 NEW_LINE dem = int ( math . pow ( 10 , count_after_dot ) ) NEW_LINE return ( dem / gcd ( num , dem ) ) NEW_LINE DEDENT str = \"5.125\" NEW_LINE print findnum ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number to multiply to convert floating point to natural | Python program to find the smallest number to multiply to convert a floating point number into natural number . Finding GCD of two number ; Returns smallest integer k such that k * str becomes natural . str is an input floating point number ; Find size of string representing a floating point number . ; Below is used to find denominator in fraction form . ; Used to find value of count_after_dot ; To find numerator in fraction form of given number . For example , for 30.25 , numerator would be 3025. ; If there was no dot , then number is already a natural . ; Find denominator in fraction form . For example , for 30.25 , denominator is 100 ; Result is denominator divided by GCD - of - numerator - and - denominator . For example , for 30.25 , result is 100 / GCD ( 3025 , 100 ) = 100 / 25 = 4 ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "13305-13305",
        "Code": "def gcd ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return i NEW_LINE DEDENT if ( i > j ) : NEW_LINE INDENT return gcd ( i - j , j ) NEW_LINE DEDENT return gcd ( i , j - i ) NEW_LINE DEDENT def ispossible ( x , y , a , b ) : NEW_LINE INDENT x , y , a , b = abs ( x ) , abs ( y ) , abs ( a ) , abs ( b ) NEW_LINE return ( gcd ( x , y ) == gcd ( a , b ) ) NEW_LINE DEDENT x , y = 35 , 15 NEW_LINE a , b = 20 , 25 NEW_LINE if ( ispossible ( x , y , a , b ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if possible to move from given coordinate to desired coordinate | Python program to check if it is possible to reach ( a , b ) from ( x , y ) . Returns GCD of i and j ; Returns true if it is possible to go to ( a , b ) from ( x , y ) ; Find absolute values of all as sign doesn 't  matter. ; If gcd is equal then it is possible to reach . Else not possible . ; Driven Program Converting coordinate into positive integer",
        "Category": "Math"
    },
    {
        "ID": "13310-13310",
        "Code": "def divisible ( N , digit ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT ans = ( ans * 10 + ( ord ( N [ i ] ) - ord ( '0' ) ) ) ; NEW_LINE ans %= digit ; NEW_LINE DEDENT return ( ans == 0 ) ; NEW_LINE DEDENT def allDigits ( N ) : NEW_LINE INDENT divide = [ False ] * 10 ; NEW_LINE for digit in range ( 2 , 10 ) : NEW_LINE INDENT if ( divisible ( N , digit ) ) : NEW_LINE INDENT divide [ digit ] = True ; NEW_LINE DEDENT DEDENT result = 0 ; NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if ( divide [ ( ord ( N [ i ] ) - ord ( '0' ) ) ] == True ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT N = \"122324\" ; NEW_LINE print ( allDigits ( N ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count digits in given number N which divide N | Utility function to check divisibility by digit ; ( N [ i ] - '0' ) gives the digit value and form the number ; Function to count digits which appears in N and divide N divide [ 10 ] -- > array which tells that particular digit divides N or not count [ 10 ] -- > counts frequency of digits which divide N ; We initialize all digits of N as not divisible by N . ; start checking divisibility of N by digits 2 to 9 ; if digit divides N then mark it as true ; Now traverse the number string to find and increment result whenever a digit divides N . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13311-13311",
        "Code": "from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i == i : NEW_LINE INDENT summ += i NEW_LINE DEDENT else : NEW_LINE INDENT summ += i NEW_LINE summ += n // i NEW_LINE DEDENT DEDENT DEDENT return summ - n NEW_LINE DEDENT def printAliquot ( n ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE nextt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n in s : NEW_LINE INDENT print ( \" Repeats ▁ with \" , n ) NEW_LINE break NEW_LINE DEDENT print ( n , end = \" ▁ \" ) NEW_LINE s . add ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT printAliquot ( 12 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Aliquot Sequence | Python implementation of Optimized approach to generate Aliquot Sequence ; Function to calculate sum of all proper divisors ; Note that this loop runs till square root of n ; If divisors are equal , take only one of them ; Otherwise take both ; calculate sum of all proper divisors only ; Function to print Aliquot Sequence for an input n . ; Print the first term ; Calculate next term from previous term ; Print next term ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13317-13317",
        "Code": "import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= ( math . sqrt ( n ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT sum = sum - n NEW_LINE return sum NEW_LINE DEDENT def checkAbundant ( n ) : NEW_LINE INDENT if ( getSum ( n ) > n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( checkAbundant ( 12 ) == 1 ) : NEW_LINE INDENT print \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" NO \" NEW_LINE DEDENT if ( checkAbundant ( 15 ) == 1 ) : NEW_LINE INDENT print \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" NO \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Abundant Number | An Optimized Solution to check Abundant Number in PYTHON ; Function to calculate sum of divisors ; Note that this loop runs till square root of n ; If divisors are equal , take only one of them ; else : Otherwise take both ; calculate sum of all proper divisors only ; Function to check Abundant Number ; Return true if sum of divisors is greater than n . ; Driver program to test above function",
        "Category": "Math"
    },
    {
        "ID": "13320-13320",
        "Code": "import math NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT print ( \" YES \" if isPowerful ( 20 ) else \" NO \" ) NEW_LINE print ( \" YES \" if isPowerful ( 27 ) else \" NO \" ) NEW_LINE",
        "Type": "py",
        "NL": "Powerful Number | Python program to find if a number is powerful or not . ; function to check if the number is powerful ; First divide the number repeatedly by 2 ; If only 2 ^ 1 divides n ( not higher powers ) , then return false ; if n is not a power of 2 then this loop will execute repeat above process ; Find highest power of \" factor \" that divides n ; If only factor ^ 1 divides n ( not higher powers ) , then return false ; n must be 1 now if it is not a prime numenr . Since prime numbers are not powerful , we return false if n is not 1. ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13326-13326",
        "Code": "import math NEW_LINE def iskaprekar ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT sq_n = n * n NEW_LINE count_digits = 1 NEW_LINE while not sq_n == 0 : NEW_LINE INDENT count_digits = count_digits + 1 NEW_LINE sq_n = sq_n / 10 NEW_LINE DEDENT r_digits = 0 NEW_LINE while r_digits < count_digits : NEW_LINE INDENT r_digits = r_digits + 1 NEW_LINE eq_parts = ( int ) ( math . pow ( 10 , r_digits ) ) NEW_LINE if eq_parts == n : NEW_LINE INDENT continue NEW_LINE DEDENT sum = sq_n / eq_parts + sq_n % eq_parts NEW_LINE if sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT i = 1 NEW_LINE while i < 10000 : NEW_LINE INDENT if ( iskaprekar ( i ) ) : NEW_LINE INDENT print i , \" ▁ \" , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Kaprekar Number | Python program to check if a number is Kaprekar number or not ; Returns true if n is a Kaprekar number , else false ; Count number of digits in square ; Split the square at different poitns and see if sum of any pair of splitted numbers is equal to n . ; To avoid numbers like 10 , 100 , 1000 ( These are not Karprekar numbers ; Find sum of current parts and compare with n ; compare with original number ; Driver method",
        "Category": "Math"
    },
    {
        "ID": "13335-13335",
        "Code": "def canBeSumofConsec ( n ) : NEW_LINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEW_LINE DEDENT n = 15 NEW_LINE if ( canBeSumofConsec ( n ) ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number can be expressed as a sum of consecutive numbers | This function returns true if n can be expressed sum of consecutive . ; We basically return true if n is a power of two ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13340-13340",
        "Code": "import math NEW_LINE def lcm ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = int ( ( ans * i ) / math . gcd ( ans , i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 20 NEW_LINE print ( lcm ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number divisible by first n numbers | Python program to find the smallest number evenly divisible by all number 1 to n ; Returns the lcm of first n numbers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13341-13341",
        "Code": "def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE",
        "Type": "py",
        "NL": "Even Fibonacci Numbers Sum | Returns sum of even Fibonacci numbers which are less than or equal to given limit . ; Initialize first two even prime numbers and their sum ; calculating sum of even Fibonacci value ; get next even value of Fibonacci sequence ; If we go beyond limit , we break loop ; Move to next even number and update sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13342-13342",
        "Code": "import math NEW_LINE def isPerfect ( n ) : NEW_LINE INDENT s = math . sqrt ( n ) NEW_LINE return ( s * s == n ) NEW_LINE DEDENT def divisorsCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def kDivisors ( a , b , k ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isPerfect ( i ) ) : NEW_LINE INDENT if ( divisorsCount ( i ) == k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = 2 NEW_LINE b = 49 NEW_LINE k = 3 NEW_LINE print ( kDivisors ( a , b , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find numbers with K odd divisors in a given range | Python3 program to count numbers with k odd divisors in a range . ; Utility function to check if number is perfect square or not ; Utility Function to return count of divisors of a number ; Note that this loop runs till square root ; If divisors are equal , counbt it only once ; Otherwise print both ; Function to calculate all divisors having exactly k divisors between a and b ; calculate only for perfect square numbers ; check if number is perfect square or not ; total divisors of number equals to k or not ; Driver program to run the case",
        "Category": "Math"
    },
    {
        "ID": "13350-13350",
        "Code": "from math import sqrt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE result = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += 2 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE b = 24 ; NEW_LINE print ( commDiv ( a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Common Divisors of Two Numbers | Python implementation of program ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find GCD of a , b ; Count divisors of n ; if i is a factor of n ; check if divisors are equal ; Driver program to run the case",
        "Category": "Math"
    },
    {
        "ID": "13353-13353",
        "Code": "def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def trapezoidal ( a , b , n ) : NEW_LINE INDENT h = ( b - a ) / n NEW_LINE s = ( y ( a ) + y ( b ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT s += 2 * y ( a + i * h ) NEW_LINE i += 1 NEW_LINE DEDENT return ( ( h / 2 ) * s ) NEW_LINE DEDENT x0 = 0 NEW_LINE xn = 1 NEW_LINE n = 6 NEW_LINE print ( \" Value ▁ of ▁ integral ▁ is ▁ \" , \" % .4f \" % trapezoidal ( x0 , xn , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Trapezoidal Rule for Approximate Value of Definite Integral | A sample function whose definite integral 's approximate value is computed using Trapezoidal rule ; Declaring the function f ( x ) = 1 / ( 1 + x * x ) ; Function to evaluate the value of integral ; Grid spacing ; Computing sum of first and last terms in above formula ; Adding middle terms in above formula ; h / 2 indicates ( b - a ) / 2 n . Multiplying h / 2 with s . ; Range of definite integral ; Number of grids . Higher value means more accuracy",
        "Category": "Math"
    },
    {
        "ID": "13357-13357",
        "Code": "def numSquareSum ( n ) : NEW_LINE INDENT squareSum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT squareSum += ( n % 10 ) * ( n % 10 ) ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return squareSum ; NEW_LINE DEDENT def isHappynumber ( n ) : NEW_LINE INDENT slow = n ; NEW_LINE fast = n ; NEW_LINE while ( True ) : NEW_LINE INDENT slow = numSquareSum ( slow ) ; NEW_LINE fast = numSquareSum ( numSquareSum ( fast ) ) ; NEW_LINE if ( slow != fast ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( slow == 1 ) ; NEW_LINE DEDENT n = 13 ; NEW_LINE if ( isHappynumber ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ a ▁ Happy ▁ number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ a ▁ Happy ▁ number \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Happy Number | Utility method to return sum of square of digit of n ; method return true if n is Happy number ; initialize slow and fast by n ; move slow number by one iteration ; move fast number by two iteration ; if both number meet at 1 , then return true ; Driver Code",
        "Category": "Two Pointers"
    },
    {
        "ID": "13359-13359",
        "Code": "def kaprekarRec ( n , prev ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT prev = n ; NEW_LINE digits = [ 0 ] * 4 ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT digits [ i ] = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT digits . sort ( ) ; NEW_LINE asc = 0 ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT asc = asc * 10 + digits [ i ] ; NEW_LINE DEDENT digits . sort ( ) ; NEW_LINE desc = 0 ; NEW_LINE for i in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT desc = desc * 10 + digits [ i ] ; NEW_LINE DEDENT diff = abs ( asc - desc ) ; NEW_LINE if ( diff == prev ) : NEW_LINE INDENT return diff ; NEW_LINE DEDENT return kaprekarRec ( diff , prev ) ; NEW_LINE DEDENT def kaprekar ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE return kaprekarRec ( n , rev ) ; NEW_LINE DEDENT print ( kaprekar ( 1000 ) ) ; NEW_LINE print ( kaprekar ( 1112 ) ) ; NEW_LINE print ( kaprekar ( 9812 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Kaprekar Constant | This function checks validity of kaprekar ' s ▁ constant . ▁ It ▁ returns ▁ kaprekar ' s constant for any four digit number \" n \" such that all digits of n are not same . ; Store current n as previous number ; Get four digits of given number ; Sort all four dgits in ascending order And giet in the form of number \" asc \" ; Get all four dgits in descending order in the form of number \" desc \" ; Get the difference of two numbers ; If difference is same as previous , we have reached kaprekar 's constant ; Else recur ; A wrapper over kaprekarRec ( ) ; Trying few four digit numbers , we always get 6174",
        "Category": "Math"
    },
    {
        "ID": "13360-13360",
        "Code": "def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE INDENT sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT num = 9.2345 ; NEW_LINE sqroot_of_num = sqroot ( num ) ; NEW_LINE print ( \" Square ▁ root ▁ of ▁ \" , num , \" = \" , round ( ( sqroot_of_num * 100000.0 ) / 100000.0 , 5 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Bakhshali Approximation for computing square roots | This Python3 program gives result approximated to 5 decimal places . ; This will be the nearest perfect square to s ; This is the sqrt of pSq ; Find the nearest perfect square to s ; calculate d ; calculate P ; calculate A ; calculate sqrt ( S ) . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13365-13365",
        "Code": "def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE return ( n % 9 ) NEW_LINE DEDENT n = 9999 NEW_LINE print ( digSum ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Finding sum of digits of a number until sum becomes single digit | ''Driver program to test the above function",
        "Category": "Math"
    },
    {
        "ID": "13375-13375",
        "Code": "def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( num ) : NEW_LINE INDENT return ( reversDigits ( num ) == num ) NEW_LINE DEDENT def ReverseandAdd ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num <= 4294967295 ) : NEW_LINE INDENT rev_num = reversDigits ( num ) NEW_LINE num = num + rev_num NEW_LINE if ( isPalindrome ( num ) ) : NEW_LINE INDENT print num NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if ( num > 4294967295 ) : NEW_LINE INDENT print \" No ▁ palindrome ▁ exist \" NEW_LINE DEDENT DEDENT DEDENT DEDENT ReverseandAdd ( 195 ) NEW_LINE ReverseandAdd ( 265 ) NEW_LINE",
        "Type": "py",
        "NL": "Reverse and Add Function | Iterative function to reverse digits of num ; Function to check whether the number is palindrome or not ; Reverse and Add Function ; Reversing the digits of the number ; Adding the reversed number with the original ; Checking whether the number is palindrome or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13386-13386",
        "Code": "def factors ( n , k ) : NEW_LINE INDENT v = [ ] ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( 2 ) ; NEW_LINE n //= 2 ; NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT for i in range ( 3 , int ( n ** ( 1 / 2 ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i ; NEW_LINE v . append ( i ) ; NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT v . append ( n ) ; NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def operation ( n , k ) : NEW_LINE INDENT answered = False ; NEW_LINE if ( n < k ) : NEW_LINE INDENT answered = True ; NEW_LINE print ( \" No \" ) ; NEW_LINE DEDENT ok = factors ( n , k ) ; NEW_LINE if ( not ok and not answered ) : NEW_LINE INDENT answered = True ; NEW_LINE print ( \" No \" ) ; NEW_LINE DEDENT if ( ok and not answered ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE k = 2 ; NEW_LINE operation ( n , k ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number exists having exactly N factors and K prime factors | Function to compute the number of factors of the given number ; Vector to store the prime factors ; While there are no two multiples in the number , divide it by 2 ; If the size is already greater than K , then return true ; Computing the remaining divisors of the number ; If n is divisible by i , then it is a divisor ; If the size is already greater than K , then return true ; If the size is already greater than K , then return true ; If none of the above conditions satisfies , then return false ; Function to check if it is possible to make a number having total N factors and K prime factors ; If total divisors are less than the number of prime divisors , then print No ; Find the number of factors of n ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13391-13391",
        "Code": "import random NEW_LINE def generateOTP ( length ) : NEW_LINE INDENT str = \" abcdefghijklmnopqrstuvwxyzAB\\ STRNEWLINE TABSYMBOL CDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; NEW_LINE n = len ( str ) ; NEW_LINE OTP = \" \" ; NEW_LINE for i in range ( 1 , length + 1 ) : NEW_LINE INDENT OTP += str [ int ( random . random ( ) * 10 ) % n ] ; NEW_LINE DEDENT return ( OTP ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT length = 6 ; NEW_LINE print ( \" Your ▁ OTP ▁ is ▁ - ▁ \" , generateOTP ( length ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "To Generate a One Time Password or Unique Identification URL | A Python3 Program to generate OTP ( One Time Password ) ; A Function to generate a unique OTP everytime ; All possible characters of my OTP ; String to hold my OTP ; Driver code ; Declare the length of OTP",
        "Category": "Math"
    },
    {
        "ID": "13396-13396",
        "Code": "one = [ \" \" , \" one ▁ \" , \" two ▁ \" , \" three ▁ \" , \" four ▁ \" , \" five ▁ \" , \" six ▁ \" , \" seven ▁ \" , \" eight ▁ \" , \" nine ▁ \" , \" ten ▁ \" , \" eleven ▁ \" , \" twelve ▁ \" , \" thirteen ▁ \" , \" fourteen ▁ \" , \" fifteen ▁ \" , \" sixteen ▁ \" , \" seventeen ▁ \" , \" eighteen ▁ \" , \" nineteen ▁ \" ] ; NEW_LINE ten = [ \" \" , \" \" , \" twenty ▁ \" , \" thirty ▁ \" , \" forty ▁ \" , \" fifty ▁ \" , \" sixty ▁ \" , \" seventy ▁ \" , \" eighty ▁ \" , \" ninety ▁ \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE out += numToWords ( ( n // 10000000 ) , \" crore ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n // 100000 ) % 100 ) , \" lakh ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n // 1000 ) % 100 ) , \" thousand ▁ \" ) ; NEW_LINE out += numToWords ( ( ( n // 100 ) % 10 ) , \" hundred ▁ \" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += \" and ▁ \" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , \" \" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to convert a given number to words | Set 2 | strings at index 0 is not used , it is to make array indexing simple ; strings at index 0 and 1 are not used , they is to make array indexing simple ; n is 1 - or 2 - digit number ; if n is more than 19 , divide it ; if n is non - zero ; Function to print a given number in words ; stores word representation of given number n ; handles digits at ten millions and hundred millions places ( if any ) ; handles digits at hundred thousands and one millions places ( if any ) ; handles digits at thousands and tens thousands places ( if any ) ; handles digit at hundreds places ( if any ) ; handles digits at ones and tens places ( if any ) ; long handles upto 9 digit no change to unsigned long long int to handle more digit number ; convert given number in words",
        "Category": "Math"
    },
    {
        "ID": "13397-13397",
        "Code": "import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 50000000 ) ) ; NEW_LINE print ( findDigits ( 1000000000 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count digits in a factorial | Set 2 | A optimised Python3 program to find the number of digits in a factorial ; Returns the number of digits present in n ! Since the result can be large long long is used as return type ; factorial of - ve number doesn 't exists ; base case ; Use Kamenetsky formula to calculate the number of digits ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "1340-1340",
        "Code": "def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum possible sum of a window in an array such that elements of same window in other array are unique | Function to return maximum sum of window in B [ ] according to given constraints . ; Map is used to store elements and their counts . ; Initialize result ; calculating the maximum possible sum for each subarray containing unique elements . ; Remove all duplicate instances of A [ i ] in current window . ; Add current instance of A [ i ] to map and to current sum . ; Update result if current sum is more . ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "13408-13408",
        "Code": "from math import gcd NEW_LINE def isPossible ( a , b , c ) : NEW_LINE INDENT return ( c % gcd ( a , b ) == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE b = 6 NEW_LINE c = 9 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT a = 3 NEW_LINE b = 6 NEW_LINE c = 8 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 5 NEW_LINE c = 1 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Linear Diophantine Equations | Python 3 program to check for solutions of diophantine equations ; This function checks if integral solutions are possible ; Driver Code ; First example ; Second example ; Third example",
        "Category": "Math"
    },
    {
        "ID": "13415-13415",
        "Code": "def pow1 ( base , exponent , modulus ) : NEW_LINE INDENT result = 1 ; NEW_LINE base = base % modulus ; NEW_LINE while ( exponent > 0 ) : NEW_LINE INDENT if ( exponent % 2 == 1 ) : NEW_LINE INDENT result = ( result * base ) % modulus ; NEW_LINE DEDENT exponent = int ( exponent ) >> 1 ; NEW_LINE base = ( base * base ) % modulus ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT DEDENT def order ( p , b ) : NEW_LINE INDENT if ( gcd ( p , b ) != 1 ) : NEW_LINE INDENT print ( \" p and b are not co - prime . \" ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT k = 3 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow1 ( b , k , p ) == 1 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT DEDENT def convertx2e ( x ) : NEW_LINE INDENT z = 0 ; NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 ; NEW_LINE z += 1 ; NEW_LINE DEDENT return [ x , z ] ; NEW_LINE DEDENT def STonelli ( n , p ) : NEW_LINE INDENT if ( gcd ( n , p ) != 1 ) : NEW_LINE INDENT print ( \" a and p are not coprime \" ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT if ( pow1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) : NEW_LINE INDENT print ( \" no sqrt possible \" ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT ar = convertx2e ( p - 1 ) ; NEW_LINE s = ar [ 0 ] ; NEW_LINE e = ar [ 1 ] ; NEW_LINE q = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT q += 1 ; NEW_LINE DEDENT x = pow1 ( n , ( s + 1 ) / 2 , p ) ; NEW_LINE b = pow1 ( n , s , p ) ; NEW_LINE g = pow1 ( q , s , p ) ; NEW_LINE r = e ; NEW_LINE while ( True ) : NEW_LINE INDENT m = 0 ; NEW_LINE while ( m < r ) : NEW_LINE INDENT if ( order ( p , b ) == - 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( order ( p , b ) == pow ( 2 , m ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT m += 1 ; NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT x = ( x * pow1 ( g , pow ( 2 , r - m - 1 ) , p ) ) % p ; NEW_LINE g = pow1 ( g , pow ( 2 , r - m ) , p ) ; NEW_LINE b = ( b * g ) % p ; NEW_LINE if ( b == 1 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT r = m ; NEW_LINE DEDENT DEDENT n = 2 ; NEW_LINE p = 113 ; NEW_LINE x = STonelli ( n , p ) ; NEW_LINE if ( x == - 1 ) : NEW_LINE INDENT print ( \" Modular square root is not exist \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular ▁ square ▁ root ▁ of \" , n , \" and \" , p , \" is \" , x ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Square Root under Modulo p | Set 2 ( Shanks Tonelli algorithm ) | utility function to find pow ( base , exponent ) % modulus ; utility function to find gcd ; Returns k such that b ^ k = 1 ( mod p ) ; Initializing k with first odd prime number ; function return p - 1 ( = x argument ) as x * 2 ^ e , where x will be odd sending e as reference because updation is needed in actual e ; Main function for finding the modular square root ; a and p should be coprime for finding the modular square root ; If below expression return ( p - 1 ) then modular square root is not possible ; expressing p - 1 , in terms of s * 2 ^ e , where s is odd number ; finding smallest q such that q ^ ( ( p - 1 ) / 2 ) ( mod p ) = p - 1 ; q - 1 is in place of ( - 1 % p ) ; Initializing variable x , b and g ; keep looping until b become 1 or m becomes 0 ; finding m such that b ^ ( 2 ^ m ) = 1 ; updating value of x , g and b according to algorithm ; Driver Code ; p should be prime",
        "Category": "Math"
    },
    {
        "ID": "13417-13417",
        "Code": "import math NEW_LINE def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) // math . log ( x ) ; NEW_LINE res2 = math . log ( y ) / math . log ( x ) ; NEW_LINE return 1 if ( res1 == res2 ) else 0 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( isPower ( 27 , 729 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is a power of another number | Python3 program to check given number number y ; logarithm function to calculate value ; Note : this is double ; compare to the result1 or result2 both are equal ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13418-13418",
        "Code": "import math NEW_LINE def findRoots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT d = b * b - 4 * a * c NEW_LINE sqrt_val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( \" Roots ▁ are ▁ real ▁ and ▁ different ▁ \" ) NEW_LINE print ( ( - b + sqrt_val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sqrt_val ) / ( 2 * a ) ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( \" Roots ▁ are ▁ real ▁ and ▁ same \" ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE print ( \" Roots ▁ are ▁ complex \" ) NEW_LINE print ( - b / ( 2 * a ) , \" ▁ + ▁ i \" , sqrt_val ) NEW_LINE print ( - b / ( 2 * a ) , \" ▁ - ▁ i \" , sqrt_val ) NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = - 7 NEW_LINE c = 12 NEW_LINE findRoots ( a , b , c ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find the Roots of Quadratic equation | Python program to find roots of a quadratic equation ; Prints roots of quadratic equation ax * 2 + bx + x ; If a is 0 , then equation is not quadratic , but linear ; else : d < 0 ; Driver Program ; Function call",
        "Category": "Math"
    },
    {
        "ID": "13419-13419",
        "Code": "def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_sum = 0 NEW_LINE while the_sum < n : NEW_LINE INDENT the_sum += i NEW_LINE if the_sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( ' Yes ' ) if isPerfectSquare ( 35 ) else print ( ' NO ' ) NEW_LINE print ( ' Yes ' ) if isPerfectSquare ( 49 ) else print ( ' NO ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check perfect square using addition / subtraction | This function returns true if n is perfect square , else false ; the_sum is sum of all odd numbers . i is used one by one hold odd numbers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13422-13422",
        "Code": "import math NEW_LINE def CountSquares ( a , b ) : NEW_LINE INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT a = 9 NEW_LINE b = 25 NEW_LINE print \" Count ▁ of ▁ squares ▁ is : \" , int ( CountSquares ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of perfect squares between two given numbers | An Efficient Method to count squares between a and b ; An efficient solution to count square between a and b ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13433-13433",
        "Code": "def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( \" The ▁ number ▁ is ▁ a ▁ triangular ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Triangular Numbers | Returns True if ' num ' is triangular , else False ; Base case ; A Triangular number must be sum of first n natural numbers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13434-13434",
        "Code": "import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( \" The ▁ number ▁ is ▁ a ▁ triangular ▁ number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Triangular Numbers | Python3 program to check if a number is a triangular number using quadratic equation . ; Returns True if num is triangular ; Considering the equation n * ( n + 1 ) / 2 = num The equation is : a ( n ^ 2 ) + bn + c = 0 ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13438-13438",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT while ( a != 0 ) : NEW_LINE INDENT c = a ; NEW_LINE a = b % a ; NEW_LINE b = c ; NEW_LINE DEDENT return b ; NEW_LINE DEDENT def forbenius ( X , Y ) : NEW_LINE INDENT if ( gcd ( X , Y ) != 1 ) : NEW_LINE INDENT print ( \" NA \" ) ; NEW_LINE return ; NEW_LINE DEDENT A = ( X * Y ) - ( X + Y ) ; NEW_LINE N = ( X - 1 ) * ( Y - 1 ) // 2 ; NEW_LINE print ( \" Largest ▁ Amount ▁ = \" , A ) ; NEW_LINE print ( \" Total ▁ Count ▁ = \" , N ) ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 5 ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE X = 5 ; NEW_LINE Y = 10 ; NEW_LINE print ( \" \" ) ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE",
        "Type": "py",
        "NL": "Frobenius coin problem | Utility function to find gcd ; Function to print the desired output ; Solution doesn 't exist   if GCD is not 1 ; Else apply the formula ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13440-13440",
        "Code": "def xor_c ( a , b ) : NEW_LINE INDENT return '0' if ( a == b ) else '1' ; NEW_LINE DEDENT def flip ( c ) : NEW_LINE INDENT return '1' if ( c == '0' ) else '0' ; NEW_LINE DEDENT def binarytoGray ( binary ) : NEW_LINE INDENT gray = \" \" ; NEW_LINE gray += binary [ 0 ] ; NEW_LINE for i in range ( 1 , len ( binary ) ) : NEW_LINE INDENT gray += xor_c ( binary [ i - 1 ] , binary [ i ] ) ; NEW_LINE DEDENT return gray ; NEW_LINE DEDENT def graytoBinary ( gray ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE binary += gray [ 0 ] ; NEW_LINE for i in range ( 1 , len ( gray ) ) : NEW_LINE INDENT if ( gray [ i ] == '0' ) : NEW_LINE INDENT binary += binary [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT binary += flip ( binary [ i - 1 ] ) ; NEW_LINE DEDENT DEDENT return binary ; NEW_LINE DEDENT binary = \"01001\" ; NEW_LINE print ( \" Gray ▁ code ▁ of \" , binary , \" is \" , binarytoGray ( binary ) ) ; NEW_LINE gray = \"01101\" ; NEW_LINE print ( \" Binary ▁ code ▁ of \" , gray , \" is \" , graytoBinary ( gray ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Gray to Binary and Binary to Gray conversion | Helper function to xor two characters ; Helper function to flip the bit ; function to convert binary string to gray string ; MSB of gray code is same as binary code ; Compute remaining bits , next bit is computed by doing XOR of previous and current in Binary ; Concatenate XOR of previous bit with current bit ; function to convert gray code string to binary string ; MSB of binary code is same as gray code ; Compute remaining bits ; If current bit is 0 , concatenate previous bit ; Else , concatenate invert of previous bit ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13441-13441",
        "Code": "def greyConverter ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( greyConverter ( n ) ) NEW_LINE n = 9 NEW_LINE print ( greyConverter ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Gray to Binary and Binary to Gray conversion | Python3 code for above approach ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13446-13446",
        "Code": "def mulmod ( a , b , mod ) : NEW_LINE INDENT a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b //= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT a = 9223372036854775807 ; NEW_LINE b = 9223372036854775807 ; NEW_LINE print ( mulmod ( a , b , 100000000000 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "How to avoid overflow in modular multiplication ? | To compute ( a * b ) % mod ; res = 0 ; Initialize result ; If b is odd , add ' a ' to result ; Multiply ' a ' with 2 ; Divide b by 2 ; Return result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13450-13450",
        "Code": "import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = \" \" ) NEW_LINE print ( \" / \" , end = \" \" ) NEW_LINE print ( y1 , x2 , end = \" \" ) NEW_LINE print ( \" / \" , end = \" \" ) NEW_LINE print ( y2 , end = \" ▁ \" ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; NEW_LINE print ( x , end = \" \" ) NEW_LINE print ( \" / \" , end = \" \" ) NEW_LINE print ( y , end = \" ▁ \" ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( \" Farey ▁ Sequence ▁ of ▁ order \" , n , \" is \" ) ; NEW_LINE farey ( n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Farey Sequence | Efficient Python3 program to print Farey Sequence of order n ; Optimized function to print Farey sequence of order n ; We know first two terms are 0 / 1 and 1 / n ; For next terms to be evaluated ; Using recurrence relation to find the next term ; Print next term ; Update x1 , y1 , x2 and y2 for next iteration ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13469-13469",
        "Code": "def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 = x1 + m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prod = prod * num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result = result + rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( \" x ▁ is ▁ \" , findMinX ( num , rem , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Chinese Remainder Theorem | Set 2 ( Inverse Modulo based Implementation ) | Returns modulo inverse of a with respect to m using extended Euclid Algorithm . Refer below post for details : https : www . geeksforgeeks . org / multiplicative - inverse - under - modulo - m / ; Apply extended Euclid Algorithm ; q is quotient ; m is remainder now , process same as euclid 's algo ; Make x1 positive ; k is size of num [ ] and rem [ ] . Returns the smallest number x such that : x % num [ 0 ] = rem [ 0 ] , x % num [ 1 ] = rem [ 1 ] , ... ... ... ... ... ... x % num [ k - 2 ] = rem [ k - 1 ] Assumption : Numbers in num [ ] are pairwise coprime ( gcd for every pair is 1 ) ; Compute product of all numbers ; Initialize result ; Apply above formula ; Driver method",
        "Category": "Math"
    },
    {
        "ID": "13472-13472",
        "Code": "N = 30 NEW_LINE fib = [ 0 for i in range ( N ) ] NEW_LINE def largestFiboLessOrEqual ( n ) : NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE INDENT i = 2 NEW_LINE while fib [ i - 1 ] <= n : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE i += 1 NEW_LINE DEDENT return ( i - 2 ) NEW_LINE DEDENT def fibonacciEncoding ( n ) : NEW_LINE INDENT index = largestFiboLessOrEqual ( n ) NEW_LINE codeword = [ ' a ' for i in range ( index + 2 ) ] NEW_LINE i = index NEW_LINE while ( n ) : NEW_LINE INDENT codeword [ i ] = '1' NEW_LINE n = n - fib [ i ] NEW_LINE i = i - 1 NEW_LINE while ( i >= 0 and fib [ i ] > n ) : NEW_LINE INDENT codeword [ i ] = '0' NEW_LINE i = i - 1 NEW_LINE DEDENT DEDENT codeword [ index + 1 ] = '1' NEW_LINE return \" \" . join ( codeword ) NEW_LINE DEDENT n = 143 NEW_LINE print ( \" Fibonacci ▁ code ▁ word ▁ for \" , n , \" is \" , fibonacciEncoding ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Fibonacci Coding | To limit on the largest Fibonacci number to be used ; Array to store fibonacci numbers . fib [ i ] is going to store ( i + 2 ) 'th Fibonacci number ; Stores values in fib and returns index of the largest fibonacci number smaller than n . ; Fib [ 0 ] stores 2 nd Fibonacci No . ; Fib [ 1 ] stores 3 rd Fibonacci No . ; Keep Generating remaining numbers while previously generated number is smaller ; Return index of the largest fibonacci number smaller than or equal to n . Note that the above loop stopped when fib [ i - 1 ] became larger . ; Returns pointer to the char string which corresponds to code for n ; allocate memory for codeword ; index of the largest Fibonacci f <= n ; Mark usage of Fibonacci f ( 1 bit ) ; Subtract f from n ; Move to Fibonacci just smaller than f ; Mark all Fibonacci > n as not used ( 0 bit ) , progress backwards ; additional '1' bit ; return pointer to codeword ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "1349-1349",
        "Code": "def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT Map = { } NEW_LINE curr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE if curr_sum == Sum : NEW_LINE INDENT print ( \" Sum ▁ found ▁ between ▁ indexes ▁ 0 ▁ to \" , i ) NEW_LINE return NEW_LINE DEDENT if ( curr_sum - Sum ) in Map : NEW_LINE INDENT print ( \" Sum ▁ found ▁ between ▁ indexes \" ,   \\ Map [ curr_sum - Sum ] + 1 , \" to \" , i ) NEW_LINE return NEW_LINE DEDENT Map [ curr_sum ] = i NEW_LINE DEDENT print ( \" No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 2 , - 2 , - 20 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE Sum = - 10 NEW_LINE subArraySum ( arr , n , Sum ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find subarray with given sum | Set 2 ( Handles Negative Numbers ) | Function to print subarray with sum as given sum ; create an empty map ; if curr_sum is equal to target sum we found a subarray starting from index 0 and ending at index i ; If curr_sum - sum already exists in map we have found a subarray with target sum ; if value is not present then add to hashmap ; If we reach here , then no subarray exists ; Driver program to test above function",
        "Category": "Hash Table"
    },
    {
        "ID": "13502-13502",
        "Code": "def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT print ( \" Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000\" ) NEW_LINE n = 2 NEW_LINE for n in range ( 10000 ) : NEW_LINE INDENT if isPerfect ( n ) : NEW_LINE INDENT print ( n , \" ▁ is ▁ a ▁ perfect ▁ number \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Perfect Number | Returns true if n is perfect ; To store sum of divisors ; Find all divisors and add them ; If sum of divisors is equal to n , then n is a perfect number ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "13503-13503",
        "Code": "' NEW_LINE def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num / base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given number can be represented in given a no . of digits in any base | Returns true if ' num ' can be represented using ' dig ' digits in 'base ; Base case ; If there are more than 1 digits left and number is more than base , then remove last digit by doing num / base , reduce the number of digits and recur ; return true of num can be represented in ' dig ' digits in any base from 2 to 32 ; Check for all bases one by one ; driver code",
        "Category": "Math"
    },
    {
        "ID": "13508-13508",
        "Code": "def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT n = 5 NEW_LINE print ( \" nth ▁ magic ▁ number ▁ is \" , nthMagicNo ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find nth Magic Number | Function to find nth magic number ; Go through every bit of n ; If last bit of n is set ; proceed to next bit n >>= 1 or n = n / 2 ; Driver program to test above function",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13511-13511",
        "Code": "def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( \" Modular ▁ multiplicative ▁ inverse ▁ is \" , modInverse ( a , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Modular multiplicative inverse | Returns modulo inverse of a with respect to m using extended Euclid Algorithm Assumption : a and m are coprimes , i . e . , gcd ( a , m ) = 1 ; q is quotient ; m is remainder now , process same as Euclid 's algo ; Update x and y ; Make x positive ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "13519-13519",
        "Code": "' NEW_LINE class Date : NEW_LINE INDENT def __init__ ( self , d , m , y ) : NEW_LINE INDENT self . d = d NEW_LINE self . m = m NEW_LINE self . y = y NEW_LINE DEDENT DEDENT monthDays = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE def countLeapYears ( d ) : NEW_LINE INDENT years = d . y NEW_LINE if ( d . m <= 2 ) : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT ans = int ( years / 4 ) NEW_LINE ans -= int ( years / 100 ) NEW_LINE ans += int ( years / 400 ) NEW_LINE return ans NEW_LINE DEDENT def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE for i in range ( 0 , dt1 . m - 1 ) : NEW_LINE INDENT n1 += monthDays [ i ] NEW_LINE DEDENT n1 += countLeapYears ( dt1 ) NEW_LINE DEDENT ' NEW_LINE INDENT n2 = dt2 . y * 365 + dt2 . d NEW_LINE for i in range ( 0 , dt2 . m - 1 ) : NEW_LINE INDENT n2 += monthDays [ i ] NEW_LINE DEDENT n2 += countLeapYears ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT dt1 = Date ( 1 , 9 , 2014 ) NEW_LINE dt2 = Date ( 3 , 9 , 2020 ) NEW_LINE print ( \" Difference ▁ between ▁ two ▁ dates ▁ is \" , getDifference ( dt1 , dt2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find number of days between two given dates | A date has day ' d ' , month ' m ' and year 'y ; To store number of days in all months from January to Dec . ; This function counts number of leap years before the given date ; Check if the current year needs to be considered for the count of leap years or not ; An year is a leap year if it is a multiple of 4 , multiple of 400 and not a multiple of 100. ; This function returns number of days between two given dates ; initialize count using years and day ; Add days for months in given date ; Since every leap year is of 366 days , Add a day for every leap year ; SIMILARLY , COUNT TOTAL NUMBER OF DAYS BEFORE 'dt2 ; return difference between two counts ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "13523-13523",
        "Code": "def replace0with5 ( number ) : NEW_LINE INDENT number += calculateAddedValue ( number ) NEW_LINE return number NEW_LINE DEDENT def calculateAddedValue ( number ) : NEW_LINE INDENT result = 0 NEW_LINE decimalPlace = 1 NEW_LINE if ( number == 0 ) : NEW_LINE INDENT result += ( 5 * decimalPlace ) NEW_LINE DEDENT while ( number > 0 ) : NEW_LINE INDENT if ( number % 10 == 0 ) : NEW_LINE INDENT result += ( 5 * decimalPlace ) NEW_LINE DEDENT number //= 10 NEW_LINE decimalPlace *= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT print ( replace0with5 ( 1020 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Replace all â €˜ 0 â €™ with â €˜ 5 â €™ in an input Integer |  ; returns the number to be added to the input to replace all zeroes with five ; amount to be added ; unit decimal place ; a number divisible by 10 , then this is a zero occurrence in the input ; move one decimal place ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13536-13536",
        "Code": "def isOperand ( c ) : NEW_LINE INDENT return ( c >= '0' and c <= '9' ) ; NEW_LINE DEDENT def value ( c ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) ; NEW_LINE DEDENT def evaluate ( exp ) : NEW_LINE INDENT len1 = len ( exp ) ; NEW_LINE if ( len1 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT res = value ( exp [ 0 ] ) ; NEW_LINE for i in range ( 1 , len1 , 2 ) : NEW_LINE INDENT opr = exp [ i ] ; NEW_LINE opd = exp [ i + 1 ] ; NEW_LINE if ( isOperand ( opd ) == False ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( opr == ' + ' ) : NEW_LINE INDENT res += value ( opd ) ; NEW_LINE DEDENT elif ( opr == ' - ' ) : NEW_LINE INDENT res -= int ( value ( opd ) ) ; NEW_LINE DEDENT elif ( opr == ' * ' ) : NEW_LINE INDENT res *= int ( value ( opd ) ) ; NEW_LINE DEDENT elif ( opr == ' / ' ) : NEW_LINE INDENT res /= int ( value ( opd ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT expr1 = \"1 + 2*5 + 3\" ; NEW_LINE res = evaluate ( expr1 ) ; NEW_LINE print ( expr1 , \" is ▁ Invalid \" ) if ( res == - 1 ) else print ( \" Value ▁ of \" , expr1 , \" is \" , res ) ; NEW_LINE expr2 = \"1 + 2*3\" ; NEW_LINE res = evaluate ( expr2 ) ; NEW_LINE print ( expr2 , \" is ▁ Invalid \" ) if ( res == - 1 ) else print ( \" Value ▁ of \" , expr2 , \" is \" , res ) ; NEW_LINE expr3 = \"4-2 + 6*3\" ; NEW_LINE res = evaluate ( expr3 ) ; NEW_LINE print ( expr3 , \" is ▁ Invalid \" ) if ( res == - 1 ) else print ( \" Value ▁ of \" , expr3 , \" is \" , res ) ; NEW_LINE expr4 = \"1 + + 2\" ; NEW_LINE res = evaluate ( expr4 ) ; NEW_LINE print ( expr4 , \" is ▁ Invalid \" ) if ( res == - 1 ) else print ( \" Value ▁ of \" , expr4 , \" is \" , res ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to evaluate simple expressions | A utility function to check if a given character is operand ; utility function to find value of and operand ; This function evaluates simple expressions . It returns - 1 if the given expression is invalid . ; Base Case : Given expression is empty ; The first character must be an operand , find its value ; Traverse the remaining characters in pairs ; The next character must be an operator , and next to next an operand ; If next to next character is not an operand ; Update result according to the operator ; If not a valid operator ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13539-13539",
        "Code": "def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( f1 , end = \" ▁ \" ) NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT print ( f2 , end = \" ▁ \" ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE",
        "Type": "py",
        "NL": "Program to print first n Fibonacci Numbers | Set 1 | Function to print first n Fibonacci Numbers ; Driven code",
        "Category": "Math"
    },
    {
        "ID": "13544-13544",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a / gcd ( a , b ) ) * b NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find LCM of two numbers | Recursive function to return gcd of a and b ; Function to return LCM of two numbers ; Driver program to test above function",
        "Category": "Math"
    },
    {
        "ID": "13564-13564",
        "Code": "def isMultipleof5 ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 5 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5\" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is multiple of 5 without using / and % operators | Assumes that n is a positive integer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13584-13584",
        "Code": "def countbitdiff ( xo ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xo ) : NEW_LINE INDENT if ( xo % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xo = xo // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT def shortestPath ( n , a , b ) : NEW_LINE INDENT xorVal = a ^ b NEW_LINE cnt = countbitdiff ( xorVal ) NEW_LINE if ( cnt % 2 == 0 ) : NEW_LINE INDENT print ( cnt // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE a , b = 15 , 3 NEW_LINE shortestPath ( n , a , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Shortest path length between two given nodes such that adjacent nodes are at bit difference 2 | Function to count set bits in a number ; Stores count of set bits in xo ; Iterate over each bits of xo ; If current bit of xo is 1 ; Update count ; Update xo ; Function to find length of shortest path between the nodes a and b ; Stores XOR of a and b ; Stores the count of set bits in xorVal ; If cnt is an even number ; Driver Code ; Given N ; Given a and b ; Function call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13586-13586",
        "Code": "M = 3 NEW_LINE N = 3 NEW_LINE def findXOR ( X ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( X ) : NEW_LINE INDENT ans ^= ( X % 10 ) NEW_LINE X //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def printXORmatrix ( arr ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def convertXOR ( arr ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT X = arr [ i ] [ j ] NEW_LINE temp = findXOR ( X ) NEW_LINE arr [ i ] [ j ] = temp NEW_LINE DEDENT DEDENT printXORmatrix ( arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 27 , 173 , 5 ] , [ 21 , 6 , 624 ] , [ 5 , 321 , 49 ] ] NEW_LINE convertXOR ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify a matrix by converting each element to XOR of its digits | Python3 program for the above approach ; Function to calculate Bitwise XOR of digits present in X ; Stores the Bitwise XOR ; While X is true ; Update Bitwise XOR of its digits ; Return the result ; Function to print matrix after converting each matrix element to XOR of its digits ; Traverse each row of arr [ ] [ ] ; Traverse each column of arr [ ] [ ] ; Function to convert the given matrix to required XOR matrix ; Traverse each row of arr [ ] [ ] ; Traverse each column of arr [ ] [ ] ; Store the current matrix element ; Find the xor of digits present in X ; Stores the XOR value ; Print resultant matrix ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "13595-13595",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self , val = 0 , left = None , right = None ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = left NEW_LINE self . right = right NEW_LINE DEDENT DEDENT def uniqueLevels ( root ) : NEW_LINE INDENT uniqueLevels = 0 NEW_LINE que = [ root ] NEW_LINE while len ( que ) : NEW_LINE INDENT length = len ( que ) NEW_LINE prefix_XOR = 0 ; NEW_LINE prefix_OR = 0 NEW_LINE flag = True NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE prefix_OR |= temp . val NEW_LINE prefix_XOR ^= temp . val NEW_LINE if prefix_XOR != prefix_OR : NEW_LINE INDENT flag = False NEW_LINE DEDENT if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT uniqueLevels += 1 NEW_LINE DEDENT DEDENT print ( uniqueLevels ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 5 ) NEW_LINE root . left = TreeNode ( 6 ) NEW_LINE root . right = TreeNode ( 9 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 4 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE uniqueLevels ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count levels in a Binary Tree consisting of node values having set bits at different positions | Structure of a node in the binary tree ; Function to find total unique levels ; Stores count of levels , where the set bits of all the nodes are at different positions ; Store nodes at each level of the tree using BFS ; Performing level order traversal ; Stores count of nodes at current level ; Stores prefix XOR of all the nodes at current level ; Stores prefix OR of all the nodes at current level ; Check if set bit of all the nodes at current level is at different positions or not ; Traverse nodes at current level ; Stores front element of the que ; Update prefix_OR ; Update prefix_XOR ; If left subtree not NULL ; If right subtree not NULL ; If bitwise AND is zero ; Driver Code ; Function Call",
        "Category": "Binary Tree"
    },
    {
        "ID": "13596-13596",
        "Code": "def check ( x ) : NEW_LINE INDENT if ( ( ( x ) & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def query ( l , r , pre ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return pre [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return pre [ r ] - pre [ l - 1 ] NEW_LINE DEDENT DEDENT def countInRange ( arr , N , queries , Q ) : NEW_LINE INDENT pre = [ 0 ] * N NEW_LINE pre [ 0 ] = check ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + check ( arr [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE while ( Q > 0 ) : NEW_LINE INDENT l = queries [ 0 ] NEW_LINE r = queries [ 1 ] NEW_LINE c += 1 NEW_LINE print ( query ( l , r , pre ) , end = \" ▁ \" ) NEW_LINE Q -= 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 11 , 16 , 8 , 2 , 5 , 1 , 3 , 256 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE queries = [ [ 0 , 9 ] , [ 4 , 9 ] ] NEW_LINE Q = len ( queries ) NEW_LINE countInRange ( arr , N , queries , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to count array elements from a given range having a single set bit | Function to check whether only one bit is set or not ; Function to perform Range - query ; Function to count array elements with a single set bit for each range in a query ; Initialize array for Prefix sum ; Driver Code ; Given array ; Size of the array ; Given queries ; Size of queries array",
        "Category": "Math"
    },
    {
        "ID": "13609-13609",
        "Code": "adj = [ [ ] for i in range ( 100005 ) ] NEW_LINE visited = [ 0 ] * 100005 NEW_LINE ans = 0 NEW_LINE def dfs ( node , xorr , k ) : NEW_LINE INDENT global ans NEW_LINE visited [ node ] = 1 NEW_LINE if ( node != 1 and xorr == k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for x in adj [ node ] : NEW_LINE INDENT if ( not visited [ x [ 0 ] ] ) : NEW_LINE INDENT xorr1 = xorr ^ x [ 1 ] NEW_LINE dfs ( x [ 0 ] , xorr1 , k ) NEW_LINE DEDENT DEDENT DEDENT def countNodes ( N , K , R , edges ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] NEW_LINE v = edges [ i ] [ 1 ] NEW_LINE w = edges [ i ] [ 2 ] NEW_LINE adj [ u ] . append ( [ v , w ] ) NEW_LINE adj [ v ] . append ( [ u , w ] ) NEW_LINE DEDENT dfs ( R , 0 , K ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 0 NEW_LINE R = 1 NEW_LINE edges = [ [ 1 , 2 , 3 ] , [ 1 , 3 , 1 ] , [ 2 , 4 , 3 ] , [ 2 , 5 , 4 ] , [ 3 , 6 , 1 ] , [ 3 , 7 , 2 ] ] NEW_LINE N = len ( edges ) NEW_LINE countNodes ( N , K , R , edges ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count nodes having Bitwise XOR of all edges in their path from the root equal to K | Initialize the adjacency list to represent the tree ; Marks visited / unvisited vertices ; Stores the required count of nodes ; DFS to visit each vertex ; Mark the current node as visited ; Update the counter xor is K ; Visit adjacent nodes ; Calculate Bitwise XOR of edges in the path ; Recursive call to dfs function ; Function to construct the tree and prrequired count of nodes ; Add edges ; Print answer ; Driver Code ; Given K and R ; Given edges ; Number of vertices ; Function call",
        "Category": "Graph Theory"
    },
    {
        "ID": "13646-13646",
        "Code": "def isEven ( n ) : NEW_LINE INDENT if ( n ^ 1 == n + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 ; NEW_LINE print ( \" Even \" ) if isEven ( n ) else print ( \" Odd \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a Number is Odd or Even using Bitwise Operators | Returns true if n is even , else odd ; n ^ 1 is n + 1 , then even , else odd ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13653-13653",
        "Code": "from math import ceil , log NEW_LINE maxsize = 100005 NEW_LINE xor_tree = [ 0 ] * maxsize NEW_LINE def construct_Xor_Tree_Util ( current , start , end , x ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT xor_tree [ x ] = current [ start ] NEW_LINE return NEW_LINE DEDENT left = x * 2 + 1 NEW_LINE right = x * 2 + 2 NEW_LINE mid = start + ( end - start ) // 2 NEW_LINE construct_Xor_Tree_Util ( current , start , mid , left ) NEW_LINE construct_Xor_Tree_Util ( current , mid + 1 , end , right ) NEW_LINE xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) NEW_LINE DEDENT def construct_Xor_Tree ( arr , n ) : NEW_LINE INDENT construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT leaf_nodes = [ 40 , 32 , 12 , 1 , 4 , 3 , 2 , 7 ] NEW_LINE n = len ( leaf_nodes ) NEW_LINE construct_Xor_Tree ( leaf_nodes , n ) NEW_LINE x = ( ceil ( log ( n , 2 ) ) ) NEW_LINE max_size = 2 * pow ( 2 , x ) - 1 NEW_LINE print ( \" Nodes ▁ of ▁ the ▁ XOR ▁ Tree : \" ) NEW_LINE for i in range ( max_size ) : NEW_LINE INDENT print ( xor_tree [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT root = 0 NEW_LINE print ( \" Root :   \" , xor_tree [ root ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct XOR tree by Given leaf nodes of Perfect Binary Tree | Python3 implementation of the above approach ; Maximum size for xor tree ; Allocating space to xor tree ; A recursive function that constructs xor tree for vector array [ start ... . . end ] . x is index of current node in XOR tree ; If there is one element in vector array , store it in current node of XOR tree ; cout << xor_tree [ x ] << \" ▁ x \" ; for left subtree ; for right subtree ; for getting the middle index from corner indexes . ; Build the left and the right subtrees by xor operation ; merge the left and right subtrees by XOR operation ; Function to construct XOR tree from the given vector array . This function calls construct_Xor_Tree_Util ( ) to fill the allocated memory of xor_tree vector array ; Driver Code ; leaf nodes of Perfect Binary Tree ; Build the xor tree ; Height of xor tree ; Maximum size of xor tree ; Root node is at index 0 considering 0 - based indexing in XOR Tree ; prevalue at root node",
        "Category": "Binary Tree"
    },
    {
        "ID": "13658-13658",
        "Code": "def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' P ' ] = 1 NEW_LINE data [ ' S ' ] = 2 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Winner in the Rock | Function to return the winner of the game ; Both the players chose to play the same move ; Player A wins the game ; Function to perform the queries ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13663-13663",
        "Code": "MAX = 64 ; NEW_LINE def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i ; NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 ; NEW_LINE break ; NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 4 ; R = 5 ; NEW_LINE print ( maxOR ( L , R ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum Bitwise OR pair from a range | Python3 implementation of the approach ; Function to return the maximum bitwise OR possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; Loop through each bit from MSB to LSB ; MSBs where the bits differ , all bits from that bit are set ; If MSBs are same , then ans bit is same as that of bit of right or left limit ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13670-13670",
        "Code": "MAX = 32 NEW_LINE def maximizeExpression ( a , b ) : NEW_LINE INDENT result = a NEW_LINE for bit in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT bitOfD = 1 << bit NEW_LINE x = b & bitOfD NEW_LINE if ( x == bitOfD ) : NEW_LINE INDENT y = result & bitOfD NEW_LINE if ( y == 0 ) : NEW_LINE INDENT result = result ^ bitOfD NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT a = 11 NEW_LINE b = 14 NEW_LINE print ( maximizeExpression ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize the Expression | Bit Manipulation | Python3 implementation of the approach ; Function to return the value of the maximized expression ; int can have 32 bits ; Consider the ith bit of D to be 1 ; Calculate the value of ( B AND bitOfD ) ; Check if bitOfD satisfies ( B AND D = D ) ; Check if bitOfD can maximize ( A XOR D ) ; Note that we do not need to consider ith bit of D to be 0 because if above condition are not satisfied then value of result will not change which is similar to considering bitOfD = 0 as result XOR 0 = result ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13682-13682",
        "Code": "from bisect import bisect_left as lower_bound NEW_LINE def getSum ( BITree , index ) : NEW_LINE INDENT s = 0 NEW_LINE while index > 0 : NEW_LINE INDENT s += BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return s NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE ' NEW_LINE INDENT while index <= n : NEW_LINE INDENT BITree [ index ] += val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def convert ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = lower_bound ( temp , arr [ i ] ) + 1 NEW_LINE DEDENT DEDENT def findElements ( arr , n ) : NEW_LINE INDENT convert ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE smaller_right = [ 0 ] * n NEW_LINE greater_left = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT smaller_right [ i ] = getSum ( BIT , arr [ i ] - 1 ) NEW_LINE updateBIT ( BIT , n , arr [ i ] , 1 ) NEW_LINE DEDENT print ( \" Smaller ▁ right : \" , end = \" ▁ \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( smaller_right [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT greater_left [ i ] = i - getSum ( BIT , arr [ i ] ) NEW_LINE updateBIT ( BIT , n , arr [ i ] , 1 ) NEW_LINE DEDENT print ( \" Greater ▁ left : \" , end = \" ▁ \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( greater_left [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 1 , 2 , 3 , 0 , 11 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count smaller elements on right side and greater elements on left side using Binary Index Tree | Python3 implementation of the approach ; Function to return the sum of arr [ 0. . index ] This function assumes that the array is preprocessed and partial sums of array elements are stored in BITree [ ] ; Initialize result ; Traverse ancestors of BITree [ index ] ; Add current element of BITree to sum ; Move index to parent node in getSum View ; Updates a node in Binary Index Tree ( BITree ) at given index in BITree . The given value ' val ' is added to BITree [ i ] and all of its ancestors in tree . ; Traverse all ancestors and add 'val ; Add ' val ' to current node of BI Tree ; Update index to that of parent in update View ; Converts an array to an array with values from 1 to n and relative order of smaller and greater elements remains same . For example , { 7 , - 90 , 100 , 1 } is converted to { 3 , 1 , 4 , 2 } ; Create a copy of arrp [ ] in temp and sort the temp array in increasing order ; Traverse all array elements ; lower_bound ( ) Returns pointer to the first element greater than or equal to arr [ i ] ; Function to find smaller_right array ; Convert arr [ ] to an array with values from 1 to n and relative order of smaller and greater elements remains same . For example , { 7 , - 90 , 100 , 1 } is converted to { 3 , 1 , 4 , 2 } ; Create a BIT with size equal to maxElement + 1 ( Extra one is used so that elements can be directly be used as index ) ; To store smaller elements in right side and greater elements on left side ; Traverse all elements from right . ; Get count of elements smaller than arr [ i ] ; Add current element to BIT ; Print smaller_right array ; Find all left side greater elements ; Get count of elements greater than arr [ i ] ; Add current element to BIT ; Print greater_left array ; Driver Code ; Function call",
        "Category": "Binary Index Tree"
    },
    {
        "ID": "13683-13683",
        "Code": "def calculate ( bit_cnt ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( bit_cnt > 0 ) : NEW_LINE INDENT bit_cnt -= 1 ; NEW_LINE res = res * 3 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def unset_bit_count ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT n = n >> 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 ; NEW_LINE count = unset_bit_count ( n ) ; NEW_LINE ans = calculate ( count ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Equal Sum and XOR of three Numbers | Function to calculate power of 3 ; Function to return the count of the unset bit ( zeros ) ; Check the bit is 0 or not ; Right shifting ( dividing by 2 ) ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13690-13690",
        "Code": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 ; c1 = 0 ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and isPrime ( i ) ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT if ( arr [ i ] == 1 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ 0s ▁ = \" , c0 ) ; NEW_LINE print ( \" Number ▁ of ▁ 1s ▁ = \" , c1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] ; NEW_LINE countPrimePosition ( arr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of 0 s and 1 s at prime positions in the given array | Function that returns true if n is prime ; Check from 2 to n ; Function to find the count of 0 s and 1 s at prime indices ; To store the count of 0 s and 1 s ; If current 0 is at prime position ; If current 1 is at prime position ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "13691-13691",
        "Code": "N = 101 NEW_LINE def prefix ( arr , prefix_xor , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT prefix_xor [ i ] [ j ] = ( arr [ i ] [ j ] ^ prefix_xor [ i - 1 ] [ j ] ^ prefix_xor [ i ] [ j - 1 ] ^ prefix_xor [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def Max_xor ( prefix_xor , n ) : NEW_LINE INDENT max_value = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i1 in range ( i , n + 1 ) : NEW_LINE INDENT for j1 in range ( j , n + 1 ) : NEW_LINE INDENT x = 0 NEW_LINE x ^= prefix_xor [ i1 ] [ j1 ] NEW_LINE x ^= prefix_xor [ i - 1 ] [ j - 1 ] NEW_LINE x ^= prefix_xor [ i1 ] [ j - 1 ] NEW_LINE x ^= prefix_xor [ i - 1 ] [ j1 ] NEW_LINE max_value = max ( max_value , x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( max_value ) NEW_LINE DEDENT arr = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] NEW_LINE n = 4 NEW_LINE prefix_xor = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE prefix ( arr , prefix_xor , n ) NEW_LINE Max_xor ( prefix_xor , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find a sub matrix with maximum XOR | Python3 program to implement the above approach ; Compute the xor of elements from ( 1 , 1 ) to ( i , j ) and store it in prefix_xor [ i ] [ j ] ; xor of submatrix from 1 , 1 to i , j is ( xor of submatrix from 1 , 1 to i - 1 , j ) ^ ( xor of submatrix from 1 , 1 to i , j - 1 ) ^ ( xor of submatrix from 1 , 1 to i - 1 , j - 1 ) ^ arr [ i ] [ j ] ; find the submatrix with maximum xor value ; we need four loops to find all the submatrix of a matrix ; xor of submatrix from i , j to i1 , j1 is ( xor of submatrix from 1 , 1 to i1 , j1 ) ^ ( xor of submatrix from 1 , 1 to i - 1 , j - 1 ) ^ ( xor of submatrix from 1 , 1 to i1 , j - 1 ) ^ ( xor of submatrix from 1 , 1 to i - 1 , j1 ) ; if the xor is greater than maximum value substitute it ; Driver code ; Find the prefix_xor ; Find submatrix with maximum bitwise xor",
        "Category": "Matrix"
    },
    {
        "ID": "13692-13692",
        "Code": "def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 4 ) NEW_LINE prod = prod - n NEW_LINE return prod NEW_LINE DEDENT n = 7 NEW_LINE print ( multiplyByFifteen ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Multiply a number by 15 without using * and / operators | Function to return ( 15 * N ) without using ' * ' or ' / ' operator ; prod = 16 * n ; ( ( 16 * n ) - n ) = 15 * n ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13696-13696",
        "Code": "arr = [ 0 ] * 32 NEW_LINE def balTernary ( ter ) : NEW_LINE INDENT carry , base , i = 0 , 10 , 31 NEW_LINE while ter > 0 : NEW_LINE INDENT rem = ( ter % base ) + carry NEW_LINE if rem == 0 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE carry , i = 0 , i - 1 NEW_LINE DEDENT elif rem == 2 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT elif rem == 3 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE carry , i = 1 , i - 1 NEW_LINE DEDENT ter = ter // base NEW_LINE DEDENT if carry == 1 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT def ternary ( number ) : NEW_LINE INDENT ans , rem , base = 0 , 1 , 1 NEW_LINE while number > 0 : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number //= 3 NEW_LINE base = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3056 NEW_LINE ter = ternary ( number ) NEW_LINE balTernary ( ter ) NEW_LINE i = 0 NEW_LINE while arr [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT for j in range ( i , 32 ) : NEW_LINE INDENT if arr [ j ] == - 1 : NEW_LINE INDENT print ( ' Z ' , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Game Theory in Balanced Ternary Numeral System | ( Moving 3 k steps at a time ) | Numbers are in range of pow ( 3 , 32 ) ; Conversion of ternary into balanced ternary as start iterating from Least Significant Bit ( i . e 0 th ) , if encountered 0 or 1 , safely skip and pass carry 0 further 2 , replace it to - 1 and pass carry 1 further 3 , replace it to 0 and pass carry 1 further ; Similar to binary conversion ; Driver code ; Moving on to first occupied bit ; Printing ; Print ' Z ' in place of - 1",
        "Category": "Math"
    },
    {
        "ID": "13697-13697",
        "Code": "def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = \"01001101ZZ \" NEW_LINE s2 = \"10Z1001000\" NEW_LINE n = 10 NEW_LINE if ( isDefeat ( s1 , s2 , n ) ) : NEW_LINE INDENT print ( \" Defeat \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Victory \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Game Theory in Balanced Ternary Numeral System | ( Moving 3 k steps at a time ) | Function that returns true if the game cannot be won ; Driver code ; Common length",
        "Category": "Math"
    },
    {
        "ID": "13699-13699",
        "Code": "def FindIndexKthBit ( n , k ) : NEW_LINE INDENT cnt , ind = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == k : NEW_LINE INDENT return ind NEW_LINE DEDENT ind += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 15 , 3 NEW_LINE ans = FindIndexKthBit ( n , k ) NEW_LINE if ans != - 1 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ k - th ▁ set ▁ bit \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Position of the K | Function that returns the Kth set bit ; Traverse in the binary ; Check if the last bit is set or not ; Check if count is equal to k then return the index ; Increase the index as we move right ; Right shift the number by 1 ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "137-137",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def existPathUtil ( root , arr , n , index ) : NEW_LINE INDENT if not root or index == n : NEW_LINE INDENT return False NEW_LINE DEDENT if not root . left and not root . right : NEW_LINE INDENT if root . val == arr [ index ] and index == n - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT return ( ( index < n ) and ( root . val == arr [ index ] ) and ( existPathUtil ( root . left , arr , n , index + 1 ) or existPathUtil ( root . right , arr , n , index + 1 ) ) ) NEW_LINE DEDENT def existPath ( root , arr , n , index ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT return existPathUtil ( root , arr , n , 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 8 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE root = Node ( 5 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . right = Node ( 8 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . left . right = Node ( 4 ) NEW_LINE root . left . left . left = Node ( 1 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . left . right = Node ( 7 ) NEW_LINE if existPath ( root , arr , n , 0 ) : NEW_LINE INDENT print ( \" Path ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Path ▁ does ▁ not ▁ Exist \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if there is a root to leaf path with given sequence | Class of Node ; Util function ; If root is NULL or reached end of the array ; If current node is leaf ; If current node is equal to arr [ index ] this means that till this level path has been matched and remaining path can be either in left subtree or right subtree . ; Function to check given sequence of root to leaf path exist in tree or not . index represents current element in sequence of rooth to leaf path ; Driver Code ; arr [ ] : sequence of root to leaf path",
        "Category": "Binary Tree"
    },
    {
        "ID": "13708-13708",
        "Code": "from math import pow NEW_LINE def binToDecimal3 ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( 64 ) ] NEW_LINE x = 0 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT a [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT if ( i < 3 ) : NEW_LINE INDENT x = 3 NEW_LINE DEDENT else : NEW_LINE INDENT x = i NEW_LINE DEDENT d = 0 NEW_LINE p = 0 NEW_LINE for i in range ( x - 3 , x , 1 ) : NEW_LINE INDENT d += a [ i ] * pow ( 2 , p ) NEW_LINE p += 1 NEW_LINE DEDENT print ( int ( d ) , end = \" ▁ \" ) NEW_LINE d = 0 NEW_LINE p = 0 NEW_LINE for i in range ( 0 , 3 , 1 ) : NEW_LINE INDENT d += a [ i ] * pow ( 2 , p ) NEW_LINE p += 1 NEW_LINE DEDENT print ( int ( d ) , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 86 NEW_LINE binToDecimal3 ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "First and Last Three Bits | Python 3 implementation of the approach ; Function to print the first and last 3 bits equivalent decimal number ; Converting n to binary ; Length of the array has to be at least 3 ; Convert first three bits to decimal ; Print the decimal ; Convert last three bits to decimal ; Print the decimal ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13709-13709",
        "Code": "def binToDecimal3 ( n ) : NEW_LINE INDENT last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; NEW_LINE n = n >> 3 NEW_LINE while ( n > 7 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE print ( first_3 , last_3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 86 NEW_LINE binToDecimal3 ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "First and Last Three Bits | Function to print the first and last 3 bits equivalent decimal number ; Number formed from last three bits ; Let us get first three bits in n ; Number formed from first three bits ; Printing result ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13725-13725",
        "Code": "def calculate ( X ) : NEW_LINE INDENT number_of_bits = 8 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ X NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 4 NEW_LINE print ( \" Required ▁ Number ▁ is : \" , calculate ( X ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a value whose XOR with given number is maximum | Function To Calculate Answer ; Find number of bits in the given integer ; XOR the given integer with poe ( 2 , number_of_bits - 1 and print the result ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13732-13732",
        "Code": "def alternate ( a , b , x ) : NEW_LINE INDENT x = a + b - x NEW_LINE print ( \" After ▁ change ▁ x ▁ is : \" , x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is : \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Assign other value to a variable from two possible values | Function to alternate the values ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13733-13733",
        "Code": "def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( \" After ▁ exchange \" ) NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x ▁ is \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE",
        "Type": "py",
        "NL": "Assign other value to a variable from two possible values | Function to alternate the values ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13734-13734",
        "Code": "def countZeros ( x ) : NEW_LINE INDENT total_bits = 32 NEW_LINE res = 0 NEW_LINE while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) : NEW_LINE INDENT x = ( x << 1 ) NEW_LINE res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT x = 101 NEW_LINE print ( countZeros ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of leading zeros in binary representation of a given number | Function to count the no . of leading zeros ; Keep shifting x by one until leftmost bit does not become 1. ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13742-13742",
        "Code": "def printSubsets ( numOfBits , num ) : NEW_LINE INDENT if num >= 0 : NEW_LINE INDENT print ( \" { \" , end = \" ▁ \" ) NEW_LINE subset ( numOfBits - 1 , num , numOfBits ) NEW_LINE print ( \" } \" ) NEW_LINE printSubsets ( numOfBits , num - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT def subset ( nthBit , num , numOfBits ) : NEW_LINE INDENT if nthBit >= 0 : NEW_LINE INDENT if num & ( 1 << nthBit ) != 0 : NEW_LINE INDENT print ( numOfBits - nthBit , end = \" ▁ \" ) NEW_LINE DEDENT subset ( nthBit - 1 , num , numOfBits ) NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printSubsets ( n , 2 ** n - 1 ) NEW_LINE",
        "Type": "py",
        "NL": "Printing all subsets of { 1 , 2 , 3 , ... n } without using array or loop | This recursive function calls subset function to print the subsets one by one . numBits -- > number of bits needed to represent the number ( simply input value n ) . num -- > Initially equal to 2 ^ n - 1 and decreases by 1 every recursion until 0. ; Print the subset corresponding to binary representation of num . ; Call the function recursively to print the next subset . ; This function recursively prints the subset corresponding to the binary representation of num . nthBit -- > nth bit from right side starting from n and decreases until 0. ; Print number in given subset only if the bit corresponding to it is set in num . ; Check for the next bit ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "13743-13743",
        "Code": "def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( \" Number ▁ of ▁ different ▁ bits ▁ : \" , count ) NEW_LINE DEDENT A = 12 NEW_LINE B = 15 NEW_LINE solve ( A , B ) NEW_LINE",
        "Type": "py",
        "NL": "Number of mismatching bits in the binary representation of two integers | compute number of different bits ; since , the numbers are less than 2 ^ 31 run the loop from '0' to '31' only ; right shift both the numbers by ' i ' and check if the bit at the 0 th position is different ; Driver code ; find number of different bits",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13748-13748",
        "Code": "def isSubsetAndZero ( array , length , N ) : NEW_LINE INDENT arrAnd = array [ 0 ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT arrAnd = arrAnd & array [ i ] NEW_LINE DEDENT if ( ( arrAnd & N ) == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 1 , 2 , 4 ] NEW_LINE length = len ( array ) NEW_LINE N = 3 NEW_LINE isSubsetAndZero ( array , length , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether bitwise AND of a number with any subset of an array is zero or not | Function to check whether bitwise AND of a number with any subset of an array is zero or not ; variable to store the AND of all the elements ; find the AND of all the elements of the array ; if the AND of all the array elements and N is equal to zero ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13751-13751",
        "Code": "def maxTriplet ( a , n ) : NEW_LINE INDENT f = [ True for i in range ( n ) ] NEW_LINE bits = [ [ 0 for i in range ( 33 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE j = 32 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT bits [ i ] [ j ] = 1 NEW_LINE DEDENT j -= 1 NEW_LINE num >>= 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 33 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( bits [ j ] [ i ] and f [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= 3 ) : NEW_LINE INDENT ans += pow ( 2 , 32 - i ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( bits [ j ] [ i ] == False ) : NEW_LINE INDENT f [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( f [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) // 6 NEW_LINE print ( NumberOfTriplets , ans ) NEW_LINE DEDENT a = [ 4 , 11 , 10 , 15 , 26 ] NEW_LINE n = len ( a ) NEW_LINE maxTriplet ( a , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find triplets in an array whose AND is maximum | Python3 program to find triplet with maximum bitwise AND . ; Flag Array initially set to true for all numbers ; 2D array for bit representation of all the numbers . Initially all bits are set to 0. ; Finding bit representation of every number and storing it in bits array . ; Checking last bit of the number ; Dividing number by 2. ; maximum And number initially 0. ; Traversing the 2d binary representation . 0 th index represents 32 th bits while 32 th index represents 0 th bit . ; If cnt greater than 3 then ( 32 - i ) th bits of the number will be set . ; Setting flags of the numbers whose ith bit is not set . ; Counting the numbers whose flag are true . ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13752-13752",
        "Code": "def setRightmostUnsetBit ( n ) : NEW_LINE INDENT if n & ( n + 1 ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT return n | ( n + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 21 NEW_LINE print ( setRightmostUnsetBit ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Set the rightmost off bit | Python3 program to set the rightmost unset bit ; If all bits are set ; Set rightmost 0 bit ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13763-13763",
        "Code": "def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) ; NEW_LINE y = y ^ ( y >> 2 ) ; NEW_LINE y = y ^ ( y >> 4 ) ; NEW_LINE y = y ^ ( y >> 8 ) ; NEW_LINE y = y ^ ( y >> 16 ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if ( findParity ( 9 ) == 0 ) : NEW_LINE INDENT print ( \" Even ▁ Parity \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd Parity \" ) ; NEW_LINE DEDENT if ( findParity ( 13 ) == 0 ) : NEW_LINE INDENT print ( \" Even ▁ Parity \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd ▁ Parity \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Finding the Parity of a number Efficiently | Function to find the parity ; Rightmost bit of y holds the parity value if ( y & 1 ) is 1 then parity is odd else even ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13764-13764",
        "Code": "def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum set bit sum in array without considering adjacent elements | Function to count total number of set bits in an integer ; Maximum sum of set bits ; Calculate total number of set bits for every element of the array ; find total set bits for each number and store back into the array ; current max excluding i ; current max including i ; return max of incl and excl ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "13766-13766",
        "Code": "def increment ( i ) : NEW_LINE INDENT i = - ( ~ i ) ; NEW_LINE return i ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( increment ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Increment a number without using ++ or + | function that increment the value . ; Invert bits and apply negative sign ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13767-13767",
        "Code": "def increment ( i ) : NEW_LINE INDENT i = - ( ~ ord ( i ) ) ; NEW_LINE return chr ( i ) ; NEW_LINE DEDENT n = ' a ' ; NEW_LINE print ( increment ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Increment a number without using ++ or + | function that increment the value . ; Invert bits and apply negative sign ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13770-13770",
        "Code": "def bit_count ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = n & ( n - 1 ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def maxsum ( arr , n ) : NEW_LINE INDENT bits = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT bits [ i ] = bit_count ( arr [ i ] ) ; NEW_LINE DEDENT sum = [ 0 ] * 32 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ bits [ i ] ] += arr [ i ] ; NEW_LINE DEDENT maximum = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT maximum = max ( sum [ i ] , maximum ) ; NEW_LINE DEDENT return maximum ; NEW_LINE DEDENT arr = [ 2 , 3 , 8 , 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxsum ( arr , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Maximum sum by adding numbers with same number of set bits | count the number of bits for each element of array ; Count the number of set bits ; Function to return the the maximum sum ; Calculate the ; Assuming the number to be a maximum of 32 bits ; Add the number to the number of set bits ; Find the maximum sum ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13782-13782",
        "Code": "def checkSame ( n ) : NEW_LINE INDENT set , unset = 0 , 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n and 1 ) : NEW_LINE INDENT set + 1 NEW_LINE DEDENT else : NEW_LINE INDENT unset += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT if ( set == unset ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE if ( checkSame ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number has same number of set and unset bits | Function to check if a number has same setbits and unset bits ; iterate for all bits of a number ; if set ; if unset ; right shift number by 1 ; is number of set bits are equal to unset bits ; Driver Code ; function to check",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13787-13787",
        "Code": "def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Bitwise OR ( or | ) of a range | Returns the Most Significant Bit Position ( MSB ) ; Returns the Bitwise OR of all integers between L and R ; Find the MSB position in L ; Find the MSB position in R ; Add this value until msb_p1 and msb_p2 are same ; ; Calculate msb_p1 and msb_p2 ; Find the max of msb_p1 and msb_p2 ; Set all the bits from msb_p1 upto 0 th bit in the result ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13804-13804",
        "Code": "BitCount = [ 0 ] * 10000 NEW_LINE def fillSetBitsmatrix ( arr : list , n : int ) : NEW_LINE INDENT global BitCount NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT temp = arr [ j ] >> i NEW_LINE if temp % 2 != 0 : NEW_LINE INDENT BitCount [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT BitCount [ i ] += BitCount [ i - 1 ] NEW_LINE DEDENT DEDENT def Query ( Q : list , q : int ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( BitCount [ Q [ i ] [ 1 ] ] - BitCount [ Q [ i ] [ 0 ] - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 1 , 5 , 6 , 10 , 9 , 4 , 67 ] NEW_LINE n = len ( Arr ) NEW_LINE fillSetBitsmatrix ( Arr , n ) NEW_LINE q = 2 NEW_LINE Q = [ ( 1 , 5 ) , ( 2 , 6 ) ] NEW_LINE Query ( Q , q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Range query for count of set bits | 2 - D array that will stored the count of bits set in element of array ; Function store the set bit count in BitCount Array ; traverse over all bits ; mark elements with i 'th bit set ; Check whether the current bit is set or not if it 's set then mark it. ; store cumulative sum of bits ; Function to process queries ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "13805-13805",
        "Code": "def printKthBit ( n , k ) : NEW_LINE INDENT print ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) NEW_LINE DEDENT n = 13 NEW_LINE k = 2 NEW_LINE printKthBit ( n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find value of k | Python 3 program to find k - th bit from right ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13809-13809",
        "Code": "def _popcnt32 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE if ( n == 32 ) : NEW_LINE INDENT return a NEW_LINE DEDENT res = ( 1 << n ) - 1 NEW_LINE return ( res << ( 32 - n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE print ( maximize ( a ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize the number by rearranging bits | An efficient python3 program to find minimum number formed by bits of a given number . ; Returns maximum number formed by bits of a given number . ; _popcnt32 ( a ) gives number of 1 's  present in binary representation of a. ; If all 32 bits are set . ; Find a number witn n least significant set bits . ; Now shift result by 32 - n ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13817-13817",
        "Code": "def isEven ( n ) : NEW_LINE INDENT isEven = True ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if isEven == True : NEW_LINE INDENT isEven = False ; NEW_LINE DEDENT else : NEW_LINE INDENT isEven = True ; NEW_LINE DEDENT DEDENT return isEven ; NEW_LINE DEDENT n = 101 ; NEW_LINE if isEven ( n ) == True : NEW_LINE INDENT print ( \" Even \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check a number is odd or even without modulus operator | Returns true if n is even , else odd ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "13823-13823",
        "Code": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Odd numbers in N | Function to get no of set bits in binary representation of positive integer n ; Count number of 1 's in binary  representation of n. ; Number of odd numbers in n - th row is 2 raised to power the count . ; Driver Program",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13825-13825",
        "Code": "import math NEW_LINE def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si , operation ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE return NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , not operation ) NEW_LINE constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , not operation ) NEW_LINE if ( operation == 1 ) : NEW_LINE INDENT st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) NEW_LINE DEDENT DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 ] * max_size NEW_LINE operationAtRoot = ( 0 if x % 2 == 0 else 1 ) NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 , operationAtRoot ) NEW_LINE return st NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT leaves = [ 1 , 6 , 3 , 7 , 5 , 9 , 10 , 4 ] NEW_LINE n = len ( leaves ) NEW_LINE segmentTree = constructST ( leaves , n ) NEW_LINE rootIndex = 0 NEW_LINE print ( \" Value ▁ at ▁ Root ▁ Node ▁ = ▁ \" , segmentTree [ rootIndex ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Levelwise Alternating OR and XOR operations in Segment Tree | Python3 program to build levelwise OR / XOR alternating Segment tree ; A utility function to get the middle index from corner indexes . ; A recursive function that constructs Segment Tree for array [ ss . . se ] . ' si ' is index of current node in segment tree ' st ' , operation denotes which operation is carried out at that level to merge the left and right child . It 's either 0 or 1. ; If there is one element in array , store it in current node of segment tree and return ; If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node ; Build the left and the right subtrees by using the fact that operation at level ( i + 1 ) = ! ( operation at level i ) ; merge the left and right subtrees by checking the operation to be carried . If operation = 1 , then do OR else XOR ; OR operation ; XOR operation ; Function to construct segment tree from given array . This function allocates memory for segment tree and calls constructSTUtil ( ) to fill the allocated memory ; Height of segment tree ; Maximum size of segment tree ; Allocate memory ; operation = 1 ( XOR ) if Height of tree is even else it is 0 ( OR ) for the root node ; Fill the allocated memory st ; Return the constructed segment tree ; Driver Code ; leaf nodes ; Build the segment tree ; Root node is at index 0 considering 0 - based indexing in segment Tree ; print value at rootIndex",
        "Category": "Segment Tree"
    },
    {
        "ID": "13835-13835",
        "Code": "def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ) ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE quotient = 0 ; NEW_LINE temp = 0 ; NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i ; NEW_LINE quotient |= 1 << i ; NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE quotient = - quotient ; NEW_LINE return quotient ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 3 ; NEW_LINE print ( divide ( a , b ) ) ; NEW_LINE a = 43 ; NEW_LINE b = - 8 ; NEW_LINE print ( divide ( a , b ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Divide two integers without using multiplication , division and mod operator | Function to divide a by b and return floor value it ; Calculate sign of divisor i . e . , sign will be negative either one of them is negative only iff otherwise it will be positive ; remove sign of operands ; Initialize the quotient ; test down from the highest bit and accumulate the tentative value for valid bit ; if the sign value computed earlier is - 1 then negate the value of quotient ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13853-13853",
        "Code": "def maxXorSum ( n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT res = 1 NEW_LINE while res <= n : NEW_LINE INDENT res <<= 1 NEW_LINE DEDENT return res - 1 NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( maxXorSum ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum XOR using K numbers from 1 to n | To return max xor sum of 1 to n using at most k numbers ; If k is 1 then maximum possible sum is n ; Finding number greater than or equal to n with most significant bit same as n . For example , if n is 4 , result is 7. If n is 5 or 6 , result is 7 ; Return res - 1 which denotes a number with all bits set to 1 ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13854-13854",
        "Code": "import math NEW_LINE def getPosOfRightmostSetBit ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) NEW_LINE DEDENT def toggleLastKBits ( n , k ) : NEW_LINE INDENT num = ( 1 << ( int ) ( k ) ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def incrementByOne ( n ) : NEW_LINE INDENT k = getPosOfRightmostSetBit ( ~ n ) NEW_LINE n = ( ( 1 << ( int ) ( k ) ) n ) NEW_LINE if ( k != 0 ) : NEW_LINE INDENT n = toggleLastKBits ( n , k ) NEW_LINE DEDENT return n NEW_LINE DEDENT n = 15 NEW_LINE print ( incrementByOne ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Increment a number by one by manipulating the bits | python 3 implementation to increment a number by one by manipulating the bits ; function to find the position of rightmost set bit ; function to toggle the last m bits ; calculating a number ' num ' having ' m ' bits and all are set ; toggle the last m bits and return the number ; function to increment a number by one by manipulating the bits ; get position of rightmost unset bit if all bits of ' n ' are set , then the bit left to the MSB is the rightmost unset bit ; kth bit of n is being set by this operation ; from the right toggle all the bits before the k - th bit ; required number ; Driver program",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13855-13855",
        "Code": "def printNumHavingAltBitPatrn ( n ) : NEW_LINE INDENT curr_num = 1 NEW_LINE print ( curr_num ) NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_num = curr_num << 1 ; NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( curr_num ) NEW_LINE curr_num = ( ( curr_num ) << 1 ) ^ 1 ; NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( curr_num ) NEW_LINE DEDENT DEDENT n = 50 NEW_LINE printNumHavingAltBitPatrn ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Print numbers in the range 1 to n having bits in alternate pattern | function to print numbers in the range 1 to nhaving bits in alternate pattern ; first number having bits in alternate pattern ; display ; loop until n < curr_num ; generate next number having alternate bit pattern ; if true then break ; display ; generate next number having alternate bit pattern ; if true then break ; display ; Driven code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13858-13858",
        "Code": "import math NEW_LINE def swap ( a , b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT def xnor ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT a_rem = 0 NEW_LINE b_rem = 0 NEW_LINE count = 0 NEW_LINE xnornum = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a_rem = a & 1 NEW_LINE b_rem = b & 1 NEW_LINE if ( a_rem == b_rem ) : NEW_LINE INDENT xnornum |= ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return xnornum ; NEW_LINE DEDENT a = 10 NEW_LINE b = 50 NEW_LINE print ( xnor ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "XNOR of two numbers | Python3 program to find XNOR of two numbers ; log ( n ) solution ; Make sure a is larger ; for last bit of a ; for last bit of b ; counter for count bit and set bit in xnor num ; for make new xnor number ; for set bits in new xnor number ; get last bit of a ; get last bit of b ; Check if current two bits are same ; counter for count bit ; Driver method",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13863-13863",
        "Code": "def power2 ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return power2 ( n / 2 ) * NEW_LINE INDENT power2 ( n / 2 ) ; NEW_LINE DEDENT DEDENT def multiply ( x , n ) : NEW_LINE INDENT return x * power2 ( n ) ; NEW_LINE DEDENT x = 70 NEW_LINE n = 2 NEW_LINE print ( multiply ( x , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Multiplication with a power of 2 | Returns 2 raised to power n ; Driven program",
        "Category": "Math"
    },
    {
        "ID": "13864-13864",
        "Code": "def multiply ( x , n ) : NEW_LINE INDENT return x << n NEW_LINE DEDENT x = 70 NEW_LINE n = 2 NEW_LINE print ( multiply ( x , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Multiplication with a power of 2 | Efficient Python3 code to compute x * ( 2 ^ n ) ; Driven code to check above function",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13871-13871",
        "Code": "def perfectPowerOf2 ( n ) : NEW_LINE INDENT per_pow = 1 NEW_LINE while n > 0 : NEW_LINE INDENT per_pow = per_pow << 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return per_pow NEW_LINE DEDENT n = 128 NEW_LINE print ( \" Perfect ▁ power ▁ of ▁ 2 ▁ greater ▁ than \" , n , \" : \" , perfectPowerOf2 ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest perfect power of 2 greater than n ( without using arithmetic operators ) | Function to find smallest perfect power of 2 greater than n ; To store perfect power of 2 ; bitwise left shift by 1 ; bitwise right shift by 1 ; Required perfect power of 2 ; Driver program to test above",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13879-13879",
        "Code": "def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = \" negative \" , \" zero \" , \" positive \" NEW_LINE val = index ( n ) NEW_LINE print ( n , \" is \" , s [ val ] ) NEW_LINE DEDENT check ( 30 ) NEW_LINE check ( - 20 ) NEW_LINE check ( 0 ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a number is positive , negative or zero using bit operators | function to return 1 if it is zero returns 0 if it is negative returns 2 if it is positive ; string array to store all kinds of number ; function call to check the sign of number ; driver program to test the above function",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13881-13881",
        "Code": "def compute ( S , X ) : NEW_LINE INDENT A = ( S - X ) // 2 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT Xi = ( X & ( 1 << i ) ) NEW_LINE Ai = ( A & ( 1 << i ) ) NEW_LINE if ( Xi == 0 and Ai == 0 ) : NEW_LINE INDENT pass NEW_LINE DEDENT elif ( Xi == 0 and Ai > 0 ) : NEW_LINE INDENT a = ( ( 1 << i ) a ) NEW_LINE b = ( ( 1 << i ) b ) NEW_LINE DEDENT elif ( Xi > 0 and Ai == 0 ) : NEW_LINE INDENT a = ( ( 1 << i ) a ) NEW_LINE print ( \" Not ▁ Possible \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" a ▁ = ▁ \" , a ) NEW_LINE print ( \" b ▁ = \" , b ) NEW_LINE DEDENT S = 17 NEW_LINE X = 13 NEW_LINE compute ( S , X ) NEW_LINE",
        "Type": "py",
        "NL": "Find two numbers from their sum and XOR | Function that takes in the sum and XOR of two numbers and generates the two numbers such that the value of X is minimized ; Traverse through all bits ; Let us leave bits as 0. ; else : ( Xi == 1 and Ai == 1 ) ; Driver function",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13882-13882",
        "Code": "def checking ( s ) : NEW_LINE INDENT c = 0 NEW_LINE n = len ( s ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c >= 6 and s [ i ] == '1' ) : NEW_LINE INDENT return True NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"100010001\" NEW_LINE if ( checking ( s ) ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Divisibility by 64 with removal of bits allowed | function to check if it is possible to make it a multiple of 64. ; counter to count 0 's ; loop which traverses right to left and calculates the number of zeros before 1. ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13883-13883",
        "Code": "def modifyBit ( n , p , b ) : NEW_LINE INDENT mask = 1 << p NEW_LINE return ( n & ~ mask ) | ( ( b << p ) & mask ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( modifyBit ( 6 , 2 , 0 ) ) NEW_LINE print ( modifyBit ( 6 , 5 , 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify a bit at a given position | Returns modified n . ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13889-13889",
        "Code": "' NEW_LINE def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) ; NEW_LINE DEDENT ' NEW_LINE INDENT return allBitsAreSet ( num ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE if ( bitsAreInAltOrder ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number has bits in alternate pattern | Set | function to check if all the bits are set or not in the binary representation of 'n ; if true , then all bits are set ; else all bits are not set ; function to check if a number has bits in alternate pattern ; to check if all bits are set in 'num ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13891-13891",
        "Code": "import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue / 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) / math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min ▁ Flips ▁ = ▁ \" , minFlip ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum flips required to maximize a number with k set bits | Python3 for finding min flip for maximizing given n ; function for finding set bit ; return count of set bit ; function for finding min flip ; number of bits in n ; Find the largest number of same size with k set bits ; Count bit differences to find required flipping . ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13894-13894",
        "Code": "def setallbitgivenrange ( n , l , r ) : NEW_LINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEW_LINE return ( n range ) NEW_LINE DEDENT n , l , r = 17 , 2 , 3 NEW_LINE print ( setallbitgivenrange ( n , l , r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Set all the bits in given range of a number | Function to toggle bits in the given range ; calculating a number ' range ' having set bits in the range from l to r and all other bits as 0 ( or unset ) . ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13895-13895",
        "Code": "import math NEW_LINE def countBits ( number ) : NEW_LINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEW_LINE DEDENT num = 65 ; NEW_LINE print ( countBits ( num ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count total bits in a number | Python3 program to find total bit in given number ; log function in base 2 take only integer part ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13901-13901",
        "Code": "def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Toggle all bits after most significant bit | Function to toggle bits starting from MSB ; temporary variable to use XOR with one of a n ; Run loop until the only set bit in temp crosses MST of n . ; Toggle bit of n corresponding to current set bit in temp . ; Move set bit to next higher position . ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13902-13902",
        "Code": "def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Toggle all bits after most significant bit | Returns a number which has all set bits starting from MSB of n ; This makes sure two bits ( From MSB and including MSB ) are set ; This makes sure 4 bits ( From MSB and including MSB ) are set ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13903-13903",
        "Code": "from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is power of 8 or not | Python3 program to check if a number is power of 8 ; function to check if power of 8 ; calculate log8 ( n ) ; check if i is an integer or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "13906-13906",
        "Code": "def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE if ( adjacentSet ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number has two adjacent set bits | Python 3 program to check if there are two adjacent set bits . ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13911-13911",
        "Code": "INT_MAX = 2147483647 NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT return 1 if ( x & ( 1 << ( k - 1 ) ) ) else 0 NEW_LINE DEDENT def leftmostSetBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def isBinPalindrome ( x ) : NEW_LINE INDENT l = leftmostSetBit ( x ) NEW_LINE r = 1 NEW_LINE while ( l > r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def findNthPalindrome ( n ) : NEW_LINE INDENT pal_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 1 , INT_MAX + 1 ) : NEW_LINE INDENT if ( isBinPalindrome ( i ) ) : NEW_LINE INDENT pal_count += 1 NEW_LINE DEDENT if ( pal_count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( findNthPalindrome ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the n | Python 3 program to find n - th number whose binary representation is palindrome . ; Finds if the kth bit is set in the binary representation ; Returns the position of leftmost set bit in the binary representation ; Finds whether the integer in binary representation is palindrome or not ; One by one compare bits ; Compare left and right bits and converge ; Start from 1 , traverse through all the integers ; If we reach n , break the loop ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "13912-13912",
        "Code": "def convertStringToInt ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNthNumber ( n ) : NEW_LINE INDENT q = [ ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n - 1 NEW_LINE q . append ( \"11\" ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT curr = q . pop ( 0 ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return convertStringToInt ( curr ) NEW_LINE DEDENT lenn = len ( curr ) NEW_LINE if ( len ( curr ) % 2 == 0 ) : NEW_LINE INDENT q . append ( curr [ 0 : int ( lenn / 2 ) ] + \"0\" + curr [ int ( lenn / 2 ) : ] ) NEW_LINE q . append ( curr [ 0 : int ( lenn / 2 ) ] + \"1\" + curr [ int ( lenn / 2 ) : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT midChar = curr [ int ( lenn / 2 ) ] NEW_LINE q . append ( curr [ 0 : int ( lenn / 2 ) ] + midChar + curr [ int ( lenn / 2 ) : ] ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT n = 9 NEW_LINE print ( getNthNumber ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the n | utility function which is used to convert binary string into integer ; convert binary string into integer ; function to find nth binary palindrome number ; stores the binary palindrome string ; base case ; add 2 nd binary palindrome string ; runs till the nth binary palindrome number ; remove curr binary palindrome string from queue ; if n == 0 then we find the n 'th binary  palindrome so we return our answer ; calculate length of curr binary palindrome string ; if length is even . so it is our first case we have two choices ; if length is odd . so it is our second case we have only one choice ; Driver code ; Function Call",
        "Category": "Breadth-First Search (Graph Theory)"
    },
    {
        "ID": "13913-13913",
        "Code": "INT_SIZE = 32 NEW_LINE def constructNthNumber ( group_no , aux_num , op ) : NEW_LINE INDENT a = [ 0 ] * INT_SIZE NEW_LINE num , i = 0 , 0 NEW_LINE if op == 2 : NEW_LINE INDENT len_f = 2 * group_no NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif op == 0 : NEW_LINE INDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 0 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len_f ) : NEW_LINE INDENT num += ( 1 << i ) * a [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT def getNthNumber ( n ) : NEW_LINE INDENT group_no = 0 NEW_LINE count_upto_group , count_temp = 0 , 1 NEW_LINE while count_temp < n : NEW_LINE INDENT group_no += 1 NEW_LINE count_upto_group = count_temp NEW_LINE count_temp += 3 * ( 1 << ( group_no - 1 ) ) NEW_LINE DEDENT group_offset = n - count_upto_group - 1 NEW_LINE if ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) : NEW_LINE INDENT aux_num = group_offset NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) : NEW_LINE else : NEW_LINE aux_num = ( ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) // 2 ) NEW_LINE DEDENT return constructNthNumber ( group_no , aux_num , op ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 9 NEW_LINE print ( getNthNumber ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the n | Efficient Python3 program to find n - th palindrome ; Construct the nth binary palindrome with the given group number , aux_number and operation type ; No need to insert any bit in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith  bit and fill around middle ; Insert bit 0 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith  bit and fill around middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith  bit and fill around middle ; Convert the number to decimal from binary ; Will return the nth binary palindrome number ; Add number of elements in all the groups , until the group of the nth number is found ; Total number of elements until this group ; Element 's offset position in the group ; Finding which bit to be placed in the middle and finding the number , which we will fill from the middle in both directions ; We need to fill this auxiliary number in binary form the middle in both directions ; op = 0 Need to Insert 0 at middle ; op = 1 Need to Insert 1 at middle ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "13914-13914",
        "Code": "def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT N = 3 NEW_LINE key = 3 NEW_LINE shuffle ( N , key ) NEW_LINE",
        "Type": "py",
        "NL": "Shuffle a pack of cards and answer the query | Function to find card at given index ; Answer will be reversal of N bits from MSB ; Calculating the reverse binary representation ; Printing the result ; No . of Shuffle Steps ; Key position",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13931-13931",
        "Code": "def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Toggle the last m bits | function to toggle the last m bits ; calculating a number ' num ' having ' m ' bits and all are set . ; toggle the last m bits and return the number ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13935-13935",
        "Code": "import math NEW_LINE def getFirstSetBitPos ( n ) : NEW_LINE INDENT return ( int ) ( math . log ( n & - n ) / math . log ( 2 ) ) + 1 NEW_LINE DEDENT def previousSmallerInteger ( n ) : NEW_LINE INDENT pos = getFirstSetBitPos ( n ) NEW_LINE DEDENT ' NEW_LINE INDENT return ( n & ~ ( 1 << ( pos - 1 ) ) ) NEW_LINE DEDENT n = 25 NEW_LINE print ( \" Previous ▁ small ▁ Integer ▁ = ▁ \" , previousSmallerInteger ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Previous smaller integer having one less number of set bits | Python3 implementation to find the previous smaller integer with one less number of set bits ; Function to find the position of rightmost set bit . ; Function to find the previous smaller integer ; position of rightmost set bit of n ; turn off or unset the bit at position 'pos ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13937-13937",
        "Code": "import math NEW_LINE ' NEW_LINE def getRightMostSetBit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT ' NEW_LINE def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return getRightMostSetBit ( m ^ n ) NEW_LINE DEDENT m = 52 NEW_LINE n = 4 NEW_LINE print ( \" position ▁ = ▁ \" , int ( posOfRightMostDiffBit ( m , n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Position of rightmost different bit | Python implementation to find the position of rightmost different bit ; Function to find the position of rightmost set bit in 'n ; to handle edge case when n = 0. ; Function to find the position of rightmost different bit in the binary representations of ' m ' and 'n ; position of rightmost different bit ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13942-13942",
        "Code": "def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << k ) n ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( \" Kth ▁ bit ▁ set ▁ number ▁ = ▁ \" , setKthBit ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Set the K | function to set the kth bit ; kth bit of n is being set by this operation ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13953-13953",
        "Code": "def maxXORInRange ( L , R ) : NEW_LINE INDENT LXR = L ^ R NEW_LINE msbPos = 0 NEW_LINE while ( LXR ) : NEW_LINE INDENT msbPos += 1 NEW_LINE LXR >>= 1 NEW_LINE DEDENT maxXOR , two = 0 , 1 NEW_LINE while ( msbPos ) : NEW_LINE INDENT maxXOR += two NEW_LINE two <<= 1 NEW_LINE msbPos -= 1 NEW_LINE DEDENT return maxXOR NEW_LINE DEDENT L , R = 8 , 20 NEW_LINE print ( maxXORInRange ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum XOR value of a pair from a range | Method to get maximum xor value in range [ L , R ] ; get xor of limits ; loop to get msb position of L ^ R ; construct result by adding 1 , msbPos times ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13955-13955",
        "Code": "def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Numbers whose bitwise OR and sum with N are equal | Function to find total 0 bit in a number ; Function to find Count of non - negative numbers less than or equal to N , whose bitwise OR and SUM with N are equal . ; count number of zero bit in N ; power of 2 to count ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13957-13957",
        "Code": "class BitArray : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . arr = [ 0 ] * ( ( n >> 5 ) + 1 ) NEW_LINE DEDENT def get ( self , pos ) : NEW_LINE INDENT self . index = pos >> 5 NEW_LINE self . bitNo = pos & 0x1F NEW_LINE return ( self . arr [ self . index ] & ( 1 << self . bitNo ) ) != 0 NEW_LINE DEDENT def set ( self , pos ) : NEW_LINE INDENT self . index = pos >> 5 NEW_LINE self . bitNo = pos & 0x1F NEW_LINE self . arr [ self . index ] |= ( 1 << self . bitNo ) NEW_LINE DEDENT DEDENT def checkDuplicates ( arr ) : NEW_LINE INDENT ba = BitArray ( 320000 ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE if ba . get ( num ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ba . set ( num ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 1 , 10 , 12 , 10 ] NEW_LINE checkDuplicates ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Duplicates of array using bit array | A class to represent array of bits using array of integers ; Constructor ; Divide by 32. To store n bits , we need n / 32 + 1 integers ( Assuming int is stored using 32 bits ) ; Get value of a bit at given position ; Divide by 32 to find position of integer . ; Now find bit number in arr [ index ] ; Find value of given bit number in arr [ index ] ; Sets a bit at given position ; Find index of bit position ; Set bit number in arr [ index ] ; Main function to print all Duplicates ; create a bit with 32000 bits ; Traverse array elements ; Index in bit array ; If num is already present in bit array ; Else insert num ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "13968-13968",
        "Code": "def totalFlips ( A , B , C , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == B [ i ] and C [ i ] == '1' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif A [ i ] != B [ i ] and C [ i ] == '0' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 5 NEW_LINE a = \"10100\" NEW_LINE b = \"00010\" NEW_LINE c = \"10011\" NEW_LINE print ( totalFlips ( a , b , c , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count minimum bits to flip such that XOR of A and B equal to C | Python code to find minimum bits to be flip ; If both A [ i ] and B [ i ] are equal ; if A [ i ] and B [ i ] are unequal ; N represent total count of Bits",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13969-13969",
        "Code": "def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count smaller numbers whose XOR with n produces greater value | Python program to count numbers whose XOR with n produces a value more than n . ; Position of current bit in n ; Traverse bits from LSB to MSB ; Initialize result ; If current bit is 0 , then there are 2 ^ k numbers with current bit 1 and whose XOR with n produces greater value ; Increase position for next bit ; Reduce n to find next bit ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13971-13971",
        "Code": "def EqualNumber ( A , B ) : NEW_LINE INDENT return ( A ^ B ) NEW_LINE DEDENT A = 5 ; B = 6 NEW_LINE print ( int ( not ( EqualNumber ( A , B ) ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Compare two integers without using any Comparison operator | Function return true if A ^ B > 0 else false ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13974-13974",
        "Code": "def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Yes \" ) if ( findPattern ( n ) ) else print ( \" No \" ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a number has bits in alternate pattern | Set 1 | Returns true if n has alternate bit pattern else false ; Store last bit ; Traverse through remaining bits ; If current bit is same as previous ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13976-13976",
        "Code": "def countXOR ( n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT n = 31 NEW_LINE print ( countXOR ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "XOR counts of 0 s and 1 s in binary representation | Returns XOR of counts 0 s and 1 s in binary representation of n . ; calculating count of zeros and ones ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13982-13982",
        "Code": "def isMultipleOf4 ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT XOR = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT XOR = XOR ^ i NEW_LINE DEDENT return ( XOR == n ) NEW_LINE DEDENT for n in range ( 0 , 43 ) : NEW_LINE INDENT if ( isMultipleOf4 ( n ) ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Multiples of 4 ( An Interesting Method ) | Returns true if n is a multiple of 4. ; Find XOR of all numbers from 1 to n ; If XOR is equal n , then return true ; Printing multiples of 4 using above method",
        "Category": "Math"
    },
    {
        "ID": "13986-13986",
        "Code": "def countValues ( n ) : NEW_LINE INDENT unset_bits = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if n & 1 == 0 : NEW_LINE INDENT unset_bits += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return 1 << unset_bits NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( countValues ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Equal Sum and XOR | function to count number of values less than equal to n that satisfy the given condition ; unset_bits keeps track of count of un - set bits in binary representation of n ; Return 2 ^ unset_bits ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13989-13989",
        "Code": "def swapThree ( a , b , c ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE c [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE DEDENT a , b , c = [ 10 ] , [ 20 ] , [ 30 ] NEW_LINE print ( \" Before ▁ swapping ▁ a ▁ = ▁ \" , a [ 0 ] , \" , ▁ b ▁ = ▁ \" , b [ 0 ] , \" , ▁ c ▁ = ▁ \" , c [ 0 ] ) NEW_LINE swapThree ( a , b , c ) NEW_LINE print ( \" After ▁ swapping ▁ a ▁ = ▁ \" , a [ 0 ] , \" , ▁ b ▁ = ▁ \" , b [ 0 ] , \" , ▁ c ▁ = ▁ \" , c [ 0 ] ) NEW_LINE",
        "Type": "py",
        "NL": "Swap three variables without using temporary variable | Assign c ' s ▁ value ▁ to ▁ a , ▁ a ' s value to b and b 's value to c. ; Store XOR of all in a ; After this , b has value of a [ 0 ] ; After this , c has value of b ; After this , a [ 0 ] has value of c ; Driver code ; Calling Function",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13990-13990",
        "Code": "def findTwoMissingNumbers ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n - 2 ) : NEW_LINE INDENT XOR ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT XOR ^= i NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT if arr [ i ] & set_bit_no : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i & set_bit_no : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( \" Two Missing Numbers are % d % d \" % ( x , y ) ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 6 ] NEW_LINE n = 2 + len ( arr ) NEW_LINE findTwoMissingNumbers ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find Two Missing Numbers | Set 2 ( XOR based solution ) | Function to find two missing numbers in range [ 1 , n ] . This function assumes that size of array is n - 2 and all array elements are distinct ; Get the XOR of all elements in arr [ ] and { 1 , 2 . . n } ; Get a set bit of XOR ( We get the rightmost set bit ) ; Now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element . ; XOR of first set in arr [ ] ; XOR of second set in arr [ ] ; XOR of first set in arr [ ] and { 1 , 2 , ... n } ; XOR of second set in arr [ ] and { 1 , 2 , ... n } ; Driver program to test above function ; Range of numbers is 2 plus size of array",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "13991-13991",
        "Code": "def findProffesion ( level , pos ) : NEW_LINE INDENT if ( level == 1 ) : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT if ( findProffesion ( level - 1 , ( pos + 1 ) // 2 ) == ' d ' ) : NEW_LINE INDENT if ( pos % 2 ) : NEW_LINE INDENT return ' d ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT DEDENT if ( pos % 2 ) : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' d ' NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT level = 3 NEW_LINE pos = 4 NEW_LINE if ( findProffesion ( level , pos ) == ' e ' ) : NEW_LINE INDENT print ( \" Engineer \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Doctor \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find profession in a special family | Returns ' e ' if profession of node at given level and position is engineer . Else doctor . The function assumes that given position and level have valid values . ; Base case ; Recursively find parent 's profession. If parent  is a Doctor, this node will be a Doctor if it is  at odd position and an engineer if at even position ; If parent is an engineer , then current node will be an engineer if at add position and doctor if even position . ; Driver code",
        "Category": "Recursion"
    },
    {
        "ID": "14004-14004",
        "Code": "def findXOR ( Set , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return Set [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT Set = [ 1 , 2 , 3 ] NEW_LINE n = len ( Set ) NEW_LINE print ( \" XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ \" , findXOR ( Set , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Given a set , find XOR of the XOR 's of all subsets. | Returns XOR of all XOR 's of given subset ; XOR is 1 only when n is 1 , else 0 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "14005-14005",
        "Code": "def myXOR ( x , y ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT b1 = x & ( 1 << i ) NEW_LINE b2 = y & ( 1 << i ) NEW_LINE b1 = min ( b1 , 1 ) NEW_LINE b2 = min ( b2 , 1 ) NEW_LINE xoredBit = 0 NEW_LINE if ( b1 & b2 ) : NEW_LINE INDENT xoredBit = 0 NEW_LINE DEDENT else : NEW_LINE INDENT xoredBit = ( b1 b2 ) NEW_LINE DEDENT res <<= 1 ; NEW_LINE res |= xoredBit NEW_LINE DEDENT return res NEW_LINE DEDENT x = 3 NEW_LINE y = 5 NEW_LINE print ( \" XOR ▁ is \" , myXOR ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find XOR of two number without using XOR operator | Returns XOR of x and y ; Assuming 32 - bit Integer ; Find current bits in x and y ; If both are 1 then 0 else xor is same as OR ; Update result ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "14018-14018",
        "Code": "def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT bit1 = ( n >> p1 ) & 1 NEW_LINE bit2 = ( n >> p2 ) & 1 NEW_LINE x = ( bit1 ^ bit2 ) NEW_LINE x = ( x << p1 ) | ( x << p2 ) NEW_LINE result = n ^ x NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT res = swapBits ( 28 , 0 , 3 ) NEW_LINE print ( \" Result ▁ = ▁ \" , res ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to swap two bits in a given integer ? | This function swaps bit at positions p1 and p2 in an integer n ; Move p1 'th to rightmost side ; Move p2 'th to rightmost side ; XOR the two bits ; Put the xor bit back to their original positions ; XOR ' x ' with the original number so that the two sets are swapped ; Driver program to test above function",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "14034-14034",
        "Code": "def temp_convert ( F1 , B1 , F2 , B2 , T ) : NEW_LINE INDENT t2 = F2 + ( ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ) NEW_LINE return t2 NEW_LINE DEDENT F1 = 0 NEW_LINE B1 = 100 NEW_LINE F2 = 32 NEW_LINE B2 = 212 NEW_LINE T = 37 NEW_LINE print ( temp_convert ( F1 , B1 , F2 , B2 , T ) ) NEW_LINE",
        "Type": "py",
        "NL": "Convert a given temperature to another system based on given boiling and freezing points | Function to return temperature in the second thermometer ; Calculate the temperature ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "14043-14043",
        "Code": "import random NEW_LINE N = 2 NEW_LINE def freivald ( a , b , c ) : NEW_LINE INDENT r = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT r [ i ] = ( int ) ( random . randrange ( 509090009 ) % 2 ) NEW_LINE DEDENT br = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] NEW_LINE DEDENT DEDENT cr = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] NEW_LINE DEDENT DEDENT axbr = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( axbr [ i ] - cr [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isProduct ( a , b , c , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT if ( freivald ( a , b , c ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 1 ] , [ 1 , 1 ] ] NEW_LINE b = [ [ 1 , 1 ] , [ 1 , 1 ] ] NEW_LINE c = [ [ 2 , 2 ] , [ 2 , 2 ] ] NEW_LINE k = 2 NEW_LINE if ( isProduct ( a , b , c , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Freivaldâ €™ s Algorithm to check if a matrix is product of two | Python3 code to implement FreivaldaTMs Algorithm ; Function to check if ABx = Cx ; Generate a random vector ; Now comput B * r for evaluating expression A * ( B * r ) - ( C * r ) ; Now comput C * r for evaluating expression A * ( B * r ) - ( C * r ) ; Now comput A * ( B * r ) for evaluating expression A * ( B * r ) - ( C * r ) ; Finally check if value of expression A * ( B * r ) - ( C * r ) is 0 or not ; Runs k iterations Freivald . The value of k determines accuracy . Higher value means higher accuracy . ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "14044-14044",
        "Code": "from random import randint NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . children = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getElements ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( getElements ( root . left ) + getElements ( root . right ) + 1 ) NEW_LINE DEDENT def insertChildrenCount ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT root . children = getElements ( root ) - 1 NEW_LINE insertChildrenCount ( root . left ) NEW_LINE insertChildrenCount ( root . right ) NEW_LINE DEDENT def children ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return root . children + 1 NEW_LINE DEDENT def randomNodeUtil ( root , count ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if count == children ( root . left ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT if count < children ( root . left ) : NEW_LINE INDENT return randomNodeUtil ( root . left , count ) NEW_LINE DEDENT return randomNodeUtil ( root . right , count - children ( root . left ) - 1 ) NEW_LINE DEDENT def randomNode ( root ) : NEW_LINE INDENT count = randint ( 0 , root . children ) NEW_LINE return randomNodeUtil ( root , count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 20 ) NEW_LINE root . right = Node ( 30 ) NEW_LINE root . left . right = Node ( 40 ) NEW_LINE root . left . right = Node ( 50 ) NEW_LINE root . right . left = Node ( 60 ) NEW_LINE root . right . right = Node ( 70 ) NEW_LINE insertChildrenCount ( root ) NEW_LINE print ( \" A ▁ Random ▁ Node ▁ From ▁ Tree ▁ : \" , randomNode ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Select a Random Node from a tree with equal probability | Python3 program to Select a Random Node from a tree ; This is used to fill children counts . ; Inserts Children count for each node ; Returns number of children for root ; Helper Function to return a random node ; Returns Random node ; Driver Code ; Creating Above Tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "14045-14045",
        "Code": "def calc_Expectation ( a , n ) : NEW_LINE INDENT prb = 1 / n NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( a [ i ] * prb ) NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT n = 6 ; NEW_LINE a = [ 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 ] NEW_LINE expect = calc_Expectation ( a , n ) NEW_LINE print ( \" Expectation ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ \" , expect ) NEW_LINE",
        "Type": "py",
        "NL": "Expectation or expected value of an array | Function to calculate expectation ; variable prb is for probability of each element which is same for each element ; calculating expectation overall ; returning expectation as sum ; Driver program ; Function for calculating expectation ; Display expectation of given array",
        "Category": "Math"
    },
    {
        "ID": "14049-14049",
        "Code": "import random NEW_LINE def rand2 ( ) : NEW_LINE INDENT tmp = random . randint ( 1 , 100 ) NEW_LINE return tmp % 2 NEW_LINE DEDENT def rand3 ( ) : NEW_LINE INDENT r = 2 * rand2 ( ) + rand2 ( ) NEW_LINE if r < 3 : NEW_LINE INDENT return r NEW_LINE DEDENT return rand3 ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT print ( rand3 ( ) , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Implement rand3 ( ) using rand2 ( ) | Python3 Program to print 0 , 1 or 2 with equal Probability ; Random Function to that returns 0 or 1 with equal probability ; randint ( 0 , 100 ) function will generate odd or even number [ 1 , 100 ] with equal probability . If rand ( ) generates odd number , the function will return 1 else it will return 0 ; Random Function to that returns 0 , 1 or 2 with equal probability 1 with 75 % ; returns 0 , 1 , 2 or 3 with 25 % probability ; Driver code to test above functions",
        "Category": "Math"
    },
    {
        "ID": "141-141",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def printTopToBottomPath ( curr , parent ) : NEW_LINE INDENT stk = [ ] NEW_LINE while ( curr ) : NEW_LINE INDENT stk . append ( curr ) NEW_LINE curr = parent [ curr ] NEW_LINE DEDENT while len ( stk ) != 0 : NEW_LINE INDENT curr = stk [ - 1 ] NEW_LINE stk . pop ( - 1 ) NEW_LINE print ( curr . data , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printRootToLeaf ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT nodeStack = [ ] NEW_LINE nodeStack . append ( root ) NEW_LINE parent = { } NEW_LINE parent [ root ] = None NEW_LINE while len ( nodeStack ) != 0 : NEW_LINE INDENT current = nodeStack [ - 1 ] NEW_LINE nodeStack . pop ( - 1 ) NEW_LINE if ( not ( current . left ) and not ( current . right ) ) : NEW_LINE INDENT printTopToBottomPath ( current , parent ) NEW_LINE DEDENT if ( current . right ) : NEW_LINE INDENT parent [ current . right ] = current NEW_LINE nodeStack . append ( current . right ) NEW_LINE DEDENT if ( current . left ) : NEW_LINE INDENT parent [ current . left ] = current NEW_LINE nodeStack . append ( current . left ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE printRootToLeaf ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print root to leaf paths without using recursion | Helper function that allocates a new node with the given data and None left and right pointers . ; Function to print root to leaf path for a leaf using parent nodes stored in map ; start from leaf node and keep on appending nodes into stack till root node is reached ; Start popping nodes from stack and print them ; An iterative function to do preorder traversal of binary tree and print root to leaf path without using recursion ; Corner Case ; Create an empty stack and append root to it ; Create a map to store parent pointers of binary tree nodes ; parent of root is None ; Pop all items one by one . Do following for every popped item a ) append its right child and set its parent pointer b ) append its left child and set its parent pointer Note that right child is appended first so that left is processed first ; Pop the top item from stack ; If leaf node encountered , print Top To Bottom path ; append right & left children of the popped node to stack . Also set their parent pointer in the map ; Driver Code ; Constructed binary tree is 10 / \\ 8 2 / \\ / 3 5 2",
        "Category": "Binary Tree"
    },
    {
        "ID": "142-142",
        "Code": "MAX_PATH_SIZE = 1000 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printPath ( size ) : NEW_LINE INDENT minimum_Hd = 10 ** 19 NEW_LINE p = [ ] NEW_LINE global Allpaths NEW_LINE for it in range ( size ) : NEW_LINE INDENT p = Allpaths [ it ] NEW_LINE minimum_Hd = min ( minimum_Hd , p [ 0 ] ) NEW_LINE DEDENT for it in range ( size ) : NEW_LINE INDENT p = Allpaths [ it ] NEW_LINE noOfUnderScores = abs ( p [ 0 ] - minimum_Hd ) NEW_LINE for i in range ( noOfUnderScores ) : NEW_LINE INDENT print ( end = \" _ ▁ \" ) NEW_LINE DEDENT print ( p [ 1 ] ) NEW_LINE DEDENT print ( \" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \" ) NEW_LINE DEDENT def printAllPathsUtil ( root , HD , order ) : NEW_LINE INDENT global Allpaths NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT Allpaths [ order ] = [ HD , root . data ] NEW_LINE printPath ( order + 1 ) NEW_LINE return NEW_LINE DEDENT Allpaths [ order ] = [ HD , root . data ] NEW_LINE printAllPathsUtil ( root . left , HD - 1 , order + 1 ) NEW_LINE printAllPathsUtil ( root . right , HD + 1 , order + 1 ) NEW_LINE DEDENT def printAllPaths ( root ) : NEW_LINE INDENT global Allpaths NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printAllPathsUtil ( root , 0 , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Allpaths = [ [ 0 , 0 ] for i in range ( MAX_PATH_SIZE ) ] NEW_LINE root = Node ( ' A ' ) NEW_LINE root . left = Node ( ' B ' ) NEW_LINE root . right = Node ( ' C ' ) NEW_LINE root . left . left = Node ( ' D ' ) NEW_LINE root . left . right = Node ( ' E ' ) NEW_LINE root . right . left = Node ( ' F ' ) NEW_LINE root . right . right = Node ( ' G ' ) NEW_LINE printAllPaths ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all root to leaf paths with there relative positions | Python3 program to print the longest leaf to leaf path ; Tree node structure used in the program ; Prints given root to leafAllpaths with underscores ; Find the minimum horizontal distance value in current root to leafAllpaths ; Find minimum horizontal distance ; Print the root to leafAllpaths with \" _ \" that indicate the related position ; Current tree node ; Print underscore ; Print current key ; A utility function prall path from root to leaf working of this function is similar to function of \" Print _ vertical _ order \" : Prpaths of binary tree in vertical order https : www . geeksforgeeks . org / print - binary - tree - vertical - order - set - 2 / ; Base case ; Leaf node ; Add leaf node and then prpath ; Store current path information ; Call left sub_tree ; Call left sub_tree ; Base case ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "1454-1454",
        "Code": "def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find element at given index after a number of rotations | Function to compute the element at given index ; Range [ left ... right ] ; Rotation will not have any effect ; Returning new element ; Driver Code ; No . of rotations ; Ranges according to 0 - based indexing",
        "Category": "Array"
    },
    {
        "ID": "1455-1455",
        "Code": "def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitArr ( arr , n , position ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split the array and add the first part to the end | Python program to split array and move first part to end . ; Rotate array by 1. ; main",
        "Category": "Array"
    },
    {
        "ID": "1456-1456",
        "Code": "def SplitAndAdd ( A , length , rotation ) : NEW_LINE INDENT tmp = [ 0 for i in range ( length * 2 ) ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT tmp [ i ] = A [ i ] NEW_LINE tmp [ i + length ] = A [ i ] NEW_LINE DEDENT for i in range ( rotation , rotation + length , 1 ) : NEW_LINE INDENT A [ i - rotation ] = tmp [ i ] ; NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE SplitAndAdd ( arr , n , position ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "Type": "py",
        "NL": "Split the array and add the first part to the end | Function to spilt array and move first part to end ; make a temporary array with double the size and each index is initialized to 0 ; copy array element in to new array twice ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "147-147",
        "Code": "class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def SumOfParentOfX ( root , Sum , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( ( root . left and root . left . data == x ) or ( root . right and root . right . data == x ) ) : NEW_LINE INDENT Sum [ 0 ] += root . data NEW_LINE DEDENT SumOfParentOfX ( root . left , Sum , x ) NEW_LINE SumOfParentOfX ( root . right , Sum , x ) NEW_LINE DEDENT def SumOfParentOfXUtil ( root , x ) : NEW_LINE INDENT Sum = [ 0 ] NEW_LINE SumOfParentOfX ( root , Sum , x ) NEW_LINE return Sum [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 4 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 5 ) NEW_LINE root . left . left = getNode ( 7 ) NEW_LINE root . left . right = getNode ( 2 ) NEW_LINE root . right . left = getNode ( 2 ) NEW_LINE root . right . right = getNode ( 3 ) NEW_LINE x = 2 NEW_LINE print ( \" Sum ▁ = ▁ \" , SumOfParentOfXUtil ( root , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all the parent nodes having child node x | function to get a new node ; put in the data ; function to find the Sum of all the parent nodes having child node x ; if root == None ; if left or right child of root is ' x ' , then add the root ' s ▁ data ▁ to ▁ ' Sum '  ; recursively find the required parent nodes in the left and right subtree ; utility function to find the Sum of all the parent nodes having child node x ; required Sum of parent nodes ; Driver Code ; binary tree formation 4 ; / \\ ; 2 5 ; / \\ / \\ ; 7 2 2 3",
        "Category": "Binary Tree"
    },
    {
        "ID": "1472-1472",
        "Code": "def printArray ( array , length ) : NEW_LINE INDENT print ( \" [ \" , end = \" \" ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT print ( array [ i ] , end = \" \" ) if ( i < ( length - 1 ) ) : print ( \" , \" , end = \" ▁ \" ) else : print ( \" ] \" ) NEW_LINE DEDENT DEDENT def reverse ( array , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT temp = array [ start ] NEW_LINE array [ start ] = array [ end ] NEW_LINE array [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT def rearrange ( array , start , end ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT return NEW_LINE DEDENT rearrange ( array , ( start + 1 ) , end ) NEW_LINE if ( array [ start ] >= 0 ) : NEW_LINE INDENT reverse ( array , ( start + 1 ) , end ) NEW_LINE reverse ( array , start , end ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT array = [ - 12 , - 11 , - 13 , - 5 , - 6 , 7 , 5 , 3 , 6 ] NEW_LINE length = len ( array ) NEW_LINE countNegative = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( array [ i ] < 0 ) : NEW_LINE INDENT countNegative += 1 NEW_LINE DEDENT DEDENT print ( \" array : ▁ \" , end = \" \" ) NEW_LINE printArray ( array , length ) NEW_LINE rearrange ( array , 0 , ( length - 1 ) ) NEW_LINE reverse ( array , countNegative , ( length - 1 ) ) NEW_LINE print ( \" rearranged ▁ array : ▁ \" , end = \" \" ) NEW_LINE printArray ( array , length ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange positive and negative numbers using inbuilt sort function | Python3 implementation of the above approach ; Rearrange the array with all negative integers on left and positive integers on right use recursion to split the array with first element as one half and the rest array as another and then merge it with head of the array in each step ; exit condition ; rearrange the array except the first element in each recursive call ; If the first element of the array is positive , then right - rotate the array by one place first and then reverse the merged array . ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "1487-1487",
        "Code": "def rearrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original ▁ Array \" ) NEW_LINE print ( arr ) NEW_LINE print ( \" Modified ▁ Array \" ) NEW_LINE print ( rearrange ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Rearrange an array in maximum minimum form | Set 1 | Prints max at first position , min at second position second max at third position , second min at fourth position and so on . ; Auxiliary array to hold modified array ; Indexes of smallest and largest elements from remaining array . ; To indicate whether we need to copy rmaining largest or remaining smallest at next position ; Store result in temp [ ] ; Copy temp [ ] to arr [ ] ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "15-15",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . left = None NEW_LINE self . right = None NEW_LINE self . val = key NEW_LINE DEDENT DEDENT def printPostorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT printPostorder ( root . left ) NEW_LINE printPostorder ( root . right ) NEW_LINE print ( root . val ) , NEW_LINE DEDENT DEDENT def printInorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT printInorder ( root . left ) NEW_LINE print ( root . val ) , NEW_LINE printInorder ( root . right ) NEW_LINE DEDENT DEDENT def printPreorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT print ( root . val ) , NEW_LINE printPreorder ( root . left ) NEW_LINE printPreorder ( root . right ) NEW_LINE DEDENT DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE print \" Preorder ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" NEW_LINE printPreorder ( root ) NEW_LINE print   \" NEW_LINE Inorder traversal of binary tree is \" NEW_LINE printInorder ( root ) NEW_LINE print   \" NEW_LINE Postorder traversal of binary tree is \" NEW_LINE printPostorder ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Tree Traversals ( Inorder , Preorder and Postorder ) | A class that represents an individual node in a Binary Tree ; A function to do postorder tree traversal ; First recur on left child ; the recur on right child ; now print the data of node ; A function to do inorder tree traversal ; First recur on left child ; then print the data of node ; now recur on right child ; A function to do preorder tree traversal ; First print the data of node ; Then recur on left child ; Finally recur on right child ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "151-151",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumOfLeftLeaves ( root ) : NEW_LINE INDENT if ( root is None ) : NEW_LINE INDENT return NEW_LINE DEDENT stack = [ ] NEW_LINE stack . append ( root ) NEW_LINE sum = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT currentNode = stack . pop ( ) NEW_LINE if currentNode . left is not None : NEW_LINE INDENT stack . append ( currentNode . left ) NEW_LINE if currentNode . left . left is None and currentNode . left . right is None : NEW_LINE INDENT sum = sum + currentNode . left . data NEW_LINE DEDENT DEDENT if currentNode . right is not None : NEW_LINE INDENT stack . append ( currentNode . right ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT root = Tree ( 20 ) ; NEW_LINE root . left = Tree ( 9 ) ; NEW_LINE root . right = Tree ( 49 ) ; NEW_LINE root . right . left = Tree ( 23 ) ; NEW_LINE root . right . right = Tree ( 52 ) ; NEW_LINE root . right . right . left = Tree ( 50 ) ; NEW_LINE root . left . left = Tree ( 5 ) ; NEW_LINE root . left . right = Tree ( 12 ) ; NEW_LINE root . left . right . right = Tree ( 12 ) ; NEW_LINE print ( ' Sum ▁ of ▁ left ▁ leaves ▁ is ▁ { } ' . format ( sumOfLeftLeaves ( root ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find sum of all left leaves in a given Binary Tree | A binary tree node ; A constructor to create a new Node ; Return the sum of left leaf nodes ; Using a stack for Depth - First Traversal of the tree ; sum holds the sum of all the left leaves ; Check if currentNode 's left child is a leaf node ; if currentNode is a leaf , add its data to the sum ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "1513-1513",
        "Code": "def find3largest ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( count < 4 ) : NEW_LINE INDENT if ( check != arr [ n - i ] ) : NEW_LINE INDENT print ( arr [ n - i ] , end = \" ▁ \" ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , 45 , 1 , - 1 , 45 , 54 , 23 , 5 , 0 , - 10 ] NEW_LINE n = len ( arr ) NEW_LINE find3largest ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find the largest three distinct elements in an array | Python3 code to find largest three elements in an array ; It uses Tuned Quicksort with ; avg . case Time complexity = O ( nLogn ) ; to handle duplicate values ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "152-152",
        "Code": "from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . key = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumOfLeftLeaves ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = deque ( ) NEW_LINE q . append ( [ root , 0 ] ) NEW_LINE sum = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT temp = q [ 0 ] [ 0 ] NEW_LINE is_left_child = q [ 0 ] [ 1 ] NEW_LINE q . popleft ( ) NEW_LINE if ( not temp . left and not temp . right and is_left_child ) : NEW_LINE INDENT sum = sum + temp . key NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT q . append ( [ temp . left , 1 ] ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( [ temp . right , 0 ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 20 ) NEW_LINE root . left = Node ( 9 ) NEW_LINE root . right = Node ( 49 ) NEW_LINE root . right . left = Node ( 23 ) NEW_LINE root . right . right = Node ( 52 ) NEW_LINE root . right . right . left = Node ( 50 ) NEW_LINE root . left . left = Node ( 5 ) NEW_LINE root . left . right = Node ( 12 ) NEW_LINE root . left . right . right = Node ( 12 ) NEW_LINE print ( \" Sum ▁ of ▁ left ▁ leaves ▁ is \" , sumOfLeftLeaves ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find sum of all left leaves in a given Binary Tree | Python3 program to find sum of all left leaves ; A binary tree node ; Return the sum of left leaf nodes ; A queue of pairs to do bfs traversal and keep track if the node is a left or right child if boolean value is true then it is a left child . ; Do bfs traversal ; If temp is a leaf node and left child of its parent ; If it is not leaf then push its children nodes into queue ; Boolean value is true here because it is left child of its parent ; Boolean value is false here because it is right child of its parent ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "1539-1539",
        "Code": "class pair : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . min = 0 NEW_LINE self . max = 0 NEW_LINE DEDENT DEDENT def getMinMax ( arr : list , n : int ) -> pair : NEW_LINE INDENT minmax = pair ( ) NEW_LINE if n == 1 : NEW_LINE INDENT minmax . max = arr [ 0 ] NEW_LINE minmax . min = arr [ 0 ] NEW_LINE return minmax NEW_LINE DEDENT if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT minmax . max = arr [ 0 ] NEW_LINE minmax . min = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT minmax . max = arr [ 1 ] NEW_LINE minmax . min = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > minmax . max : NEW_LINE INDENT minmax . max = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < minmax . min : NEW_LINE INDENT minmax . min = arr [ i ] NEW_LINE DEDENT DEDENT return minmax NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE arr_size = 6 NEW_LINE minmax = getMinMax ( arr , arr_size ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , minmax . min ) NEW_LINE print ( \" Maximum ▁ element ▁ is \" , minmax . max ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum and minimum of an array using minimum number of comparisons | structure is used to return two values from minMax ( ) ; If there is only one element then return it as min and max both ; If there are more than one elements , then initialize min and max ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "1541-1541",
        "Code": "def getMinMax ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT mx = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE mn = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE i = 2 NEW_LINE DEDENT else : NEW_LINE INDENT mx = mn = arr [ 0 ] NEW_LINE i = 1 NEW_LINE DEDENT while ( i < n - 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ i + 1 ] : NEW_LINE INDENT mx = max ( mx , arr [ i + 1 ] ) NEW_LINE mn = min ( mn , arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , arr [ i ] ) NEW_LINE mn = min ( mn , arr [ i + 1 ] ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return ( mx , mn ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1000 , 11 , 445 , 1 , 330 , 3000 ] NEW_LINE mx , mn = getMinMax ( arr ) NEW_LINE print ( \" Minimum ▁ element ▁ is \" , mn ) NEW_LINE print ( \" Maximum ▁ element ▁ is \" , mx ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum and minimum of an array using minimum number of comparisons | getMinMax ( ) ; If array has even number of elements then initialize the first two elements as minimum and maximum ; set the starting index for loop ; If array has odd number of elements then initialize the first element as minimum and maximum ; set the starting index for loop ; In the while loop , pick elements in pair and compare the pair with max and min so far ; Increment the index by 2 as two elements are processed in loop ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "1542-1542",
        "Code": "def printQuerySum ( arr , Q ) : NEW_LINE INDENT for q in Q : NEW_LINE INDENT L , R = q NEW_LINE s = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of \" , q , \" is \" , s ) NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 2 , 1 , 3 , 4 , 5 , 2 , 8 ] NEW_LINE Q = [ [ 0 , 4 ] , [ 1 , 3 ] , [ 2 , 4 ] ] NEW_LINE printQuerySum ( arr , Q ) NEW_LINE",
        "Type": "py",
        "NL": "MO 's Algorithm (Query Square Root Decomposition) | Set 1 (Introduction) | Function that accepts array and list of queries and print sum of each query ; Traverse through each query ; Extract left and right indices ; Compute sum of current query range ; Print sum of current query range ; Driver script",
        "Category": "Array"
    },
    {
        "ID": "1544-1544",
        "Code": "from math import sqrt NEW_LINE MAXN = 10000 NEW_LINE SQRSIZE = 100 NEW_LINE arr = [ 0 ] * ( MAXN ) NEW_LINE block = [ 0 ] * ( SQRSIZE ) NEW_LINE blk_sz = 0 NEW_LINE def update ( idx , val ) : NEW_LINE INDENT blockNumber = idx // blk_sz NEW_LINE block [ blockNumber ] += val - arr [ idx ] NEW_LINE arr [ idx ] = val NEW_LINE DEDENT def query ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( l < r and l % blk_sz != 0 and l != 0 ) : NEW_LINE INDENT sum += arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT while ( l + blk_sz <= r ) : NEW_LINE INDENT sum += block [ l // blk_sz ] NEW_LINE l += blk_sz NEW_LINE DEDENT while ( l <= r ) : NEW_LINE INDENT sum += arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT def preprocess ( input , n ) : NEW_LINE INDENT blk_idx = - 1 NEW_LINE global blk_sz NEW_LINE blk_sz = int ( sqrt ( n ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = input [ i ] ; NEW_LINE if ( i % blk_sz == 0 ) : NEW_LINE INDENT blk_idx += 1 ; NEW_LINE DEDENT block [ blk_idx ] += arr [ i ] NEW_LINE DEDENT DEDENT input = [ 1 , 5 , 2 , 4 , 6 , 1 , 3 , 5 , 7 , 10 ] NEW_LINE n = len ( input ) NEW_LINE preprocess ( input , n ) NEW_LINE print ( \" query ( 3,8 ) ▁ : ▁ \" , query ( 3 , 8 ) ) NEW_LINE print ( \" query ( 1,6 ) ▁ : ▁ \" , query ( 1 , 6 ) ) NEW_LINE update ( 8 , 0 ) NEW_LINE print ( \" query ( 8,8 ) ▁ : ▁ \" , query ( 8 , 8 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sqrt ( or Square Root ) Decomposition Technique | Set 1 ( Introduction ) | Python 3 program to demonstrate working of Square Root Decomposition . ; original array ; decomposed array ; block size ; Time Complexity : O ( 1 ) ; Time Complexity : O ( sqrt ( n ) ) ; traversing first block in range ; traversing completely overlapped blocks in range ; traversing last block in range ; Fills values in input [ ] ; initiating block pointer ; calculating size of block ; building the decomposed array ; entering next block incementing block pointer ; We have used separate array for input because the purpose of this code is to explain SQRT decomposition in competitive programming where we have multiple inputs .",
        "Category": "Square Root Decomposition is a technique used for efficient range queries and updates, particularly when dealing with arrays. While it's not one of the listed categories verbatim, its mechanism is most closely aligned with **Array** since it operates on array data structure"
    },
    {
        "ID": "1557-1557",
        "Code": "def lowerIndex ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] >= x ) : NEW_LINE h = mid - 1 NEW_LINE else : NEW_LINE l = mid + 1 NEW_LINE DEDENT return l NEW_LINE DEDENT def upperIndex ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] <= x ) : NEW_LINE l = mid + 1 NEW_LINE else : NEW_LINE h = mid - 1 NEW_LINE DEDENT return h NEW_LINE DEDENT def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; NEW_LINE return count NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 9 , 10 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE i = 1 NEW_LINE j = 4 NEW_LINE print ( countInRange ( arr , n , i , j ) ) NEW_LINE i = 9 NEW_LINE j = 12 NEW_LINE print ( countInRange ( arr , n , i , j ) ) NEW_LINE",
        "Type": "py",
        "NL": "Queries for counts of array elements with values in given range | function to find first index >= x ; function to find last index <= x ; function to count elements within given range ; initialize result ; driver function ; Preprocess array ; Answer queries",
        "Category": "Binary Search"
    },
    {
        "ID": "1561-1561",
        "Code": "import math NEW_LINE one = [ [ 0 for x in range ( 32 ) ] for y in range ( 100001 ) ] NEW_LINE MAX = 2147483647 NEW_LINE def make_prefix ( A , n ) : NEW_LINE INDENT global one , MAX NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT one [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a = A [ i - 1 ] NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT x = int ( math . pow ( 2 , j ) ) NEW_LINE if ( a & x ) : NEW_LINE INDENT one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT one [ i ] [ j ] = one [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def Solve ( L , R ) : NEW_LINE INDENT global one , MAX NEW_LINE l = L NEW_LINE r = R NEW_LINE tot_bits = r - l + 1 NEW_LINE X = MAX NEW_LINE for i in range ( 0 , 31 ) : NEW_LINE INDENT x = one [ r ] [ i ] - one [ l - 1 ] [ i ] NEW_LINE if ( x >= ( tot_bits - x ) ) : NEW_LINE INDENT ith_bit = pow ( 2 , i ) NEW_LINE X = X ^ ith_bit NEW_LINE DEDENT DEDENT return X NEW_LINE DEDENT n = 5 NEW_LINE q = 3 NEW_LINE A = [ 210 , 11 , 48 , 22 , 133 ] NEW_LINE L = [ 1 , 4 , 2 ] NEW_LINE R = [ 3 , 14 , 4 ] NEW_LINE make_prefix ( A , n ) NEW_LINE for j in range ( 0 , q ) : NEW_LINE INDENT print ( Solve ( L [ j ] , R [ j ] ) , end = \" \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number whose sum of XOR with given array range is maximum | Python3 program to find smallest integer X such that sum of its XOR with range is maximum . ; Function to make prefix array which counts 1 's of each bit up to that number ; Making a prefix array which sums number of 1 's up to  that position ; If j - th bit of a number is set then add one to previously counted 1 's ; Function to find X ; Initially taking maximum value all bits 1 ; Iterating over each bit ; get 1 ' s ▁ at ▁ ith ▁ bit ▁ between ▁ the ▁ ▁ range ▁ L - R ▁ by ▁ subtracting ▁ 1' s till Rth number - 1 's till L-1th number ; If 1 ' s ▁ are ▁ more ▁ than ▁ or ▁ equal ▁ ▁ to ▁ 0' s then unset the ith bit from answer ; Set ith bit to 0 by doing Xor with 1 ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "1564-1564",
        "Code": "import math NEW_LINE max = 10000 NEW_LINE def update ( arr , l ) : NEW_LINE INDENT arr [ l ] += arr [ l - 1 ] NEW_LINE DEDENT def record_func ( block_size , block , record , l , r , value ) : NEW_LINE INDENT while ( l < r and l % block_size != 0 and l != 0 ) : NEW_LINE INDENT record [ l ] += value NEW_LINE l += 1 NEW_LINE DEDENT while ( l + block_size <= r + 1 ) : NEW_LINE INDENT block [ l // block_size ] += value NEW_LINE l += block_size NEW_LINE DEDENT while ( l <= r ) : NEW_LINE INDENT record [ l ] += value NEW_LINE l += 1 NEW_LINE DEDENT DEDENT def print_array ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE m = 5 NEW_LINE arr = [ 0 ] * n NEW_LINE record = [ 0 ] * m NEW_LINE block_size = ( int ) ( math . sqrt ( m ) ) NEW_LINE block = [ 0 ] * max NEW_LINE command = [ [ 1 , 1 , 2 ] , [ 1 , 4 , 5 ] , [ 2 , 1 , 2 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 4 ] ] NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( command [ i ] [ 0 ] == 2 ) : NEW_LINE INDENT x = i // ( block_size ) NEW_LINE record_func ( block_size , block , record , command [ i ] [ 1 ] - 1 , command [ i ] [ 2 ] - 1 , ( block [ x ] + record [ i ] + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT record [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT check = ( i // block_size ) NEW_LINE record [ i ] += block [ check ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( command [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT arr [ command [ i ] [ 1 ] - 1 ] += record [ i ] NEW_LINE if ( ( command [ i ] [ 2 ] - 1 ) < n - 1 ) : NEW_LINE INDENT arr [ ( command [ i ] [ 2 ] ) ] -= record [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT update ( arr , i ) NEW_LINE DEDENT print_array ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Array range queries over range queries | Python3 program to perform range queries over range queries . ; For prefix sum array ; This function is used to apply square root decomposition in the record array ; Traversing first block in range ; Traversing completely overlapped blocks in range ; Traversing last block in range ; Function to print the resultant array ; Driver code ; If query is of type 2 then function call to record_func ; If query is of type 1 then simply add 1 to the record array ; Merging the value of the block in the record array ; If query is of type 1 then the array elements are over - written by the record array ; The prefix sum of the array ; Printing the resultant array",
        "Category": "Array"
    },
    {
        "ID": "1566-1566",
        "Code": "class Query : NEW_LINE INDENT def __init__ ( self , L , R , X ) : NEW_LINE INDENT self . L = L NEW_LINE self . R = R NEW_LINE self . X = X NEW_LINE DEDENT DEDENT maxn = 100 NEW_LINE root = [ 0 ] * maxn NEW_LINE def find ( x ) : NEW_LINE INDENT if x == root [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT root [ x ] = find ( root [ x ] ) NEW_LINE return root [ x ] NEW_LINE DEDENT DEDENT def uni ( x , y ) : NEW_LINE INDENT p = find ( x ) NEW_LINE q = find ( y ) NEW_LINE if p != q : NEW_LINE INDENT root [ p ] = root [ q ] NEW_LINE DEDENT DEDENT def initialize ( a , n , q , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT root [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT uni ( i , i - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 5 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE q = [ Query ( 0 , 2 , 2 ) , Query ( 1 , 4 , 1 ) , Query ( 2 , 4 , 5 ) ] NEW_LINE m = len ( q ) NEW_LINE initialize ( a , n , q , m ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT flag = False NEW_LINE l = q [ i ] . L NEW_LINE r = q [ i ] . R NEW_LINE x = q [ i ] . X NEW_LINE p = r NEW_LINE while p >= l : NEW_LINE INDENT if a [ p ] == x : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT p = find ( p ) - 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( \" % d ▁ exists ▁ between ▁ [ % d , ▁ % d ] \" % ( x , l , r ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" % d ▁ does ▁ not ▁ exists ▁ between ▁ [ % d , ▁ % d ] \" % ( x , l , r ) ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Array range queries for searching an element | Structure to represent a query range ; Find the root of the group containing the element at index x ; merge the two groups containing elements at indices x and y into one group ; make n subsets with every element as its root ; consecutive elements equal in value are merged into one single group ; Driver Code ; check if the current element in consideration is equal to x or not if it is equal , then x exists in the range ; Print if x exists or not",
        "Category": "Union-Find (Disjoint Set Union)"
    },
    {
        "ID": "1567-1567",
        "Code": "import math as mt NEW_LINE def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer ▁ for ▁ Query ▁ \" , ( i + 1 ) , \" ▁ = ▁ \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Array range queries for elements with frequency same as value | Python 3 Program to answer Q queries to find number of times an element x appears x times in a Query subarray ; Returns the count of number x with frequency x in the subarray from start to end ; map for frequency of elements ; store frequency of each element in arr [ start end ] ; Count elements with same frequency as value ; Driver code ; 2D array of queries with 2 columns ; calculating number of queries",
        "Category": "Array"
    },
    {
        "ID": "157-157",
        "Code": "class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def printPathUtil ( node , s , root_data ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT rem = root_data - node . data NEW_LINE if rem in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( node . data ) NEW_LINE res = printPathUtil ( node . left , s , root_data ) or printPathUtil ( node . right , s , root_data ) NEW_LINE s . remove ( node . data ) NEW_LINE return res NEW_LINE DEDENT def isPathSum ( root ) : NEW_LINE INDENT s = set ( ) NEW_LINE return printPathUtil ( root . left , s , root . data ) or printPathUtil ( root . right , s , root . data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 8 ) NEW_LINE root . left = newnode ( 5 ) NEW_LINE root . right = newnode ( 4 ) NEW_LINE root . left . left = newnode ( 9 ) NEW_LINE root . left . right = newnode ( 7 ) NEW_LINE root . left . right . left = newnode ( 1 ) NEW_LINE root . left . right . right = newnode ( 12 ) NEW_LINE root . left . right . right . right = newnode ( 2 ) NEW_LINE root . right . right = newnode ( 11 ) NEW_LINE root . right . right . left = newnode ( 3 ) NEW_LINE print ( \" Yes \" ) if ( isPathSum ( root ) ) else print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if there is a pair in root to a leaf path with sum equals to root 's data | utility that allocates a new node with the given data and None left and right pointers . ; Function to prroot to leaf path which satisfies the condition ; Base condition ; Check if current node makes a pair with any of the existing elements in set . ; Insert current node in set ; If result returned by either left or right child is True , return True . ; Remove current node from hash table ; A wrapper over printPathUtil ( ) ; create an empty hash table ; Recursively check in left and right subtrees . ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "1575-1575",
        "Code": "def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT elif ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest Sum Contiguous Subarray |  ; Do not compare for all elements . Compare only when max_ending_here > 0",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1580-1580",
        "Code": "def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( \" Subarray ▁ between ▁ [ \" , res_index , \" , ▁ \" , ( res_index + k - 1 ) , \" ] ▁ has ▁ minimum ▁ average \" ) NEW_LINE DEDENT arr = [ 3 , 7 , 90 , 20 , 10 , 50 , 40 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE findMinAvgSubarray ( arr , n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find the subarray with least average | Prints beginning and ending indexes of subarray of size k with minimum average ; k must be smaller than or equal to n ; Initialize beginning index of result ; Compute sum of first subarray of size k ; Initialize minimum sum as current sum ; Traverse from ( k + 1 ) ' th ▁ ▁ element ▁ to ▁ n ' th element ; Add current item and remove first item of previous subarray ; Update result if needed ; Driver Code ; Subarray size",
        "Category": "Sliding Window"
    },
    {
        "ID": "159-159",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def Print ( root ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT Print ( root . left ) NEW_LINE print ( root . data , end = \" ▁ \" ) NEW_LINE Print ( root . right ) NEW_LINE DEDENT DEDENT def pruneUtil ( root , k , Sum ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT lSum = [ Sum [ 0 ] + ( root . data ) ] NEW_LINE rSum = [ lSum [ 0 ] ] NEW_LINE root . left = pruneUtil ( root . left , k , lSum ) NEW_LINE root . right = pruneUtil ( root . right , k , rSum ) NEW_LINE Sum [ 0 ] = max ( lSum [ 0 ] , rSum [ 0 ] ) NEW_LINE if ( Sum [ 0 ] < k [ 0 ] ) : NEW_LINE INDENT root = None NEW_LINE DEDENT return root NEW_LINE DEDENT def prune ( root , k ) : NEW_LINE INDENT Sum = [ 0 ] NEW_LINE return pruneUtil ( root , k , Sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = [ 45 ] NEW_LINE root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . left . left . right = newNode ( 9 ) NEW_LINE root . left . right . left = newNode ( 12 ) NEW_LINE root . right . right . left = newNode ( 10 ) NEW_LINE root . right . right . left . right = newNode ( 11 ) NEW_LINE root . left . left . right . left = newNode ( 13 ) NEW_LINE root . left . left . right . right = newNode ( 14 ) NEW_LINE root . left . left . right . right . left = newNode ( 15 ) NEW_LINE print ( \" Tree ▁ before ▁ truncation \" ) NEW_LINE Print ( root ) NEW_LINE print ( ) NEW_LINE root = prune ( root , k ) NEW_LINE print ( \" Tree ▁ after ▁ truncation \" ) NEW_LINE Print ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove all nodes which don 't lie in any path with sum>= k | A utility function to create a new Binary Tree node with given data ; print the tree in LVR ( Inorder traversal ) way . ; Main function which truncates the binary tree . ; Base Case ; Initialize left and right Sums as Sum from root to this node ( including this node ) ; Recursively prune left and right subtrees ; Get the maximum of left and right Sums ; If maximum is smaller than k , then this node must be deleted ; A wrapper over pruneUtil ( ) ; Driver Code ; k is 45",
        "Category": "Binary Tree"
    },
    {
        "ID": "1592-1592",
        "Code": "def countMinOperations ( target , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT zero_count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( ( target [ i ] & 1 ) > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT elif ( target [ i ] == 0 ) : NEW_LINE INDENT zero_count += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( zero_count == n ) : NEW_LINE INDENT return result ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT target [ j ] = target [ j ] // 2 ; NEW_LINE DEDENT result += 1 ; NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] -= 1 ; NEW_LINE result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 16 , 16 , 16 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ steps ▁ required ▁ to \" , \t \t \" get the given target array is \" , countMinOperations ( arr , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count minimum steps to get the given desired array | Returns count of minimum operations to convert a zero array to target array with increment and doubling operations . This function computes count by doing reverse steps , i . e . , convert target to zero array . ; Initialize result ( Count of minimum moves ) ; Keep looping while all elements of target don 't become 0. ; To store count of zeroes in current target array ; To find first odd element ; If odd number found ; If 0 , then increment zero_count ; All numbers are 0 ; All numbers are even ; Divide the whole array by 2 and increment result ; Make all odd numbers even by subtracting one and increment result . ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "1601-1601",
        "Code": "def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT len = j - i + 1 NEW_LINE if ( len > maxLen ) : NEW_LINE INDENT maxLen = len NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT arr1 = [ 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 1 , 1 , 1 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ common ▁ span ▁ with ▁ same ▁ \" \" sum ▁ is \" , longestCommonSum ( arr1 , arr2 , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Longest Span with same Sum in two Binary arrays | Returns length of the longest common subarray with same sum ; Initialize result ; One by one pick all possible starting points of subarrays ; Initialize sums of current subarrays ; Conider all points for starting with arr [ i ] ; Update sums ; If sums are same and current length is more than maxLen , update maxLen ; Driver program to test above function",
        "Category": "Array"
    },
    {
        "ID": "1614-1614",
        "Code": "def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT arr = [ 1 , 20 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ inversions ▁ are \" , getInvCount ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count Inversions in an array | Set 1 ( Using Merge Sort ) | Python3 program to count inversions in an array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "1616-1616",
        "Code": "def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are \" , arr [ min_l ] , \" and ▁ \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Two elements whose sum is closest to zero | Python3 code to find Two elements whose sum is closest to zero ; Array should have at least two elements ; Initialization of values ; Driver program to test above function",
        "Category": "Array"
    },
    {
        "ID": "1629-1629",
        "Code": "def printUnion ( arr1 , arr2 , m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT tempp = arr1 NEW_LINE arr1 = arr2 NEW_LINE arr2 = tempp NEW_LINE temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT tempp = arr1 NEW_LINE arr1 = arr2 NEW_LINE arr2 = tempp NEW_LINE temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr1 = [ 7 , 1 , 5 , 2 , 3 , 6 ] NEW_LINE arr2 = [ 3 , 8 , 6 , 20 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( \" Union ▁ of ▁ two ▁ arrays ▁ is ▁ \" ) NEW_LINE printUnion ( arr1 , arr2 , m , n ) NEW_LINE print ( \" Intersection of two arrays is   \" ) NEW_LINE printIntersection ( arr1 , arr2 , m , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find Union and Intersection of two unsorted arrays | Prints union of arr1 [ 0. . m - 1 ] and arr2 [ 0. . n - 1 ] ; Before finding union , make sure arr1 [ 0. . m - 1 ] is smaller ; Now arr1 [ ] is smaller Sort the first array and print its elements ( these two steps can be swapped as order in output is not important ) ; Search every element of bigger array in smaller array and print the element if not found ; Prints intersection of arr1 [ 0. . m - 1 ] and arr2 [ 0. . n - 1 ] ; Before finding intersection , make sure arr1 [ 0. . m - 1 ] is smaller ; Now arr1 [ ] is smaller Sort smaller array arr1 [ 0. . m - 1 ] ; Search every element of bigger array in smaller array and print the element if found ; A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be presen in left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver code ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "1636-1636",
        "Code": "def printUnsorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( \" The ▁ complete ▁ array ▁ is ▁ sorted \" ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array \" ) NEW_LINE print ( \" sorted ▁ lies ▁ between ▁ the ▁ indexes ▁ % d ▁ and ▁ % d \" % ( s , e ) ) NEW_LINE DEDENT arr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printUnsorted ( arr , arr_size ) NEW_LINE",
        "Type": "py",
        "NL": "Find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted | Python3 program to find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted ; step 1 ( a ) of above algo ; step 1 ( b ) of above algo ; step 2 ( a ) of above algo ; step 2 ( b ) of above algo ; step 2 ( c ) of above algo ; step 3 of above algo",
        "Category": "Array"
    },
    {
        "ID": "1640-1640",
        "Code": "def countPairsBruteForce ( X , Y , m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( pow ( X [ i ] , Y [ j ] ) > pow ( Y [ j ] , X [ i ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find number of pairs ( x , y ) in an array such that x ^ y > y ^ x |",
        "Category": "Brute Force"
    },
    {
        "ID": "1641-1641",
        "Code": "import bisect NEW_LINE def count ( x , Y , n , NoOfY ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if x == 1 : NEW_LINE INDENT return NoOfY [ 0 ] NEW_LINE DEDENT idx = bisect . bisect_right ( Y , x ) NEW_LINE ans = n - idx NEW_LINE ans += NoOfY [ 0 ] + NoOfY [ 1 ] NEW_LINE if x == 2 : NEW_LINE INDENT ans -= NoOfY [ 3 ] + NoOfY [ 4 ] NEW_LINE DEDENT if x == 3 : NEW_LINE INDENT ans += NoOfY [ 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def count_pairs ( X , Y , m , n ) : NEW_LINE INDENT NoOfY = [ 0 ] * 5 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if Y [ i ] < 5 : NEW_LINE INDENT NoOfY [ Y [ i ] ] += 1 NEW_LINE DEDENT DEDENT Y . sort ( ) NEW_LINE total_pairs = 0 NEW_LINE for x in X : NEW_LINE INDENT total_pairs += count ( x , Y , n , NoOfY ) NEW_LINE DEDENT return total_pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = [ 2 , 1 , 6 ] NEW_LINE Y = [ 1 , 5 ] NEW_LINE print ( \" Total ▁ pairs ▁ = ▁ \" , count_pairs ( X , Y , len ( X ) , len ( Y ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find number of pairs ( x , y ) in an array such that x ^ y > y ^ x | Python3 program to find the number of pairs ( x , y ) in an array such that x ^ y > y ^ x ; Function to return count of pairs with x as one element of the pair . It mainly looks for all values in Y where x ^ Y [ i ] > Y [ i ] ^ x ; If x is 0 , then there cannot be any value in Y such that x ^ Y [ i ] > Y [ i ] ^ x ; If x is 1 , then the number of pairs is equal to number of zeroes in Y ; Find number of elements in Y [ ] with values greater than x , bisect . bisect_right gets address of first greater element in Y [ 0. . n - 1 ] ; If we have reached here , then x must be greater than 1 , increase number of pairs for y = 0 and y = 1 ; Decrease number of pairs for x = 2 and ( y = 4 or y = 3 ) ; Increase number of pairs for x = 3 and y = 2 ; Function to return count of pairs ( x , y ) such that x belongs to X , y belongs to Y and x ^ y > y ^ x ; To store counts of 0 , 1 , 2 , 3 , and 4 in array Y ; Sort Y so that we can do binary search in it ; Initialize result ; Take every element of X and count pairs with it ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "1656-1656",
        "Code": "def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 12 , 34 , 10 , 6 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE key = 40 NEW_LINE index = findElement ( arr , n , key ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( \" element ▁ found ▁ at ▁ position : ▁ \" + str ( index + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" element ▁ not ▁ found \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Search , insert and delete in an unsorted array | Function to implement search operation ; Driver Code ; Using a last element as search element",
        "Category": "Array"
    },
    {
        "ID": "1669-1669",
        "Code": "def binary_search ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ mid ] > x : NEW_LINE INDENT return binary_search ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binary_search ( arr , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def findPos ( a , key ) : NEW_LINE INDENT l , h , val = 0 , 1 , arr [ 0 ] NEW_LINE while val < key : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE val = arr [ h ] NEW_LINE DEDENT return binary_search ( a , l , h , key ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 ] NEW_LINE ans = findPos ( arr , 10 ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print \" Element ▁ not ▁ found \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Element ▁ found ▁ at ▁ index \" , ans NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find position of an element in a sorted array of infinite numbers | Binary search algorithm implementation ; function takes an infinite size array and a key to be searched and returns its position if found else - 1. We don 't know size of a[] and we can assume size to be infinite in this function. NOTE THAT THIS FUNCTION ASSUMES a[] TO BE OF INFINITE SIZE THEREFORE, THERE IS NO INDEX OUT OF BOUND CHECKING ; Find h to do binary search ; store previous high ; double high index ; update new val ; at this point we have updated low and high indices , thus use binary search between them ; Driver function",
        "Category": "Binary Search"
    },
    {
        "ID": "1674-1674",
        "Code": "def findSingle ( ar , n ) : NEW_LINE INDENT res = ar [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 2 , 3 , 5 , 4 , 5 , 3 , 4 ] NEW_LINE print \" Element ▁ occurring ▁ once ▁ is \" , findSingle ( ar , len ( ar ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the element that appears once in an array where every other element appears twice | function to find the once appearing element in array ; Do XOR of all elements and return ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "1676-1676",
        "Code": "INT_MIN = - 2147483648 NEW_LINE def isPresent ( B , m , x ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT if B [ i ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findMaxSubarraySumUtil ( A , B , n , m ) : NEW_LINE INDENT max_so_far = INT_MIN NEW_LINE curr_max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isPresent ( B , m , A [ i ] ) == True : NEW_LINE INDENT curr_max = 0 NEW_LINE continue NEW_LINE DEDENT curr_max = max ( A [ i ] , curr_max + A [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def findMaxSubarraySum ( A , B , n , m ) : NEW_LINE INDENT maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) NEW_LINE if maxSubarraySum == INT_MIN : NEW_LINE INDENT print ( ' Maximum ▁ Subarray ▁ Sum ▁ cant ▁ be ▁ found ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ' , maxSubarraySum ) NEW_LINE DEDENT DEDENT A = [ 3 , 4 , 5 , - 4 , 6 ] NEW_LINE B = [ 1 , 8 , 5 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE findMaxSubarraySum ( A , B , n , m ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum Subarray Sum Excluding Certain Elements | Function to check the element present in array B ; Utility function for findMaxSubarraySum ( ) with the following parameters A = > Array A , B = > Array B , n = > Number of elements in Array A , m = > Number of elements in Array B ; set max_so_far to INT_MIN ; if the element is present in B , set current max to 0 and move to the next element ; Proceed as in Kadane 's Algorithm ; Wrapper for findMaxSubarraySumUtil ( ) ; This case will occour when all elements of A are present in B , thus no subarray can be formed ; Driver code ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "168-168",
        "Code": "def getHeight ( Node ) : NEW_LINE INDENT if ( Node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT lHeight = getHeight ( Node . left ) NEW_LINE rHeight = getHeight ( Node . right ) NEW_LINE if ( lHeight > rHeight ) : NEW_LINE INDENT return ( lHeight + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( rHeight + 1 ) NEW_LINE DEDENT DEDENT DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getTotalHeight ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( getTotalHeight ( root . left ) + getHeight ( root ) + getTotalHeight ( root . right ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE DEDENT print ( \" Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = \" , getTotalHeight ( root ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of heights of all individual nodes in a binary tree | Compute the \" maxHeight \" of a particular Node ; compute the height of each subtree ; use the larger one ; Helper class that allocates a new Node with the given data and None left and right pointers . ; Function to sum of heights of individual Nodes Uses Inorder traversal ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "169-169",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE def getTotalHeightUtil ( root ) : NEW_LINE INDENT global sum NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lh = getTotalHeightUtil ( root . left ) NEW_LINE rh = getTotalHeightUtil ( root . right ) NEW_LINE h = max ( lh , rh ) + 1 NEW_LINE sum = sum + h NEW_LINE return h NEW_LINE DEDENT def getTotalHeight ( root ) : NEW_LINE INDENT getTotalHeightUtil ( root ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE print ( \" Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = \" , getTotalHeight ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of heights of all individual nodes in a binary tree | A binary tree Node has data , pointer to left child and a pointer to right child ; Function to sum of heights of individual Nodes Uses Inorder traversal ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "1704-1704",
        "Code": "import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 ; NEW_LINE P = 1 ; NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( \" The ▁ two ▁ Repeating ▁ elements ▁ are ▁ \" , ( int ) ( x ) , \" ▁ & ▁ \" , ( int ) ( y ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * fact ( n - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE",
        "Type": "py",
        "NL": "Find the two repeating elements in a given array | Python3 code for Find the two repeating elements in a given array ; printRepeating function ; S is for sum of elements in arr [ ] ; P is for product of elements in arr [ ] ; Calculate Sum and Product of all elements in arr [ ] ; S is x + y now ; P is x * y now ; D is x - y now ; factorial of n ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1714-1714",
        "Code": "def maximum ( a , b , c ) : NEW_LINE INDENT return max ( max ( a , b ) , c ) NEW_LINE DEDENT def minimum ( a , b , c ) : NEW_LINE INDENT return min ( min ( a , b ) , c ) NEW_LINE DEDENT def smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE arr3 . sort ( ) NEW_LINE res_min = 0 ; res_max = 0 ; res_mid = 0 NEW_LINE i = 0 ; j = 0 ; k = 0 NEW_LINE diff = 2147483647 NEW_LINE while ( i < n and j < n and k < n ) : NEW_LINE INDENT sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] NEW_LINE max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) NEW_LINE min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) NEW_LINE if ( min == arr1 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( min == arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( diff > ( max - min ) ) : NEW_LINE INDENT diff = max - min NEW_LINE res_max = max NEW_LINE res_mid = sum - ( max + min ) NEW_LINE res_min = min NEW_LINE DEDENT DEDENT print ( res_max , \" , \" , res_mid , \" , \" , res_min ) NEW_LINE DEDENT arr1 = [ 5 , 2 , 8 ] NEW_LINE arr2 = [ 10 , 7 , 12 ] NEW_LINE arr3 = [ 9 , 14 , 6 ] NEW_LINE n = len ( arr1 ) NEW_LINE smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest Difference Triplet from Three arrays | Function to find maximum number ; Function to find minimum number ; Finds and prints the smallest Difference Triplet ; sorting all the three arrays ; To store resultant three numbers ; pointers to arr1 , arr2 , arr3 respectively ; Loop until one array reaches to its end Find the smallest difference . ; maximum number ; Find minimum and increment its index . ; Comparing new difference with the previous one and updating accordingly ; Print result ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "175-175",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddLevelDifference ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while ( size > 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . left . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 7 ) NEW_LINE result = evenOddLevelDifference ( root ) NEW_LINE print ( \" Diffence ▁ between ▁ sums ▁ is \" , result ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Difference between sums of odd level and even level nodes of a Binary Tree | Helper function that allocates a new node with the given data and None left and right poers . ; Construct to create a new node ; return difference of sums of odd level and even level ; create a queue for level order traversal ; traverse until the queue is empty ; traverse for complete level ; check if level no . is even or odd and accordingly update the evenSum or oddSum ; check for left child ; check for right child ; Driver Code ; Let us create Binary Tree shown in above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "176-176",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getLevelDiff ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( root . data - getLevelDiff ( root . left ) - getLevelDiff ( root . right ) ) NEW_LINE DEDENT root = Node ( 5 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 6 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 4 ) NEW_LINE root . left . right . left = Node ( 3 ) NEW_LINE root . right . right = Node ( 8 ) NEW_LINE root . right . right . right = Node ( 9 ) NEW_LINE root . right . right . left = Node ( 7 ) NEW_LINE print \" % d ▁ is ▁ the ▁ required ▁ difference \" % ( getLevelDiff ( root ) ) NEW_LINE",
        "Type": "py",
        "NL": "Difference between sums of odd level and even level nodes of a Binary Tree | A Binary Tree node ; The main function that returns difference between odd and even level nodes ; Base Case ; Difference for root is root 's data - difference for  left subtree - difference for right subtree ; Driver program to test above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "1779-1779",
        "Code": "def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize ( max ( A [ i ] , B [ j ] , C [ k ] ) | python code for above approach . ; assigning the length - 1 value to each of three variables ; calculating min difference from last index of lists ; checking condition ; calculating max term from list ; Moving to smaller value in the array with maximum out of three . ; driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "1780-1780",
        "Code": "def search ( arr , x ) : NEW_LINE INDENT for index , value in enumerate ( arr ) : NEW_LINE INDENT if value == x : NEW_LINE INDENT return index NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE print ( x , \" is ▁ present ▁ at ▁ index \" , search ( arr , x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Analysis of Algorithms | Set 2 ( Worst , Average and Best Cases ) | Linearly search x in arr [ ] . If x is present then return the index , otherwise return - 1 ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "179-179",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def leafSum ( root ) : NEW_LINE INDENT global total NEW_LINE if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . left is None and root . right is None ) : NEW_LINE INDENT total += root . data NEW_LINE DEDENT leafSum ( root . left ) NEW_LINE leafSum ( root . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . left . right = Node ( 8 ) NEW_LINE total = 0 NEW_LINE leafSum ( root ) NEW_LINE print ( total ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all leaf nodes of binary tree | Class for node creation ; constructor ; Utility function to calculate the sum of all leaf nodes ; add root data to sum if root is a leaf node ; propagate recursively in left and right subtree ; Binary tree Fromation ; Variable to store the sum of leaf nodes",
        "Category": "Binary Tree"
    },
    {
        "ID": "1791-1791",
        "Code": "import math NEW_LINE def jumpSearch ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while arr [ int ( min ( step , n ) - 1 ) ] < x : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if prev >= n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while arr [ int ( prev ) ] < x : NEW_LINE INDENT prev += 1 NEW_LINE if prev == min ( step , n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if arr [ int ( prev ) ] == x : NEW_LINE INDENT return prev NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 ] NEW_LINE x = 55 NEW_LINE n = len ( arr ) NEW_LINE index = jumpSearch ( arr , x , n ) NEW_LINE print ( \" Number \" , x , \" is ▁ at ▁ index \" , \" % .0f \" % index ) NEW_LINE",
        "Type": "py",
        "NL": "Jump Search | Python3 code to implement Jump Search ; Finding block size to be jumped ; Finding the block where element is present ( if it is present ) ; Doing a linear search for x in block beginning with prev . ; If we reached next block or end of array , element is not present . ; If element is found ; Driver code to test function ; Find the index of ' x ' using Jump Search ; Print the index where ' x ' is located",
        "Category": "Binary Search"
    },
    {
        "ID": "1792-1792",
        "Code": "def interpolationSearch ( arr , lo , hi , x ) : NEW_LINE INDENT if ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT pos = lo + ( ( hi - lo ) // ( arr [ hi ] - arr [ lo ] ) * ( x - arr [ lo ] ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT return interpolationSearch ( arr , pos + 1 , hi , x ) NEW_LINE DEDENT if arr [ pos ] > x : NEW_LINE INDENT return interpolationSearch ( arr , lo , pos - 1 , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE x = 18 NEW_LINE index = interpolationSearch ( arr , 0 , n - 1 , x ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( \" Element ▁ found ▁ at ▁ index \" , index ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ not ▁ found \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Interpolation Search | If x is present in arr [ 0. . n - 1 ] , then returns index of it , else returns - 1. ; Since array is sorted , an element present in array must be in range defined by corner ; Probing the position with keeping uniform distribution in mind . ; Condition of target found ; If x is larger , x is in right subarray ; If x is smaller , x is in left subarray ; Array of items in which search will be conducted ; Element to be searched ; If element was found",
        "Category": "Binary Search"
    },
    {
        "ID": "18-18",
        "Code": "def search ( arr , x , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printPostOrder ( In , pre , n ) : NEW_LINE INDENT root = search ( In , pre [ 0 ] , n ) NEW_LINE if ( root != 0 ) : NEW_LINE INDENT printPostOrder ( In , pre [ 1 : n ] , root ) NEW_LINE DEDENT if ( root != n - 1 ) : NEW_LINE INDENT printPostOrder ( In [ root + 1 : n ] , pre [ root + 1 : n ] , n - root - 1 ) NEW_LINE DEDENT print ( pre [ 0 ] , end = \" ▁ \" ) NEW_LINE DEDENT In = [ 4 , 2 , 5 , 1 , 3 , 6 ] NEW_LINE pre = [ 1 , 2 , 4 , 5 , 3 , 6 ] NEW_LINE n = len ( In ) NEW_LINE print ( \" Postorder ▁ traversal ▁ \" ) NEW_LINE printPostOrder ( In , pre , n ) NEW_LINE",
        "Type": "py",
        "NL": "Print Postorder traversal from given Inorder and Preorder traversals | A utility function to search x in arr [ ] of size n ; Prints postorder traversal from given inorder and preorder traversals ; The first element in pre [ ] is always root , search it in in [ ] to find left and right subtrees ; If left subtree is not empty , print left subtree ; If right subtree is not empty , print right subtree ; Print root ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "180-180",
        "Code": "from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumOfLeafNodesAtLeafLevel ( root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT if not root . left and not root . right : NEW_LINE INDENT return root . data NEW_LINE DEDENT Queue = deque ( ) NEW_LINE sum = f = 0 NEW_LINE Queue . append ( root ) NEW_LINE while not f : NEW_LINE INDENT nc = len ( Queue ) NEW_LINE while nc : NEW_LINE INDENT top = Queue . popleft ( ) NEW_LINE if not top . left and not top . right : NEW_LINE INDENT sum += top . data NEW_LINE f = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if top . left : NEW_LINE INDENT Queue . append ( top . left ) NEW_LINE DEDENT if top . right : NEW_LINE INDENT Queue . append ( top . right ) NEW_LINE DEDENT DEDENT nc -= 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . left . right . left = Node ( 8 ) NEW_LINE root . right . left . right = Node ( 9 ) NEW_LINE print ( \" Sum ▁ = ▁ \" , sumOfLeafNodesAtLeafLevel ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of leaf nodes at minimum level | Python3 implementation to find the sum of leaf node at minimum level ; Structure of a node in binary tree ; function to find the sum of leaf nodes at minimum level ; if tree is empty ; if there is only root node ; Queue used for level order traversal ; push rioot node in the queue ; count no . of nodes present at current level ; traverse current level nodes ; get front element from ' q ' ; if node is leaf node ; accumulate data to ' sum ' ; set flag = 1 to signify that we have encountered the minimum level ; if top 's left or right child exist  push them to Queue ; return the sum ; Driver code ; binary tree creation",
        "Category": "Binary Tree"
    },
    {
        "ID": "1800-1800",
        "Code": "def countingSort ( arr , exp1 ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE output = [ 0 ] * ( n ) NEW_LINE count = [ 0 ] * ( 10 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT index = ( arr [ i ] / exp1 ) NEW_LINE count [ int ( index % 10 ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT index = ( arr [ i ] / exp1 ) NEW_LINE output [ count [ int ( index % 10 ) ] - 1 ] = arr [ i ] NEW_LINE count [ int ( index % 10 ) ] -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = output [ i ] NEW_LINE DEDENT DEDENT def radixSort ( arr ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE exp = 1 NEW_LINE while max1 / exp > 0 : NEW_LINE INDENT countingSort ( arr , exp ) NEW_LINE exp *= 10 NEW_LINE DEDENT DEDENT arr = [ 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 ] NEW_LINE radixSort ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Radix Sort | A function to do counting sort of arr [ ] according to the digit represented by exp . ; The output array elements that will have sorted arr ; initialize count array as 0 ; Store count of occurrences in count [ ] ; Change count [ i ] so that count [ i ] now contains actual position of this digit in output array ; Build the output array ; Copying the output array to arr [ ] , so that arr now contains sorted numbers ; Method to do Radix Sort ; Find the maximum number to know number of digits ; Do counting sort for every digit . Note that instead of passing digit number , exp is passed . exp is 10 ^ i where i is current digit number ; Driver code ; Function Call",
        "Category": "Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by individual digits which share the same significant position and value. It utilizes a modified Counting Sort as a subroutine to sort the digits at each position"
    },
    {
        "ID": "181-181",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def hasPathSum ( node , s ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return ( s == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE subSum = s - node . data NEW_LINE if ( subSum == 0 and node . left == None and node . right == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT if node . left is not None : NEW_LINE INDENT ans = ans or hasPathSum ( node . left , subSum ) NEW_LINE DEDENT if node . right is not None : NEW_LINE INDENT ans = ans or hasPathSum ( node . right , subSum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT s = 21 NEW_LINE root = Node ( 10 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . right = Node ( 2 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . left . left = Node ( 3 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE if hasPathSum ( root , s ) : NEW_LINE INDENT print \" There ▁ is ▁ a ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" % ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print \" There ▁ is ▁ no ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ % d \" % ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Root to leaf path sum equal to a given number | A binary tree node ; Given a tree and a sum , return true if there is a path from the root down to a leaf , such that adding up all the values along the path equals the given sum . Strategy : subtract the node value from the sum when recurring down , and check to see if the sum is 0 when you run out of tree . s is the sum ; Constructed binary tree is 10 / \\ 8 2 / \\ / 3 5 2",
        "Category": "Binary Tree"
    },
    {
        "ID": "1814-1814",
        "Code": "def countSort ( arr , n , exp ) : NEW_LINE INDENT output = [ 0 ] * n NEW_LINE count = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count [ ( arr [ i ] // exp ) % n ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT output [ count [ ( arr [ i ] // exp ) % n ] - 1 ] = arr [ i ] NEW_LINE count [ ( arr [ i ] // exp ) % n ] -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = output [ i ] NEW_LINE DEDENT DEDENT def sort ( arr , n ) : NEW_LINE INDENT countSort ( arr , n , 1 ) NEW_LINE countSort ( arr , n , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 40 , 12 , 45 , 32 , 33 , 1 , 22 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given ▁ array ▁ is \" ) NEW_LINE print ( * arr ) NEW_LINE sort ( arr , n ) NEW_LINE print ( \" Sorted ▁ array ▁ is \" ) NEW_LINE print ( * arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort n numbers in range from 0 to n ^ 2 | A function to do counting sort of arr [ ] according to the digit represented by exp . ; output array ; Store count of occurrences in count [ ] ; Change count [ i ] so that count [ i ] now contains actual position of this digit in output [ ] ; Build the output array ; Copy the output array to arr [ ] , so that arr [ ] now contains sorted numbers according to current digit ; The main function to that sorts arr [ ] of size n using Radix Sort ; Do counting sort for first digit in base n . Note that instead of passing digit number , exp ( n ^ 0 = 1 ) is passed . ; Do counting sort for second digit in base n . Note that instead of passing digit number , exp ( n ^ 1 = n ) is passed . ; Driver Code ; Since array size is 7 , elements should be from 0 to 48",
        "Category": "Radix Sort"
    },
    {
        "ID": "1818-1818",
        "Code": "import sys NEW_LINE def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ar1 [ l ] + ar2 [ r ] > x : NEW_LINE INDENT r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT DEDENT print ( \" The ▁ closest ▁ pair ▁ is ▁ [ \" , ar1 [ res_l ] , \" , \" , ar2 [ res_r ] , \" ] \" ) NEW_LINE DEDENT ar1 = [ 1 , 4 , 5 , 7 ] NEW_LINE ar2 = [ 10 , 20 , 30 , 40 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE x = 38 NEW_LINE printClosest ( ar1 , ar2 , m , n , x ) NEW_LINE",
        "Type": "py",
        "NL": "Find the closest pair from two sorted arrays | Python3 program to find the pair from two sorted arays such that the sum of pair is closest to a given number x ; ar1 [ 0. . m - 1 ] and ar2 [ 0. . n - 1 ] are two given sorted arrays and x is given number . This function prints the pair from both arrays such that the sum of the pair is closest to x . ; Initialize the diff between pair sum and x . ; Start from left side of ar1 [ ] and right side of ar2 [ ] ; If this pair is closer to x than the previously found closest , then update res_l , res_r and diff ; If sum of this pair is more than x , move to smaller side ; move to the greater side ; Print the result ; Driver program to test above functions",
        "Category": "Two Pointers"
    },
    {
        "ID": "1841-1841",
        "Code": "def EditDistDP ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE DP = [ [ 0 for i in range ( len1 + 1 ) ] for j in range ( 2 ) ] ; NEW_LINE for i in range ( 0 , len1 + 1 ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i NEW_LINE DEDENT for i in range ( 1 , len2 + 1 ) : NEW_LINE INDENT for j in range ( 0 , len1 + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT DP [ i % 2 ] [ j ] = i NEW_LINE DEDENT elif ( str1 [ j - 1 ] == str2 [ i - 1 ] ) : NEW_LINE INDENT DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i % 2 ] [ j ] = ( 1 + min ( DP [ ( i - 1 ) % 2 ] [ j ] , min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ) NEW_LINE DEDENT DEDENT DEDENT print ( DP [ len2 % 2 ] [ len1 ] , \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" food \" NEW_LINE str2 = \" money \" NEW_LINE EditDistDP ( str1 , str2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Edit Distance | DP | A Space efficient Dynamic Programming based Python3 program to find minimum number operations to convert str1 to str2 ; Create a DP array to memoize result of previous computations ; Base condition when second String is empty then we remove all characters ; Start filling the DP This loop run for every character in second String ; This loop compares the char from second String with first String characters ; If first String is empty then we have to perform add character operation to get second String ; If character from both String is same then we do not perform any operation . here i % 2 is for bound the row number . ; If character from both String is not same then we take the minimum from three specified operation ; After complete fill the DP array if the len2 is even then we end up in the 0 th row else we end up in the 1 th row so we take len2 % 2 to get row ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1842-1842",
        "Code": "def minDis ( s1 , s2 , n , m , dp ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( dp [ n ] [ m ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ m ] ; NEW_LINE DEDENT if ( s1 [ n - 1 ] == s2 [ m - 1 ] ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ m - 1 ] == - 1 ) : NEW_LINE INDENT dp [ n ] [ m ] = minDis ( s1 , s2 , n - 1 , m - 1 , dp ) NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] [ m ] = dp [ n - 1 ] [ m - 1 ] NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( dp [ n - 1 ] [ m ] != - 1 ) : NEW_LINE m1 = dp [ n - 1 ] [ m ] NEW_LINE else : NEW_LINE m1 = minDis ( s1 , s2 , n - 1 , m , dp ) NEW_LINE if ( dp [ n ] [ m - 1 ] != - 1 ) : NEW_LINE m2 = dp [ n ] [ m - 1 ] NEW_LINE else : NEW_LINE m2 = minDis ( s1 , s2 , n , m - 1 , dp ) NEW_LINE if ( dp [ n - 1 ] [ m - 1 ] != - 1 ) : NEW_LINE m3 = dp [ n - 1 ] [ m - 1 ] NEW_LINE else : NEW_LINE m3 = minDis ( s1 , s2 , n - 1 , m - 1 , dp ) NEW_LINE dp [ n ] [ m ] = 1 + min ( m1 , min ( m2 , m3 ) ) NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT DEDENT str1 = \" voldemort \" NEW_LINE str2 = \" dumbledore \" NEW_LINE n = len ( str1 ) NEW_LINE m = len ( str2 ) NEW_LINE dp = [ [ - 1 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE print ( minDis ( str1 , str2 , n , m , dp ) ) NEW_LINE",
        "Type": "py",
        "NL": "Edit Distance | DP |  ; If any string is empty , return the remaining characters of other string ; To check if the recursive tree for given n & m has already been executed ; If characters are equal , execute recursive function for n - 1 , m - 1 ; If characters are nt equal , we need to find the minimum cost out of all 3 operations . ; temp variables ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1868-1868",
        "Code": "def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT seq = \" GEEKS ▁ FOR ▁ GEEKS \" NEW_LINE n = len ( seq ) NEW_LINE print ( \" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ \" + str ( lps ( seq ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Longest Palindromic Subsequence | DP | Returns the length of the longest palindromic subsequence in seq ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of length 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . The values are filled in a manner similar to Matrix Chain Multiplication DP solution ( See https : www . geeksforgeeks . org / dynamic - programming - set - 8 - matrix - chain - multiplication / cl is length of substring ; Driver program to test above functions",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1894-1894",
        "Code": "def maxDivide ( a , b ) : NEW_LINE INDENT while a % b == 0 : NEW_LINE INDENT a = a / b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return 1 if no == 1 else 0 NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while n > count : NEW_LINE INDENT i += 1 NEW_LINE if isUgly ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( \"150th ▁ ugly ▁ no . ▁ is ▁ \" , no ) NEW_LINE",
        "Type": "py",
        "NL": "Ugly Numbers | This function divides a by greatest divisible power of b ; Function to check if a number is ugly or not ; Function to get the nth ugly number ; ugly number count ; Check for all integers untill ugly count becomes n ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "1899-1899",
        "Code": "import sys NEW_LINE def printSubStr ( st , low , high ) : NEW_LINE INDENT sys . stdout . write ( st [ low : high + 1 ] ) NEW_LINE sys . stdout . flush ( ) NEW_LINE return ' ' NEW_LINE DEDENT def longestPalSubstr ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE table = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE maxLength = 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT table [ i ] [ i ] = True NEW_LINE i = i + 1 NEW_LINE DEDENT start = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] ) : NEW_LINE INDENT table [ i ] [ i + 1 ] = True NEW_LINE start = i NEW_LINE maxLength = 2 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT k = 3 NEW_LINE while k <= n : NEW_LINE INDENT i = 0 NEW_LINE while i < ( n - k + 1 ) : NEW_LINE INDENT j = i + k - 1 NEW_LINE if ( table [ i + 1 ] [ j - 1 ] and st [ i ] == st [ j ] ) : NEW_LINE INDENT table [ i ] [ j ] = True NEW_LINE if ( k > maxLength ) : NEW_LINE INDENT start = i NEW_LINE maxLength = k NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT print \" Longest ▁ palindrome ▁ substring ▁ is : ▁ \" , printSubStr ( st , start , start + maxLength - 1 ) NEW_LINE return maxLength NEW_LINE DEDENT st = \" forgeeksskeegfor \" NEW_LINE l = longestPalSubstr ( st ) NEW_LINE print \" Length ▁ is : \" , l NEW_LINE",
        "Type": "py",
        "NL": "Longest Palindromic Substring | Set 1 | Python program ; A utility function to print a substring str [ low . . high ] ; This function prints the longest palindrome substring of st [ ] . It also returns the length of the longest palindrome ; get length of input string ; table [ i ] [ j ] will be false if substring str [ i . . j ] is not palindrome . Else table [ i ] [ j ] will be true ; All substrings of length 1 are palindromes ; check for sub - string of length 2. ; Check for lengths greater than 2. k is length of substring ; Fix the starting index ; Get the ending index of substring from starting index i and length k ; checking for sub - string from ith index to jth index iff st [ i + 1 ] to st [ ( j - 1 ) ] is a palindrome ; return length of LPS ; Driver program to test above functions",
        "Category": "Substring"
    },
    {
        "ID": "1902-1902",
        "Code": "def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT class node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def LISS ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT size_excl = LISS ( root . left ) + LISS ( root . right ) NEW_LINE size_incl = 1 NEW_LINE if ( root . left != None ) : NEW_LINE INDENT size_incl += LISS ( root . left . left ) + LISS ( root . left . right ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT size_incl += LISS ( root . right . left ) + LISS ( root . right . right ) NEW_LINE DEDENT return max ( size_incl , size_excl ) NEW_LINE DEDENT def newNode ( data ) : NEW_LINE INDENT temp = node ( ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT root = newNode ( 20 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 12 ) NEW_LINE root . left . right . left = newNode ( 10 ) NEW_LINE root . left . right . right = newNode ( 14 ) NEW_LINE root . right = newNode ( 22 ) NEW_LINE root . right . right = newNode ( 25 ) NEW_LINE print ( \" Size ▁ of ▁ the ▁ Largest \" , \" ▁ Independent ▁ Set ▁ is ▁ \" , LISS ( root ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest Independent Set Problem | DP | A utility function to find max of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; The function returns size of the largest independent set in a given binary tree ; Calculate size excluding the current node ; Calculate size including the current node ; Return the maximum of two sizes ; A utility function to create a node ; Let us construct the tree given in the above diagram",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1908-1908",
        "Code": "def countParenth ( symb , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if symb [ i ] == ' F ' : NEW_LINE INDENT F [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ i ] = 0 NEW_LINE DEDENT if symb [ i ] == ' T ' : NEW_LINE INDENT T [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ i ] = 0 NEW_LINE DEDENT DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( gap , n ) : NEW_LINE INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0 NEW_LINE for g in range ( gap ) : NEW_LINE INDENT k = i + g NEW_LINE tik = T [ i ] [ k ] + F [ i ] [ k ] NEW_LINE tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] NEW_LINE if oper [ k ] == ' & ' : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == ' | ' : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == ' ^ ' : NEW_LINE INDENT T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT return T [ 0 ] [ n - 1 ] NEW_LINE DEDENT symbols = \" TTFT \" NEW_LINE operators = \" | & ^ \" NEW_LINE n = len ( symbols ) NEW_LINE print ( countParenth ( symbols , operators , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Boolean Parenthesization Problem | DP | Returns count of all possible parenthesizations that lead to result true for a boolean expression with symbols like true and false and operators like & , | and ^ filled between symbols ; Fill diaginal entries first All diagonal entries in T [ i ] [ i ] are 1 if symbol [ i ] is T ( true ) . Similarly , all F [ i ] [ i ] entries are 1 if symbol [ i ] is F ( False ) ; Now fill T [ i ] [ i + 1 ] , T [ i ] [ i + 2 ] , T [ i ] [ i + 3 ] ... in order And F [ i ] [ i + 1 ] , F [ i ] [ i + 2 ] , F [ i ] [ i + 3 ] ... in order ; Find place of parenthesization using current value of gap ; Store Total [ i ] [ k ] and Total [ k + 1 ] [ j ] ; Follow the recursive formulas according to the current operator ; Driver Code ; There are 4 ways ( ( T T ) & ( F ^ T ) ) , ( T | ( T & ( F ^ T ) ) ) , ( ( ( T T ) & F ) ^ T ) and ( T | ( ( T & F ) ^ T ) )",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "192-192",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def findLCAUtil ( root , n1 , n2 , v ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return None NEW_LINE DEDENT if root . key == n1 : NEW_LINE INDENT v [ 0 ] = True NEW_LINE return root NEW_LINE DEDENT if root . key == n2 : NEW_LINE INDENT v [ 1 ] = True NEW_LINE return root NEW_LINE DEDENT left_lca = findLCAUtil ( root . left , n1 , n2 , v ) NEW_LINE right_lca = findLCAUtil ( root . right , n1 , n2 , v ) NEW_LINE if left_lca and right_lca : NEW_LINE INDENT return root NEW_LINE DEDENT return left_lca if left_lca is not None else right_lca NEW_LINE DEDENT def find ( root , k ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return False NEW_LINE DEDENT if ( root . key == k or find ( root . left , k ) or find ( root . right , k ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def findLCA ( root , n1 , n2 ) : NEW_LINE INDENT v = [ False , False ] NEW_LINE lca = findLCAUtil ( root , n1 , n2 , v ) NEW_LINE if ( v [ 0 ] and v [ 1 ] or v [ 0 ] and find ( lca , n2 ) or v [ 1 ] and find ( lca , n1 ) ) : NEW_LINE INDENT return lca NEW_LINE DEDENT return None NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE lca = findLCA ( root , 4 , 5 ) NEW_LINE if lca is not None : NEW_LINE INDENT print \" LCA ( 4 , ▁ 5 ) ▁ = ▁ \" , lca . key NEW_LINE DEDENT else : NEW_LINE INDENT print \" Keys ▁ are ▁ not ▁ present \" NEW_LINE DEDENT lca = findLCA ( root , 4 , 10 ) NEW_LINE if lca is not None : NEW_LINE INDENT print \" LCA ( 4,10 ) ▁ = ▁ \" , lca . key NEW_LINE DEDENT else : NEW_LINE INDENT print \" Keys ▁ are ▁ not ▁ present \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lowest Common Ancestor in a Binary Tree | Set 1 | A binary tree node ; This function retturn pointer to LCA of two given values n1 and n2 v1 is set as true by this function if n1 is found v2 is set as true by this function if n2 is found ; Base Case ; IF either n1 or n2 matches ith root 's key, report  the presence by setting v1 or v2 as true and return  root (Note that if a key is ancestor of other, then the ancestor key becomes LCA) ; Look for keys in left and right subtree ; If both of the above calls return Non - NULL , then one key is present in once subtree and other is present in other , So this node is the LCA ; Otherwise check if left subtree or right subtree is LCA ; Returns true if key k is present in tree rooted with root ; This function returns LCA of n1 and n2 onlue if both n1 and n2 are present in tree , otherwise returns None ; Initialize n1 and n2 as not visited ; Find lac of n1 and n2 using the technique discussed above ; Returns LCA only if both n1 and n2 are present in tree ; Else return None ; Driver program to test above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "1922-1922",
        "Code": "import math NEW_LINE def findCount ( n , sum ) : NEW_LINE INDENT start = math . pow ( 10 , n - 1 ) ; NEW_LINE end = math . pow ( 10 , n ) - 1 ; NEW_LINE count = 0 ; NEW_LINE i = start ; NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 ; NEW_LINE temp = i ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 ; NEW_LINE temp = temp // 10 ; NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE i += 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE sum = 5 ; NEW_LINE findCount ( n , sum ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count of n digit numbers whose sum of digits equals to given sum | Python3 program to Count of n digit numbers whose sum of digits equals to given sum ; in case n = 2 start is 10 and end is ( 100 - 1 ) = 99 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "1935-1935",
        "Code": "def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT result = result + sumOfDigits ( x ) NEW_LINE DEDENT return result NEW_LINE DEDENT def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" is \" , sumOfDigitsFrom1ToN ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Compute sum of digits in all numbers from 1 to n | Returns sum of all digits in numbers from 1 to n ; initialize result ; One by one compute sum of digits in every number from 1 to n ; A utility function to compute sum of digits in a given number x ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "1938-1938",
        "Code": "def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT countB = 1 NEW_LINE countS = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_countB = countB NEW_LINE prev_countS = countS NEW_LINE countS = prev_countB + prev_countS NEW_LINE countB = prev_countS NEW_LINE DEDENT result = countS + countB NEW_LINE return ( result * result ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE print ( \" Count ▁ of ▁ ways ▁ for ▁ \" , N , \" ▁ sections ▁ is ▁ \" , countWays ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count possible ways to construct buildings | Returns count of possible ways for N sections ; Base case ; 2 for one side and 4 for two sides ; countB is count of ways with a building at the end countS is count of ways with a space at the end prev_countB and prev_countS are previous values of countB and countS respectively . Initialize countB and countS for one side ; Use the above recursive formula for calculating countB and countS using previous values ; Result for one side is sum of ways ending with building and ending with space ; Result for 2 sides is square of result for one side ; Driver program",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1944-1944",
        "Code": "def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of ways to reach a given score in a game | Returns number of ways to reach score n . ; table [ i ] will store count of solutions for value i . Initialize all table values as 0. ; Base case ( If given value is 0 ) ; One by one consider given 3 moves and update the table [ ] values after the index greater than or equal to the value of the picked move . ; Driver Program",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "1949-1949",
        "Code": "def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( \" Pattern ▁ found ▁ at ▁ index ▁ \" , i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT txt = \" AABAACAADAABAAABAA \" NEW_LINE pat = \" AABA \" NEW_LINE search ( pat , txt ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Naive algorithm for Pattern Searching | Python3 program for Naive Pattern Searching algorithm ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "1958-1958",
        "Code": "MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * MAX NEW_LINE countTW = [ 0 ] * MAX NEW_LINE for i in range ( M ) : NEW_LINE INDENT ( countP [ ord ( pat [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( \" Found ▁ at ▁ Index \" , ( i - M ) ) NEW_LINE DEDENT ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i - M ] ) ] ) -= 1 NEW_LINE DEDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( \" Found ▁ at ▁ Index \" , N - M ) NEW_LINE DEDENT DEDENT txt = \" BACDGABCDA \" NEW_LINE pat = \" ABCD \" NEW_LINE search ( pat , txt ) NEW_LINE",
        "Type": "py",
        "NL": "Anagram Substring Search ( Or Search for all permutations ) | Python program to search all anagrams of a pattern in a text ; This function returns true if contents of arr1 [ ] and arr2 [ ] are same , otherwise false . ; This function search for all permutations of pat [ ] in txt [ ] ; countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text ; Traverse through remaining characters of pattern ; Compare counts of current window of text with counts of pattern [ ] ; Add current character to current window ; Remove the first character of previous window ; Check for the last window in text ; Driver program to test above function",
        "Category": "Sliding Window"
    },
    {
        "ID": "1962-1962",
        "Code": "def findLongestPalindromicString ( text ) : NEW_LINE INDENT N = len ( text ) NEW_LINE if N == 0 : NEW_LINE INDENT return NEW_LINE DEDENT N = 2 * N + 1 NEW_LINE L = [ 0 ] * N NEW_LINE L [ 0 ] = 0 NEW_LINE L [ 1 ] = 1 NEW_LINE C = 1 NEW_LINE R = 2 NEW_LINE i = 0 NEW_LINE iMirror = 0 NEW_LINE maxLPSLength = 0 NEW_LINE maxLPSCenterPosition = 0 NEW_LINE start = - 1 NEW_LINE end = - 1 NEW_LINE diff = - 1 NEW_LINE for i in xrange ( 2 , N ) : NEW_LINE INDENT iMirror = 2 * C - i NEW_LINE L [ i ] = 0 NEW_LINE diff = R - i NEW_LINE if diff > 0 : NEW_LINE INDENT L [ i ] = min ( L [ iMirror ] , diff ) NEW_LINE DEDENT try : NEW_LINE INDENT while ( ( i + L [ i ] ) < N and ( i - L [ i ] ) > 0 ) and ( ( ( i + L [ i ] + 1 ) % 2 == 0 ) or ( text [ ( i + L [ i ] + 1 ) / 2 ] == text [ ( i - L [ i ] - 1 ) / 2 ] ) ) : NEW_LINE INDENT L [ i ] += 1 NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT if L [ i ] > maxLPSLength : NEW_LINE INDENT maxLPSLength = L [ i ] NEW_LINE maxLPSCenterPosition = i NEW_LINE DEDENT if i + L [ i ] > R : NEW_LINE INDENT C = i NEW_LINE R = i + L [ i ] NEW_LINE DEDENT DEDENT start = ( maxLPSCenterPosition - maxLPSLength ) / 2 NEW_LINE end = start + maxLPSLength - 1 NEW_LINE print \" LPS ▁ of ▁ string ▁ is ▁ \" + text + \" ▁ : ▁ \" , NEW_LINE print text [ start : end + 1 ] , NEW_LINE print   \" NEW_LINE DEDENT \" , NEW_LINE text1 = \" babcbabcbaccba \" NEW_LINE findLongestPalindromicString ( text1 ) NEW_LINE text2 = \" abaaba \" NEW_LINE findLongestPalindromicString ( text2 ) NEW_LINE text3 = \" abababa \" NEW_LINE findLongestPalindromicString ( text3 ) NEW_LINE text4 = \" abcbabcbabcba \" NEW_LINE findLongestPalindromicString ( text4 ) NEW_LINE text5 = \" forgeeksskeegfor \" NEW_LINE findLongestPalindromicString ( text5 ) NEW_LINE text6 = \" caba \" NEW_LINE findLongestPalindromicString ( text6 ) NEW_LINE text7 = \" abacdfgdcaba \" NEW_LINE findLongestPalindromicString ( text7 ) NEW_LINE text8 = \" abacdfgdcabba \" NEW_LINE findLongestPalindromicString ( text8 ) NEW_LINE text9 = \" abacdedcaba \" NEW_LINE findLongestPalindromicString ( text9 ) NEW_LINE",
        "Type": "py",
        "NL": "Manacher 's Algorithm | Python program to implement Manacher 's Algorithm ; Position count ; LPS Length Array ; centerPosition ; centerRightPosition ; currentRightPosition ; currentLeftPosition ; Uncomment it to print LPS Length array printf ( \" % d ▁ % d ▁ \" , L [ 0 ] , L [ 1 ] ) ; ; get currentLeftPosition iMirror for currentRightPosition i ; If currentRightPosition i is within centerRightPosition R ; Attempt to expand palindrome centered at currentRightPosition i Here for odd positions , we compare characters and if match then increment LPS Length by ONE If even position , we just increment LPS by ONE without any character comparison ; Track maxLPSLength ; If palindrome centered at currentRightPosition i expand beyond centerRightPosition R , adjust centerPosition C based on expanded palindrome . ; Uncomment it to print LPS Length array printf ( \" % d ▁ \" , L [ i ] ) ; ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "1973-1973",
        "Code": "N = 9 NEW_LINE def printing ( arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def isSafe ( grid , row , col , num ) : NEW_LINE INDENT for x in range ( 9 ) : NEW_LINE INDENT if grid [ row ] [ x ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for x in range ( 9 ) : NEW_LINE INDENT if grid [ x ] [ col ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT startRow = row - row % 3 NEW_LINE startCol = col - col % 3 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if grid [ i + startRow ] [ j + startCol ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def solveSuduko ( grid , row , col ) : NEW_LINE INDENT if ( row == N - 1 and col == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT if col == N : NEW_LINE INDENT row += 1 NEW_LINE col = 0 NEW_LINE DEDENT if grid [ row ] [ col ] > 0 : NEW_LINE INDENT return solveSuduko ( grid , row , col + 1 ) NEW_LINE DEDENT for num in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if isSafe ( grid , row , col , num ) : NEW_LINE INDENT grid [ row ] [ col ] = num NEW_LINE if solveSuduko ( grid , row , col + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT return False NEW_LINE DEDENT grid = [ [ 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 ] , [ 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 ] , [ 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 ] , [ 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 ] , [ 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 ] , [ 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 ] , [ 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 ] ] NEW_LINE if ( solveSuduko ( grid , 0 , 0 ) ) : NEW_LINE INDENT printing ( grid ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no ▁ solution ▁ exists ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sudoku | Backtracking | N is the size of the 2D matrix N * N ; A utility function to print grid ; Checks whether it will be legal to assign num to the given row , col ; Check if we find the same num in the similar row , we return false ; Check if we find the same num in the similar column , we return false ; Check if we find the same num in the particular 3 * 3 matrix , we return false ; Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes ) ; Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking ; Check if column value becomes 9 , we move to next row and column start from 0 ; Check if the current position of the grid already contains value > 0 , we iterate for next column ; Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column ; Assigning the num in the current ( row , col ) position of the grid and assuming our assined num in the position is correct ; Checking for next possibility with next column ; Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value ; Driver Code 0 means unassigned cells",
        "Category": "Backtracking"
    },
    {
        "ID": "198-198",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def findLCA ( root , n1 , n2 ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( root . key == n1 or root . key == n2 ) : NEW_LINE INDENT return root NEW_LINE DEDENT left_lca = findLCA ( root . left , n1 , n2 ) NEW_LINE right_lca = findLCA ( root . right , n1 , n2 ) NEW_LINE if ( left_lca and right_lca ) : NEW_LINE INDENT return root NEW_LINE DEDENT if ( left_lca != None ) : NEW_LINE INDENT return left_lca NEW_LINE DEDENT else : NEW_LINE INDENT return right_lca NEW_LINE DEDENT DEDENT def printAncestors ( root , target ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( root . key == target ) : NEW_LINE INDENT print ( root . key , end = \" ▁ \" ) NEW_LINE return True NEW_LINE DEDENT if ( printAncestors ( root . left , target ) or printAncestors ( root . right , target ) ) : NEW_LINE INDENT print ( root . key , end = \" ▁ \" ) NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT def findCommonNodes ( root , first , second ) : NEW_LINE INDENT LCA = findLCA ( root , first , second ) NEW_LINE if ( LCA == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT printAncestors ( root , LCA . key ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . right . left . left = newNode ( 9 ) NEW_LINE root . right . left . right = newNode ( 10 ) NEW_LINE if ( findCommonNodes ( root , 9 , 7 ) == False ) : NEW_LINE INDENT print ( \" No ▁ Common ▁ nodes \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Print common nodes on path from root ( or common ancestors ) | Utility class to create a new tree Node ; Utility function to find the LCA of two given values n1 and n2 . ; Base case ; If either n1 or n2 matches with root 's key,   report the presence by returning root (Note   that if a key is ancestor of other, then the   ancestor key becomes LCA  ; Look for keys in left and right subtrees ; If both of the above calls return Non - None , then one key is present in once subtree and other is present in other , So this node is the LCA ; Otherwise check if left subtree or right subtree is LCA ; Utility Function to print all ancestors of LCA ; base cases ; If target is present in either left or right subtree of this node , then prthis node ; Else return False ; Function to find nodes common to given two nodes ; Driver Code ; Let us create binary tree given in the above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "1981-1981",
        "Code": "def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] <= ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT ar1 = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE ar2 = [ 2 , 13 , 17 , 30 , 45 ] NEW_LINE n1 = len ( ar1 ) NEW_LINE n2 = len ( ar2 ) NEW_LINE if n1 == n2 : NEW_LINE INDENT print ( \" Median ▁ is ▁ \" , getMedian ( ar1 , ar2 , n1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Median of two sorted arrays of same size | This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements ; Since there are 2 n elements , median will be average of elements at index n - 1 and n in the array obtained after merging ar1 and ar2 ; Below is to handle case where all elements of ar1 [ ] are smaller than smallest ( or first ) element of ar2 [ ] ; Below is to handle case where all elements of ar2 [ ] are smaller than smallest ( or first ) element of ar1 [ ] ; equals sign because if two arrays have some common elements ; Store the prev median ; Store the prev median ; Driver code to test above function",
        "Category": "Binary Search"
    },
    {
        "ID": "1983-1983",
        "Code": "def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i , j = n - 1 , 0 NEW_LINE while ( ar1 [ i ] > ar2 [ j ] and i > - 1 and j < n ) : NEW_LINE INDENT ar1 [ i ] , ar2 [ j ] = ar2 [ j ] , ar1 [ i ] NEW_LINE i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT ar1 . sort ( ) NEW_LINE ar2 . sort ( ) NEW_LINE return ( ar1 [ - 1 ] + ar2 [ 0 ] ) >> 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar1 = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE ar2 = [ 2 , 13 , 17 , 30 , 45 ] NEW_LINE n1 , n2 = len ( ar1 ) , len ( ar2 ) NEW_LINE if ( n1 == n2 ) : NEW_LINE INDENT print ( ' Median ▁ is ' , getMedian ( ar1 , ar2 , n1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Median of two sorted arrays of same size | while loop to swap all smaller numbers to arr1 ; Driver program",
        "Category": "Two Pointers"
    },
    {
        "ID": "1985-1985",
        "Code": "class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def onSegment ( p , q , r ) : NEW_LINE INDENT if ( ( q . x <= max ( p . x , r . x ) ) and ( q . x >= min ( p . x , r . x ) ) and ( q . y <= max ( p . y , r . y ) ) and ( q . y >= min ( p . y , r . y ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def orientation ( p , q , r ) : NEW_LINE INDENT val = ( float ( q . y - p . y ) * ( r . x - q . x ) ) - ( float ( q . x - p . x ) * ( r . y - q . y ) ) NEW_LINE if ( val > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( val < 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def doIntersect ( p1 , q1 , p2 , q2 ) : NEW_LINE INDENT o1 = orientation ( p1 , q1 , p2 ) NEW_LINE o2 = orientation ( p1 , q1 , q2 ) NEW_LINE o3 = orientation ( p2 , q2 , p1 ) NEW_LINE o4 = orientation ( p2 , q2 , q1 ) NEW_LINE if ( ( o1 != o2 ) and ( o3 != o4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( o1 == 0 ) and onSegment ( p1 , p2 , q1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( o2 == 0 ) and onSegment ( p1 , q2 , q1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( o3 == 0 ) and onSegment ( p2 , p1 , q2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( o4 == 0 ) and onSegment ( p2 , q1 , q2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT p1 = Point ( 1 , 1 ) NEW_LINE q1 = Point ( 10 , 1 ) NEW_LINE p2 = Point ( 1 , 2 ) NEW_LINE q2 = Point ( 10 , 2 ) NEW_LINE if doIntersect ( p1 , q1 , p2 , q2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT p1 = Point ( 10 , 0 ) NEW_LINE q1 = Point ( 0 , 10 ) NEW_LINE p2 = Point ( 0 , 0 ) NEW_LINE q2 = Point ( 10 , 10 ) NEW_LINE if doIntersect ( p1 , q1 , p2 , q2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT p1 = Point ( - 5 , - 5 ) NEW_LINE q1 = Point ( 0 , 0 ) NEW_LINE p2 = Point ( 1 , 1 ) NEW_LINE q2 = Point ( 10 , 10 ) NEW_LINE if doIntersect ( p1 , q1 , p2 , q2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to check if two given line segments intersect ? | A Python3 program to find if 2 given line segments intersect or not ; Given three colinear points p , q , r , the function checks if point q lies on line segment ' pr ' ; to find the orientation of an ordered triplet ( p , q , r ) function returns the following values : 0 : Colinear points 1 : Clockwise points 2 : Counterclockwise See https : www . geeksforgeeks . org / orientation - 3 - ordered - points / amp / for details of below formula . ; Counterclockwise orientation ; The main function that returns true if the line segment ' p1q1' and ' p2q2' intersect . ; Find the 4 orientations required for the general and special cases ; General case ; Special Cases p1 , q1 and p2 are colinear and p2 lies on segment p1q1 ; p1 , q1 and q2 are colinear and q2 lies on segment p1q1 ; p2 , q2 and p1 are colinear and p1 lies on segment p2q2 ; p2 , q2 and q1 are colinear and q1 lies on segment p2q2 ; If none of the cases ; Driver program to test above functions :",
        "Category": "Math"
    },
    {
        "ID": "1989-1989",
        "Code": "def area ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) NEW_LINE DEDENT def isInside ( x1 , y1 , x2 , y2 , x3 , y3 , x , y ) : NEW_LINE INDENT A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE A1 = area ( x , y , x2 , y2 , x3 , y3 ) NEW_LINE A2 = area ( x1 , y1 , x , y , x3 , y3 ) NEW_LINE A3 = area ( x1 , y1 , x2 , y2 , x , y ) NEW_LINE if ( A == A1 + A2 + A3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) : NEW_LINE INDENT print ( ' Inside ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Not ▁ Inside ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a given point lies inside a triangle or not | A utility function to calculate area of triangle formed by ( x1 , y1 ) , ( x2 , y2 ) and ( x3 , y3 ) ; A function to check whether point P ( x , y ) lies inside the triangle formed by A ( x1 , y1 ) , B ( x2 , y2 ) and C ( x3 , y3 ) ; Calculate area of triangle ABC ; Calculate area of triangle PBC ; Calculate area of triangle PAC ; Calculate area of triangle PAB ; Check if sum of A1 , A2 and A3 is same as A ; Let us check whether the point P ( 10 , 15 ) lies inside the triangle formed by A ( 0 , 0 ) , B ( 20 , 0 ) and C ( 10 , 30 )",
        "Category": "Math"
    },
    {
        "ID": "2-2",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . left = None NEW_LINE self . right = None NEW_LINE self . val = key NEW_LINE DEDENT DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) ; NEW_LINE root . right = Node ( 3 ) ; NEW_LINE root . left . left = Node ( 4 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Binary Tree | Set 1 ( Introduction ) | Class containing left and right child of current node and key value ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "200-200",
        "Code": "_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxDiffUtil ( t , res ) : NEW_LINE INDENT if ( t == None ) : NEW_LINE INDENT return _MAX , res NEW_LINE DEDENT if ( t . left == None and t . right == None ) : NEW_LINE INDENT return t . key , res NEW_LINE DEDENT a , res = maxDiffUtil ( t . left , res ) NEW_LINE b , res = maxDiffUtil ( t . right , res ) NEW_LINE val = min ( a , b ) NEW_LINE res = max ( res , t . key - val ) NEW_LINE return min ( val , t . key ) , res NEW_LINE DEDENT def maxDiff ( root ) : NEW_LINE INDENT res = _MIN NEW_LINE x , res = maxDiffUtil ( root , res ) NEW_LINE return res NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT inorder ( root . left ) NEW_LINE prf ( \" % d ▁ \" , root . key ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 8 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 6 ) NEW_LINE root . left . right . left = newNode ( 4 ) NEW_LINE root . left . right . right = newNode ( 7 ) NEW_LINE root . right = newNode ( 10 ) NEW_LINE root . right . right = newNode ( 14 ) NEW_LINE root . right . right . left = newNode ( 13 ) NEW_LINE print ( \" Maximum ▁ difference ▁ between ▁ a ▁ node ▁ and \" , \" its ▁ ancestor ▁ is ▁ : \" , maxDiff ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum difference between node and its ancestor in Binary Tree | Python3 program to find maximum difference between node and its ancestor ; Helper function that allocates a new node with the given data and None left and right poers . ; Recursive function to calculate maximum ancestor - node difference in binary tree . It updates value at ' res ' to store the result . The returned value of this function is minimum value in subtree rooted with ' t ' ; Returning Maximum value if node is not there ( one child case ) ; If leaf node then just return node 's value  ; Recursively calling left and right subtree for minimum value ; Updating res if ( node value - minimum value from subtree ) is bigger than res ; Returning minimum value got so far ; This function mainly calls maxDiffUtil ( ) ; Initialising result with minimum value ; Helper function to print inorder traversal of binary tree ; Driver Code ; Let us create Binary Tree shown in above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "201-201",
        "Code": "v1 = False NEW_LINE INDENT v2 = False NEW_LINE DEDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def findLCAUtil ( root : Node , n1 : int , n2 : int ) -> Node : NEW_LINE INDENT global v1 , v2 NEW_LINE if ( root is None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( root . data == n1 ) : NEW_LINE INDENT v1 = True NEW_LINE return root NEW_LINE DEDENT if ( root . data == n2 ) : NEW_LINE INDENT v2 = True NEW_LINE return root NEW_LINE DEDENT left_lca = findLCAUtil ( root . left , n1 , n2 ) NEW_LINE right_lca = findLCAUtil ( root . right , n1 , n2 ) NEW_LINE if ( left_lca and right_lca ) : NEW_LINE INDENT return root NEW_LINE DEDENT return left_lca if ( left_lca != None ) else right_lca NEW_LINE DEDENT def find ( root : Node , k : int ) -> bool : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( root . data == k or find ( root . left , k ) or find ( root . right , k ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def findLCA ( root : Node , n1 : int , n2 : int ) -> Node : NEW_LINE INDENT global v1 , v2 NEW_LINE lca = findLCAUtil ( root , n1 , n2 ) NEW_LINE if ( v1 and v2 or v1 and find ( lca , n2 ) or v2 and find ( lca , n1 ) ) : NEW_LINE INDENT return lca NEW_LINE DEDENT return None NEW_LINE DEDENT def hasPath ( root : Node , arr : list , x : int ) -> Node : NEW_LINE INDENT if ( root is None ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( ) NEW_LINE return False NEW_LINE DEDENT def printCommonPath ( root : Node , n1 : int , n2 : int ) : NEW_LINE INDENT arr = [ ] NEW_LINE lca = findLCA ( root , n1 , n2 ) NEW_LINE if ( lca ) : NEW_LINE INDENT if ( hasPath ( root , arr , lca . data ) ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( arr [ - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" No ▁ Common ▁ Path \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v1 = 0 NEW_LINE v2 = 0 NEW_LINE root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . left . right . left = Node ( 8 ) NEW_LINE root . right . left . right = Node ( 9 ) NEW_LINE n1 = 4 NEW_LINE n2 = 8 NEW_LINE printCommonPath ( root , n1 , n2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print the path common to the two paths from the root to the two given nodes | Initialize n1 and n2 as not visited ; structure of a node of binary tree ; This function returns pointer to LCA of two given values n1 and n2 . v1 is set as True by this function if n1 is found v2 is set as True by this function if n2 is found ; Base case ; If either n1 or n2 matches with root 's data, report the presence  by setting v1 or v2 as True and return root (Note that if a key is ancestor of other, then the ancestor key becomes LCA) ; Look for nodes in left and right subtrees ; If both of the above calls return Non - None , then one node is present in one subtree and other is present in other , So this current node is the LCA ; Otherwise check if left subtree or right subtree is LCA ; Returns True if key k is present in tree rooted with root ; Base Case ; If key k is present at root , or in left subtree or right subtree , return True ; Else return False ; This function returns LCA of n1 and n2 only if both n1 and n2 are present in tree , otherwise returns None ; Find lca of n1 and n2 ; Return LCA only if both n1 and n2 are present in tree ; Else return None ; function returns True if there is a path from root to the given node . It also populates arr ' with the given path ; if root is None there is no path ; push the node ' s ▁ value ▁ in ▁ ' arr ; if it is the required node return True ; else check whether there the required node lies in the left subtree or right subtree of the current node ; required node does not lie either in the left or right subtree of the current node Thus , remove current node ' s ▁ value ▁ from ▁ ' arr '  and then return False; ; function to print the path common to the two paths from the root to the two given nodes if the nodes lie in the binary tree ; vector to store the common path ; LCA of node n1 and n2 ; if LCA of both n1 and n2 exists ; then print the path from root to LCA node ; LCA is not present in the binary tree either n1 or n2 or both are not present ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2018-2018",
        "Code": "def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE while n >= 1 : NEW_LINE INDENT f = f * n NEW_LINE n = n - 1 NEW_LINE DEDENT return f NEW_LINE DEDENT def findSmallerInRight ( st , low , high ) : NEW_LINE INDENT countRight = 0 NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if st [ i ] < st [ low ] : NEW_LINE INDENT countRight = countRight + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return countRight NEW_LINE DEDENT def findRank ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE mul = fact ( ln ) NEW_LINE rank = 1 NEW_LINE i = 0 NEW_LINE while i < ln : NEW_LINE INDENT mul = mul / ( ln - i ) NEW_LINE countRight = findSmallerInRight ( st , i , ln - 1 ) NEW_LINE rank = rank + countRight * mul NEW_LINE i = i + 1 NEW_LINE DEDENT return rank NEW_LINE DEDENT st = \" string \" NEW_LINE print ( findRank ( st ) ) NEW_LINE",
        "Type": "py",
        "NL": "Lexicographic rank of a string | A utility function to find factorial of n ; A utility function to count smaller characters on right of arr [ low ] ; A function to find rank of a string in all permutations of characters ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Driver program to test above function",
        "Category": "Math"
    },
    {
        "ID": "2019-2019",
        "Code": "MAX_CHAR = 256 ; NEW_LINE count = [ 0 ] * ( MAX_CHAR + 1 ) ; NEW_LINE def fact ( n ) : NEW_LINE INDENT return 1 if ( n <= 1 ) else ( n * fact ( n - 1 ) ) ; NEW_LINE DEDENT def populateAndIncreaseCount ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , MAX_CHAR ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] ; NEW_LINE DEDENT DEDENT def updatecount ( ch ) : NEW_LINE INDENT for i in range ( ord ( ch ) , MAX_CHAR ) : NEW_LINE INDENT count [ i ] -= 1 ; NEW_LINE DEDENT DEDENT def findRank ( str ) : NEW_LINE INDENT len1 = len ( str ) ; NEW_LINE mul = fact ( len1 ) ; NEW_LINE rank = 1 ; NEW_LINE populateAndIncreaseCount ( str ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT mul = mul // ( len1 - i ) ; NEW_LINE rank += count [ ord ( str [ i ] ) - 1 ] * mul ; NEW_LINE updatecount ( str [ i ] ) ; NEW_LINE DEDENT return rank ; NEW_LINE DEDENT str = \" string \" ; NEW_LINE print ( findRank ( str ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Lexicographic rank of a string | A O ( n ) solution for finding rank of string ; all elements of count [ ] are initialized with 0 ; A utility function to find factorial of n ; Construct a count array where value at every index contains count of smaller characters in whole string ; Removes a character ch from count [ ] array constructed by populateAndIncreaseCount ( ) ; A function to find rank of a string in all permutations of characters ; Populate the count array such that count [ i ] contains count of characters which are present in str and are smaller than i ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Reduce count of characters greater than str [ i ] ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2033-2033",
        "Code": "import random NEW_LINE def findCeil ( arr , r , l , h ) : NEW_LINE INDENT while ( l < h ) : NEW_LINE INDENT mid = l + ( ( h - l ) >> 1 ) ; NEW_LINE if r > arr [ mid ] : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT if arr [ l ] >= r : NEW_LINE INDENT return l NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT def myRand ( arr , freq , n ) : NEW_LINE INDENT prefix = [ 0 ] * n NEW_LINE prefix [ 0 ] = freq [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + freq [ i ] NEW_LINE DEDENT r = random . randint ( 0 , prefix [ n - 1 ] ) + 1 NEW_LINE indexc = findCeil ( prefix , r , 0 , n - 1 ) NEW_LINE return arr [ indexc ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE freq = [ 10 , 5 , 20 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( myRand ( arr , freq , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Random number generator in arbitrary probability distribution fashion | Python3 program to generate random numbers according to given frequency distribution ; Utility function to find ceiling of r in arr [ l . . h ] ; Same as mid = ( l + h ) / 2 ; The main function that returns a random number from arr [ ] according to distribution array defined by freq [ ] . n is size of arrays . ; Create and fill prefix array ; prefix [ n - 1 ] is sum of all frequencies . Generate a random number with value from 1 to this sum ; Find index of ceiling of r in prefix arrat ; Driver code ; Let us generate 10 random numbers accroding to given distribution",
        "Category": "Binary Search"
    },
    {
        "ID": "2034-2034",
        "Code": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return s * s == x NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT if ( isFibonacci ( i ) == True ) : NEW_LINE INDENT print i , \" is ▁ a ▁ Fibonacci ▁ Number \" NEW_LINE DEDENT else : NEW_LINE INDENT print i , \" is ▁ a ▁ not ▁ Fibonacci ▁ Number ▁ \" NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "How to check if a given number is Fibonacci number ? | python program to check if x is a perfect square ; A utility function that returns true if x is perfect square ; Returns true if n is a Fibinacci Number , else false ; n is Fibinacci if one of 5 * n * n + 4 or 5 * n * n - 4 or both is a perferct square ; A utility function to test above functions",
        "Category": "Math"
    },
    {
        "ID": "2038-2038",
        "Code": "def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print catalan ( i ) , NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program for nth Catalan Number | A recursive function to find nth catalan number ; Base Case ; Catalan ( n ) is the sum of catalan ( i ) * catalan ( n - i - 1 ) ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "2041-2041",
        "Code": "def catalan ( n ) : NEW_LINE INDENT cat_ = 1 NEW_LINE print ( cat_ , \" ▁ \" , end = ' ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cat_ *= ( 4 * i - 2 ) ; NEW_LINE cat_ //= ( i + 1 ) ; NEW_LINE print ( cat_ , \" ▁ \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE catalan ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Program for nth Catalan Number | Function to print the number ; For the first number C ( 0 ) ; Iterate till N ; Calculate the number and print it ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "2044-2044",
        "Code": "MAX = 50 NEW_LINE def printString ( n ) : NEW_LINE INDENT string = [ \" \\0\" ] * MAX NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 26 NEW_LINE if rem == 0 : NEW_LINE INDENT string [ i ] = ' Z ' NEW_LINE i += 1 NEW_LINE n = ( n / 26 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT string [ i ] = chr ( ( rem - 1 ) + ord ( ' A ' ) ) NEW_LINE i += 1 NEW_LINE n = n / 26 NEW_LINE DEDENT DEDENT string [ i ] = ' \\0' NEW_LINE string = string [ : : - 1 ] NEW_LINE print \" \" . join ( string ) NEW_LINE DEDENT printString ( 26 ) NEW_LINE printString ( 51 ) NEW_LINE printString ( 52 ) NEW_LINE printString ( 80 ) NEW_LINE printString ( 676 ) NEW_LINE printString ( 702 ) NEW_LINE printString ( 705 ) NEW_LINE",
        "Type": "py",
        "NL": "Find Excel column name from a given column number | Python program to find Excel column name from a given column number ; Function to print Excel column name for a given column number ; To store current index in str which is result ; Find remainder ; if remainder is 0 , then a ' Z ' must be there in output ; If remainder is non - zero ; Reverse the string and print result ; Driver program to test the above Function",
        "Category": "Math"
    },
    {
        "ID": "205-205",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def kthAncestorDFS ( root , node , k ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( root . data == node or ( kthAncestorDFS ( root . left , node , k ) ) or ( kthAncestorDFS ( root . right , node , k ) ) ) : NEW_LINE INDENT if ( k [ 0 ] > 0 ) : NEW_LINE INDENT k [ 0 ] -= 1 NEW_LINE DEDENT elif ( k [ 0 ] == 0 ) : NEW_LINE INDENT print ( \" Kth ▁ ancestor ▁ is : \" , root . data ) NEW_LINE return None NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE k = [ 2 ] NEW_LINE node = 5 NEW_LINE parent = kthAncestorDFS ( root , node , k ) NEW_LINE if ( parent ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Kth ancestor of a node in binary tree | Set 2 | A Binary Tree Node ; recursive function to calculate Kth ancestor ; Base case ; print the kth ancestor ; return None to stop further backtracking ; return current node to previous call ; Driver Code ; prkth ancestor of given node ; check if parent is not None , it means there is no Kth ancestor of the node",
        "Category": "Binary Tree"
    },
    {
        "ID": "2052-2052",
        "Code": "import math NEW_LINE def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) ; NEW_LINE DEDENT print ( find ( 0.70 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Birthday Paradox | Python3 code to approximate number of people in Birthday Paradox problem ; Returns approximate number of people for a given probability ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2063-2063",
        "Code": "MAX_ITER = 1000000 NEW_LINE def func ( x ) : NEW_LINE INDENT return ( x * x * x - x * x + 2 ) NEW_LINE DEDENT def regulaFalsi ( a , b ) : NEW_LINE INDENT if func ( a ) * func ( b ) >= 0 : NEW_LINE INDENT print ( \" You ▁ have ▁ not ▁ assumed ▁ right ▁ a ▁ and ▁ b \" ) NEW_LINE return - 1 NEW_LINE DEDENT c = a NEW_LINE for i in range ( MAX_ITER ) : NEW_LINE INDENT c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) NEW_LINE if func ( c ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif func ( c ) * func ( a ) < 0 : NEW_LINE INDENT b = c NEW_LINE DEDENT else : NEW_LINE INDENT a = c NEW_LINE DEDENT DEDENT print ( \" The ▁ value ▁ of ▁ root ▁ is ▁ : ▁ \" , ' % .4f ' % c ) NEW_LINE DEDENT a = - 200 NEW_LINE b = 300 NEW_LINE regulaFalsi ( a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Method Of False Position | Python3 implementation of Bisection Method for solving equations ; An example function whose solution is determined using Bisection Method . The function is x ^ 3 - x ^ 2 + 2 ; Prints root of func ( x ) in interval [ a , b ] ; Initialize result ; Find the point that touches x axis ; Check if the above found point is root ; Decide the side to repeat the steps ; Initial values assumed",
        "Category": "Math"
    },
    {
        "ID": "2064-2064",
        "Code": "def func ( x ) : NEW_LINE INDENT return x * x * x - x * x + 2 NEW_LINE DEDENT def derivFunc ( x ) : NEW_LINE INDENT return 3 * x * x - 2 * x NEW_LINE DEDENT def newtonRaphson ( x ) : NEW_LINE INDENT h = func ( x ) / derivFunc ( x ) NEW_LINE while abs ( h ) >= 0.0001 : NEW_LINE INDENT h = func ( x ) / derivFunc ( x ) NEW_LINE x = x - h NEW_LINE DEDENT print ( \" The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ : ▁ \" , \" % .4f \" % x ) NEW_LINE DEDENT x0 = - 20 NEW_LINE newtonRaphson ( x0 ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Newton Raphson Method | An example function whose solution is determined using Bisection Method . The function is x ^ 3 - x ^ 2 + 2 ; Derivative of the above function which is 3 * x ^ x - 2 * x ; Function to find the root ; x ( i + 1 ) = x ( i ) - f ( x ) / f '(x) ; Initial values assumed",
        "Category": "Math"
    },
    {
        "ID": "2065-2065",
        "Code": "def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ \" , getSingle ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the element that appears once | Method to find the element that occur only once ; one & arr [ i ] \" gives the bits that  are there in both 'ones' and new  element from arr[]. We add these  bits to 'twos' using bitwise OR ; one & arr [ i ] \" gives the bits that  are there in both 'ones' and new  element from arr[]. We add these  bits to 'twos' using bitwise OR ; The common bits are those bits which appear third time . So these bits should not be there in both ' ones ' and ' twos ' . common_bit_mask contains all these bits as 0 , so that the bits can be removed from ' ones ' and 'twos   ; Remove common bits ( the bits that appear third time ) from 'ones   ; Remove common bits ( the bits that appear third time ) from 'twos   ; driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2066-2066",
        "Code": "INT_SIZE = 32 NEW_LINE def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( ( sm % 3 ) != 0 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ \" , getSingle ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the element that appears once | Python3 code to find the element that occur only once ; Initialize result ; Iterate through every bit ; Find sum of set bits at ith position in all array elements ; The bits with sum not multiple of 3 , are the bits of element with single occurrence . ; Driver program",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2069-2069",
        "Code": "def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) ; NEW_LINE DEDENT x = 100 NEW_LINE y = 1 NEW_LINE if ( oppositeSigns ( x , y ) == True ) : NEW_LINE INDENT print \" Signs ▁ are ▁ opposite \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Signs ▁ are ▁ not ▁ opposite \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Detect if two integers have opposite signs | Function to detect signs ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2072-2072",
        "Code": "def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if int ( x % 2 ) == 0 else 1 ) + countSetBitsUtil ( int ( x / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( \" Total ▁ set ▁ bit ▁ count ▁ is \" , countSetBits ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count total set bits in all numbers from 1 to n | Returns count of set bits present in all numbers from 1 to n ; initialize the result ; A utility function to count set bits in a number x ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "2073-2073",
        "Code": "def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count total set bits in all numbers from 1 to n | Function which counts set bits from 0 to n ; ans store sum of set bits from 0 to n ; while n greater than equal to 2 ^ i ; This k will get flipped after 2 ^ i iterations ; change is iterator from 2 ^ i to 1 ; This will loop from 0 to n for every bit position ; When change = 1 flip the bit ; again set change to 2 ^ i ; increment the position ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2074-2074",
        "Code": "def getLeftmostBit ( n ) : NEW_LINE INDENT m = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE m += 1 NEW_LINE DEDENT return m NEW_LINE DEDENT def getNextLeftmostBit ( n , m ) : NEW_LINE INDENT temp = 1 << m NEW_LINE while ( n < temp ) : NEW_LINE INDENT temp = temp >> 1 NEW_LINE m -= 1 NEW_LINE DEDENT return m NEW_LINE DEDENT def countSetBits ( n ) : NEW_LINE INDENT m = getLeftmostBit ( n ) NEW_LINE return _countSetBits ( n , m ) NEW_LINE DEDENT def _countSetBits ( n , m ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = getNextLeftmostBit ( n , m ) NEW_LINE if ( n == ( 1 << ( m + 1 ) ) - 1 ) : NEW_LINE INDENT return ( ( m + 1 ) * ( 1 << m ) ) NEW_LINE DEDENT n = n - ( 1 << m ) NEW_LINE return ( n + 1 ) + countSetBits ( n ) + m * ( 1 << ( m - 1 ) ) NEW_LINE DEDENT n = 17 NEW_LINE print ( \" Total ▁ set ▁ bit ▁ count ▁ is \" , countSetBits ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count total set bits in all numbers from 1 to n | Returns position of leftmost set bit . The rightmost position is considered as 0 ; Given the position of previous leftmost set bit in n ( or an upper bound onleftmost position ) returns the new position of leftmost set bit in n ; The main recursive function used by countSetBits ( ) def _countSetBits ( n , m ) Returns count of set bits present in all numbers from 1 to n ; Get the position of leftmost set bit in n . This will be used as an upper bound for next set bit function ; Use the position ; Base Case : if n is 0 , then set bit count is 0 ; get position of next leftmost set bit ; If n is of the form 2 ^ x - 1 , i . e . , if n is like 1 , 3 , 7 , 15 , 31 , . . etc , then we are done . Since positions are considered starting from 0 , 1 is added to m ; update n for next recursive call ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2075-2075",
        "Code": "def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two = 2 NEW_LINE ans = 0 NEW_LINE n = N NEW_LINE while ( n != 0 ) : NEW_LINE INDENT ans += int ( N / two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return ans NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count total set bits in all numbers from 1 to n |",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2076-2076",
        "Code": "def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT res = swapBits ( 28 , 0 , 3 , 2 ) NEW_LINE print ( \" Result ▁ = \" , res ) NEW_LINE",
        "Type": "py",
        "NL": "Swap bits in a given number | Python program to swap bits in a given number ; Move all bits of first set to rightmost side ; Moce all bits of second set to rightmost side ; XOR the two sets ; Put the xor bits back to their original positions ; XOR the ' xor ' with the original number so that the two sets are swapped ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2078-2078",
        "Code": "def swapBits ( num , p1 , p2 , n ) : NEW_LINE INDENT shift1 = 0 NEW_LINE shift2 = 0 NEW_LINE value1 = 0 NEW_LINE value2 = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT shift1 = 1 << p1 NEW_LINE shift2 = 1 << p2 NEW_LINE value1 = ( ( num & shift1 ) ) NEW_LINE value2 = ( ( num & shift2 ) ) NEW_LINE if ( ( value1 == 0 and value2 != 0 ) or ( value2 == 0 and value1 != 0 ) ) : NEW_LINE INDENT if ( value1 != 0 ) : NEW_LINE INDENT num = num & ( ~ shift1 ) NEW_LINE num = num | shift2 NEW_LINE DEDENT else : NEW_LINE INDENT num = num & ( ~ shift2 ) NEW_LINE num = num | shift1 NEW_LINE DEDENT DEDENT p1 += 1 NEW_LINE p2 += 1 NEW_LINE n -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT res = swapBits ( 28 , 0 , 3 , 2 ) NEW_LINE print ( \" Result ▁ = \" , res ) NEW_LINE",
        "Type": "py",
        "NL": "Swap bits in a given number |  ; Setting bit at p1 position to 1 ; Setting bit at p2 position to 1 ; value1 and value2 will have 0 if num at the respective positions - p1 and p2 is 0. ; check if value1 and value2 are different i . e . at one position bit is set and other it is not ; if bit at p1 position is set ; unset bit at p1 position ; set bit at p2 position ; if bit at p2 position is set ; set bit at p2 position ; unset bit at p2 position ; return final result ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2081-2081",
        "Code": "def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is \" , smallest ( x , y , z ) ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest of three integers without comparison operators | Python3 program to find Smallest of three integers without comparison operators ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2083-2083",
        "Code": "def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y / x ) ) : NEW_LINE INDENT return y if ( not ( y / z ) ) else z NEW_LINE DEDENT return x if ( not ( x / z ) ) else z NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 78 NEW_LINE y = 88 NEW_LINE z = 68 NEW_LINE print ( \" Minimum ▁ of ▁ 3 ▁ numbers ▁ is \" , smallest ( x , y , z ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest of three integers without comparison operators | Using division operator to find minimum of three numbers ; Same as \" if ▁ ( y ▁ < ▁ x ) \" ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2084-2084",
        "Code": "def changeToZero ( a ) : NEW_LINE INDENT a [ a [ 1 ] ] = a [ not a [ 1 ] ] NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 0 ] NEW_LINE a = changeToZero ( a ) ; NEW_LINE print ( \" ▁ arr [ 0 ] ▁ = ▁ \" + str ( a [ 0 ] ) ) NEW_LINE print ( \" ▁ arr [ 1 ] ▁ = ▁ \" + str ( a [ 1 ] ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "A Boolean Array Puzzle |  ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "2089-2089",
        "Code": "def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( \" Next ▁ higher ▁ number ▁ with ▁ \" + \" same ▁ number ▁ of ▁ set ▁ bits ▁ is \" , snoob ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Next higher number with same number of set bits | This function returns next higher number with same number of set bits as x . ; right most set bit ; reset the pattern and set next higher bit left part of x will be here ; nextHigherOneBit is now part [ D ] of the above explanation . isolate the pattern ; right adjust pattern ; correction factor ; rightOnesPattern is now part [ A ] of the above explanation . integrate new pattern ( Add [ D ] and [ A ] ) ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2091-2091",
        "Code": "def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) ; NEW_LINE DEDENT print ( addOne ( 13 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Add 1 to a given number | Python3 code to add 1 to a given number ; Driver program",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2092-2092",
        "Code": "def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Multiply a given Integer with 3.5 | Python 3 program to multiply a number with 3.5 ; Driver program to test above functions",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2095-2095",
        "Code": "def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( \" The ▁ number ▁ after ▁ unsetting ▁ the ▁ rightmost ▁ set ▁ bit \" , fun ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Turn off the rightmost set bit | unsets the rightmost set bit of n and returns the result ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2099-2099",
        "Code": "import math NEW_LINE def logn ( n , r ) : NEW_LINE INDENT return math . log ( n ) / math . log ( r ) NEW_LINE DEDENT def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( math . floor ( logn ( n , 4 ) ) == math . ceil ( logn ( n , 4 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( test_no ) ) : NEW_LINE INDENT print ( test_no , \" ▁ is ▁ a ▁ power ▁ of ▁ 4\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , \" ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4\" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find whether a given number is a power of 4 or not | Python3 program to check if given number is power of 4 or not ; 0 is not considered as a power of 4 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2103-2103",
        "Code": "def min ( x , y ) : NEW_LINE INDENT return y ^ ( ( x ^ y ) & - ( x < y ) ) NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x ^ ( ( x ^ y ) & - ( x < y ) ) NEW_LINE DEDENT x = 15 NEW_LINE y = 6 NEW_LINE print ( \" Minimum ▁ of \" , x , \" and \" , y , \" is \" , end = \" ▁ \" ) NEW_LINE print ( min ( x , y ) ) NEW_LINE print ( \" Maximum ▁ of \" , x , \" and \" , y , \" is \" , end = \" ▁ \" ) NEW_LINE print ( max ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Compute the minimum or maximum of two integers without branching | Function to find minimum of x and y ; Function to find maximum of x and y ; Driver program to test above functions",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2104-2104",
        "Code": "import sys ; NEW_LINE CHAR_BIT = 8 ; NEW_LINE INT_BIT = sys . getsizeof ( int ( ) ) ; NEW_LINE def Min ( x , y ) : NEW_LINE INDENT return y + ( ( x - y ) & ( ( x - y ) >> ( INT_BIT * CHAR_BIT - 1 ) ) ) ; NEW_LINE DEDENT def Max ( x , y ) : NEW_LINE INDENT return x - ( ( x - y ) & ( ( x - y ) >> ( INT_BIT * CHAR_BIT - 1 ) ) ) ; NEW_LINE DEDENT x = 15 ; NEW_LINE y = 6 ; NEW_LINE print ( \" Minimum ▁ of \" , x , \" and \" , y , \" is \" , Min ( x , y ) ) ; NEW_LINE print ( \" Maximum ▁ of \" , x , \" and \" , y , \" is \" , Max ( x , y ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Compute the minimum or maximum of two integers without branching | Python3 implementation of the approach ; Function to find minimum of x and y ; Function to find maximum of x and y ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2105-2105",
        "Code": "def absbit32 ( x , y ) : NEW_LINE INDENT sub = x - y NEW_LINE mask = ( sub >> 31 ) NEW_LINE return ( sub ^ mask ) - mask NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT abs = absbit32 ( x , y ) NEW_LINE return ( x + y + abs ) // 2 NEW_LINE DEDENT def min ( x , y ) : NEW_LINE INDENT abs = absbit32 ( x , y ) NEW_LINE return ( x + y - abs ) // 2 NEW_LINE DEDENT print ( max ( 2 , 3 ) ) NEW_LINE print ( max ( 2 , - 3 ) ) NEW_LINE print ( max ( - 2 , - 3 ) ) NEW_LINE print ( min ( 2 , 3 ) ) NEW_LINE print ( min ( 2 , - 3 ) ) NEW_LINE print ( min ( - 2 , - 3 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Compute the minimum or maximum of two integers without branching | absbit32 function ; max function ; min function ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2136-2136",
        "Code": "INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Position of rightmost set bit | Python 3 implementation of above approach ; counting the position of first set bit ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2138-2138",
        "Code": "def bin ( n ) : NEW_LINE INDENT i = 1 << 31 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( ( n & i ) != 0 ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT i = i // 2 NEW_LINE DEDENT DEDENT bin ( 7 ) NEW_LINE print ( ) NEW_LINE bin ( 4 ) NEW_LINE",
        "Type": "py",
        "NL": "Binary representation of a given number | bin function ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2142-2142",
        "Code": "def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT x = 23 NEW_LINE print ( swapBits ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Swap all odd and even bits | Function for swapping even and odd bits ; Get all even bits of x ; Get all odd bits of x ; Right shift even bits ; Left shift odd bits ; Combine even and odd bits ; 00010111 ; Output is 43 ( 00101011 )",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "216-216",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def sizeoftree ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE count = 1 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT root = q . pop ( 0 ) NEW_LINE if ( root . left ) : NEW_LINE INDENT count += 1 NEW_LINE q . append ( root . left ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT count += 1 NEW_LINE q . append ( root . right ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE print ( sizeoftree ( root ) ) NEW_LINE",
        "Type": "py",
        "NL": "Iterative program to Calculate Size of a tree | Node Structure ; Return size of tree ; if tree is empty it will return 0 ; Using level order Traversal . ; when the queue is empty : the pop ( ) method returns null . ; Increment count ; Enqueue left child ; Increment count ; Enqueue right child ; creating a binary tree and entering the nodes",
        "Category": "Binary Tree"
    },
    {
        "ID": "2160-2160",
        "Code": "def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ \" , maxOnesIndex ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1 s in a binary array | Returns index of 0 to be replaced with 1 to get longest continuous sequence of 1 s . If there is no 0 in array , then it returns - 1. ; for maximum number of 1 around a zero ; for storing result ; index of previous zero ; index of previous to previous zero ; Traverse the input array ; If current element is 0 , then calculate the difference between curr and prev_prev_zero ; Update result if count of 1 s around prev_zero is more ; Update for next iteration ; Check for the last encountered zero ; Driver program",
        "Category": "Sliding Window"
    },
    {
        "ID": "2163-2163",
        "Code": "def min ( x , y ) : NEW_LINE INDENT return x if ( x < y ) else y NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ \" , findLength ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of the largest subarray with contiguous elements | Set 1 | Utility functions to find minimum and maximum of two elements ; Returns length of the longest contiguous subarray ; Initialize result ; Initialize min and max for all subarrays starting with i ; Consider all subarrays starting with i and ending with j ; Update min and max in this subarray if needed ; If current subarray has all contiguous elements ; Return result ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "2165-2165",
        "Code": "def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if string1 [ m - 1 ] == string2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT string1 = \" gksrek \" NEW_LINE string2 = \" geeksforgeeks \" NEW_LINE if isSubSequence ( string1 , string2 , len ( string1 ) , len ( string2 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Given two strings , find if first string is a subsequence of second | Returns true if str1 [ ] is a subsequence of str2 [ ] . ; Base Cases ; If last characters of two strings are matching ; If last characters are not matching ; Driver program to test the above function",
        "Category": "Substring"
    },
    {
        "ID": "2176-2176",
        "Code": "def maxCircularSum ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT curr_max = a [ 0 ] NEW_LINE max_so_far = a [ 0 ] NEW_LINE curr_min = a [ 0 ] NEW_LINE min_so_far = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_max = max ( curr_max + a [ i ] , a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE curr_min = min ( curr_min + a [ i ] , a [ i ] ) NEW_LINE min_so_far = min ( min_so_far , curr_min ) NEW_LINE DEDENT if ( min_so_far == sum ) : NEW_LINE INDENT return max_so_far NEW_LINE DEDENT return max ( max_so_far , sum - min_so_far ) NEW_LINE DEDENT a = [ 11 , 10 , - 20 , 5 , - 3 , - 5 , 8 , - 13 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( \" Maximum ▁ circular ▁ sum ▁ is \" , maxCircularSum ( a , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum circular subarray sum | The function returns maximum circular contiguous sum in a [ ] ; Corner Case ; Initialize sum variable which store total sum of the array . ; Initialize every variable with first value of array . ; Concept of Kadane 's Algorithm ; Kadane 's Algorithm to find Maximum subarray sum. ; Kadane 's Algorithm to find Minimum subarray sum. ; returning the maximum value ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "2184-2184",
        "Code": "def updateindex ( index , a , ai , b , bi ) : NEW_LINE INDENT index [ a ] = ai NEW_LINE index [ b ] = bi NEW_LINE DEDENT def minSwapsUtil ( arr , pairs , index , i , n ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) : NEW_LINE INDENT return minSwapsUtil ( arr , pairs , index , i + 2 , n ) NEW_LINE DEDENT one = arr [ i + 1 ] NEW_LINE indextwo = i + 1 NEW_LINE indexone = index [ pairs [ arr [ i ] ] ] NEW_LINE two = arr [ index [ pairs [ arr [ i ] ] ] ] NEW_LINE arr [ i + 1 ] , arr [ indexone ] = arr [ indexone ] , arr [ i + 1 ] NEW_LINE updateindex ( index , one , indexone , two , indextwo ) NEW_LINE a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) NEW_LINE arr [ i + 1 ] , arr [ indexone ] = arr [ indexone ] , arr [ i + 1 ] NEW_LINE updateindex ( index , one , indextwo , two , indexone ) NEW_LINE one = arr [ i ] NEW_LINE indexone = index [ pairs [ arr [ i + 1 ] ] ] NEW_LINE two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] NEW_LINE indextwo = i NEW_LINE arr [ i ] , arr [ indexone ] = arr [ indexone ] , arr [ i ] NEW_LINE updateindex ( index , one , indexone , two , indextwo ) NEW_LINE b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) NEW_LINE arr [ i ] , arr [ indexone ] = arr [ indexone ] , arr [ i ] NEW_LINE updateindex ( index , one , indextwo , two , indexone ) NEW_LINE return 1 + min ( a , b ) NEW_LINE DEDENT def minSwaps ( n , pairs , arr ) : NEW_LINE INDENT index = [ ] NEW_LINE for i in range ( 2 * n + 1 + 1 ) : NEW_LINE INDENT index . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT index [ arr [ i ] ] = i NEW_LINE DEDENT return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) NEW_LINE DEDENT arr = [ 0 , 3 , 5 , 6 , 4 , 1 , 2 ] NEW_LINE pairs = [ 0 , 3 , 6 , 1 , 5 , 4 , 2 ] NEW_LINE m = len ( pairs ) NEW_LINE n = m // 2 NEW_LINE print ( \" Min ▁ swaps ▁ required ▁ is ▁ \" , minSwaps ( n , pairs , arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of swaps required for arranging pairs adjacent to each other | This function updates indexes of elements ' a ' and 'b   ; This function returns minimum number of swaps required to arrange all elements of arr [ i . . n ] become arranged ; If all pairs procesed so no swapping needed return 0 ; If current pair is valid so DO NOT DISTURB this pair and move ahead . ; Swap pair of arr [ i ] with arr [ i + 1 ] and recursively compute minimum swap required if this move is made . ; Backtrack to previous configuration . Also restore the previous indices , of one and two ; Now swap arr [ i ] with pair of arr [ i + 1 ] and recursively compute minimum swaps required for the subproblem after this move ; Backtrack to previous configuration . Also restore 3 the previous indices , of one and two ; Return minimum of two cases ; Returns minimum swaps required ; To store indices of array elements ; Store index of each element in array index ; Call the recursive function ; For simplicity , it is assumed that arr [ 0 ] is not used . The elements from index 1 to n are only valid elements ; if ( a , b ) is pair than we have assigned elements in array such that pairs [ a ] = b and pairs [ b ] = a ; Number of pairs n is half of total elements ; If there are n elements in array , then there are n pairs",
        "Category": "Backtracking"
    },
    {
        "ID": "2192-2192",
        "Code": "def maxDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE maxRight = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxRight ) : NEW_LINE INDENT maxRight = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = maxRight - arr [ i ] NEW_LINE if ( diff > maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE DEDENT DEDENT DEDENT return maxDiff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 90 , 10 , 110 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum ▁ difference ▁ is \" , maxDiff ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum difference between two elements such that larger element appears after the smaller number | The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order and returns 0 if elements are equal ; Initialize Result ; Initialize max element from right side ; Driver Code ; Function calling",
        "Category": "Array"
    },
    {
        "ID": "2199-2199",
        "Code": "def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ maximum ▁ element ▁ is ▁ % d \" % findMaximum ( arr , 0 , n - 1 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the maximum element in an array which is first increasing and then decreasing | Python3 program to find maximum element ; Driver program to check above functions",
        "Category": "Array"
    },
    {
        "ID": "22-22",
        "Code": "def getPostOrderBST ( pre , N ) : NEW_LINE INDENT pivotPoint = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( pre [ 0 ] <= pre [ i ] ) : NEW_LINE INDENT pivotPoint = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( pivotPoint - 1 , 0 , - 1 ) : NEW_LINE INDENT print ( pre [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT for i in range ( N - 1 , pivotPoint - 1 , - 1 ) : NEW_LINE INDENT print ( pre [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( pre [ 0 ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find postorder traversal of BST from preorder traversal | Run loop from 1 to length of pre ; Prfrom pivot length - 1 to zero ; Prfrom end to pivot length ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2206-2206",
        "Code": "def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < size and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE return findMissingPositive ( arr [ shift : ] , size - shift ) NEW_LINE DEDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( \" The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ \" , missing ) NEW_LINE",
        "Type": "py",
        "NL": "Find the smallest positive number missing from an unsorted array | Set 1 | Utility function that puts all non - positive ( 0 and negative ) numbers on left side of arr [ ] and return count of such numbers ; increment count of non - positive integers ; Find the smallest positive missing number in an array that contains all positive integers ; Mark arr [ i ] as visited by making arr [ arr [ i ] - 1 ] negative . Note that 1 is subtracted because index start from 0 and positive numbers start from 1 ; Return the first index value at which is positive ; 1 is added because indexes start from 0 ; Find the smallest positive missing number in an array that contains both positive and negative integers ; First separate positive and negative numbers ; Shift the array and call findMissingPositive for positive part ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "2218-2218",
        "Code": "d = 256 NEW_LINE q = 103 NEW_LINE def checkPalindromes ( string ) : NEW_LINE INDENT N = len ( string ) NEW_LINE print string [ 0 ] + \" ▁ Yes \" NEW_LINE if N == 1 : NEW_LINE INDENT return NEW_LINE DEDENT firstr = ord ( string [ 0 ] ) % q NEW_LINE second = ord ( string [ 1 ] ) % q NEW_LINE h = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for i in xrange ( 1 , N ) : NEW_LINE INDENT if firstr == second : NEW_LINE INDENT for j in xrange ( 0 , i / 2 ) : NEW_LINE INDENT if string [ j ] != string [ i - j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j += 1 NEW_LINE if j == i / 2 : NEW_LINE INDENT print string [ i ] + \" ▁ Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print string [ i ] + \" ▁ No \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print string [ i ] + \" ▁ No \" NEW_LINE DEDENT if i != N - 1 : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT h = ( h * d ) % q NEW_LINE firstr = ( firstr + h * ord ( string [ i / 2 ] ) ) % q NEW_LINE second = ( second * d + ord ( string [ i + 1 ] ) ) % q NEW_LINE DEDENT else : NEW_LINE INDENT second = ( d * ( second + q - ord ( string [ ( i + 1 ) / 2 ] ) * h ) % q + ord ( string [ i + 1 ] ) ) % q NEW_LINE DEDENT DEDENT DEDENT DEDENT txt = \" aabaacaabaa \" NEW_LINE checkPalindromes ( txt ) NEW_LINE",
        "Type": "py",
        "NL": "Online algorithm for checking palindrome in a stream | d is the number of characters in input alphabet ; q is a prime number used for evaluating Rabin Karp 's Rolling hash ; Length of input string ; A single character is always a palindrome ; Return if string has only one character ; Initialize first half reverse and second half for as firstr and second characters ; Now check for palindromes from second character onward ; If the hash values of ' firstr ' and ' second ' match , then only check individual characters ; Check if str [ 0. . i ] is palindrome using simple character by character match ; Calculate hash values for next iteration . Don 't calculate hash for next characters if  this is the last character of string ; If i is even ( next i is odd ) ; Add next character after first half at beginning of 'firstr   ; Add next character after second half at the end of second half . ; If next i is odd ( next i is even ) then we need not to change firstr , we need to remove first character of second and append a character to it . ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "2220-2220",
        "Code": "def findZeroes ( arr , n , m ) : NEW_LINE INDENT wL = wR = 0 NEW_LINE bestL = bestWindow = 0 NEW_LINE zeroCount = 0 NEW_LINE while wR < n : NEW_LINE INDENT if zeroCount <= m : NEW_LINE INDENT if arr [ wR ] == 0 : NEW_LINE INDENT zeroCount += 1 NEW_LINE DEDENT wR += 1 NEW_LINE DEDENT if zeroCount > m : NEW_LINE INDENT if arr [ wL ] == 0 : NEW_LINE INDENT zeroCount -= 1 NEW_LINE DEDENT wL += 1 NEW_LINE DEDENT if ( wR - wL > bestWindow ) and ( zeroCount <= m ) : NEW_LINE INDENT bestWindow = wR - wL NEW_LINE bestL = wL NEW_LINE DEDENT DEDENT for i in range ( 0 , bestWindow ) : NEW_LINE INDENT if arr [ bestL + i ] == 0 : NEW_LINE INDENT print ( bestL + i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE m = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are \" , end = \" ▁ \" ) NEW_LINE findZeroes ( arr , n , m ) NEW_LINE",
        "Type": "py",
        "NL": "Find zeroes to be flipped so that number of consecutive 1 's is maximized | m is maximum of number zeroes allowed to flip , n is size of array ; Left and right indexes of current window ; Left index and size of the widest window ; Count of zeroes in current window ; While right boundary of current window doesn 't cross right end ; If zero count of current window is less than m , widen the window toward right ; If zero count of current window is more than m , reduce the window from left ; Updqate widest window if this window size is more ; Print positions of zeroes in the widest window ; Driver program",
        "Category": "Sliding Window"
    },
    {
        "ID": "2227-2227",
        "Code": "def preprocess ( arr , N , left , right ) : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE lastIncr = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT lastIncr = i NEW_LINE DEDENT left [ i ] = lastIncr NEW_LINE DEDENT right [ N - 1 ] = N - 1 NEW_LINE firstDecr = N - 1 NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT firstDecr = i NEW_LINE DEDENT right [ i ] = firstDecr NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT def isSubarrayMountainForm ( arr , left , right , L , R ) : NEW_LINE INDENT return ( right [ L ] >= left [ R ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 2 , 4 , 4 , 6 , 3 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE left = [ 0 for i in range ( N ) ] NEW_LINE right = [ 0 for i in range ( N ) ] NEW_LINE preprocess ( arr , N , left , right ) NEW_LINE L = 0 NEW_LINE R = 2 NEW_LINE if ( isSubarrayMountainForm ( arr , left , right , L , R ) ) : NEW_LINE INDENT print ( \" Subarray ▁ is ▁ in ▁ mountain ▁ form \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Subarray ▁ is ▁ not ▁ in ▁ mountain ▁ form \" ) NEW_LINE DEDENT L = 1 NEW_LINE R = 3 NEW_LINE if ( isSubarrayMountainForm ( arr , left , right , L , R ) ) : NEW_LINE INDENT print ( \" Subarray ▁ is ▁ in ▁ mountain ▁ form \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Subarray ▁ is ▁ not ▁ in ▁ mountain ▁ form \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find whether a subarray is in form of a mountain or not | Utility method to construct left and right array ; initialize first left index as that index only ; if current value is greater than previous , update last increasing ; initialize last right index as that index only ; if current value is greater than next , update first decreasing ; method returns true if arr [ L . . R ] is in mountain form ; return true only if right at starting range is greater than left at ending range ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "2231-2231",
        "Code": "twos = [ 0 ] * 1000 NEW_LINE fives = [ 0 ] * 1000 NEW_LINE sum = 0 NEW_LINE def returnTwos ( val ) : NEW_LINE INDENT count = 0 NEW_LINE while ( val % 2 == 0 and val != 0 ) : NEW_LINE INDENT val = val // 2 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def returnFives ( val ) : NEW_LINE INDENT count = 0 NEW_LINE while ( val % 5 == 0 and val != 0 ) : NEW_LINE INDENT val = val // 5 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def solve_queries ( arr , n ) : NEW_LINE INDENT global sum NEW_LINE arrr1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE typee = arrr1 [ 0 ] NEW_LINE if ( typee == 1 ) : NEW_LINE INDENT ql , qr , x = arrr1 [ 1 ] , arrr1 [ 2 ] , arrr1 [ 3 ] NEW_LINE temp = returnTwos ( x ) NEW_LINE temp1 = returnFives ( x ) NEW_LINE i = ql - 1 NEW_LINE while ( i < qr ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * x NEW_LINE twos [ i ] += temp NEW_LINE fives [ i ] += temp1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( typee == 2 ) : NEW_LINE INDENT ql , qr , y = arrr1 [ 1 ] , arrr1 [ 2 ] , arrr1 [ 3 ] NEW_LINE temp = returnTwos ( y ) NEW_LINE temp1 = returnFives ( y ) NEW_LINE i = ql - 1 NEW_LINE while ( i < qr ) : NEW_LINE INDENT arr [ i ] = ( i - ql + 2 ) * y NEW_LINE twos [ i ] = returnTwos ( i - ql + 2 ) + temp NEW_LINE fives [ i ] = returnFives ( i - ql + 2 ) + temp1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( typee == 3 ) : NEW_LINE INDENT ql , qr = arrr1 [ 1 ] , arrr1 [ 2 ] NEW_LINE sumtwos = 0 NEW_LINE sumfives = 0 NEW_LINE i = ql - 1 NEW_LINE while ( i < qr ) : NEW_LINE INDENT sumtwos += twos [ i ] NEW_LINE sumfives += fives [ i ] NEW_LINE i += 1 NEW_LINE DEDENT sum += min ( sumtwos , sumfives ) NEW_LINE DEDENT DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos [ i ] = returnTwos ( arr [ i ] ) NEW_LINE fives [ i ] = returnFives ( arr [ i ] ) NEW_LINE DEDENT while ( m ) : NEW_LINE INDENT m -= 1 NEW_LINE solve_queries ( arr , n ) NEW_LINE DEDENT print ( sum ) NEW_LINE",
        "Type": "py",
        "NL": "Array Queries for multiply , replacements and product | vector of 1000 elements , all set to 0 ; vector of 1000 elements , all set to 0 ; Function to check number of trailing zeros in multiple of 2 ; Function to check number of trailing zeros in multiple of 5 ; Function to solve the queries received ; If the query is of typee 1. ; Counting the number of zeros in the given value of x ; The value x has been multiplied to their respective indices ; The value obtained above has been added to their respective vectors ; If the query is of typee 2. ; Counting the number of zero in the given value of x ; The value y has been replaced to their respective indices ; The value obtained above has been added to their respective vectors ; If the query is of typee 2 ; As the number of trailing zeros for each case has been found for each array element then we simply add those to the respective index to a variable ; Compare the number of zeros obtained in the multiples of five and two consider the minimum of them and add them ; Input the Size of array and number of queries ; Running the while loop for m number of queries",
        "Category": "Array"
    },
    {
        "ID": "2237-2237",
        "Code": "def modInverse ( a , m ) : NEW_LINE INDENT m0 , x0 , x1 = m , 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m , a = a % m , t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def calculate_Pre_Product ( A , N , P ) : NEW_LINE INDENT pre_product [ 0 ] = A [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] NEW_LINE pre_product [ i ] = pre_product [ i ] % P NEW_LINE DEDENT DEDENT def calculate_inverse_product ( A , N , P ) : NEW_LINE INDENT inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) NEW_LINE DEDENT DEDENT def calculateProduct ( A , L , R , P ) : NEW_LINE INDENT L = L - 1 NEW_LINE R = R - 1 NEW_LINE ans = 0 NEW_LINE if L == 0 : NEW_LINE INDENT ans = pre_product [ R ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = pre_product [ R ] * inverse_product [ L - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( A ) NEW_LINE P = 113 NEW_LINE MAX = 100 NEW_LINE pre_product = [ None ] * ( MAX ) NEW_LINE inverse_product = [ None ] * ( MAX ) NEW_LINE calculate_Pre_Product ( A , N , P ) NEW_LINE calculate_inverse_product ( A , N , P ) NEW_LINE L , R = 2 , 5 NEW_LINE print ( calculateProduct ( A , L , R , P ) ) NEW_LINE L , R = 1 , 3 NEW_LINE print ( calculateProduct ( A , L , R , P ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Products of ranges in an array | Returns modulo inverse of a with respect to m using extended Euclid Algorithm . Assumption : a and m are coprimes , i . e . , gcd ( a , m ) = 1 ; q is quotient ; m is remainder now , process same as Euclid 's algo ; Make x1 positive ; calculating pre_product array ; Cacluating inverse_product array . ; Function to calculate Product in the given range . ; As our array is 0 based as and L and R are given as 1 based index . ; Driver Code ; Array ; Prime P ; Calculating PreProduct and InverseProduct ; Range [ L , R ] in 1 base index",
        "Category": "Array"
    },
    {
        "ID": "224-224",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isLeaf ( node ) : NEW_LINE INDENT return node . left and node . left . right == node and node . right and node . right . left == node NEW_LINE DEDENT def maxDepth ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isLeaf ( node ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + max ( maxDepth ( node . left ) , maxDepth ( node . right ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . left . left . left = newNode ( 6 ) NEW_LINE L1 = root . left . left . left NEW_LINE L2 = root . left . right NEW_LINE L3 = root . right NEW_LINE L1 . right = L2 NEW_LINE L2 . right = L3 NEW_LINE L3 . right = L1 NEW_LINE L3 . left = L2 NEW_LINE L2 . left = L1 NEW_LINE L1 . left = L3 NEW_LINE print ( \" Height ▁ of ▁ tree ▁ is ▁ \" , maxDepth ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find height of a special binary tree whose leaf nodes are connected | Helper function that allocates a new node with the given data and None left and right poers . ; Construct to create a new node ; function to check if given node is a leaf node or node ; If given node ' s ▁ left ' s right is pointing to given node and its right ' s ▁ left ▁ is ▁ pointing ▁ to ▁ the ▁ node ▁ itself ▁ ▁ then ▁ it ' s a leaf ; Compute the height of a tree -- the number of Nodes along the longest path from the root node down to the farthest leaf node . ; if node is None , return 0 ; if node is a leaf node , return 1 ; compute the depth of each subtree and take maximum ; Driver Code ; Given tree contains 3 leaf nodes ; create circular doubly linked list out of leaf nodes of the tree set next pointer of linked list ; set prev pointer of linked list ; calculate height of the tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "2244-2244",
        "Code": "MAX = 1000001 NEW_LINE class Query : NEW_LINE INDENT def __init__ ( self , l , r , idx ) : NEW_LINE INDENT self . l = l NEW_LINE self . r = r NEW_LINE self . idx = idx NEW_LINE DEDENT DEDENT def update ( idx , val , bit , n ) : NEW_LINE INDENT while idx <= n : NEW_LINE INDENT bit [ idx ] += val NEW_LINE idx += idx & - idx NEW_LINE DEDENT DEDENT def query ( idx , bit , n ) : NEW_LINE INDENT summ = 0 NEW_LINE while idx : NEW_LINE INDENT summ += bit [ idx ] NEW_LINE idx -= idx & - idx NEW_LINE DEDENT return summ NEW_LINE DEDENT def answeringQueries ( arr , n , queries , q ) : NEW_LINE INDENT bit = [ 0 ] * ( n + 1 ) NEW_LINE last_visit = [ - 1 ] * MAX NEW_LINE ans = [ 0 ] * q NEW_LINE query_counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if last_visit [ arr [ i ] ] != - 1 : NEW_LINE INDENT update ( last_visit [ arr [ i ] ] + 1 , - 1 , bit , n ) NEW_LINE DEDENT last_visit [ arr [ i ] ] = i NEW_LINE update ( i + 1 , 1 , bit , n ) NEW_LINE while query_counter < q and queries [ query_counter ] . r == i : NEW_LINE INDENT ans [ queries [ query_counter ] . idx ] = query ( queries [ query_counter ] . r + 1 , bit , n ) - query ( queries [ query_counter ] . l , bit , n ) NEW_LINE query_counter += 1 NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ Query ( 0 , 4 , 0 ) , Query ( 1 , 3 , 1 ) , Query ( 2 , 4 , 2 ) ] NEW_LINE q = len ( queries ) NEW_LINE queries . sort ( key = lambda x : x . r ) NEW_LINE answeringQueries ( a , n , queries , q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries for number of distinct elements in a subarray | Python3 code to find number of distinct numbers in a subarray ; structure to store queries ; updating the bit array ; querying the bit array ; initialising bit array ; holds the rightmost index of any number as numbers of a [ i ] are less than or equal to 10 ^ 6 ; answer for each query ; If last visit is not - 1 update - 1 at the idx equal to last_visit [ arr [ i ] ] ; Setting last_visit [ arr [ i ] ] as i and updating the bit array accordingly ; If i is equal to r of any query store answer for that query in ans [ ] ; print answer for each query ; Driver Code",
        "Category": "Binary Indexed Tree (Fenwick Tree)"
    },
    {
        "ID": "2248-2248",
        "Code": "def countDe ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE v = arr . copy ( ) NEW_LINE arr . sort ( ) NEW_LINE count1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE count2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return ( min ( count1 , count2 ) ) NEW_LINE DEDENT arr = [ 5 , 9 , 21 , 17 , 13 ] NEW_LINE n = 5 NEW_LINE print ( \" Minimum ▁ Dearrangement ▁ = \" , countDe ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum De | function to count Dearrangement ; create a copy of original array ; sort the array ; traverse sorted array for counting mismatches ; reverse the sorted array ; traverse reverse sorted array for counting mismatches ; return minimum mismatch count ; Driven code",
        "Category": "Array"
    },
    {
        "ID": "2296-2296",
        "Code": "def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT def countOccurrences ( arr , n , x ) : NEW_LINE INDENT ind = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if ind == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 1 NEW_LINE left = ind - 1 NEW_LINE while ( left >= 0 and arr [ left ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE left -= 1 NEW_LINE DEDENT right = ind + 1 ; NEW_LINE while ( right < n and arr [ right ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( countOccurrences ( arr , n , x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of occurrences ( or frequency ) in a sorted array | A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be present in left subarray ; Else the element can only be present in right subarray ; Returns number of times x occurs in arr [ 0. . n - 1 ] ; If element is not present ; Count elements on left side . ; Count elements on right side . ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "23-23",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . key = item NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def preorder ( root ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT print root . key , NEW_LINE preorder ( root . left ) NEW_LINE preorder ( root . right ) NEW_LINE DEDENT DEDENT def getTrees ( arr , start , end ) : NEW_LINE INDENT trees = [ ] NEW_LINE if start > end : NEW_LINE INDENT trees . append ( None ) NEW_LINE return trees NEW_LINE DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT ltrees = getTrees ( arr , start , i - 1 ) NEW_LINE rtrees = getTrees ( arr , i + 1 , end ) NEW_LINE for j in ltrees : NEW_LINE INDENT for k in rtrees : NEW_LINE INDENT node = Node ( arr [ i ] ) NEW_LINE node . left = j NEW_LINE node . right = k NEW_LINE trees . append ( node ) NEW_LINE DEDENT DEDENT DEDENT return trees NEW_LINE DEDENT inp = [ 4 , 5 , 7 ] NEW_LINE n = len ( inp ) NEW_LINE trees = getTrees ( inp , 0 , n - 1 ) NEW_LINE print \" Preorder ▁ traversals ▁ of ▁ different ▁ possible\\ STRNEWLINE ▁ Binary ▁ Trees ▁ are ▁ \" NEW_LINE for i in trees : NEW_LINE INDENT preorder ( i ) ; NEW_LINE print \" \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find all possible binary trees with given Inorder Traversal | Node Structure ; Utility to create a new node ; A utility function to do preorder traversal of BST ; Function for constructing all possible trees with given inorder traversal stored in an array from arr [ start ] to arr [ end ] . This function returns a vector of trees . ; List to store all possible trees ; if start > end then subtree will be empty so returning NULL in the list ; Iterating through all values from start to end for constructing left and right subtree recursively ; Constructing left subtree ; Constructing right subtree ; Looping through all left and right subtrees and connecting to ith root below ; Making arr [ i ] as root ; Connecting left subtree ; Connecting right subtree ; Adding this tree to list ; Driver program to test above function",
        "Category": "Backtracking"
    },
    {
        "ID": "2303-2303",
        "Code": "def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if ( M != N - 1 and N != M - 1 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT res = res ^ arr1 [ i ] ; NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT res = res ^ arr2 [ i ] NEW_LINE DEDENT print ( \" Missing ▁ element ▁ is \" , res ) NEW_LINE DEDENT arr1 = [ 4 , 1 , 5 , 9 , 7 ] NEW_LINE arr2 = [ 7 , 5 , 9 , 4 ] NEW_LINE M = len ( arr1 ) NEW_LINE N = len ( arr2 ) NEW_LINE findMissing ( arr1 , arr2 , M , N ) NEW_LINE",
        "Type": "py",
        "NL": "Find lost element from a duplicated array | This function mainly does XOR of all elements of arr1 [ ] and arr2 [ ] ; Do XOR of all element ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2320-2320",
        "Code": "def search ( arr , n , x ) : NEW_LINE INDENT if ( arr [ n - 1 ] == x ) : NEW_LINE INDENT return \" Found \" NEW_LINE DEDENT backup = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = x NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT arr [ n - 1 ] = backup NEW_LINE if ( i < n - 1 ) : NEW_LINE INDENT return \" Found \" NEW_LINE DEDENT return \" Not ▁ Found \" NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT arr = [ 4 , 6 , 1 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( search ( arr , n , x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Search an element in an unsorted array using minimum number of comparisons | function to search an element in minimum number of comparisons ; 1 st comparison ; no termination condition and thus no comparison ; this would be executed at - most n times and therefore at - most n comparisons ; replace arr [ n - 1 ] with its actual element as in original 'arr[]   ; if ' x ' is found before the ' ( n - 1 ) th ' index , then it is present in the array final comparison ; else not present in the array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "233-233",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isleaf ( curr_node ) : NEW_LINE INDENT return ( curr_node . left == None and curr_node . right == None ) NEW_LINE DEDENT def deepestOddLevelDepthUtil ( curr_node , curr_level ) : NEW_LINE INDENT if ( curr_node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT curr_level += 1 NEW_LINE if ( curr_level % 2 != 0 and isleaf ( curr_node ) ) : NEW_LINE INDENT return curr_level NEW_LINE DEDENT return max ( deepestOddLevelDepthUtil ( curr_node . left , curr_level ) , deepestOddLevelDepthUtil ( curr_node . right , curr_level ) ) NEW_LINE DEDENT def deepestOddLevelDepth ( curr_node ) : NEW_LINE INDENT return deepestOddLevelDepthUtil ( curr_node , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 28 ) NEW_LINE root . right = newNode ( 13 ) NEW_LINE root . right . left = newNode ( 14 ) NEW_LINE root . right . right = newNode ( 15 ) NEW_LINE root . right . right . left = newNode ( 23 ) NEW_LINE root . right . right . right = newNode ( 24 ) NEW_LINE print ( deepestOddLevelDepth ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Depth of the deepest odd level node in Binary Tree | Python3 program to find depth of the deepest odd level node Helper function that allocates a new node with the given data and None left and right poers . ; Constructor to create a new node ; Utility function which returns whether the current node is a leaf or not ; function to return the longest odd level depth if it exists otherwise 0 ; Base case return from here ; increment current level ; if curr_level is odd and its a leaf node ; A wrapper over deepestOddLevelDepth ( ) ; Driver Code ; 10 / \\ 28 13 / \\ 14 15 / \\ 23 24 Let us create Binary Tree shown in above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "2341-2341",
        "Code": "def maxWater ( arr , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE l_max = 0 NEW_LINE r_max = 0 NEW_LINE result = 0 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if r_max <= l_max : NEW_LINE INDENT result += max ( 0 , r_max - arr [ right ] ) NEW_LINE r_max = max ( r_max , arr [ right ] ) NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += max ( 0 , l_max - arr [ left ] ) NEW_LINE l_max = max ( l_max , arr [ left ] ) NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxWater ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Trapping Rain Water | Function to return the maximum water that can be stored ; indices to traverse the array ; To store Left max and right max for two pointers left and right ; To store the total amount of rain water trapped ; We need check for minimum of left and right max for each element ; Add the difference between current value and right max at index r ; Update right max ; Update right pointer ; Add the difference between current value and left max at index l ; Update left max ; Update left pointer ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "2348-2348",
        "Code": "def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" ▁ \" ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE",
        "Type": "py",
        "NL": "Print uncommon elements from two sorted arrays | Python 3 program to find uncommon elements of two sorted arrays ; If not common , print smaller ; Skip common element ; printing remaining elements ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "236-236",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . visited = False NEW_LINE DEDENT DEDENT def find ( root , level , maxLevel , res ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT level += 1 NEW_LINE find ( root . left , level , maxLevel , res ) NEW_LINE if ( level > maxLevel [ 0 ] ) : NEW_LINE INDENT res [ 0 ] = root . data NEW_LINE maxLevel [ 0 ] = level NEW_LINE DEDENT find ( root . right , level , maxLevel , res ) NEW_LINE DEDENT DEDENT def deepestNode ( root ) : NEW_LINE INDENT res = [ - 1 ] NEW_LINE maxLevel = [ - 1 ] NEW_LINE find ( root , 0 , maxLevel , res ) NEW_LINE return res [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . right . left = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE root . right . left . right = newNode ( 7 ) NEW_LINE root . right . right . right = newNode ( 8 ) NEW_LINE root . right . left . right . left = newNode ( 9 ) NEW_LINE print ( deepestNode ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Deepest Node in a Binary Tree | A Binary Tree Node Utility function to create a new tree node ; maxLevel : keeps track of maximum level seen so far . res : Value of deepest node so far . level : Level of root ; Update level and resue ; Returns value of deepest node ; Initialze result and max level ; Updates value \" res \" and \" maxLevel \" Note that res and maxLen are passed by reference . ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2362-2362",
        "Code": "import math NEW_LINE def find_consecutive_steps ( arr , len ) : NEW_LINE INDENT count = 0 ; maximum = 0 NEW_LINE for index in range ( 1 , len ) : NEW_LINE INDENT if ( arr [ index ] > arr [ index - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( maximum , count ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE len = len ( arr ) NEW_LINE print ( find_consecutive_steps ( arr , len ) ) NEW_LINE",
        "Type": "py",
        "NL": "Consecutive steps to roof top | Python3 code to find maximum number of consecutive steps ; Function to count consecutive steps ; count the number of consecutive increasing height building ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "2369-2369",
        "Code": "def findClosest ( arr , n , target ) : NEW_LINE INDENT if ( target <= arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( target >= arr [ n - 1 ] ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT i = 0 ; j = n ; mid = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = ( i + j ) // 2 NEW_LINE if ( arr [ mid ] == target ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( target < arr [ mid ] ) : NEW_LINE INDENT if ( mid > 0 and target > arr [ mid - 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) NEW_LINE DEDENT j = mid NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid < n - 1 and target < arr [ mid + 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) NEW_LINE DEDENT i = mid + 1 NEW_LINE DEDENT DEDENT return arr [ mid ] NEW_LINE DEDENT def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE target = 11 NEW_LINE print ( findClosest ( arr , n , target ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find closest number in array | Returns element closest to target in arr [ ] ; Corner cases ; Doing binary search ; If target is less than array element , then search in left ; If target is greater than previous to mid , return closest of two ; Repeat for left half ; If target is greater than mid ; update i ; Only single element left after search ; Method to compare which one is the more close . We find the closest by taking the difference between the target and both values . It assumes that val2 is greater than val1 and target lies between these two . ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "237-237",
        "Code": "class new_Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def height ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT leftHt = height ( root . left ) NEW_LINE rightHt = height ( root . right ) NEW_LINE return max ( leftHt , rightHt ) + 1 NEW_LINE DEDENT def deepestNode ( root , levels ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( levels == 1 ) : NEW_LINE INDENT print ( root . data ) NEW_LINE DEDENT elif ( levels > 1 ) : NEW_LINE INDENT deepestNode ( root . left , levels - 1 ) NEW_LINE deepestNode ( root . right , levels - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = new_Node ( 1 ) NEW_LINE root . left = new_Node ( 2 ) NEW_LINE root . right = new_Node ( 3 ) NEW_LINE root . left . left = new_Node ( 4 ) NEW_LINE root . right . left = new_Node ( 5 ) NEW_LINE root . right . right = new_Node ( 6 ) NEW_LINE root . right . left . right = new_Node ( 7 ) NEW_LINE root . right . right . right = new_Node ( 8 ) NEW_LINE root . right . left . right . left = new_Node ( 9 ) NEW_LINE levels = height ( root ) NEW_LINE deepestNode ( root , levels ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Deepest Node in a Binary Tree | A tree node with constructor ; Utility function to find height of a tree , rooted at ' root ' . ; levels : current Level Utility function to print all nodes at a given level . ; Driver Code ; Calculating height of tree ; Printing the deepest node",
        "Category": "Binary Tree"
    },
    {
        "ID": "240-240",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def deepestLeftLeafUtil ( root , lvl , maxlvl , isLeft ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if ( isLeft is True ) : NEW_LINE INDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT if lvl > maxlvl [ 0 ] : NEW_LINE INDENT deepestLeftLeafUtil . resPtr = root NEW_LINE maxlvl [ 0 ] = lvl NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT deepestLeftLeafUtil ( root . left , lvl + 1 , maxlvl , True ) NEW_LINE deepestLeftLeafUtil ( root . right , lvl + 1 , maxlvl , False ) NEW_LINE DEDENT def deepestLeftLeaf ( root ) : NEW_LINE INDENT maxlvl = [ 0 ] NEW_LINE deepestLeftLeafUtil . resPtr = None NEW_LINE deepestLeftLeafUtil ( root , 0 , maxlvl , False ) NEW_LINE return deepestLeftLeafUtil . resPtr NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . right . left = Node ( 5 ) NEW_LINE root . right . right = Node ( 6 ) NEW_LINE root . right . left . right = Node ( 7 ) NEW_LINE root . right . right . right = Node ( 8 ) NEW_LINE root . right . left . right . left = Node ( 9 ) NEW_LINE root . right . right . right . right = Node ( 10 ) NEW_LINE result = deepestLeftLeaf ( root ) NEW_LINE if result is None : NEW_LINE INDENT print \" There ▁ is ▁ not ▁ left ▁ leaf ▁ in ▁ the ▁ given ▁ tree \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" The ▁ deepst ▁ left ▁ child ▁ is \" , result . val NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Deepest left leaf node in a binary tree | A binary tree node ; Constructor to create a new node ; A utility function to find deepest leaf node . lvl : level of current node . maxlvl : pointer to the deepest left leaf node found so far isLeft : A bool indicate that this node is left child of its parent resPtr : Pointer to the result ; Base CAse ; Update result if this node is left leaf and its level is more than the max level of the current result ; Recur for left and right subtrees ; A wrapper for left and right subtree ; Driver program to test above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "2411-2411",
        "Code": "def deleteAlt ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT node = head . next NEW_LINE if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT head . next = node . next NEW_LINE deleteAlt ( head . next ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Delete alternate nodes of a Linked List | deletes alternate nodes of a list starting with head ; Change the next link of head ; Recursively call for the new next of head",
        "Category": "Linked List"
    },
    {
        "ID": "2414-2414",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def areIdentical ( self , listb ) : NEW_LINE INDENT a = self . head NEW_LINE b = listb . head NEW_LINE while ( a != None and b != None ) : NEW_LINE INDENT if ( a . data != b . data ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = a . next NEW_LINE b = b . next NEW_LINE DEDENT return ( a == None and b == None ) NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE self . head = new_node NEW_LINE DEDENT DEDENT llist1 = LinkedList ( ) NEW_LINE llist2 = LinkedList ( ) NEW_LINE llist1 . push ( 1 ) NEW_LINE llist1 . push ( 2 ) NEW_LINE llist1 . push ( 3 ) NEW_LINE llist2 . push ( 1 ) NEW_LINE llist2 . push ( 2 ) NEW_LINE llist2 . push ( 3 ) NEW_LINE if ( llist1 . areIdentical ( llist2 ) == True ) : NEW_LINE INDENT print ( \" Identical ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ identical ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Identical Linked Lists | Linked list Node ; head of list ; Returns true if linked lists a and b are identical , otherwise false ; If we reach here , then a and b are not null and their data is same , so move to next nodes in both lists ; If linked lists are identical , then ' a ' and ' b ' must be null at this point . ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; 1 & 2 : Allocate the Node & Put in the data ; 3. Make next of new Node as head ; 4. Move the head to point to new Node ; Driver Code ; The constructed linked lists are : llist1 : 3 -> 2 -> 1 llist2 : 3 -> 2 -> 1",
        "Category": "Linked List"
    },
    {
        "ID": "2415-2415",
        "Code": "def areIdentical ( a , b ) : NEW_LINE INDENT if ( a == None and b == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a != None and b != None ) : NEW_LINE INDENT return ( ( a . data == b . data ) and areIdentical ( a . next , b . next ) ) NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Identical Linked Lists | A recursive Python3 function to check if two linked lists are identical or not ; If both lists are empty ; If both lists are not empty , then data of current nodes must match , and same should be recursively true for rest of the nodes . ; If we reach here , then one of the lists is empty and other is not",
        "Category": "Linked List"
    },
    {
        "ID": "2423-2423",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def rotate ( head_ref , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT current = head_ref NEW_LINE while ( current . next != None ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT current . next = head_ref NEW_LINE current = head_ref NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT head_ref = current . next NEW_LINE current . next = None NEW_LINE return head_ref NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = ' ▁ ' ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE for i in range ( 60 , 0 , - 10 ) : NEW_LINE INDENT head = push ( head , i ) NEW_LINE DEDENT print ( \" Given ▁ linked ▁ list ▁ \" ) NEW_LINE printList ( head ) NEW_LINE head = rotate ( head , 4 ) NEW_LINE print ( \" Rotated Linked list   \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rotate a Linked List | Link list node ; This function rotates a linked list counter - clockwise and updates the head . The function assumes that k is smaller than size of linked list . ; Let us understand the below code for example k = 4 and list = 10.20 . 30.40 .50 . 60. ; Traverse till the end . ; Traverse the linked list to k - 1 position which will be last element for rotated array . ; Update the head_ref and last element pointer to None ; Function to push a node ; Allocate node ; Put in the data ; Link the old list off the new node ; Move the head to point to the new node ; Function to print linked list ; Driver code ; Start with the empty list ; Create a list 10.20 . 30.40 .50 . 60",
        "Category": "Linked List"
    },
    {
        "ID": "2427-2427",
        "Code": "class LinkedList ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT class Node ( object ) : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def sortList ( self ) : NEW_LINE INDENT count = [ 0 , 0 , 0 ] NEW_LINE ptr = self . head NEW_LINE while ptr != None : NEW_LINE INDENT count [ ptr . data ] += 1 NEW_LINE ptr = ptr . next NEW_LINE DEDENT i = 0 NEW_LINE ptr = self . head NEW_LINE while ptr != None : NEW_LINE INDENT if count [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ptr . data = i NEW_LINE count [ i ] -= 1 NEW_LINE ptr = ptr . next NEW_LINE DEDENT DEDENT DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = self . Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE self . head = new_node NEW_LINE DEDENT def printList ( self ) : NEW_LINE INDENT temp = self . head NEW_LINE while temp != None : NEW_LINE INDENT print str ( temp . data ) , NEW_LINE temp = temp . next NEW_LINE DEDENT print ' ' NEW_LINE DEDENT DEDENT llist = LinkedList ( ) NEW_LINE llist . push ( 0 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . push ( 0 ) NEW_LINE llist . push ( 2 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . push ( 2 ) NEW_LINE llist . push ( 1 ) NEW_LINE llist . push ( 2 ) NEW_LINE print \" Linked ▁ List ▁ before ▁ sorting \" NEW_LINE llist . printList ( ) NEW_LINE llist . sortList ( ) NEW_LINE print \" Linked ▁ List ▁ after ▁ sorting \" NEW_LINE llist . printList ( ) NEW_LINE",
        "Type": "py",
        "NL": "Sort a linked list of 0 s , 1 s and 2 s | Python program to sort a linked list of 0 , 1 and 2 ; head of list ; Linked list Node ; initialise count of 0 1 and 2 as 0 ; count total number of '0' , '1' and '2' * count [ 0 ] will store total number of '0' s * count [ 1 ] will store total number of '1' s * count [ 2 ] will store total number of '2' s ; Let say count [ 0 ] = n1 , count [ 1 ] = n2 and count [ 2 ] = n3 * now start traversing list from head node , * 1 ) fill the list with 0 , till n1 > 0 * 2 ) fill the list with 1 , till n2 > 0 * 3 ) fill the list with 2 , till n3 > 0 ; Inserts a new Node at front of the list . ; 1 & 2 : Allocate the Node & Put in the data ; 3. Make next of new Node as head ; 4. Move the head to point to new Node ; Function to print linked list ; Constructed Linked List is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 8 -> 9 -> null",
        "Category": "Linked List"
    },
    {
        "ID": "2441-2441",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def newNode ( self , key ) : NEW_LINE INDENT temp = Node ( key ) NEW_LINE self . next = None NEW_LINE return temp NEW_LINE DEDENT def rearrangeEvenOdd ( self , head ) : NEW_LINE INDENT if ( self . head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT odd = self . head NEW_LINE even = self . head . next NEW_LINE evenFirst = even NEW_LINE while ( 1 == 1 ) : NEW_LINE INDENT if ( odd == None or even == None or ( even . next ) == None ) : NEW_LINE INDENT odd . next = evenFirst NEW_LINE break NEW_LINE DEDENT odd . next = even . next NEW_LINE odd = even . next NEW_LINE if ( odd . next == None ) : NEW_LINE INDENT even . next = None NEW_LINE odd . next = evenFirst NEW_LINE break NEW_LINE DEDENT even . next = odd . next NEW_LINE even = odd . next NEW_LINE DEDENT return head NEW_LINE DEDENT def printlist ( self , node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \" ) NEW_LINE print ( \" - > \" , end = \" \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" NULL \" ) NEW_LINE DEDENT def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE self . head = new_node NEW_LINE DEDENT DEDENT ll = LinkedList ( ) NEW_LINE ll . push ( 5 ) NEW_LINE ll . push ( 4 ) NEW_LINE ll . push ( 3 ) NEW_LINE ll . push ( 2 ) NEW_LINE ll . push ( 1 ) NEW_LINE print ( \" Given ▁ Linked ▁ List \" ) NEW_LINE ll . printlist ( ll . head ) NEW_LINE start = ll . rearrangeEvenOdd ( ll . head ) NEW_LINE print ( \" Modified Linked List \" ) NEW_LINE ll . printlist ( start ) NEW_LINE",
        "Type": "py",
        "NL": "Rearrange a linked list such that all even and odd positioned nodes are together | Linked List Node ; A utility function to create a new node ; Rearranges given linked list such that all even positioned nodes are before odd positioned . Returns new head of linked List . ; Corner case ; Initialize first nodes of even and odd lists ; Remember the first node of even list so that we can connect the even list at the end of odd list . ; If there are no more nodes , then connect first node of even list to the last node of odd list ; Connecting odd nodes ; If there are NO more even nodes after current odd . ; Connecting even nodes ; A utility function to print a linked list ; Function to insert a new node at the beginning ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "2445-2445",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE return new_node NEW_LINE DEDENT def addWithCarry ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = head . data + addWithCarry ( head . next ) NEW_LINE head . data = int ( ( res ) % 10 ) NEW_LINE return int ( ( res ) / 10 ) NEW_LINE DEDENT def addOne ( head ) : NEW_LINE INDENT carry = addWithCarry ( head ) NEW_LINE if ( carry != 0 ) : NEW_LINE INDENT newNode = Node ( 0 ) NEW_LINE newNode . data = carry NEW_LINE newNode . next = head NEW_LINE return newNode NEW_LINE DEDENT return head NEW_LINE DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT head = newNode ( 1 ) NEW_LINE head . next = newNode ( 9 ) NEW_LINE head . next . next = newNode ( 9 ) NEW_LINE head . next . next . next = newNode ( 9 ) NEW_LINE print ( \" List ▁ is ▁ \" ) NEW_LINE printList ( head ) NEW_LINE head = addOne ( head ) NEW_LINE print ( \" Resultant list is   \" ) NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Add 1 to a number represented as linked list | Node class ; Function to create a new node with given data ; Recursively add 1 from end to beginning and returns carry after all nodes are processed . ; If linked list is empty , then return carry ; Add carry returned be next node call ; Update data and return new carry ; This function mainly uses addWithCarry ( ) . ; Add 1 to linked list from end to beginning ; If there is carry after processing all nodes , then we need to add a new node to linked list ; New node becomes head now ; A utility function to print a linked list ; Driver program to test above function",
        "Category": "Linked List"
    },
    {
        "ID": "2449-2449",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . head = None NEW_LINE DEDENT def isPalindromeUtil ( self , string ) : NEW_LINE INDENT return ( string == string [ : : - 1 ] ) NEW_LINE DEDENT def isPalindrome ( self ) : NEW_LINE INDENT node = self . head NEW_LINE temp = [ ] NEW_LINE while ( node is not None ) : NEW_LINE INDENT temp . append ( node . data ) NEW_LINE node = node . next NEW_LINE DEDENT string = \" \" . join ( temp ) NEW_LINE return self . isPalindromeUtil ( string ) NEW_LINE DEDENT def printList ( self ) : NEW_LINE INDENT temp = self . head NEW_LINE while ( temp ) : NEW_LINE INDENT print temp . data , NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT DEDENT llist = LinkedList ( ) NEW_LINE llist . head = Node ( ' a ' ) NEW_LINE llist . head . next = Node ( ' bc ' ) NEW_LINE llist . head . next . next = Node ( \" d \" ) NEW_LINE llist . head . next . next . next = Node ( \" dcb \" ) NEW_LINE llist . head . next . next . next . next = Node ( \" a \" ) NEW_LINE print \" true \" if llist . isPalindrome ( ) else \" false \" NEW_LINE",
        "Type": "py",
        "NL": "Check if a linked list of strings forms a palindrome | Node class ;  ; A utility function to check if str is palindrome or not ; Match characters from beginning and end . ; Returns true if string formed by linked list is palindrome ; Append all nodes to form a string ; Utility function to print the linked LinkedList ; Driver program to test above function",
        "Category": "Linked List"
    },
    {
        "ID": "2453-2453",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def deleteLast ( head , x ) : NEW_LINE INDENT temp = head NEW_LINE ptr = None NEW_LINE while ( temp != None ) : NEW_LINE INDENT if ( temp . data == x ) : NEW_LINE INDENT ptr = temp NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT if ( ptr != None and ptr . next == None ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp . next != ptr ) : NEW_LINE INDENT temp = temp . next NEW_LINE DEDENT temp . next = None NEW_LINE DEDENT if ( ptr != None and ptr . next != None ) : NEW_LINE INDENT ptr . data = ptr . next . data NEW_LINE temp = ptr . next NEW_LINE ptr . next = ptr . next . next NEW_LINE DEDENT return head NEW_LINE DEDENT def newNode ( x ) : NEW_LINE INDENT node = Node ( 0 ) NEW_LINE node . data = x NEW_LINE node . next = None NEW_LINE return node NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT temp = head NEW_LINE if ( head == None ) : NEW_LINE INDENT print ( \" None \" ) NEW_LINE return NEW_LINE DEDENT while ( temp != None ) : NEW_LINE INDENT print ( temp . data , \" ▁ - > ▁ \" , end = \" \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( \" None \" ) NEW_LINE DEDENT head = newNode ( 1 ) NEW_LINE head . next = newNode ( 2 ) NEW_LINE head . next . next = newNode ( 3 ) NEW_LINE head . next . next . next = newNode ( 4 ) NEW_LINE head . next . next . next . next = newNode ( 5 ) NEW_LINE head . next . next . next . next . next = newNode ( 4 ) NEW_LINE head . next . next . next . next . next . next = newNode ( 4 ) NEW_LINE print ( \" Created ▁ Linked ▁ list : ▁ \" ) NEW_LINE display ( head ) NEW_LINE head = deleteLast ( head , 4 ) NEW_LINE print ( \" List ▁ after ▁ deletion ▁ of ▁ 4 : ▁ \" ) NEW_LINE display ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Delete last occurrence of an item from linked list | A linked list Node ; Function to delete the last occurrence ; If found key , update ; If the last occurrence is the last node ; If it is not the last node ; Utility function to create a new node with given key ; This function prints contents of linked list starting from the given Node ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "2462-2462",
        "Code": "def flattenList2 ( head ) : NEW_LINE INDENT headcop = head NEW_LINE save = [ ] NEW_LINE save . append ( head ) NEW_LINE prev = None NEW_LINE while ( len ( save ) != 0 ) : NEW_LINE INDENT temp = save [ - 1 ] NEW_LINE save . pop ( ) NEW_LINE if ( temp . next ) : NEW_LINE INDENT save . append ( temp . next ) NEW_LINE DEDENT if ( temp . down ) : NEW_LINE INDENT save . append ( temp . down ) NEW_LINE DEDENT if ( prev != None ) : NEW_LINE INDENT prev . next = temp NEW_LINE DEDENT prev = temp NEW_LINE DEDENT return headcop NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Flatten a multi |",
        "Category": "Linked List"
    },
    {
        "ID": "2469-2469",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def countCommon ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a != None and b != None ) : NEW_LINE INDENT if ( a . data == b . data ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT a = a . next NEW_LINE b = b . next NEW_LINE DEDENT return count NEW_LINE DEDENT def maxPalindrome ( head ) : NEW_LINE INDENT result = 0 NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE curr . next = prev NEW_LINE result = max ( result , 2 * countCommon ( prev , next ) + 1 ) NEW_LINE result = max ( result , 2 * countCommon ( curr , next ) ) NEW_LINE prev = curr NEW_LINE curr = next NEW_LINE DEDENT return result NEW_LINE DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = key NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT head = newNode ( 2 ) NEW_LINE head . next = newNode ( 4 ) NEW_LINE head . next . next = newNode ( 3 ) NEW_LINE head . next . next . next = newNode ( 4 ) NEW_LINE head . next . next . next . next = newNode ( 2 ) NEW_LINE head . next . next . next . next . next = newNode ( 15 ) NEW_LINE print ( maxPalindrome ( head ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of longest palindrome list in a linked list using O ( 1 ) extra space | Linked List node ; function for counting the common elements ; loop to count coomon in the list starting from node a and b ; increment the count for same values ; Returns length of the longest palindrome sublist in given list ; loop till the end of the linked list ; The sublist from head to current reversed . ; check for odd length palindrome by finding longest common list elements beginning from prev and from next ( We exclude curr ) ; check for even length palindrome by finding longest common list elements beginning from curr and from next ; update prev and curr for next iteration ; Utility function to create a new list node ; Let us create a linked lists to test the functions Created list is a : 2 -> 4 -> 3 -> 4 -> 2 -> 15",
        "Category": "Linked List"
    },
    {
        "ID": "2474-2474",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( x ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = x NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def moveToEnd ( head , key ) : NEW_LINE INDENT pKey = head NEW_LINE pCrawl = head NEW_LINE while ( pCrawl != None ) : NEW_LINE INDENT if ( pCrawl != pKey and pCrawl . data != key ) : NEW_LINE INDENT pKey . data = pCrawl . data NEW_LINE pCrawl . data = key NEW_LINE pKey = pKey . next NEW_LINE DEDENT if ( pKey . data != key ) : NEW_LINE INDENT pKey = pKey . next NEW_LINE DEDENT pCrawl = pCrawl . next NEW_LINE DEDENT return head NEW_LINE DEDENT head = newNode ( 10 ) NEW_LINE head . next = newNode ( 20 ) NEW_LINE head . next . next = newNode ( 10 ) NEW_LINE head . next . next . next = newNode ( 30 ) NEW_LINE head . next . next . next . next = newNode ( 40 ) NEW_LINE head . next . next . next . next . next = newNode ( 10 ) NEW_LINE head . next . next . next . next . next . next = newNode ( 60 ) NEW_LINE print ( \" Before moveToEnd ( ) , the Linked list is \" ) NEW_LINE printList ( head ) NEW_LINE key = 10 NEW_LINE head = moveToEnd ( head , key ) NEW_LINE print ( \" After moveToEnd ( ) , the Linked list is \" ) NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Move all occurrences of an element to end in a linked list | Linked List node ; A urility function to create a new node . ; Utility function to print the elements in Linked list ; Moves all occurrences of given key to end of linked list . ; Keeps track of locations where key is present . ; Traverse list ; If current pointer is not same as pointer to a key location , then we must have found a key in linked list . We swap data of pCrawl and pKey and move pKey to next position . ; Find next position where key is present ; Moving to next Node ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "2475-2475",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( x ) : NEW_LINE INDENT temp = Node ( x ) NEW_LINE return temp NEW_LINE DEDENT def keyToEnd ( head , key ) : NEW_LINE INDENT tail = head NEW_LINE if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT while ( tail . next != None ) : NEW_LINE INDENT tail = tail . next NEW_LINE DEDENT last = tail NEW_LINE current = head NEW_LINE prev = None NEW_LINE prev2 = None NEW_LINE while ( current != tail ) : NEW_LINE INDENT if ( current . data == key and prev2 == None ) : NEW_LINE INDENT prev = current NEW_LINE current = current . next NEW_LINE head = current NEW_LINE last . next = prev NEW_LINE last = last . next NEW_LINE last . next = None NEW_LINE prev = None NEW_LINE DEDENT else : NEW_LINE INDENT if ( current . data == key and prev2 != None ) : NEW_LINE INDENT prev = current NEW_LINE current = current . next NEW_LINE prev2 . next = current NEW_LINE last . next = prev NEW_LINE last = last . next NEW_LINE last . next = None NEW_LINE DEDENT elif ( current != tail ) : NEW_LINE INDENT prev2 = current NEW_LINE current = current . next NEW_LINE DEDENT DEDENT DEDENT return head NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . next = newNode ( 2 ) NEW_LINE root . next . next = newNode ( 2 ) NEW_LINE root . next . next . next = newNode ( 7 ) NEW_LINE root . next . next . next . next = newNode ( 2 ) NEW_LINE root . next . next . next . next . next = newNode ( 2 ) NEW_LINE root . next . next . next . next . next . next = newNode ( 2 ) NEW_LINE key = 2 NEW_LINE print ( \" Linked ▁ List ▁ before ▁ operations ▁ : \" ) NEW_LINE printList ( root ) NEW_LINE print ( \" Linked ▁ List ▁ after ▁ operations ▁ : \" ) NEW_LINE root = keyToEnd ( root , key ) NEW_LINE printList ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Move all occurrences of an element to end in a linked list | A Linked list Node ; Function to remove key to end ; Node to keep pointing to tail ; Node to point to last of linked list ; Node prev2 to point to previous when head . data != key ; Loop to perform operations to remove key to end ; Function to display linked list ; Driver Code",
        "Category": "Linked List"
    },
    {
        "ID": "2478-2478",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . next = None NEW_LINE self . head = None NEW_LINE DEDENT def LinkedListLength ( self ) : NEW_LINE INDENT while ( self . head != None and self . head . next != None ) : NEW_LINE INDENT self . head = self . head . next . next NEW_LINE DEDENT if ( self . head == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def push ( self , info ) : NEW_LINE INDENT node = Node ( info ) NEW_LINE node . next = ( self . head ) NEW_LINE ( self . head ) = node NEW_LINE DEDENT DEDENT head = Node ( 0 ) NEW_LINE head . push ( 4 ) NEW_LINE head . push ( 5 ) NEW_LINE head . push ( 7 ) NEW_LINE head . push ( 2 ) NEW_LINE head . push ( 9 ) NEW_LINE head . push ( 6 ) NEW_LINE head . push ( 1 ) NEW_LINE head . push ( 2 ) NEW_LINE head . push ( 0 ) NEW_LINE head . push ( 5 ) NEW_LINE head . push ( 5 ) NEW_LINE check = head . LinkedListLength ( ) NEW_LINE if ( check == 0 ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether the length of given linked list is Even or Odd | Defining structure ; Function to check the length of linklist ; Push function ; Allocating node ; Next of new node to head ; head points to new node ; Driver code ; Adding elements to Linked List ; Checking for length of linklist",
        "Category": "Linked List"
    },
    {
        "ID": "249-249",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def fillSet ( root , s , hd ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT fillSet ( root . left , s , hd - 1 ) NEW_LINE s . add ( hd ) NEW_LINE fillSet ( root . right , s , hd + 1 ) NEW_LINE DEDENT def verticalWidth ( root ) : NEW_LINE INDENT s = set ( ) NEW_LINE fillSet ( root , s , 0 ) NEW_LINE return len ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . right . left . right = Node ( 8 ) NEW_LINE root . right . right . right = Node ( 9 ) NEW_LINE print ( verticalWidth ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Vertical width of Binary tree | Set 2 | A binary tree node has data , pointer to left child and a pointer to right child ; Function to fill hd in set . ; Third parameter is horizontal distance ; Driver Code ; Creating the above tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "2493-2493",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def mergeKLists ( arr , last ) : NEW_LINE INDENT for i in range ( 1 , last + 1 ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT head_0 = arr [ 0 ] NEW_LINE head_i = arr [ i ] NEW_LINE if ( head_i == None ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( head_0 . data >= head_i . data ) : NEW_LINE INDENT arr [ i ] = head_i . next NEW_LINE head_i . next = head_0 NEW_LINE arr [ 0 ] = head_i NEW_LINE DEDENT else : NEW_LINE INDENT while ( head_0 . next != None ) : NEW_LINE INDENT if ( head_0 . next . data >= head_i . data ) : NEW_LINE INDENT arr [ i ] = head_i . next NEW_LINE head_i . next = head_0 . next NEW_LINE head_0 . next = head_i NEW_LINE break NEW_LINE DEDENT head_0 = head_0 . next NEW_LINE if ( head_0 . next == None ) : NEW_LINE INDENT arr [ i ] = head_i . next NEW_LINE head_i . next = None NEW_LINE head_0 . next = head_i NEW_LINE head_0 . next . next = None NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return arr [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE n = 4 NEW_LINE arr = [ None for i in range ( k ) ] NEW_LINE arr [ 0 ] = Node ( 1 ) NEW_LINE arr [ 0 ] . next = Node ( 3 ) NEW_LINE arr [ 0 ] . next . next = Node ( 5 ) NEW_LINE arr [ 0 ] . next . next . next = Node ( 7 ) NEW_LINE arr [ 1 ] = Node ( 2 ) NEW_LINE arr [ 1 ] . next = Node ( 4 ) NEW_LINE arr [ 1 ] . next . next = Node ( 6 ) NEW_LINE arr [ 1 ] . next . next . next = Node ( 8 ) NEW_LINE arr [ 2 ] = Node ( 0 ) NEW_LINE arr [ 2 ] . next = Node ( 9 ) NEW_LINE arr [ 2 ] . next . next = Node ( 10 ) NEW_LINE arr [ 2 ] . next . next . next = Node ( 11 ) NEW_LINE head = mergeKLists ( arr , k - 1 ) NEW_LINE printList ( head ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Merge K sorted linked lists | Set 1 | A Linked List node ; Function to prnodes in a given linked list ; The main function that takes an array of lists arr [ 0. . last ] and generates the sorted output ; Traverse form second list to last ; head of both the lists , 0 and ith list . ; Break if list ended ; Smaller than first element ; Traverse the first list ; Smaller than next element ; go to next node ; if last node ; Driver code ; Number of linked lists ; Number of elements in each list ; an array of pointers storing the head nodes of the linked lists ; Merge all lists",
        "Category": "Linked List"
    },
    {
        "ID": "2500-2500",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def swapNodes ( head_ref , currX , currY , prevY ) : NEW_LINE INDENT head_ref = currY NEW_LINE prevY . next = currX NEW_LINE temp = currY . next NEW_LINE currY . next = currX . next NEW_LINE currX . next = temp NEW_LINE return head_ref NEW_LINE DEDENT def recurSelectionSort ( head ) : NEW_LINE INDENT if ( head . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT min = head NEW_LINE beforeMin = None NEW_LINE ptr = head NEW_LINE while ( ptr . next != None ) : NEW_LINE INDENT if ( ptr . next . data < min . data ) : NEW_LINE INDENT min = ptr . next NEW_LINE beforeMin = ptr NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT if ( min != head ) : NEW_LINE INDENT head = swapNodes ( head , head , min , beforeMin ) NEW_LINE DEDENT head . next = recurSelectionSort ( head . next ) NEW_LINE return head NEW_LINE DEDENT def sort ( head_ref ) : NEW_LINE INDENT if ( ( head_ref ) == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT head_ref = recurSelectionSort ( head_ref ) NEW_LINE return head_ref NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT head = None NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 10 ) NEW_LINE print ( \" Linked ▁ list ▁ before ▁ sorting : \" ) NEW_LINE printList ( head ) NEW_LINE head = sort ( head ) NEW_LINE print (   \" Linked list after sorting : \" ) NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Recursive selection sort for singly linked list | Swapping node links | Linked List node ; function to swap nodes ' currX ' and ' currY ' in a linked list without swapping data ; make ' currY ' as new head ; adjust links ; Swap next pointers ; function to sort the linked list using recursive selection sort technique ; if there is only a single node ; ' min ' - pointer to store the node having minimum data value ; ' beforeMin ' - pointer to store node previous to ' min ' node ; traverse the list till the last node ; if true , then update ' min ' and 'beforeMin   ; if ' min ' and ' head ' are not same , swap the head node with the ' min ' node ; recursively sort the remaining list ; function to sort the given linked list ; if list is empty ; sort the list using recursive selection sort technique ; function to insert a node at the beginning of the linked list ; allocate node ; put in the data ; link the old list to the new node ; move the head to point to the new node ; function to print the linked list ; Driver code ; create linked list 10.12 .8 .4 .6 ; sort the linked list",
        "Category": "Linked List"
    },
    {
        "ID": "2508-2508",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def setMiddleHead ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT one_node = head NEW_LINE two_node = head NEW_LINE prev = None NEW_LINE while ( two_node != None and two_node . next != None ) : NEW_LINE INDENT prev = one_node NEW_LINE one_node = one_node . next NEW_LINE two_node = two_node . next . next NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE one_node . next = head NEW_LINE head = one_node NEW_LINE return head NEW_LINE DEDENT def push ( head , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( str ( temp . data ) , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT head = None NEW_LINE for i in range ( 5 , 0 , - 1 ) : NEW_LINE INDENT head = push ( head , i ) NEW_LINE DEDENT print ( \" ▁ list ▁ before : ▁ \" , end = \" \" ) NEW_LINE printList ( head ) NEW_LINE head = setMiddleHead ( head ) NEW_LINE print ( \" ▁ list ▁ After : ▁ \" , end = \" \" ) NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Make middle node head in a linked list | Linked List node ; function to get the middle node set it as the beginning of the linked list ; to traverse nodes one by one ; to traverse nodes by skipping one ; to keep track of previous middle ; for previous node of middle node ; move one node each time ; move two nodes each time ; set middle node at head ; To insert a node at the beginning of linked list . ; allocate new node ; link the old list to new node ; move the head to point the new node ; A function to print a given linked list ; Create a list of 5 nodes",
        "Category": "Linked List"
    },
    {
        "ID": "2515-2515",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def insert ( head_ref , data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE if ( head_ref == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE DEDENT else : NEW_LINE INDENT last = head_ref . prev NEW_LINE new_node . next = head_ref NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def merge ( first , second ) : NEW_LINE INDENT if ( first == None ) : NEW_LINE INDENT return second NEW_LINE DEDENT if ( second == None ) : NEW_LINE INDENT return first NEW_LINE DEDENT if ( first . data < second . data ) : NEW_LINE INDENT first . next = merge ( first . next , second ) NEW_LINE first . next . prev = first NEW_LINE first . prev = None NEW_LINE return first NEW_LINE DEDENT else : NEW_LINE INDENT second . next = merge ( first , second . next ) NEW_LINE second . next . prev = second NEW_LINE second . prev = None NEW_LINE return second NEW_LINE DEDENT DEDENT def mergeUtil ( head1 , head2 ) : NEW_LINE INDENT if ( head1 == None ) : NEW_LINE INDENT return head2 NEW_LINE DEDENT if ( head2 == None ) : NEW_LINE INDENT return head1 NEW_LINE DEDENT if ( head1 . prev . data < head2 . prev . data ) : NEW_LINE INDENT last_node = head2 . prev NEW_LINE DEDENT else : NEW_LINE INDENT last_node = head1 . prev NEW_LINE DEDENT head1 . prev . next = None NEW_LINE head2 . prev . next = None NEW_LINE finalHead = merge ( head1 , head2 ) NEW_LINE finalHead . prev = last_node NEW_LINE last_node . next = finalHead NEW_LINE return finalHead NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head1 = None NEW_LINE head2 = None NEW_LINE head1 = insert ( head1 , 8 ) NEW_LINE head1 = insert ( head1 , 5 ) NEW_LINE head1 = insert ( head1 , 3 ) NEW_LINE head1 = insert ( head1 , 1 ) NEW_LINE head2 = insert ( head2 , 11 ) NEW_LINE head2 = insert ( head2 , 9 ) NEW_LINE head2 = insert ( head2 , 7 ) NEW_LINE head2 = insert ( head2 , 2 ) NEW_LINE newHead = mergeUtil ( head1 , head2 ) NEW_LINE print ( \" Final ▁ Sorted ▁ List : ▁ \" , end = \" \" ) NEW_LINE printList ( newHead ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sorted merge of two sorted doubly circular linked lists | Python3 implementation for Sorted merge of two sorted doubly circular linked list ; A utility function to insert a new node at the beginning of doubly circular linked list ; allocate space ; put in the data ; if list is empty ; pointer points to last Node ; setting up previous and next of new node ; update next and previous pointers of head_ref and last . ; update head_ref pointer ; function for Sorted merge of two sorted doubly linked list ; If first list is empty ; If second list is empty ; Pick the smaller value and adjust the links ; function for Sorted merge of two sorted doubly circular linked list ; if 1 st list is empty ; if 2 nd list is empty ; get pointer to the node which will be the last node of the final list last_node ; store None to the ' next ' link of the last nodes of the two lists ; sorted merge of head1 and head2 ; ' prev ' of 1 st node pointing the last node ' next ' of last node pointing to 1 st node ; function to print the list ; Driver Code ; list 1 : ; list 2 :",
        "Category": "Linked List"
    },
    {
        "ID": "2516-2516",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( val ) : NEW_LINE INDENT temp = Node ( val ) NEW_LINE temp . data = val NEW_LINE temp . prev = None NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head . next != None ) : NEW_LINE INDENT print ( head . data , end = \" < - - > \" ) NEW_LINE head = head . next NEW_LINE DEDENT print ( head . data ) NEW_LINE DEDENT def insert ( head , val ) : NEW_LINE INDENT temp = newNode ( val ) NEW_LINE temp . next = head NEW_LINE ( head ) . prev = temp NEW_LINE ( head ) = temp NEW_LINE return head NEW_LINE DEDENT def reverseList ( head ) : NEW_LINE INDENT left = head NEW_LINE right = head NEW_LINE while ( right . next != None ) : NEW_LINE INDENT right = right . next NEW_LINE DEDENT while ( left != right and left . prev != right ) : NEW_LINE INDENT t = left . data NEW_LINE left . data = right . data NEW_LINE right . data = t NEW_LINE left = left . next NEW_LINE right = right . prev NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = newNode ( 5 ) NEW_LINE head = insert ( head , 4 ) NEW_LINE head = insert ( head , 3 ) NEW_LINE head = insert ( head , 2 ) NEW_LINE head = insert ( head , 1 ) NEW_LINE printList ( head ) NEW_LINE print ( \" List ▁ After ▁ Reversing \" ) NEW_LINE head = reverseList ( head ) NEW_LINE printList ( head ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse a Doubly Linked List | Set 4 ( Swapping Data ) | Python3 Program to Reverse a List using Data Swapping ; Insert a new node at the head of the list ; Function to reverse the list ; Traverse the list and set right pointer to end of list ; Swap data of left and right pointer and move them towards each other until they meet or cross each other ; Swap data of left and right pointer ; Advance left pointer ; Advance right pointer ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "2519-2519",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data , next , prev ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE self . prev = prev NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data , head_ref , None ) NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE head_ref = new_node NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def isPalindrome ( left ) : NEW_LINE INDENT if left == None : NEW_LINE INDENT return True NEW_LINE DEDENT right = left NEW_LINE while right . next != None : NEW_LINE INDENT right = right . next NEW_LINE DEDENT while left != right : NEW_LINE INDENT if left . data != right . data : NEW_LINE INDENT return False NEW_LINE DEDENT left = left . next NEW_LINE right = right . prev NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE head = push ( head , ' l ' ) NEW_LINE head = push ( head , ' e ' ) NEW_LINE head = push ( head , ' v ' ) NEW_LINE head = push ( head , ' e ' ) NEW_LINE head = push ( head , ' l ' ) NEW_LINE if isPalindrome ( head ) : NEW_LINE INDENT print ( \" It ▁ is ▁ Palindrome \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Palindrome \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a doubly linked list of characters is palindrome or not | Structure of node ; Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list . ; Function to check if list is palindrome or not ; Find rightmost node ; Driver program",
        "Category": "Two Pointers"
    },
    {
        "ID": "2521-2521",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printLevels ( root , low , high ) : NEW_LINE INDENT Q = [ ] NEW_LINE marker = Node ( 11114 ) NEW_LINE level = 1 NEW_LINE Q . append ( root ) NEW_LINE Q . append ( marker ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT n = Q [ 0 ] NEW_LINE Q . pop ( 0 ) NEW_LINE if n == marker : NEW_LINE INDENT print NEW_LINE level += 1 NEW_LINE if len ( Q ) == 0 or level > high : NEW_LINE INDENT break NEW_LINE DEDENT Q . append ( marker ) NEW_LINE continue NEW_LINE DEDENT if level >= low : NEW_LINE INDENT print n . key , NEW_LINE DEDENT if n . left is not None : NEW_LINE INDENT Q . append ( n . left ) NEW_LINE Q . append ( n . right ) NEW_LINE DEDENT DEDENT DEDENT root = Node ( 20 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . right = Node ( 22 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 12 ) NEW_LINE root . left . right . left = Node ( 10 ) NEW_LINE root . left . right . right = Node ( 14 ) NEW_LINE print \" Level ▁ Order ▁ Traversal ▁ between ▁ given ▁ two ▁ levels ▁ is \" , NEW_LINE printLevels ( root , 2 , 3 ) NEW_LINE",
        "Type": "py",
        "NL": "Print nodes between two given level numbers of a binary tree | A binary tree node ; Given a binary tree , print nodes form level number ' low ' to level number 'high   ; Marker node to indicate end of level ; Initialize level number ; Enqueue the only first level node and marker node for end of level ; print Q Simple level order traversal loop ; Remove the front item from queue ; print Q Check if end of level is reached ; print a new line and increment level number ; Check if marker node was last node in queue or level nubmer is beyond the given upper limit ; Enqueue the marker for end of next level ; If this is marker , then we don 't need print it  and enqueue its children ; If level is equal to or greater than given lower level , print it ; Enqueue children of non - marker node ; Driver program to test the above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "2523-2523",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def printKDistant ( root , klevel ) : NEW_LINE INDENT q = [ ] NEW_LINE level = 1 NEW_LINE flag = False NEW_LINE q . append ( root ) NEW_LINE q . append ( None ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE if ( level == klevel and temp != None ) : NEW_LINE INDENT flag = True NEW_LINE print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT q . pop ( 0 ) NEW_LINE if ( temp == None ) : NEW_LINE INDENT if ( len ( q ) ) : NEW_LINE INDENT q . append ( None ) NEW_LINE DEDENT level += 1 NEW_LINE if ( level > klevel ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE return flag NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 20 ) NEW_LINE root . left = newNode ( 10 ) NEW_LINE root . right = newNode ( 30 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . left . right = newNode ( 15 ) NEW_LINE root . left . right . left = newNode ( 12 ) NEW_LINE root . right . left = newNode ( 25 ) NEW_LINE root . right . right = newNode ( 40 ) NEW_LINE print ( \" data ▁ at ▁ level ▁ 1 ▁ : ▁ \" , end = \" \" ) NEW_LINE ret = printKDistant ( root , 1 ) NEW_LINE if ( ret == False ) : NEW_LINE INDENT print ( \" Number ▁ exceeds ▁ total \" , \" number ▁ of ▁ levels \" ) NEW_LINE DEDENT print ( \" data ▁ at ▁ level ▁ 2 ▁ : ▁ \" , end = \" \" ) NEW_LINE ret = printKDistant ( root , 2 ) NEW_LINE if ( ret == False ) : NEW_LINE INDENT print ( \" Number ▁ exceeds ▁ total \" , \" number ▁ of ▁ levels \" ) NEW_LINE DEDENT print ( \" data ▁ at ▁ level ▁ 3 ▁ : ▁ \" , end = \" \" ) NEW_LINE ret = printKDistant ( root , 3 ) NEW_LINE if ( ret == False ) : NEW_LINE INDENT print ( \" Number ▁ exceeds ▁ total \" , \" number ▁ of ▁ levels \" ) NEW_LINE DEDENT print ( \" data ▁ at ▁ level ▁ 6 ▁ : ▁ \" , end = \" \" ) NEW_LINE ret = printKDistant ( root , 6 ) NEW_LINE if ( ret == False ) : NEW_LINE INDENT print ( \" Number ▁ exceeds ▁ total ▁ number ▁ of ▁ levels \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Print nodes at k distance from root | Iterative | Node of binary tree Function to add a new node ; Function to prnodes of given level ; extra None is appended to keep track of all the nodes to be appended before level is incremented by 1 ; prwhen level is equal to k ; break the loop if level exceeds the given level number ; Driver Code ; create a binary tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "2531-2531",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def kDistantFromLeafUtil ( node , path , visited , pathLen , k ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT path [ pathLen ] = node . key NEW_LINE visited [ pathLen ] = False NEW_LINE pathLen += 1 NEW_LINE if ( node . left == None and node . right == None and pathLen - k - 1 >= 0 and visited [ pathLen - k - 1 ] == False ) : NEW_LINE INDENT print ( path [ pathLen - k - 1 ] , end = \" ▁ \" ) NEW_LINE visited [ pathLen - k - 1 ] = True NEW_LINE return NEW_LINE DEDENT kDistantFromLeafUtil ( node . left , path , visited , pathLen , k ) NEW_LINE kDistantFromLeafUtil ( node . right , path , visited , pathLen , k ) NEW_LINE DEDENT def printKDistantfromLeaf ( node , k ) : NEW_LINE INDENT global MAX_HEIGHT NEW_LINE path = [ None ] * MAX_HEIGHT NEW_LINE visited = [ False ] * MAX_HEIGHT NEW_LINE kDistantFromLeafUtil ( node , path , visited , 0 , k ) NEW_LINE DEDENT MAX_HEIGHT = 10000 NEW_LINE root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . right . left . right = newNode ( 8 ) NEW_LINE print ( \" Nodes ▁ at ▁ distance ▁ 2 ▁ are : \" , end = \" ▁ \" ) NEW_LINE printKDistantfromLeaf ( root , 2 ) NEW_LINE",
        "Type": "py",
        "NL": "Print all nodes that are at distance k from a leaf node | utility that allocates a new Node with the given key ; This function prints all nodes that are distance k from a leaf node path [ ] - . Store ancestors of a node visited [ ] - . Stores true if a node is printed as output . A node may be k distance away from many leaves , we want to print it once ; Base case ; append this Node to the path array ; it 's a leaf, so print the ancestor at  distance k only if the ancestor is  not already printed ; If not leaf node , recur for left and right subtrees ; Given a binary tree and a nuber k , print all nodes that are k distant from a leaf ; Driver Code ; Let us create binary tree given in the above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "2535-2535",
        "Code": "from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printCorner ( root : Node ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT q = deque ( ) NEW_LINE q . append ( root ) NEW_LINE while q : NEW_LINE INDENT n = len ( q ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . popleft ( ) NEW_LINE if i == 0 or i == n - 1 : NEW_LINE INDENT print ( temp . key , end = \" ▁ \" ) NEW_LINE DEDENT if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 15 ) NEW_LINE root . left = Node ( 10 ) NEW_LINE root . right = Node ( 20 ) NEW_LINE root . left . left = Node ( 8 ) NEW_LINE root . left . right = Node ( 12 ) NEW_LINE root . right . left = Node ( 16 ) NEW_LINE root . right . right = Node ( 25 ) NEW_LINE printCorner ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print leftmost and rightmost nodes of a Binary Tree | Python3 program to print corner node at each level of binary tree ; A binary tree node has key , pointer to left child and a pointer to right child ; Function to print corner node at each level ; If the root is null then simply return ; star node is for keeping track of levels ; pushing root node and star node ; Do level order traversal using a single queue ; n denotes the size of the current level in the queue ; If it is leftmost corner value or rightmost corner value then print it ; push the left and right children of the temp node ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2549-2549",
        "Code": "def rotateMatrix ( mat ) : NEW_LINE INDENT i = 0 NEW_LINE mat1 = [ ] NEW_LINE for it in mat : NEW_LINE INDENT it . reverse ( ) NEW_LINE it1 = it [ : i ] NEW_LINE it1 . reverse ( ) NEW_LINE it2 = it [ i : ] NEW_LINE it2 . reverse ( ) NEW_LINE i += 1 NEW_LINE mat1 . append ( it1 + it2 ) NEW_LINE DEDENT for rows in mat1 : NEW_LINE INDENT for cols in rows : NEW_LINE INDENT print ( cols , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE rotateMatrix ( mat ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify a matrix by rotating ith row exactly i times in clockwise direction | Function to rotate every i - th row of the matrix i times ; Traverse the matrix row - wise ; Reverse the current row ; Reverse the first i elements ; Reverse the last ( N - i ) elements ; Increment count ; Print final matrix ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "2553-2553",
        "Code": "def findLargestRotation ( num ) : NEW_LINE INDENT ans = num NEW_LINE length = len ( str ( num ) ) NEW_LINE x = 10 ** ( length - 1 ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT lastDigit = num % 10 NEW_LINE num = num // 10 NEW_LINE num += ( lastDigit * x ) NEW_LINE if ( num > ans ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT N = 657 NEW_LINE findLargestRotation ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum value possible by rotating digits of a given number | Function to find the maximum value possible by rotations of digits of N ; Store the required result ; Store the number of digits ; Iterate over the range [ 1 , len - 1 ] ; Store the unit 's digit ; Store the remaining number ; Find the next rotation ; If the current rotation is greater than the overall answer , then update answer ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2556-2556",
        "Code": "def numberOfDigit ( N ) : NEW_LINE INDENT digit = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit += 1 NEW_LINE N //= 10 NEW_LINE DEDENT return digit NEW_LINE DEDENT def rotateNumberByK ( N , K ) : NEW_LINE INDENT X = numberOfDigit ( N ) NEW_LINE K = ( ( K % X ) + X ) % X NEW_LINE left_no = N // pow ( 10 , X - K ) NEW_LINE N = N % pow ( 10 , X - K ) NEW_LINE left_digit = numberOfDigit ( left_no ) NEW_LINE N = N * pow ( 10 , left_digit ) + left_no NEW_LINE print ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , K = 12345 , 7 NEW_LINE rotateNumberByK ( N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rotate digits of a given number by K | Function to find the count of digits in N ; Stores count of digits in N ; Calculate the count of digits in N ; Update digit ; Update N ; Function to rotate the digits of N by K ; Stores count of digits in N ; Update K so that only need to handle left rotation ; Stores first K digits of N ; Remove first K digits of N ; Stores count of digits in left_no ; Append left_no to the right of digits of N ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "2561-2561",
        "Code": "def getMinimumRemoval ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ans = n NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT freqEven = { } NEW_LINE freqOdd = { } NEW_LINE for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT freqEven [ chr ( ch ) ] = 0 NEW_LINE freqOdd [ chr ( ch ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if str [ i ] in freqEven : NEW_LINE INDENT freqEven [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if str [ i ] in freqOdd : NEW_LINE INDENT freqOdd [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT evenMax = 0 NEW_LINE oddMax = 0 NEW_LINE for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT evenMax = max ( evenMax , freqEven [ chr ( ch ) ] ) NEW_LINE oddMax = max ( oddMax , freqOdd [ chr ( ch ) ] ) NEW_LINE DEDENT ans = ans - evenMax - oddMax NEW_LINE DEDENT else : NEW_LINE INDENT freq = { } NEW_LINE for ch in range ( ' a ' , ' z ' ) : NEW_LINE INDENT freq [ chr ( ch ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if str [ i ] in freq : NEW_LINE INDENT freq [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT strMax = 0 NEW_LINE for ch in range ( ' a ' , ' z ' ) : NEW_LINE INDENT strMax = max ( strMax , freq [ chr ( ch ) ] ) NEW_LINE DEDENT ans = ans - strMax NEW_LINE DEDENT return ans NEW_LINE DEDENT str = \" geeksgeeks \" NEW_LINE print ( getMinimumRemoval ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize characters to be changed to make the left and right rotation of a string same | Function to find the minimum characters to be removed from the string ; Initialize answer by N ; If length is even ; Frequency array for odd and even indices ; Store the frequency of the characters at even and odd indices ; Stores the most occuring frequency for even and odd indices ; Update the answer ; If length is odd ; Stores the frequency of the characters of the string ; Stores the most occuring characterin the string ; Update the answer ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "2574-2574",
        "Code": "from collections import defaultdict NEW_LINE def maximumMatchingPairs ( perm1 , perm2 , n ) : NEW_LINE INDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE mp1 = { } NEW_LINE mp2 = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp1 [ perm1 [ i ] ] = i NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT mp2 [ perm2 [ j ] ] = j NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT idx2 = mp2 [ perm1 [ i ] ] NEW_LINE idx1 = i NEW_LINE if ( idx1 == idx2 ) : NEW_LINE INDENT left [ i ] = 0 NEW_LINE right [ i ] = 0 NEW_LINE DEDENT elif ( idx1 < idx2 ) : NEW_LINE INDENT left [ i ] = ( n - ( idx2 - idx1 ) ) NEW_LINE right [ i ] = ( idx2 - idx1 ) NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = ( idx1 - idx2 ) NEW_LINE right [ i ] = ( n - ( idx1 - idx2 ) ) NEW_LINE DEDENT DEDENT freq1 = defaultdict ( int ) NEW_LINE freq2 = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq1 [ left [ i ] ] += 1 NEW_LINE freq2 [ right [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , max ( freq1 [ left [ i ] ] , freq2 [ right [ i ] ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P1 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE P2 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( P1 ) NEW_LINE print ( maximumMatchingPairs ( P1 , P2 , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize count of corresponding same elements in given permutations using cyclic rotations | Python3 program for the above approach ; Function to maximize the matching pairs between two permutation using left and right rotation ; Left array store distance of element from left side and right array store distance of element from right side ; Map to store index of elements ; idx1 is index of element in first permutation idx2 is index of element in second permutation ; If element if present on same index on both permutations then distance is zero ; Calculate distance from left and right side ; Calculate distance from left and right side ; Maps to store frequencies of elements present in left and right arrays ; Find maximum frequency ; Return the result ; Driver Code ; Given permutations P1 and P2 ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "2582-2582",
        "Code": "def isConversionPossible ( s1 , s2 , x ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s1 = list ( s1 ) NEW_LINE s2 = list ( s2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE if diff == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT diff = diff + 26 NEW_LINE DEDENT if diff > x : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" you \" NEW_LINE s2 = \" ara \" NEW_LINE x = 6 NEW_LINE result = isConversionPossible ( s1 , s2 , x ) NEW_LINE if result : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string can be formed from another string by at most X circular clockwise shifts | Function to check that the string s1 can be converted to s2 by clockwise circular shift of all characters of str1 atmost X times ; Check for all characters of the strings whether the difference between their ascii values is less than X or not ; If both characters are the same ; Condition to check if the difference less than 0 then find the circular shift by adding 26 to it ; If difference between their ASCII values exceeds X ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "2593-2593",
        "Code": "def countOddRotations ( n ) : NEW_LINE INDENT odd_count = 0 ; even_count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE if digit % 2 == 0 : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( \" Odd ▁ = \" , odd_count ) NEW_LINE print ( \" Even ▁ = \" , even_count ) NEW_LINE DEDENT n = 1234 NEW_LINE countOddRotations ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Count rotations of N which are Odd and Even | Function to count of all rotations which are odd and even ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2596-2596",
        "Code": "def CheckKCycles ( n , s ) : NEW_LINE INDENT ff = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = int ( s [ i : ] + s [ 0 : i ] ) NEW_LINE if ( x >= int ( s ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT ff = False NEW_LINE break NEW_LINE DEDENT if ( ff ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE s = \"123\" NEW_LINE CheckKCycles ( n , s ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether all the rotations of a given number is greater than or equal to the given number or not | Python3 implementation of the approach ; Splitting the number at index i and adding to the front ; Checking if the value is greater than or equal to the given value ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "26-26",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT next = None NEW_LINE def populateNext ( p ) : NEW_LINE INDENT global next NEW_LINE if ( p != None ) : NEW_LINE INDENT populateNext ( p . right ) NEW_LINE p . next = next NEW_LINE next = p NEW_LINE populateNext ( p . left ) NEW_LINE DEDENT DEDENT def newnode ( data ) : NEW_LINE INDENT node = Node ( 0 ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE node . next = None NEW_LINE return ( node ) NEW_LINE DEDENT root = newnode ( 10 ) NEW_LINE root . left = newnode ( 8 ) NEW_LINE root . right = newnode ( 12 ) NEW_LINE root . left . left = newnode ( 3 ) NEW_LINE p = populateNext ( root ) NEW_LINE ptr = root . left . left NEW_LINE while ( ptr != None ) : NEW_LINE INDENT out = 0 NEW_LINE if ( ptr . next != None ) : NEW_LINE INDENT out = ptr . next . data NEW_LINE DEDENT else : NEW_LINE INDENT out = - 1 NEW_LINE DEDENT print ( \" Next ▁ of \" , ptr . data , \" is \" , out ) NEW_LINE ptr = ptr . next NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Populate Inorder Successor for all nodes | Tree node ; Set next of p and all descendants of p by traversing them in reverse Inorder ; The first visited node will be the rightmost node next of the rightmost node will be NULL ; First set the next pointer in right subtree ; Set the next as previously visited node in reverse Inorder ; Change the prev for subsequent node ; Finally , set the next pointer in left subtree ; UTILITY FUNCTIONS Helper function that allocates a new node with the given data and None left and right pointers . ; Driver Code Constructed binary tree is 10 / \\ 8 12 / 3 ; Populates nextRight pointer in all nodes ; Let us see the populated values ; - 1 is printed if there is no successor",
        "Category": "Binary Tree"
    },
    {
        "ID": "2600-2600",
        "Code": "from math import log10 NEW_LINE def generateNumbers ( m ) : NEW_LINE INDENT numbers = [ ] NEW_LINE for y in range ( 1 , 10 ) : NEW_LINE INDENT k_max = ( ( 10 ** ( m - 2 ) * ( 10 * y + 1 ) ) // ( 10 ** ( m - 1 ) + y ) ) NEW_LINE for k in range ( 1 , k_max + 1 ) : NEW_LINE INDENT x = ( ( y * ( 10 ** ( m - 1 ) - k ) ) // ( 10 * k - 1 ) ) NEW_LINE if ( ( y * ( 10 ** ( m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) : NEW_LINE INDENT numbers . append ( 10 * x + y ) NEW_LINE DEDENT DEDENT DEDENT for n in sorted ( numbers ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE generateNumbers ( m ) NEW_LINE",
        "Type": "py",
        "NL": "Generating numbers that are divisor of their right | Python program to Generating numbers that are divisor of their right - rotations ; Function to generate m - digit numbers which are divisor of their right - rotation ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2611-2611",
        "Code": "def rvereseArray ( arr , start , end ) : NEW_LINE INDENT while start < end : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ end ] NEW_LINE arr [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def splitArr ( arr , k , n ) : NEW_LINE INDENT rvereseArray ( arr , 0 , n - 1 ) NEW_LINE rvereseArray ( arr , 0 , n - k - 1 ) NEW_LINE rvereseArray ( arr , n - k , n - 1 ) NEW_LINE DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE splitArr ( arr , k , n ) NEW_LINE printArray ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Split the array and add the first part to the end | Set 2 | Function to reverse arr [ ] from index start to end ; Function to print an array ; Function to left rotate arr [ ] of size n by k ; Driver Code ; Function calling",
        "Category": "Array"
    },
    {
        "ID": "2613-2613",
        "Code": "def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"43262488612\" NEW_LINE print ( \" Rotations : \" , countRotationsDivBy8 ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count rotations divisible by 8 | function to count of all rotations divisible by 8 ; For single digit number ; For two - digit numbers ( considering all pairs ) ; first pair ; second pair ; considering all three - digit sequences ; Considering the number formed by the last digit and the first two digits ; Considering the number formed by the last two digits and the first digit ; required count of rotations ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "2617-2617",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def countRotation ( head ) : NEW_LINE INDENT count = 0 NEW_LINE min = head . data NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( min > head . data ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE head = head . next NEW_LINE DEDENT return count NEW_LINE DEDENT def push ( head , data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE newNode . next = ( head ) NEW_LINE ( head ) = newNode NEW_LINE return head NEW_LINE DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = ' ▁ ' ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 11 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 18 ) NEW_LINE head = push ( head , 15 ) NEW_LINE printList ( head ) ; NEW_LINE print ( ) NEW_LINE print ( \" Linked ▁ list ▁ rotated ▁ elements : ▁ \" , end = ' ' ) NEW_LINE print ( countRotation ( head ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count rotations in sorted and rotated linked list | Linked list node ; Function that count number of rotation in singly linked list . ; Declare count variable and assign it 1. ; Declare a min variable and assign to data of head node . ; Check that while head not equal to None . ; If min value is greater then head -> data then it breaks the while loop and return the value of count . ; head assign the next value of head . ; Function to push element in linked list . ; Allocate dynamic memory for newNode . ; Assign the data into newNode . ; newNode -> next assign the address of head node . ; newNode become the headNode . ; Display linked list . ; Driver code ; Create a node and initialize with None ; push ( ) insert node in linked list . 15 -> 18 -> 5 -> 8 -> 11 -> 12 ; Function call countRotation ( )",
        "Category": "Linked List"
    },
    {
        "ID": "262-262",
        "Code": "import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . nextRight = None NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return ' { } ' . format ( self . data ) NEW_LINE DEDENT DEDENT def connect ( root ) : NEW_LINE INDENT queue = [ ] NEW_LINE queue . append ( root ) NEW_LINE queue . append ( None ) NEW_LINE while queue : NEW_LINE INDENT p = queue . pop ( 0 ) NEW_LINE if p : NEW_LINE INDENT p . nextRight = queue [ 0 ] NEW_LINE if p . left : NEW_LINE INDENT queue . append ( p . left ) NEW_LINE DEDENT if p . right : NEW_LINE INDENT queue . append ( p . right ) NEW_LINE DEDENT DEDENT elif queue : NEW_LINE INDENT queue . append ( None ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . right = Node ( 2 ) NEW_LINE root . left . left = Node ( 3 ) NEW_LINE root . right . right = Node ( 90 ) NEW_LINE connect ( root ) NEW_LINE print ( \" Following are populated nextRight pointers in \" \t \" the tree ( - 1 is printed if there is no nextRight ) \" ) NEW_LINE if ( root . nextRight != None ) : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . data , root . nextRight . data ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . data , - 1 ) ) NEW_LINE DEDENT if ( root . left . nextRight != None ) : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . left . data , root . left . nextRight . data ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . left . data , - 1 ) ) NEW_LINE DEDENT if ( root . right . nextRight != None ) : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . right . data , root . right . nextRight . data ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . right . data , - 1 ) ) NEW_LINE DEDENT if ( root . left . left . nextRight != None ) : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . left . left . data , root . left . left . nextRight . data ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . left . left . data , - 1 ) ) NEW_LINE DEDENT if ( root . right . right . nextRight != None ) : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . right . right . data , root . right . right . nextRight . data ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" nextRight of % d is % d \" % ( root . right . right . data , - 1 ) ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT def printLevelByLevel ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT node = root NEW_LINE while node : NEW_LINE INDENT print ( ' { } ' . format ( node . data ) , end = ' ▁ ' ) NEW_LINE node = node . nextRight NEW_LINE DEDENT print ( ) NEW_LINE if root . left : NEW_LINE INDENT printLevelByLevel ( root . left ) NEW_LINE DEDENT else : NEW_LINE INDENT printLevelByLevel ( root . right ) NEW_LINE DEDENT DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . data , end = ' ▁ ' ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Connect Nodes at same Level ( Level Order Traversal ) | connect nodes at same level using level order traversal ; Node class ; set nextRight of all nodes of a tree ; null marker to represent end of current level ; do level order of tree using None markers ; next element in queue represents next node at current level ; pus left and right children of current node ; if queue is not empty , push NULL to mark nodes at this level are visited ; Driver program to test above functions . ; Constructed binary tree is 10 / \\ 8 2 / \\ 3 90 ; Populates nextRight pointer in all nodes ; Let us check the values of nextRight pointers ; print level by level ; print inorder",
        "Category": "Binary Tree"
    },
    {
        "ID": "2622-2622",
        "Code": "def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 122 NEW_LINE y = 2147483678 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if two numbers are bit rotations of each other or not | function to check if two numbers are equal after bit rotation ; x64 has concatenation of x with itself . ; comapring only last 32 bits ; right shift by 1 unit ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2625-2625",
        "Code": "def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( str1 ) < 2 ) : NEW_LINE INDENT return str1 == str2 NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticlock_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE DEDENT if isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a string can be obtained by rotating another string 2 places | Function to check if string2 is obtained by string 1 ; Initialize string as anti - clockwise rotation ; Initialize string as clock wise rotation ; check if any of them is equal to string1 ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "2626-2626",
        "Code": "def minLexRotation ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE arr = [ 0 ] * n NEW_LINE concat = str_ + str_ NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : n + i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT print ( minLexRotation ( \" GEEKSFORGEEKS \" ) ) NEW_LINE print ( minLexRotation ( \" GEEKSQUIZ \" ) ) NEW_LINE print ( minLexRotation ( \" BCABDADAB \" ) ) NEW_LINE",
        "Type": "py",
        "NL": "Lexicographically minimum string rotation | Set 1 | This function return lexicographically minimum rotation of str ; Find length of given string ; Create an array of strings to store all rotations ; Create a concatenation of string with itself ; One by one store all rotations of str in array . A rotation is obtained by getting a substring of concat ; Sort all rotations ; Return the first rotation from the sorted array ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "2655-2655",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , data ) : NEW_LINE INDENT ptr1 = Node ( ) NEW_LINE temp = head_ref ; NEW_LINE ptr1 . data = data ; NEW_LINE ptr1 . next = head_ref ; NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT while ( temp . next != head_ref ) : NEW_LINE INDENT temp = temp . next ; NEW_LINE DEDENT temp . next = ptr1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ptr1 . next = ptr1 ; NEW_LINE DEDENT head_ref = ptr1 ; NEW_LINE return head_ref NEW_LINE DEDENT def deleteNode ( head_ref , delt ) : NEW_LINE INDENT temp = head_ref ; NEW_LINE if ( head_ref == delt ) : NEW_LINE INDENT head_ref = delt . next ; NEW_LINE DEDENT while ( temp . next != delt ) : NEW_LINE INDENT temp = temp . next ; NEW_LINE DEDENT temp . next = delt . next ; NEW_LINE del ( delt ) ; NEW_LINE return ; NEW_LINE DEDENT def largestElement ( head_ref ) : NEW_LINE INDENT current = None NEW_LINE current = head_ref ; NEW_LINE maxEle = - 10000000 NEW_LINE while ( True ) : NEW_LINE INDENT if ( current . data > maxEle ) : NEW_LINE INDENT maxEle = current . data ; NEW_LINE DEDENT current = current . next ; NEW_LINE if ( current == head_ref ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return maxEle ; NEW_LINE DEDENT def createHash ( hashmap , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 ; NEW_LINE hashmap . add ( prev ) ; NEW_LINE hashmap . add ( curr ) ; NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev ; NEW_LINE hashmap . add ( temp ) ; NEW_LINE prev = curr ; NEW_LINE curr = temp ; NEW_LINE DEDENT DEDENT def deleteFibonacciNodes ( head ) : NEW_LINE INDENT maxEle = largestElement ( head ) ; NEW_LINE hashmap = set ( ) NEW_LINE createHash ( hashmap , maxEle ) ; NEW_LINE ptr = head ; NEW_LINE next = None NEW_LINE while ( True ) : NEW_LINE INDENT if ( ptr . data in hashmap ) : NEW_LINE INDENT deleteNode ( head , ptr ) ; NEW_LINE DEDENT next = ptr . next ; NEW_LINE ptr = next ; NEW_LINE if ( ptr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT temp = head ; NEW_LINE if ( head != None ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE temp = temp . next NEW_LINE if ( temp == head ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None ; NEW_LINE head = push ( head , 20 ) ; NEW_LINE head = push ( head , 13 ) ; NEW_LINE head = push ( head , 6 ) ; NEW_LINE head = push ( head , 34 ) ; NEW_LINE head = push ( head , 11 ) ; NEW_LINE head = push ( head , 9 ) ; NEW_LINE deleteFibonacciNodes ( head ) ; NEW_LINE printList ( head ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove all Fibonacci Nodes from a Circular Singly Linked List | Structure for a node ; Function to add a node at the beginning of a Circular linked list ; Create a new node and make head as next of it . ; If linked list is not None then set the next of last node ; Find the node before head and update next of it . ; Point for the first node ; Delete the node from a Circular Linked list ; If node to be deleted is head node ; Traverse list till not found delete node ; Copy the address of the node ; Finally , free the memory occupied by delt ; Function to find the maximum node of the circular linked list ; Pointer for traversing ; Initialize head to the current pointer ; Initialize min value to max ; While the last node is not reached ; If current node data is greater for max then replace it ; Function to create hashmap table to check Fibonacci numbers ; Adding the first two elements to the hashmap ; Inserting the Fibonacci numbers into the hashmap ; Function to delete all the Fibonacci nodes from the singly circular linked list ; Find the largest node value in Circular Linked List ; Creating a hashmap containing all the Fibonacci numbers upto the maximum data value in the circular linked list ; Traverse the list till the end ; If the node ' s ▁ data ▁ is ▁ Fibonacci , ▁ ▁ delete ▁ node ▁ ' ptr ; Point to the next node ; Function to print nodes in a given Circular linked list ; Driver code ; Initialize lists as empty ; Created linked list will be 9.11 .34 .6 .13 .20",
        "Category": "Linked List"
    },
    {
        "ID": "2658-2658",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def addToEmpty ( last , data ) : NEW_LINE INDENT if ( last != None ) : NEW_LINE INDENT return last NEW_LINE DEDENT temp = Node ( data ) NEW_LINE last = temp NEW_LINE last . next = last NEW_LINE return last NEW_LINE DEDENT def addBegin ( last , data ) : NEW_LINE INDENT if ( last == None ) : NEW_LINE INDENT return addToEmpty ( data ) NEW_LINE DEDENT temp = Node ( data ) NEW_LINE temp . next = last . next NEW_LINE last . next = temp NEW_LINE return last NEW_LINE DEDENT def traverse ( last ) : NEW_LINE INDENT if ( last == None ) : NEW_LINE INDENT print ( \" List ▁ is ▁ empty . \" ) NEW_LINE return NEW_LINE DEDENT p = last . next NEW_LINE while True : NEW_LINE INDENT print ( p . data , end = \" ▁ \" ) NEW_LINE p = p . next NEW_LINE if p == last . next : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT def length ( last ) : NEW_LINE INDENT x = 0 NEW_LINE if ( last == None ) : NEW_LINE INDENT return x NEW_LINE DEDENT itr = last . next NEW_LINE while ( itr . next != last . next ) : NEW_LINE INDENT x += 1 NEW_LINE itr = itr . next NEW_LINE DEDENT return ( x + 1 ) NEW_LINE DEDENT def split ( last , k ) : NEW_LINE INDENT passs = Node ( - 1 ) NEW_LINE if ( last == None ) : NEW_LINE INDENT return last NEW_LINE DEDENT itr = last NEW_LINE for i in range ( k ) : NEW_LINE INDENT itr = itr . next NEW_LINE DEDENT newLast = itr NEW_LINE passs . next = itr . next NEW_LINE newLast . next = last . next NEW_LINE last . next = passs . next NEW_LINE return newLast NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT clist = None NEW_LINE clist = addToEmpty ( clist , 12 ) NEW_LINE clist = addBegin ( clist , 10 ) NEW_LINE clist = addBegin ( clist , 8 ) NEW_LINE clist = addBegin ( clist , 6 ) NEW_LINE clist = addBegin ( clist , 4 ) NEW_LINE clist = addBegin ( clist , 2 ) NEW_LINE print ( \" Original ▁ list : \" , end = \" \" ) NEW_LINE traverse ( clist ) NEW_LINE k = 4 NEW_LINE clist2 = split ( clist , k ) NEW_LINE print ( \" The ▁ new ▁ lists ▁ are : \" , end = \" \" ) NEW_LINE traverse ( clist2 ) NEW_LINE traverse ( clist ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Splitting starting N nodes into new Circular Linked List while preserving the old nodes | Python3 implementation of the approach ; Function to add a node to the empty list ; If not empty ; Assigning the data ; Creating the link ; Function to add a node to the beginning of the list ; If list is empty ; Assign data ; Function to traverse and prthe list ; If list is empty ; Pointing to the first Node of the list ; Traversing the list ; Function to find the length of the CircularLinkedList ; Stores the length ; List is empty ; Iterator Node to traverse the List ; Return the length of the list ; Function to split the first k nodes into a new CircularLinkedList and the remaining nodes stay in the original CircularLinkedList ; Empty Node for reference ; Check if the list is empty If yes , then return NULL ; NewLast will contain the last node of the new split list itr to iterate the node till the required node ; Update NewLast to the required node and link the last to the start of rest of the list ; Return the last node of the required list ; Driver code ; Append the new last node into the new list ; Print the new lists",
        "Category": "Linked List"
    },
    {
        "ID": "2667-2667",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def Insert ( head , data ) : NEW_LINE INDENT current = head NEW_LINE newNode = Node ( 0 ) NEW_LINE if ( newNode == None ) : NEW_LINE INDENT print ( \" Memory Error \" ) NEW_LINE return None NEW_LINE DEDENT newNode . data = data NEW_LINE if ( head == None ) : NEW_LINE INDENT newNode . next = newNode NEW_LINE head = newNode NEW_LINE return head NEW_LINE DEDENT else : NEW_LINE INDENT while ( current . next != head ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT newNode . next = head NEW_LINE current . next = newNode NEW_LINE DEDENT return head NEW_LINE DEDENT def Display ( head ) : NEW_LINE INDENT current = head NEW_LINE if ( head == None ) : NEW_LINE INDENT print ( \" Display List is empty \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT print ( current . data , end = \" ▁ \" ) NEW_LINE current = current . next NEW_LINE if ( current == head ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def Length ( head ) : NEW_LINE INDENT current = head NEW_LINE count = 0 NEW_LINE if ( head == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT current = current . next NEW_LINE count = count + 1 NEW_LINE if ( current == head ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def DeleteFirst ( head ) : NEW_LINE INDENT previous = head NEW_LINE next = head NEW_LINE if ( head == None ) : NEW_LINE INDENT print ( \" List is empty \" ) NEW_LINE return None NEW_LINE DEDENT if ( previous . next == previous ) : NEW_LINE INDENT head = None NEW_LINE return None NEW_LINE DEDENT while ( previous . next != head ) : NEW_LINE INDENT previous = previous . next NEW_LINE next = previous . next NEW_LINE DEDENT previous . next = next . next NEW_LINE head = previous . next NEW_LINE return head NEW_LINE DEDENT def DeleteLast ( head ) : NEW_LINE INDENT current = head NEW_LINE temp = head NEW_LINE previous = None NEW_LINE if ( head == None ) : NEW_LINE INDENT print ( \" List is empty \" ) NEW_LINE return None NEW_LINE DEDENT if ( current . next == current ) : NEW_LINE INDENT head = None NEW_LINE return None NEW_LINE DEDENT while ( current . next != head ) : NEW_LINE INDENT previous = current NEW_LINE current = current . next NEW_LINE DEDENT previous . next = current . next NEW_LINE head = previous . next NEW_LINE return head NEW_LINE DEDENT def DeleteAtPosition ( head , index ) : NEW_LINE INDENT len = Length ( head ) NEW_LINE count = 1 NEW_LINE previous = head NEW_LINE next = head NEW_LINE if ( head == None ) : NEW_LINE INDENT print ( \" Delete Last List is empty \" ) NEW_LINE return None NEW_LINE DEDENT if ( index >= len or index < 0 ) : NEW_LINE INDENT print ( \" Index is not Found \" ) NEW_LINE return None NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT head = DeleteFirst ( head ) NEW_LINE return head NEW_LINE DEDENT while ( len > 0 ) : NEW_LINE INDENT if ( index == count ) : NEW_LINE INDENT previous . next = next . next NEW_LINE return head NEW_LINE DEDENT previous = previous . next NEW_LINE next = previous . next NEW_LINE len = len - 1 NEW_LINE count = count + 1 NEW_LINE DEDENT return head NEW_LINE DEDENT head = None NEW_LINE head = Insert ( head , 99 ) NEW_LINE head = Insert ( head , 11 ) NEW_LINE head = Insert ( head , 22 ) NEW_LINE head = Insert ( head , 33 ) NEW_LINE head = Insert ( head , 44 ) NEW_LINE head = Insert ( head , 55 ) NEW_LINE head = Insert ( head , 66 ) NEW_LINE print ( \" Initial ▁ List : ▁ \" ) NEW_LINE Display ( head ) NEW_LINE print ( \" After Deleting node at index 4 :   \" ) NEW_LINE head = DeleteAtPosition ( head , 4 ) NEW_LINE Display ( head ) NEW_LINE print ( \" Initial List :   \" ) NEW_LINE Display ( head ) NEW_LINE print ( \" After Deleting first node :   \" ) NEW_LINE head = DeleteFirst ( head ) NEW_LINE Display ( head ) NEW_LINE print ( \" Initial List :   \" ) NEW_LINE Display ( head ) NEW_LINE print ( \" After Deleting last node :   \" ) NEW_LINE head = DeleteLast ( head ) NEW_LINE Display ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Deletion at different positions in a Circular Linked List | A linked list node ; Function to insert a node at the end of a Circular linked list ; Create a new node ; check node is created or not ; insert data into newly created node ; check list is empty if not have any node then make first node it ; if list have already some node ; move first node to last node ; put first or head node address in new node link ; put new node address into last node link ( next ) ; Function print data of list ; if list is empty , simply show message ; traverse first to last node ; Function return number of nodes present in list ; if list is empty simply return length zero ; traverse forst to last node ; Function delete First node of Circular Linked List ; check list have any node if not then return ; check list have single node if yes then delete it and return ; traverse second to first ; now previous is last node and next is first node of list first node ( next ) link address put in last node ( previous ) link ; make second node as head node ; Function to delete last node of Circular Linked List ; check if list doesn 't have any node  if not then return ; check if list have single node if yes then delete it and return ; move first node to last previous ; Function delete node at a given poisition of Circular Linked List ; Find length of list ; check list have any node if not then return ; given index is in list or not ; delete first node ; traverse first to last node ; if index found delete that node ; Driver Code ; Deleting Node at position ; Deleting first Node ; Deleting last Node",
        "Category": "Linked List"
    },
    {
        "ID": "2671-2671",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT head = Node ( data ) NEW_LINE head . next = head NEW_LINE return head NEW_LINE DEDENT lnode = head NEW_LINE while ( lnode and lnode . next is not head ) : NEW_LINE INDENT lnode = lnode . next NEW_LINE DEDENT ptr1 = Node ( data ) NEW_LINE ptr1 . next = head NEW_LINE lnode . next = ptr1 NEW_LINE head = ptr1 NEW_LINE return head NEW_LINE DEDENT def sumOfList ( head ) : NEW_LINE INDENT temp = head NEW_LINE tsum = temp . data NEW_LINE temp = temp . next NEW_LINE while ( temp is not head ) : NEW_LINE INDENT tsum += temp . data NEW_LINE temp = temp . next NEW_LINE DEDENT return tsum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 56 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 11 ) NEW_LINE print ( \" Sum ▁ of ▁ circular ▁ list ▁ is ▁ = ▁ { } \" . format ( sumOfList ( head ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of the nodes of a Circular Linked List | Python3 program to find the sum of all nodes of a Circular linked list ; class for a node ; Function to insert a node at the beginning of a Circular linked list ; If linked list is not NULL then set the next of last node ; For the first node ; Function to find sum of the given Circular linked list ; Driver code ; Initialize lists as empty ; Created linked list will be 11 -> 2 -> 56 -> 12",
        "Category": "Linked List"
    },
    {
        "ID": "2672-2672",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def prList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( temp . data , end = \" - > \" ) NEW_LINE temp = temp . next NEW_LINE while ( temp != head ) : NEW_LINE INDENT print ( temp . data , end = \" - > \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( head . data ) NEW_LINE DEDENT def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while True : NEW_LINE INDENT if ( curr . next == head and curr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT prList ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if ( curr == head ) : NEW_LINE INDENT prev = head NEW_LINE while ( prev . next != head ) : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif ( curr . next == head ) : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT DEDENT def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = Node ( x ) NEW_LINE if ( head == None ) : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while ( temp1 . next != head ) : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertNode ( head , 1 ) NEW_LINE head = insertNode ( head , 2 ) NEW_LINE head = insertNode ( head , 3 ) NEW_LINE head = insertNode ( head , 4 ) NEW_LINE head = insertNode ( head , 5 ) NEW_LINE head = insertNode ( head , 6 ) NEW_LINE head = insertNode ( head , 7 ) NEW_LINE head = insertNode ( head , 8 ) NEW_LINE head = insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE deleteK ( head , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Delete every Kth node from circular linked list | Python3 program to delete every kth Node from circular linked list . ; structure for a Node ; Utility function to print the circular linked list ; Function to delete every kth Node ; If list is empty , simply return . ; take two poers - current and previous ; Check if Node is the only Node \\ If yes , we reached the goal , therefore return . ; Pr intermediate list . ; If more than one Node present in the list , Make previous pointer po to current Iterate current pointer k times , i . e . current Node is to be deleted . ; If Node to be deleted is head ; If Node to be deleted is last Node . ; Function to insert a Node at the end of a Circular linked list ; Create a new Node ; if the list is empty , make the new Node head Also , it will po to itself . ; traverse the list to reach the last Node and insert the Node ; Driver Code ; insert Nodes in the circular linked list ; Delete every kth Node from the circular linked list .",
        "Category": "Linked List"
    },
    {
        "ID": "2677-2677",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE return node NEW_LINE DEDENT def alivesol ( Num ) : NEW_LINE INDENT if ( Num == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT last = newNode ( 1 ) ; NEW_LINE last . next = last ; NEW_LINE for i in range ( 2 , Num + 1 ) : NEW_LINE INDENT temp = newNode ( i ) ; NEW_LINE temp . next = last . next ; NEW_LINE last . next = temp ; NEW_LINE last = temp ; NEW_LINE DEDENT curr = last . next ; NEW_LINE temp = None NEW_LINE while ( curr . next != curr ) : NEW_LINE INDENT temp = curr ; NEW_LINE curr = curr . next ; NEW_LINE temp . next = curr . next ; NEW_LINE del curr ; NEW_LINE temp = temp . next ; NEW_LINE curr = temp ; NEW_LINE DEDENT res = temp . data ; NEW_LINE del temp ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 100 ; NEW_LINE print ( alivesol ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lucky alive person in a circle | Code Solution to sword puzzle | Node structure ; Function to find the luckiest person ; Create a single node circular linked list . ; Starting from first soldier . ; condition for evaluating the existence of single soldier who is not killed . ; deleting soldier from the circular list who is killed in the fight . ; Returning the Luckiest soldier who remains alive . ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "2681-2681",
        "Code": "MAX = 1000 NEW_LINE lg = 10 NEW_LINE level = [ 0 for i in range ( MAX ) ] NEW_LINE lca = [ [ 0 for i in range ( lg ) ] for j in range ( MAX ) ] NEW_LINE dist = [ [ 0 for i in range ( lg ) ] for j in range ( MAX ) ] NEW_LINE graph = [ [ ] for i in range ( MAX ) ] NEW_LINE def addEdge ( u , v , cost ) : NEW_LINE INDENT global graph NEW_LINE graph [ u ] . append ( [ v , cost ] ) NEW_LINE graph [ v ] . append ( [ u , cost ] ) NEW_LINE DEDENT def dfs ( node , parent , h , cost ) : NEW_LINE INDENT lca [ node ] [ 0 ] = parent NEW_LINE level [ node ] = h NEW_LINE if ( parent != - 1 ) : NEW_LINE INDENT dist [ node ] [ 0 ] = cost NEW_LINE DEDENT for i in range ( 1 , lg ) : NEW_LINE INDENT if ( lca [ node ] [ i - 1 ] != - 1 ) : NEW_LINE INDENT lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] NEW_LINE dist [ node ] [ i ] = ( dist [ node ] [ i - 1 ] + dist [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in graph [ node ] : NEW_LINE INDENT if ( i [ 0 ] == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( i [ 0 ] , node , h + 1 , i [ 1 ] ) NEW_LINE DEDENT DEDENT def findDistance ( u , v ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( level [ u ] > level [ v ] ) : NEW_LINE INDENT temp = u NEW_LINE u = v NEW_LINE v = temp NEW_LINE DEDENT i = lg - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( lca [ v ] [ i ] != - 1 and level [ lca [ v ] [ i ] ] >= level [ u ] ) : NEW_LINE INDENT ans += dist [ v ] [ i ] NEW_LINE v = lca [ v ] [ i ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( v == u ) : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT i = lg - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( lca [ v ] [ i ] != lca [ u ] [ i ] ) : NEW_LINE INDENT ans += dist [ u ] [ i ] + dist [ v ] [ i ] NEW_LINE v = lca [ v ] [ i ] NEW_LINE u = lca [ u ] [ i ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT ans += ( dist [ u ] [ 0 ] + dist [ v ] [ 0 ] ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE addEdge ( 1 , 2 , 2 ) NEW_LINE addEdge ( 1 , 3 , 3 ) NEW_LINE addEdge ( 2 , 4 , 5 ) NEW_LINE addEdge ( 2 , 5 , 7 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( lg ) : NEW_LINE INDENT lca [ i ] [ j ] = - 1 NEW_LINE dist [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT dfs ( 1 , - 1 , 0 , 0 ) NEW_LINE findDistance ( 1 , 3 ) NEW_LINE findDistance ( 2 , 3 ) NEW_LINE findDistance ( 3 , 5 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find distance between two nodes in the given Binary tree for Q queries | Python3 Program to find distance between two nodes using LCA ; lg2 ( MAX ) ; Array to store the level of each node ; Vector to store tree ; Pre - Processing to calculate values of lca [ ] [ ] , dist [ ] [ ] ; Using recursion formula to calculate the values of lca [ ] [ ] ; Storing the level of each node ; Using recursion formula to calculate the values of lca [ ] [ ] and dist [ ] [ ] ; Function to find the distance between given nodes u and v ; The node which is present farthest from the root node is taken as v . If u is farther from root node then swap the two ; Finding the ancestor of v which is at same level as u ; Adding distance of node v till its 2 ^ i - th ancestor ; If u is the ancestor of v then u is the LCA of u and v ; Finding the node closest to the root which is not the common ancestor of u and v i . e . a node x such that x is not the common ancestor of u and v but lca [ x ] [ 0 ] is ; Adding the distance of v and u to its 2 ^ i - th ancestor ; Adding the distance of u and v to its first ancestor ; Driver Code ; Number of nodes ; Add edges with their cost ; Initialising lca and dist values with - 1 and 0 respectively ; Perform DFS ; Query 1 : { 1 , 3 } ; Query 2 : { 2 , 3 } ; Query 3 : { 3 , 5 }",
        "Category": "Binary Tree"
    },
    {
        "ID": "2683-2683",
        "Code": "import sys NEW_LINE MAX = 1000 NEW_LINE log = 10 NEW_LINE level = [ 0 for i in range ( MAX ) ] ; NEW_LINE lca = [ [ - 1 for j in range ( log ) ] for i in range ( MAX ) ] NEW_LINE minWeight = [ [ sys . maxsize for j in range ( log ) ] for i in range ( MAX ) ] NEW_LINE maxWeight = [ [ - sys . maxsize for j in range ( log ) ] for i in range ( MAX ) ] NEW_LINE graph = [ [ ] for i in range ( MAX ) ] NEW_LINE weight = [ 0 for i in range ( MAX ) ] NEW_LINE def addEdge ( u , v ) : NEW_LINE INDENT graph [ u ] . append ( v ) ; NEW_LINE graph [ v ] . append ( u ) ; NEW_LINE DEDENT def dfs ( node , parent , h ) : NEW_LINE INDENT lca [ node ] [ 0 ] = parent ; NEW_LINE level [ node ] = h ; NEW_LINE if ( parent != - 1 ) : NEW_LINE INDENT minWeight [ node ] [ 0 ] = ( min ( weight [ node ] , weight [ parent ] ) ) ; NEW_LINE maxWeight [ node ] [ 0 ] = ( max ( weight [ node ] , weight [ parent ] ) ) ; NEW_LINE DEDENT for i in range ( 1 , log ) : NEW_LINE INDENT if ( lca [ node ] [ i - 1 ] != - 1 ) : NEW_LINE INDENT lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; NEW_LINE minWeight [ node ] [ i ] = min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; NEW_LINE maxWeight [ node ] [ i ] = max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; NEW_LINE DEDENT DEDENT for i in graph [ node ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dfs ( i , node , h + 1 ) ; NEW_LINE DEDENT DEDENT def findMinMaxWeight ( u , v ) : NEW_LINE INDENT minWei = sys . maxsize NEW_LINE maxWei = - sys . maxsize NEW_LINE if ( level [ u ] > level [ v ] ) : NEW_LINE INDENT u , v = v , u NEW_LINE DEDENT for i in range ( log - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( lca [ v ] [ i ] != - 1 and level [ lca [ v ] [ i ] ] >= level [ u ] ) : NEW_LINE INDENT minWei = min ( minWei , minWeight [ v ] [ i ] ) ; NEW_LINE maxWei = max ( maxWei , maxWeight [ v ] [ i ] ) ; NEW_LINE v = lca [ v ] [ i ] ; NEW_LINE DEDENT DEDENT if ( v == u ) : NEW_LINE INDENT print ( str ( minWei ) + ' ▁ ' + str ( maxWei ) ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( log - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( lca [ v ] [ i ] != lca [ u ] [ i ] ) : NEW_LINE INDENT minWei = ( min ( minWei , min ( minWeight [ v ] [ i ] , minWeight [ u ] [ i ] ) ) ) ; NEW_LINE maxWei = max ( maxWei , max ( maxWeight [ v ] [ i ] , maxWeight [ u ] [ i ] ) ) ; NEW_LINE v = lca [ v ] [ i ] ; NEW_LINE u = lca [ u ] [ i ] ; NEW_LINE DEDENT DEDENT minWei = min ( minWei , min ( minWeight [ v ] [ 0 ] , minWeight [ u ] [ 0 ] ) ) ; NEW_LINE maxWei = max ( maxWei , max ( maxWeight [ v ] [ 0 ] , maxWeight [ u ] [ 0 ] ) ) ; NEW_LINE print ( str ( minWei ) + ' ▁ ' + str ( maxWei ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE addEdge ( 1 , 2 ) ; NEW_LINE addEdge ( 1 , 5 ) ; NEW_LINE addEdge ( 2 , 4 ) ; NEW_LINE addEdge ( 2 , 3 ) ; NEW_LINE weight [ 1 ] = - 1 ; NEW_LINE weight [ 2 ] = 5 ; NEW_LINE weight [ 3 ] = - 1 ; NEW_LINE weight [ 4 ] = 3 ; NEW_LINE weight [ 5 ] = - 2 ; NEW_LINE dfs ( 1 , - 1 , 0 ) ; NEW_LINE findMinMaxWeight ( 1 , 3 ) ; NEW_LINE findMinMaxWeight ( 2 , 4 ) ; NEW_LINE findMinMaxWeight ( 3 , 5 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Query to find the maximum and minimum weight between two nodes in the given tree using LCA . | Python3 Program to find the maximum and minimum weight between two nodes in the given tree using LCA ; log2 ( MAX ) ; Array to store the level of each node ; Vector to store tree ; Array to store weight of nodes ; Pre - Processing to calculate values of lca [ ] [ ] , MinWeight [ ] [ ] and MaxWeight [ ] [ ] ; Using recursion formula to calculate the values of lca [ ] [ ] ; Storing the level of each node ; Using recursion formula to calculate the values of lca [ ] [ ] , MinWeight [ ] [ ] and MaxWeight [ ] [ ] ; Function to find the minimum and maximum weights in the given range ; The node which is present farthest from the root node is taken as v If u is farther from root node then swap the two ; Finding the ancestor of v which is at same level as u ; Calculating Minimum and Maximum Weight of node v till its 2 ^ i - th ancestor ; If u is the ancestor of v then u is the LCA of u and v ; Finding the node closest to the root which is not the common ancestor of u and v i . e . a node x such that x is not the common ancestor of u and v but lca [ x ] [ 0 ] is ; Calculating the minimum of MinWeight of v to its 2 ^ i - th ancestor and MinWeight of u to its 2 ^ i - th ancestor ; Calculating the maximum of MaxWeight of v to its 2 ^ i - th ancestor and MaxWeight of u to its 2 ^ i - th ancestor ; Calculating the Minimum of first ancestor of u and v ; Calculating the maximum of first ancestor of u and v ; Driver code ; Number of nodes ; Add edges ; Perform DFS ; Query 1 : { 1 , 3 } ; Query 2 : { 2 , 4 } ; Query 3 : { 3 , 5 }",
        "Category": "Graph Theory"
    },
    {
        "ID": "2690-2690",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE return node NEW_LINE DEDENT def getPath ( root , arr , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( getPath ( root . left , arr , x ) or getPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( ) NEW_LINE return False NEW_LINE DEDENT def sumOddNodes ( root , n1 , n2 ) : NEW_LINE INDENT path1 = [ ] NEW_LINE path2 = [ ] NEW_LINE getPath ( root , path1 , n1 ) NEW_LINE getPath ( root , path2 , n2 ) NEW_LINE intersection = - 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i != len ( path1 ) or j != len ( path2 ) ) : NEW_LINE INDENT if ( i == j and path1 [ i ] == path2 [ j ] ) : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT intersection = j - 1 NEW_LINE break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE i = len ( path1 ) - 1 NEW_LINE while ( i > intersection ) : NEW_LINE INDENT if ( path1 [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += path1 [ i ] NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = intersection NEW_LINE while ( i < len ( path2 ) ) : NEW_LINE INDENT if ( path2 [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += path2 [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE node1 = 5 NEW_LINE node2 = 6 NEW_LINE print ( sumOddNodes ( root , node1 , node2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of all odd nodes in the path connecting two given nodes | Binary Tree node ; Utitlity function to create a Binary Tree node ; Function to check if there is a path from root to the given node . It also populates arr ' with the given path ; if root is None there is no path ; push the node ' s ▁ value ▁ in ▁ ' arr ; if it is the required node return True ; else check whether the required node lies in the left subtree or right subtree of the current node ; required node does not lie either in the left or right subtree of the current node Thus , remove current node ' s ▁ value ▁ from ▁ ▁ ' arr 'and then return False ; Function to get the sum of odd nodes in the path between any two nodes in a binary tree ; vector to store the path of first node n1 from root ; vector to store the path of second node n2 from root ; Get intersection point ; Keep moving forward until no intersection is found ; calculate sum of ODD nodes from the path ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2691-2691",
        "Code": "MAX = 1000 NEW_LINE def findLCA ( n1 , n2 , parent ) : NEW_LINE INDENT visited = [ False for i in range ( MAX ) ] NEW_LINE visited [ n1 ] = True NEW_LINE while ( parent [ n1 ] != - 1 ) : NEW_LINE INDENT visited [ n1 ] = True NEW_LINE n1 = parent [ n1 ] NEW_LINE DEDENT visited [ n1 ] = True NEW_LINE while ( visited [ n2 ] == False ) : NEW_LINE INDENT n2 = parent [ n2 ] NEW_LINE DEDENT return n2 NEW_LINE DEDENT def insertAdj ( parent , i , j ) : NEW_LINE INDENT parent [ i ] = j NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT parent = [ 0 for i in range ( MAX ) ] NEW_LINE parent [ 20 ] = - 1 NEW_LINE insertAdj ( parent , 8 , 20 ) NEW_LINE insertAdj ( parent , 22 , 20 ) NEW_LINE insertAdj ( parent , 4 , 8 ) NEW_LINE insertAdj ( parent , 12 , 8 ) NEW_LINE insertAdj ( parent , 10 , 12 ) NEW_LINE insertAdj ( parent , 14 , 12 ) NEW_LINE print ( findLCA ( 10 , 14 , parent ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lowest Common Ancestor in Parent Array Representation | Maximum value in a node ; Function to find the Lowest common ancestor ; Create a visited vector and mark all nodes as not visited . ; Moving from n1 node till root and mark every accessed node as visited ; Move to the parent of node n1 ; For second node finding the first node common ; Insert function for Binary tree ; Driver Code ; Maximum capacity of binary tree ; Root marked",
        "Category": "Binary Tree"
    },
    {
        "ID": "27-27",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT next = None NEW_LINE def populateNext ( node ) : NEW_LINE INDENT populateNextRecur ( node , next ) NEW_LINE DEDENT def populateNextRecur ( p , next_ref ) : NEW_LINE INDENT if ( p != None ) : NEW_LINE INDENT populateNextRecur ( p . right , next_ref ) NEW_LINE p . next = next_ref NEW_LINE next_ref = p NEW_LINE populateNextRecur ( p . left , next_ref ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Populate Inorder Successor for all nodes | Python3 program to populate inorder traversal of all nodes ; A wrapper over populateNextRecur ; The first visited node will be the rightmost node next of the rightmost node will be NULL ; Set next of all descendants of p by traversing them in reverse Inorder ; First set the next pointer in right subtree ; Set the next as previously visited node in reverse Inorder ; Change the prev for subsequent node ; Finally , set the next pointer in right subtree",
        "Category": "Binary Tree"
    },
    {
        "ID": "2701-2701",
        "Code": "V = 5 NEW_LINE WHITE = 1 NEW_LINE BLACK = 2 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class subset : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . parent = 0 NEW_LINE self . rank = 0 NEW_LINE self . ancestor = 0 NEW_LINE self . child = 0 NEW_LINE self . sibling = 0 NEW_LINE self . color = 0 NEW_LINE DEDENT DEDENT class Query : NEW_LINE INDENT def __init__ ( self , L , R ) : NEW_LINE INDENT self . L = L NEW_LINE self . R = R NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( ) NEW_LINE node . data = data NEW_LINE node . left = node . right = None NEW_LINE return ( node ) NEW_LINE DEDENT def makeSet ( subsets , i ) : NEW_LINE INDENT if ( i < 1 or i > V ) : NEW_LINE INDENT return NEW_LINE DEDENT subsets [ i ] . color = WHITE NEW_LINE subsets [ i ] . parent = i NEW_LINE subsets [ i ] . rank = 0 NEW_LINE return NEW_LINE DEDENT def findSet ( subsets , i ) : NEW_LINE INDENT if ( subsets [ i ] . parent != i ) : NEW_LINE INDENT subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) NEW_LINE DEDENT return subsets [ i ] . parent NEW_LINE DEDENT def unionSet ( subsets , x , y ) : NEW_LINE INDENT xroot = findSet ( subsets , x ) NEW_LINE yroot = findSet ( subsets , y ) NEW_LINE if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) : NEW_LINE INDENT subsets [ xroot ] . parent = yroot NEW_LINE DEDENT elif ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) : NEW_LINE INDENT subsets [ yroot ] . parent = xroot NEW_LINE DEDENT else : NEW_LINE INDENT subsets [ yroot ] . parent = xroot NEW_LINE ( subsets [ xroot ] . rank ) += 1 NEW_LINE DEDENT DEDENT def lcaWalk ( u , q , m , subsets ) : NEW_LINE INDENT makeSet ( subsets , u ) NEW_LINE subsets [ findSet ( subsets , u ) ] . ancestor = u NEW_LINE child = subsets [ u ] . child NEW_LINE while ( child != 0 ) : NEW_LINE INDENT lcaWalk ( child , q , m , subsets ) NEW_LINE unionSet ( subsets , u , child ) NEW_LINE subsets [ findSet ( subsets , u ) ] . ancestor = u NEW_LINE child = subsets [ child ] . sibling NEW_LINE DEDENT subsets [ u ] . color = BLACK NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( q [ i ] . L == u ) : NEW_LINE INDENT if ( subsets [ q [ i ] . R ] . color == BLACK ) : NEW_LINE INDENT print ( \" LCA ( % d ▁ % d ) ▁ - > ▁ % d \" % ( q [ i ] . L , q [ i ] . R , subsets [ findSet ( subsets , q [ i ] . R ) ] . ancestor ) ) NEW_LINE DEDENT DEDENT elif ( q [ i ] . R == u ) : NEW_LINE INDENT if ( subsets [ q [ i ] . L ] . color == BLACK ) : NEW_LINE INDENT print ( \" LCA ( % d ▁ % d ) ▁ - > ▁ % d \" % ( q [ i ] . L , q [ i ] . R , subsets [ findSet ( subsets , q [ i ] . L ) ] . ancestor ) ) NEW_LINE DEDENT DEDENT DEDENT return NEW_LINE DEDENT def preprocess ( node , subsets ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT preprocess ( node . left , subsets ) NEW_LINE if ( node . left != None and node . right != None ) : NEW_LINE INDENT subsets [ node . data ] . child = node . left . data NEW_LINE subsets [ node . left . data ] . sibling = node . right . data NEW_LINE DEDENT elif ( ( node . left != None and node . right == None ) or ( node . left == None and node . right != None ) ) : NEW_LINE INDENT if ( node . left != None and node . right == None ) : NEW_LINE INDENT subsets [ node . data ] . child = node . left . data NEW_LINE DEDENT else : NEW_LINE INDENT subsets [ node . data ] . child = node . right . data NEW_LINE DEDENT DEDENT preprocess ( node . right , subsets ) NEW_LINE DEDENT def initialise ( subsets ) : NEW_LINE INDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT subsets [ i ] . color = WHITE NEW_LINE DEDENT return NEW_LINE DEDENT def printLCAs ( root , q , m ) : NEW_LINE INDENT subsets = [ subset ( ) for _ in range ( V + 1 ) ] NEW_LINE initialise ( subsets ) NEW_LINE preprocess ( root , subsets ) NEW_LINE lcaWalk ( root . data , q , m , subsets ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE q = [ Query ( 5 , 4 ) , Query ( 1 , 3 ) , Query ( 2 , 3 ) ] NEW_LINE m = len ( q ) NEW_LINE printLCAs ( root , q , m ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Tarjan 's off | Number of nodes in input tree ; COLOUR ' WHITE ' is assigned value 1 ; COLOUR ' BLACK ' is assigned value 2 ; A binary tree node has data , pointer to left child and a pointer to right child ; subset [ i ] . parent - . Holds the parent of node - ' i ' subset [ i ] . rank - . Holds the rank of node - ' i ' subset [ i ] . ancestor - . Holds the LCA queries answers subset [ i ] . child - . Holds one of the child of node - ' i ' if present , else - '0' subset [ i ] . sibling - . Holds the right - sibling of node - ' i ' if present , else - '0' subset [ i ] . color - . Holds the colour of node - ' i ' ; Structure to represent a query A query consists of ( L , R ) and we will process the queries offline a / c to Tarjan 's oflline LCA algorithm ; Helper function that allocates a new node with the given data and None left and right pointers . ; A utility function to make set ; A utility function to find set of an element i ( uses path compression technique ) ; Find root and make root as parent of i ( path compression ) ; A function that does union of two sets of x and y ( uses union by rank ) ; Attach smaller rank tree under root of high rank tree ( Union by Rank ) ; If ranks are same , then make one as root and increment its rank by one ; The main function that prints LCAs . u is root 's data. m is size of q[] ; Make Sets ; Initially , each node 's ancestor is the node  itself. ; This while loop doesn 't run for more than 2 times  as there can be at max. two children of a node ; This is basically an inorder traversal and we preprocess the arrays . child [ ] and sibling [ ] in \" struct ▁ subset \" with the tree structure using this function . ; Recur on left child ; Note that the below two lines can also be this - subsets [ node . data ] . child = node . right . data ; subsets [ node . right . data ] . sibling = node . left . data ; This is because if both left and right children of node - ' i ' are present then we can store any of them in subsets [ i ] . child and correspondingly its sibling ; Recur on right child ; A function to initialise prior to pre - processing and LCA walk ; Initialising the structure with 0 's  memset(subsets, 0, (V+1) * sizeof(struct subset)); ; Prints LCAs for given queries q [ 0. . m - 1 ] in a tree with given root ; Allocate memory for V subsets and nodes ; Creates subsets and colors them WHITE ; Preprocess the tree ; Perform a tree walk to process the LCA queries offline ; Driver code ; We construct a binary tree : - 1 / \\ 2 3 / \\ 4 5 ; LCA Queries to answer",
        "Category": "Graph Theory"
    },
    {
        "ID": "2706-2706",
        "Code": "def NimGame ( N , A , B ) : NEW_LINE INDENT sum = A + B NEW_LINE if ( N % sum <= A - 1 ) : NEW_LINE INDENT return \" Bob \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Alice \" NEW_LINE DEDENT DEDENT N = 3 NEW_LINE A = 1 NEW_LINE B = 2 NEW_LINE print ( NimGame ( N , A , B ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find winner in game of N balls , in which a player can remove any balls in range [ A , B ] in a single move | Function to find the winner of the game ; Stores sum of A and B ; If N is of the form m * ( A + B ) + y ; Otherwise , ; Input ; Function call",
        "Category": "Math"
    },
    {
        "ID": "271-271",
        "Code": "from queue import Queue NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def heightoftree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT left = heightoftree ( root . left ) NEW_LINE right = heightoftree ( root . right ) NEW_LINE if left > right : NEW_LINE INDENT return left + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return right + 1 NEW_LINE DEDENT DEDENT def printPerLevelMinimum ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( root ) NEW_LINE q . put ( None ) NEW_LINE Min = 9999999999999 NEW_LINE level = 0 NEW_LINE while ( q . empty ( ) == False ) : NEW_LINE INDENT node = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( node == None ) : NEW_LINE INDENT print ( \" level \" , level , \" min ▁ is ▁ = \" , Min ) NEW_LINE if ( q . empty ( ) ) : NEW_LINE INDENT break NEW_LINE DEDENT q . put ( None ) NEW_LINE level += 1 NEW_LINE Min = 999999999999 NEW_LINE continue NEW_LINE DEDENT if ( Min > node . data ) : NEW_LINE INDENT Min = node . data NEW_LINE DEDENT if ( node . left != None ) : NEW_LINE INDENT q . put ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . put ( node . right ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 6 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( \" Every ▁ Level ▁ minimum ▁ is \" ) NEW_LINE printPerLevelMinimum ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest value in each level of Binary Tree | Python3 program to prminimum element in each level of binary tree . Importing Queue ; Utility class to create a new tree node ; return height of tree p ; Iterative method to find every level minimum element of Binary Tree ; Base Case ; Create an empty queue for level order traversal ; put the root for Change the level ; for go level by level ; for check the level ; Get get of queue ; if node == None ( Means this is boundary between two levels ) ; here queue is empty represent no element in the actual queue ; increment level ; Reset min for next level minimum value ; get Minimum in every level ; Enqueue left child ; Enqueue right child ; Driver Code ; Let us create binary tree shown in above diagram ; 7 / \\ 6 5 / \\ / \\ 4 3 2 1",
        "Category": "Binary Tree"
    },
    {
        "ID": "2715-2715",
        "Code": "import math NEW_LINE def checkPascaltriangle ( N ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * N + 1 ) - 1 ) / 2 NEW_LINE if ( math . ceil ( x ) - x == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE checkPascaltriangle ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Check if Pascal 's Triangle is possible with a complete layer by using numbers upto N | Python3 program for the above approach ; Function to check if Pascaltriangle can be made by N integers ; Find X ; If x is integer ; Given number N ; Function call",
        "Category": "Math"
    },
    {
        "ID": "2717-2717",
        "Code": "def findCountRooks ( row , col , n , k ) : NEW_LINE INDENT res = n - k NEW_LINE print ( res ) NEW_LINE ri = 0 NEW_LINE ci = 0 NEW_LINE while ( res > 0 ) : NEW_LINE INDENT while ( ri < k and row [ ri ] == 1 ) : NEW_LINE INDENT ri += 1 NEW_LINE DEDENT while ( ci < k and col [ ci ] == 1 ) : NEW_LINE INDENT ci += 1 NEW_LINE DEDENT print ( ( ri + 1 ) , \" \" , ( ci + 1 ) ) NEW_LINE ri += 1 NEW_LINE ci += 1 NEW_LINE res -= 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE k = 2 NEW_LINE row = [ 1 , 2 ] NEW_LINE col = [ 4 , 2 ] NEW_LINE findCountRooks ( row , col , n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find position of non | Function to find the count of placing non - attacking rooks on the N x N chessboard ; Count of the Non - attacking rooks ; Printing lexographically smallest configuration ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "272-272",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getLevelUtil ( node , data , level ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( node . data == data ) : NEW_LINE INDENT return level NEW_LINE DEDENT downlevel = getLevelUtil ( node . left , data , level + 1 ) NEW_LINE if ( downlevel != 0 ) : NEW_LINE INDENT return downlevel NEW_LINE DEDENT downlevel = getLevelUtil ( node . right , data , level + 1 ) NEW_LINE return downlevel NEW_LINE DEDENT def getLevel ( node , data ) : NEW_LINE INDENT return getLevelUtil ( node , data , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 3 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE for x in range ( 1 , 6 ) : NEW_LINE INDENT level = getLevel ( root , x ) NEW_LINE if ( level ) : NEW_LINE INDENT print ( \" Level ▁ of \" , x , \" is \" , getLevel ( root , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , \" is ▁ not ▁ present ▁ in ▁ tree \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Get Level of a node in a Binary Tree | Python3 program to Get Level of a node in a Binary Tree Helper function that allocates a new node with the given data and None left and right pairs . ; Constructor to create a new node ; Helper function for getLevel ( ) . It returns level of the data if data is present in tree , otherwise returns 0 ; Returns level of given data value ; Driver Code ; Let us construct the Tree shown in the above figure",
        "Category": "Binary Tree"
    },
    {
        "ID": "2721-2721",
        "Code": "import math NEW_LINE def countNo ( A , N , L , R ) : NEW_LINE INDENT ans = L - 1 + N + math . floor ( ( N - 1 ) / ( A - 1 ) ) NEW_LINE if ans % A == 0 : NEW_LINE INDENT ans = ans + 1 ; NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT / * Driver Code * / NEW_LINE A , N , L , R = 5 , 10 , 4 , 20 NEW_LINE countNo ( A , N , L , R ) NEW_LINE",
        "Type": "py",
        "NL": "Find Nth number in a sequence which is not a multiple of a given number | Python3 program for the above approach ; Function to find Nth number not a multiple of A in range [ L , R ] ; Calculate the Nth no ; Check for the edge case ;  ; Input parameters ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "2724-2724",
        "Code": "def maxProfit ( prices , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rest = [ 0 ] * n NEW_LINE hold = [ 0 ] * n NEW_LINE sold = [ 0 ] * n NEW_LINE rest [ 0 ] = 0 NEW_LINE hold [ 0 ] = - prices [ 0 ] NEW_LINE sold [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rest [ i ] = max ( rest [ i - 1 ] , sold [ i - 1 ] ) NEW_LINE hold [ i ] = max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) NEW_LINE sold [ i ] = hold [ i - 1 ] + prices [ i ] NEW_LINE DEDENT return max ( rest [ n - 1 ] , sold [ n - 1 ] ) NEW_LINE DEDENT price = [ 2 , 4 , 5 , 0 , 2 ] NEW_LINE n = len ( price ) NEW_LINE print ( maxProfit ( price , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize profit in buying and selling stocks with Rest condition | Python3 program for the above problem ; If there is only one day for buying and selling no profit can be made ; Array to store Maxprofit by resting on given day ; Array to store Maxprofit by buying or resting on the given day ; Array to store Maxprofit by selling on given day ; Initially there will 0 profit ; Buying on 1 st day results in negative profit ; zero profit since selling before buying isn 't possible ; max of profit on ( i - 1 ) th day by resting and profit on ( i - 1 ) th day by selling . ; max of profit by resting on ith day and buying on ith day . ; max of profit by selling on ith day ; maxprofit ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "2725-2725",
        "Code": "def compute ( query ) : NEW_LINE INDENT v = [ None ] * 100001 NEW_LINE dp = [ None ] * 100001 NEW_LINE v [ 1 ] = 1 NEW_LINE v [ 2 ] = 0 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = 0 NEW_LINE for i in range ( 3 , 100001 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT if ( ( i // 2 ) % 2 == 0 ) : NEW_LINE INDENT v [ i ] = 1 NEW_LINE dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT v [ i ] = v [ i // 2 ] + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT v [ i ] = 0 NEW_LINE dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT DEDENT for x in query : NEW_LINE INDENT print ( dp [ x ] ) NEW_LINE DEDENT DEDENT query = [ 5 , 2 ] NEW_LINE compute ( query ) NEW_LINE",
        "Type": "py",
        "NL": "Count of paths in given Binary Tree with odd bitwise AND for Q queries | Function to count number of paths in binary tree such that bitwise AND of all nodes is Odd ; vector dp to store the count of bitwise odd paths till that vertex ; Precomputing for each value ; Check for odd value ; Number of odd elements will be + 1 till the parent node ; For even case ; Since node is even Number of odd elements will be 0 ; Even value node will not contribute in answer hence dp [ i ] = previous answer ; Printing the answer for each query ; Vector to store queries",
        "Category": "Binary Tree"
    },
    {
        "ID": "2733-2733",
        "Code": "factorial = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE def isStrong ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += factorial [ ord ( num [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT if sum == N : NEW_LINE return True NEW_LINE else : NEW_LINE return False NEW_LINE DEDENT def printStrongNumbers ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isStrong ( i ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1000 NEW_LINE printStrongNumbers ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all Strong numbers less than or equal to N | Store the factorial of all the digits from [ 0 , 9 ] ; Function to return true if number is strong or not ; Converting N to String so that can easily access all it 's digit ; sum will store summation of factorial of all digits of a number N ; Returns true of N is strong number ; Function to print all strong number till N ; Iterating from 1 to N ; Checking if a number is strong then print it ; Driver Code ; Given number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "2739-2739",
        "Code": "max_len = 100005 NEW_LINE cnt = [ 0 ] * max_len NEW_LINE def precompute ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT cnt [ i + 1 ] = cnt [ i ] NEW_LINE if s [ i : len ( K ) + i ] == K : NEW_LINE INDENT cnt [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ABCABCABABC \" NEW_LINE K = \" ABC \" NEW_LINE precompute ( s , K ) NEW_LINE Q = [ [ 1 , 6 ] , [ 5 , 11 ] ] NEW_LINE for it in Q : NEW_LINE INDENT print ( cnt [ it [ 1 ] - 1 ] - cnt [ it [ 0 ] - 1 ] ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Queries to find frequencies of a string within specified substrings | Python3 Program to find frequency of a string K in a substring [ L , R ] in S ; Store the frequency of string for each index ; Compute and store frequencies for every index ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "2742-2742",
        "Code": "def getXOR ( BITree , index ) : NEW_LINE INDENT ans = 0 NEW_LINE index += 1 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT ans ^= BITree [ index ] NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT index = index + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BITree [ index ] ^= val NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def constructBITree ( arr , n ) : NEW_LINE INDENT BITree = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT updateBIT ( BITree , n , i , arr [ i ] ) NEW_LINE DEDENT return BITree NEW_LINE DEDENT def rangeXor ( BITree , l , r ) : NEW_LINE INDENT return ( getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 1 , 1 , 3 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( A ) NEW_LINE q = [ [ 1 , 0 , 9 ] , [ 2 , 3 , 6 ] , [ 2 , 5 , 5 ] , [ 2 , 8 , 1 ] , [ 1 , 0 , 9 ] ] NEW_LINE BITree = constructBITree ( A , n ) NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT id = q [ i ] [ 0 ] NEW_LINE if ( id == 1 ) : NEW_LINE INDENT L = q [ i ] [ 1 ] NEW_LINE R = q [ i ] [ 2 ] NEW_LINE print ( \" XOR ▁ of ▁ elements ▁ in ▁ \" \" given ▁ range ▁ is ▁ \" , rangeXor ( BITree , L , R ) ) NEW_LINE DEDENT else : NEW_LINE INDENT idx = q [ i ] [ 1 ] NEW_LINE val = q [ i ] [ 2 ] NEW_LINE A [ idx ] ^= val NEW_LINE updateBIT ( BITree , n , idx , val ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "XOR of elements in a given range with updates using Fenwick Tree | Returns XOR of arr [ 0. . index ] . This function assumes that the array is preprocessed and partial XORs of array elements are stored in BITree [ ] . ; Traverse ancestors of BITree [ index ] ; XOR current element of BIT to ans ; Update index to that of the parent node in getXor ( ) view by subtracting LSB ( Least Significant Bit ) ; Updates the Binary Index Tree by replacing all ancestors of index by their respective XOR with val ; Traverse all ancestors and XOR with ' val ' . ; XOR ' val ' to current node of BIT ; Update index to that of the parent node in updateBit ( ) view by adding LSB ( Least Significant Bit ) ; Constructs and returns a Binary Indexed Tree for the given array ; Create and initialize the Binary Indexed Tree ; Store the actual values in BITree [ ] using update ( ) ; Driver Code ; Create the Binary Indexed Tree ; Solve each query in Q ; Update the values of all ancestors of idx",
        "Category": "Binary Tree"
    },
    {
        "ID": "275-275",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def largestSubtreeUtil ( root , Str , maxSize , maxNode ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT left = [ \" \" ] NEW_LINE right = [ \" \" ] NEW_LINE ls = largestSubtreeUtil ( root . left , left , maxSize , maxNode ) NEW_LINE rs = largestSubtreeUtil ( root . right , right , maxSize , maxNode ) NEW_LINE size = ls + rs + 1 NEW_LINE if ( left [ 0 ] == right [ 0 ] ) : NEW_LINE INDENT if ( size > maxSize [ 0 ] ) : NEW_LINE INDENT maxSize [ 0 ] = size NEW_LINE maxNode [ 0 ] = root NEW_LINE DEDENT DEDENT Str [ 0 ] = Str [ 0 ] + \" | \" + left [ 0 ] + \" | \" NEW_LINE Str [ 0 ] = Str [ 0 ] + \" | \" + str ( root . data ) + \" | \" NEW_LINE Str [ 0 ] = Str [ 0 ] + \" | \" + right [ 0 ] + \" | \" NEW_LINE return size NEW_LINE DEDENT def largestSubtree ( node , maxNode ) : NEW_LINE INDENT maxSize = [ 0 ] NEW_LINE Str = [ \" \" ] NEW_LINE largestSubtreeUtil ( node , Str , maxSize , maxNode ) NEW_LINE return maxSize NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 50 ) NEW_LINE root . left = newNode ( 10 ) NEW_LINE root . right = newNode ( 60 ) NEW_LINE root . left . left = newNode ( 5 ) NEW_LINE root . left . right = newNode ( 20 ) NEW_LINE root . right . left = newNode ( 70 ) NEW_LINE root . right . left . left = newNode ( 65 ) NEW_LINE root . right . left . right = newNode ( 80 ) NEW_LINE root . right . right = newNode ( 70 ) NEW_LINE root . right . right . left = newNode ( 65 ) NEW_LINE root . right . right . right = newNode ( 80 ) NEW_LINE maxNode = [ None ] NEW_LINE maxSize = largestSubtree ( root , maxNode ) NEW_LINE print ( \" Largest ▁ Subtree ▁ is ▁ rooted ▁ at ▁ node ▁ \" , maxNode [ 0 ] . data ) NEW_LINE print ( \" and ▁ its ▁ size ▁ is ▁ \" , maxSize ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find largest subtree having identical left and right subtrees | Helper class that allocates a new node with the given data and None left and right pointers . ; Sets maxSize to size of largest subtree with identical left and right . maxSize is set with size of the maximum sized subtree . It returns size of subtree rooted with current node . This size is used to keep track of maximum size . ; string to store structure of left and right subtrees ; traverse left subtree and finds its size ; traverse right subtree and finds its size ; if left and right subtrees are similar update maximum subtree if needed ( Note that left subtree may have a bigger value than right and vice versa ) ; append left subtree data ; append current node data ; append right subtree data ; function to find the largest subtree having identical left and right subtree ; Driver Code ; Let us construct the following Tree 50 / \\ 10 60 / \\ / \\ 5 20 70 70 / \\ / \\ 65 80 65 80",
        "Category": "Binary Tree"
    },
    {
        "ID": "2751-2751",
        "Code": "def findSolution ( N ) : NEW_LINE INDENT if ( N % 4 != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = 0 NEW_LINE sum_odd = 0 NEW_LINE sum_even = 0 NEW_LINE result = [ 0 ] * N NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT temp += 2 NEW_LINE result [ i + 1 ] = temp NEW_LINE sum_even += result [ i + 1 ] NEW_LINE result [ i ] = temp - 1 NEW_LINE sum_odd += result [ i ] NEW_LINE DEDENT diff = sum_even - sum_odd NEW_LINE result [ N - 2 ] += diff NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( result [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 8 ; NEW_LINE findSolution ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Generate an array of given size with equal count and sum of odd and even numbers | Function to find the array such that the array contains the same count of even and odd elements with equal sum of even and odd elements ; Length of array which is not divisible by 4 is unable to form such array ; Loop to find the resulted array containing the same count of even and odd elements ; Find the total sum of even elements ; Find the total sum of odd elements ; Find the difference between the total sum of even and odd elements ; The difference will be added in the last odd element ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "2754-2754",
        "Code": "import math NEW_LINE def possiblePositions ( n ) : NEW_LINE INDENT term1 = pow ( n , 4 ) ; NEW_LINE term2 = pow ( n , 3 ) ; NEW_LINE term3 = pow ( n , 2 ) ; NEW_LINE term4 = n / 3 ; NEW_LINE ans = ( ( math . ceil ( term1 ) ) / 2 - ( math . ceil ( 5 * term2 ) ) / 3 + ( math . ceil ( 3 * term3 ) ) / 2 - term4 ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE ans = possiblePositions ( n ) NEW_LINE print ( int ( ans ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways to place two queens on a N * N chess | Python3 implementation to find the number of ways to place two queens on the N * N chess board ; Function to find number of valid positions for two queens in the N * N chess board ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "2763-2763",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def digitSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( num ) : NEW_LINE INDENT sum += ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def sumAndProduct ( head_ref ) : NEW_LINE INDENT prod = 1 NEW_LINE sum = 0 NEW_LINE ptr = head_ref NEW_LINE while ( ptr != None ) : NEW_LINE INDENT if ( not ( digitSum ( ptr . data ) & 1 ) ) : NEW_LINE INDENT prod *= ptr . data NEW_LINE sum += ptr . data NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT print ( \" Sum ▁ = \" , sum ) NEW_LINE print ( \" Product ▁ = \" , prod ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 13 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE sumAndProduct ( head ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum and Product of all even digit sum Nodes of a Singly Linked List | Node of Linked List ; Function to insert a node at the beginning of the singly Linked List ; Insert the data ; Link old list to the new node ; Move head to pothe new node ; Function to find the digit sum for a number ; Return the sum ; Function to find the required sum and product ; Initialise the sum and product to 0 and 1 respectively ; Traverse the given linked list ; If current node has even digit sum then include it in resultant sum and product ; Find the sum and the product ; Print the final Sum and Product ; Driver Code ; Head of the linked list ; Create the linked list 15 . 16 . 8 . 6 . 13 ; Function call",
        "Category": "Linked List"
    },
    {
        "ID": "2764-2764",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT def IsPossible ( a , b , x , y ) : NEW_LINE INDENT final = gcd ( x , y ) ; NEW_LINE initial = gcd ( a , b ) ; NEW_LINE if ( initial == final ) : NEW_LINE INDENT print ( \" POSSIBLE \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NOT ▁ POSSIBLE \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 1 ; B = 2 ; X = 4 ; Y = 11 ; NEW_LINE IsPossible ( A , B , X , Y ) ; NEW_LINE A = 2 ; B = 2 ; X = 3 ; Y = 6 ; NEW_LINE IsPossible ( A , B , X , Y ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Two Balls Reachability Game | Recursive function to return gcd of a and b ; Function returns if it 's possible to have X white and Y black balls or not. ; Finding gcd of ( x , y ) and ( a , b ) ; If gcd is same , it 's always  possible to reach (x, y) ; Here it 's never possible  if gcd is not same ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2766-2766",
        "Code": "mod = 1000000007 NEW_LINE def waysToColor ( arr , n , k ) : NEW_LINE INDENT global mod NEW_LINE powOf2 = [ 0 for i in range ( 500 ) ] NEW_LINE c = [ [ 0 for i in range ( 500 ) ] for j in range ( 500 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT c [ i ] [ 0 ] = 1 ; NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) % mod ; NEW_LINE DEDENT DEDENT powOf2 [ 0 ] = 1 NEW_LINE powOf2 [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT powOf2 [ i ] = ( powOf2 [ i - 1 ] * 2 ) % mod ; NEW_LINE DEDENT rem = n - k ; NEW_LINE arr [ k ] = n + 1 ; NEW_LINE k += 1 NEW_LINE arr . sort ( ) NEW_LINE answer = 1 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = 0 NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT x = arr [ i ] - arr [ i - 1 ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] - 1 NEW_LINE DEDENT answer = answer * ( c [ rem ] [ x ] % mod ) * ( ( powOf2 [ x ] if ( i != 0 and i != k - 1 ) else 1 ) ) % mod NEW_LINE rem -= x ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 ; NEW_LINE K = 3 ; NEW_LINE arr = [ 1 , 2 , 6 , 0 ] NEW_LINE print ( waysToColor ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways to color N | Python3 program for the above approach ; Function to count the ways to color block ; For storing powers of 2 ; For storing binomial coefficient values ; Calculating binomial coefficient using DP ; Calculating powers of 2 ; Sort the indices to calculate length of each section ; Initialise answer to 1 ; Find the length of each section ; Merge this section ; Return the final count ; Driver Code ; Number of blocks ; Number of colored blocks ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "2769-2769",
        "Code": "def SumGPUtil ( r , n , m ) : NEW_LINE INDENT if n == 0 : return 1 NEW_LINE if n == 1 : return ( 1 + r ) % m NEW_LINE if n % 2 == 1 : NEW_LINE INDENT ans = ( 1 + r ) * SumGPUtil ( r * r % m , ( n - 1 ) // 2 , m ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 + r * ( 1 + r ) * SumGPUtil ( r * r % m , n // 2 - 1 , m ) NEW_LINE DEDENT return ans % m NEW_LINE DEDENT def SumGP ( a , r , N , M ) : NEW_LINE INDENT answer = a * SumGPUtil ( r , N , M ) NEW_LINE answer = answer % M NEW_LINE print ( answer ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE a = 1 NEW_LINE r = 4 NEW_LINE N = 10000 NEW_LINE M = 100000 NEW_LINE INDENT SumGP ( a , r , N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of N | Function to calculate the sum recursively ; Base cases ; If n is odd ; If n is even ; Function to print the value of Sum ; Driver Program ; first element ; common difference ; Number of elements ; Mod value",
        "Category": "Math"
    },
    {
        "ID": "2779-2779",
        "Code": "def checkPermutation ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT prefix = [ 0 ] * ( n + 1 ) ; NEW_LINE prefix [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT lsum = prefix [ i ] ; NEW_LINE rsum = sum - prefix [ i ] ; NEW_LINE l_len = i + 1 NEW_LINE r_len = n - i - 1 ; NEW_LINE if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) and ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkPermutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a Sequence is a concatenation of two permutations | Function to Check if a given sequence is a concatenation of two permutations or not ; Computing the sum of all the elements in the array ; Computing the prefix sum for all the elements in the array ; Iterating through the i from lengths 1 to n - 1 ; Sum of first i + 1 elements ; Sum of remaining n - i - 1 elements ; Lengths of the 2 permutations ; Checking if the sums satisfy the formula or not ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "278-278",
        "Code": "INT_MAX = 2 ** 32 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def closestDown ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT if root . left is None and root . right is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + min ( closestDown ( root . left ) , closestDown ( root . right ) ) NEW_LINE DEDENT def findClosestUtil ( root , k , ancestors , index ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT if root . key == k : NEW_LINE INDENT res = closestDown ( root ) NEW_LINE for i in reversed ( range ( 0 , index ) ) : NEW_LINE INDENT res = min ( res , index - i + closestDown ( ancestors [ i ] ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT ancestors [ index ] = root NEW_LINE return min ( findClosestUtil ( root . left , k , ancestors , index + 1 ) , findClosestUtil ( root . right , k , ancestors , index + 1 ) ) NEW_LINE DEDENT def findClosest ( root , k ) : NEW_LINE INDENT ancestors = [ None for i in range ( 100 ) ] NEW_LINE return findClosestUtil ( root , k , ancestors , 0 ) NEW_LINE DEDENT root = Node ( ' A ' ) NEW_LINE root . left = Node ( ' B ' ) NEW_LINE root . right = Node ( ' C ' ) ; NEW_LINE root . right . left = Node ( ' E ' ) ; NEW_LINE root . right . right = Node ( ' F ' ) ; NEW_LINE root . right . left . left = Node ( ' G ' ) ; NEW_LINE root . right . left . left . left = Node ( ' I ' ) ; NEW_LINE root . right . left . left . right = Node ( ' J ' ) ; NEW_LINE root . right . right . right = Node ( ' H ' ) ; NEW_LINE root . right . right . right . left = Node ( ' K ' ) ; NEW_LINE k = ' H ' ; NEW_LINE print \" Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ \" + k + \" ▁ is \" , NEW_LINE print findClosest ( root , k ) NEW_LINE k = ' C ' NEW_LINE print \" Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ \" + k + \" ▁ is \" , NEW_LINE print findClosest ( root , k ) NEW_LINE k = ' E ' NEW_LINE print \" Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ \" + k + \" ▁ is \" , NEW_LINE print findClosest ( root , k ) NEW_LINE k = ' B ' NEW_LINE print \" Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ \" + k + \" ▁ is \" , NEW_LINE print findClosest ( root , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find the closest leaf in a Binary Tree | Python program to find closest leaf of a given key in binary tree ; A binary tree node ; A utility function to find distance of closest leaf of the tree rooted under given root ; Base Case ; Return minum of left and right plus one ; Returns destance of the closes leaf to a given key k The array ancestors us used to keep track of ancestors of current node and ' index ' is used to keep track of current index in 'ancestors[i]   ; Base Case ; if key found ; Find closest leaf under the subtree rooted with given key ; Traverse ll ancestors and update result if any parent node gives smaller distance ; if key node found , store current node and recur for left and right childrens ; The main function that return distance of the clses key to key '. It mainly uses recursive function findClosestUtil() to find the closes distance ; Create an arrray to store ancestors Assumption : Maximum height of tree is 100 ; Let us construct the BST shown in the above figure",
        "Category": "Binary Tree"
    },
    {
        "ID": "2784-2784",
        "Code": "MAXN = 1000005 ; NEW_LINE even = [ 0 ] * MAXN ; NEW_LINE odd = [ 0 ] * MAXN ; NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd [ i ] = 1 ; NEW_LINE DEDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even [ i ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] ; NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] ; NEW_LINE DEDENT DEDENT def isOdd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] ; NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= odd [ L - 1 ] ; NEW_LINE DEDENT if ( cnt == R - L + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def performQueries ( a , n , q , m ) : NEW_LINE INDENT precompute ( a , n ) ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT L = q [ i ] [ 0 ] ; NEW_LINE R = q [ i ] [ 1 ] ; NEW_LINE if ( isOdd ( L , R ) ) : NEW_LINE INDENT print ( \" Odd \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Even \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] ; NEW_LINE n = len ( a ) ; NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] ; NEW_LINE m = len ( q ) ; NEW_LINE performQueries ( a , n , q , m ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to check whether bitwise AND of a subarray is even or odd | Python implementation of the approach ; Function to precompute the count of even and odd numbers ; If the current element is odd then put 1 at odd [ i ] ; If the current element is even then put 1 at even [ i ] ; Taking the prefix sums of these two arrays so we can get the count of even and odd numbers in a range [ L , R ] in O ( 1 ) ; Function that returns True if the bitwise AND of the subarray a [ L ... R ] is odd ; cnt will store the count of odd numbers in the range [ L , R ] ; Check if all the numbers in the range are odd or not ; Function to perform the queries ; Perform queries ; Driver code ; Queries",
        "Category": "Math"
    },
    {
        "ID": "2791-2791",
        "Code": "import math NEW_LINE def getArea ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT a = 3 NEW_LINE print ( ' { 0 : . 6f } ' . format ( getArea ( a ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Area of the circle that has a square and a circle inscribed in it | Python3 implementation of the approach ; Function to return the required area ; Calculate the area ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2793-2793",
        "Code": "def PerformQueries ( a , vec ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE n = len ( a ) - 1 ; NEW_LINE q = len ( vec ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = vec [ i ] [ 0 ] ; NEW_LINE m = vec [ i ] [ 1 ] ; NEW_LINE if ( m > n ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT turn = t // n ; NEW_LINE rem = t % n ; NEW_LINE if ( rem == 0 and turn % 2 == 1 ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( rem == 0 and turn % 2 == 0 ) : NEW_LINE INDENT ans . append ( a [ m ] ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( turn % 2 == 0 ) : NEW_LINE INDENT cursize = n - rem ; NEW_LINE if ( cursize < m ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT ans . append ( a [ m + rem ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT cursize = rem ; NEW_LINE if ( cursize < m ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT ans . append ( a [ m ] ) ; NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE vec = [ [ 1 , 4 ] , [ 6 , 1 ] , [ 3 , 5 ] ] ; NEW_LINE PerformQueries ( a , vec ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries On Array with disappearing and reappearing elements | Function to perform the queries ; Size of the array with 1 - based indexing ; Number of queries ; Iterating through the queries ; If m is more than the size of the array ; Count of turns ; Find the remainder ; If the remainder is 0 and turn is odd then the array is empty ; If the remainder is 0 and turn is even then array is full and is in its initial state ; If the remainder is not 0 and the turn is even ; Current size of the array ; Current size of the array ; Print the result ; Driver code ; The initial array , - 1 is for 1 base indexing ; Queries in the form of the pairs of ( t , M )",
        "Category": "Array"
    },
    {
        "ID": "2795-2795",
        "Code": "def minSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1884 ; NEW_LINE print ( minSum ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize the sum of digits of A and B such that A + B = N | Function to return the minimum possible sum of digits of A and B such that A + B = n ; Find the sum of digits of n ; If num is a power of 10 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2797-2797",
        "Code": "def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return \" First \" ; NEW_LINE DEDENT return \" Second \" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GSSS \" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getWinner ( string , length ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Optimal Strategy for a Game | Special Gold Coin | Function to return the winner of the game ; To store the count of silver coins ; Update the position of the gold coin ; First player will win the game ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2798-2798",
        "Code": "MAX = 1000000000 ; NEW_LINE def findTriangle ( S ) : NEW_LINE INDENT X1 = 0 ; Y1 = 0 ; NEW_LINE X2 = MAX ; Y2 = 1 ; NEW_LINE X3 = ( MAX - S % MAX ) % MAX ; NEW_LINE Y3 = ( S + X3 ) / MAX ; NEW_LINE print ( \" ( \" , X1 , \" , \" , Y1 , \" ) \" ) ; NEW_LINE print ( \" ( \" , X2 , \" , \" , Y2 , \" ) \" ) ; NEW_LINE print ( \" ( \" , X3 , \" , \" , Y3 , \" ) \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 4 ; NEW_LINE findTriangle ( S ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the coordinates of a triangle whose Area = ( S / 2 ) | Python3 implementation of the approach ; Function to find the triangle with area = ( S / 2 ) ; Fix the two pairs of coordinates ; Find ( X3 , Y3 ) with integer coordinates ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2801-2801",
        "Code": "DIGITS = 10 ; NEW_LINE MAX = 10000 ; NEW_LINE MOD = 1000000007 ; NEW_LINE dp = [ [ 0 for i in range ( DIGITS ) ] for i in range ( MAX ) ] ; NEW_LINE cnt = [ [ 0 for i in range ( DIGITS ) ] for i in range ( MAX ) ] ; NEW_LINE def precompute ( ) : NEW_LINE INDENT for i in range ( DIGITS ) : NEW_LINE INDENT dp [ 1 ] [ i ] = i ; NEW_LINE cnt [ 1 ] [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT for j in range ( DIGITS ) : NEW_LINE INDENT for k in range ( DIGITS ) : NEW_LINE INDENT if ( j != k ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + ( dp [ i - 1 ] [ k ] + ( cnt [ i - 1 ] [ k ] * j ) % MOD ) % MOD ; NEW_LINE dp [ i ] [ j ] %= MOD ; NEW_LINE cnt [ i ] [ j ] += cnt [ i - 1 ] [ k ] ; NEW_LINE cnt [ i ] [ j ] %= MOD ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT x = 6 ; y = 4 ; NEW_LINE precompute ( ) ; NEW_LINE print ( dp [ x ] [ y ] ) ; NEW_LINE",
        "Type": "py",
        "NL": "Sum of Digits of the Good Strings | Python3 implementation of the approach ; To store the states of the dp ; Function to fill the dp table ; Sum of digits of the string of length 1 is i as i is only number in that string and count of good strings of length 1 that end with i is also 1 ; Adjacent digits are different ; Increment the count as digit at ( i - 1 ) 'th index is k and count  of good strings is equal to this  because at the end of the strings of  length (i - 1) we are just  putting digit j as the last digit ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "2805-2805",
        "Code": "def findMin ( N : int ) : NEW_LINE INDENT digit = N % 10 NEW_LINE if digit == 0 and N >= 90 : NEW_LINE INDENT return 10 NEW_LINE DEDENT elif digit == 1 and N >= 81 : NEW_LINE INDENT return 9 NEW_LINE DEDENT elif digit == 2 and N >= 72 : NEW_LINE INDENT return 8 NEW_LINE DEDENT elif digit == 3 and N >= 63 : NEW_LINE INDENT return 7 NEW_LINE DEDENT elif digit == 4 and N >= 54 : NEW_LINE INDENT return 6 NEW_LINE DEDENT elif digit == 5 and N >= 45 : NEW_LINE INDENT return 5 NEW_LINE DEDENT elif digit == 6 and N >= 36 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif digit == 7 and N >= 27 : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif digit == 8 and N >= 18 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif digit == 9 and N >= 9 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 27 NEW_LINE print ( findMin ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum numbers with one 's place as 9 to be added to get N | Function to find minimum count of numbers ( with one 's digit 9) that sum up to N ; Fetch one 's digit ; Apply Cases mentioned in approach ; If no possible answer exists ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2813-2813",
        "Code": "from math import gcd NEW_LINE def lcm ( x , y ) : NEW_LINE INDENT temp = ( x * y ) // gcd ( x , y ) ; NEW_LINE return temp ; NEW_LINE DEDENT def findNumbers ( a , n , b , m ) : NEW_LINE INDENT lcmA = 1 ; __gcdB = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT lcmA = lcm ( lcmA , a [ i ] ) ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT __gcdB = gcd ( __gcdB , b [ i ] ) ; NEW_LINE DEDENT if ( __gcdB % lcmA != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE DEDENT num = lcmA ; NEW_LINE while ( num <= __gcdB ) : NEW_LINE INDENT if ( __gcdB % num == 0 ) : NEW_LINE INDENT print ( num , end = \" ▁ \" ) ; NEW_LINE DEDENT num += lcmA ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 2 , 4 ] ; NEW_LINE b = [ 16 , 32 , 64 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE findNumbers ( a , n , b , m ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find numbers which are multiples of first array and factors of second array | Python3 implementation of the approach ; Function to return the LCM of two numbers ; Function to print the required numbers ; To store the lcm of array a [ ] elements and the gcd of array b [ ] elements ; Finding LCM of first array ; Finding GCD of second array ; No such element exists ; All the multiples of lcmA which are less than or equal to gcdB and evenly divide gcdB will satisfy the conditions ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2815-2815",
        "Code": "def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( \" Even \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( \" Odd \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkEvenOdd ( arr , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether bitwise AND of N numbers is Even or Odd | Function to check if the bitwise AND of the array elements is even or odd ; If at least an even element is present then the bitwise AND of the array elements will be even ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2830-2830",
        "Code": "def find_number ( N , K ) : NEW_LINE INDENT r = \" \" NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += \"00\" NEW_LINE DEDENT return r NEW_LINE DEDENT N = 1000 NEW_LINE K = 2 ; NEW_LINE ans = find_number ( N , K ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Find Nth smallest number that is divisible by 100 exactly K times | Function to find the Nth smallest number ; If N is divisible by 100 then we multiply N + 1 otherwise , it will be divisible by 100 more than K times ; convert integer to string ; if N is not divisible by 100 ; convert integer to string ; add 2 * K 0 's at the end to be divisible  by 100 exactly K times ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2833-2833",
        "Code": "def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of adjacent Vowel Consonant Pairs | Function to count the adjacent pairs of consonant and vowels in the string ; Using a set to store the vowels so that checking each character becomes easier ; Variable to store number of consonant - vowel pairs ; If the ith character is not found in the set , means it is a consonant And if the ( i + 1 ) th character is found in the set , means it is a vowel We increment the count of such pairs ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "2835-2835",
        "Code": "def maxSize ( v , n ) : NEW_LINE INDENT v . append ( 0 ) NEW_LINE v . append ( 100001 ) NEW_LINE n += 2 NEW_LINE v = sorted ( v ) NEW_LINE mx = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT L = v [ i - 1 ] + 1 NEW_LINE R = v [ i + 1 ] - 1 NEW_LINE cnt = R - L + 1 NEW_LINE mx = max ( mx , cnt ) NEW_LINE DEDENT return mx NEW_LINE DEDENT v = [ 200 , 10 , 5 ] NEW_LINE n = len ( v ) NEW_LINE print ( maxSize ( v , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the largest interval that contains exactly one of the given N integers . | Function to return the maximum size of the required interval ; Insert the borders for array ; Sort the elements in ascending order ; To store the maximum size ; To store the range [ L , R ] such that only v [ i ] lies within the range ; Total integers in the range ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "2836-2836",
        "Code": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT L = 2 ; P = pow ( 10 , 9 ) ; NEW_LINE ans = power ( 325 , L , P ) ; NEW_LINE print ( ans ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find number of magical pairs of string of length L | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is >= p ; If y is odd , multiply x with result ; Y must be even now y = y >> 1 ; y = y / 2 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2838-2838",
        "Code": "MAXN = 30 NEW_LINE def countMaxLength ( N ) : NEW_LINE INDENT pre = [ 0 for i in range ( MAXN ) ] NEW_LINE p = 1 NEW_LINE pre [ 0 ] = 0 NEW_LINE for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT p *= 2 NEW_LINE pre [ i ] = pre [ i - 1 ] + i * p NEW_LINE DEDENT for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT if ( pre [ i ] >= N ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT x = N - pre [ ind - 1 ] NEW_LINE y = 2 * ind - 1 NEW_LINE if ( x >= y ) : NEW_LINE INDENT res = min ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( x , 2 * ( ind - 2 ) + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( countMaxLength ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest substring of only 4 's from the first N characters of the infinite string | Python 3 implementation of the approach ; Function to return the length of longest contiguous string containing only 4 aTMs from the first N characters of the string ; Initialize prefix sum array of characters and product variable ; Preprocessing of prefix sum array ; Finding the string length where N belongs to ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "2841-2841",
        "Code": "def getMinVal ( p , q ) : NEW_LINE INDENT if q % p == 0 : NEW_LINE INDENT return p NEW_LINE DEDENT return - 1 NEW_LINE DEDENT p = 24 ; q = 48 NEW_LINE print ( getMinVal ( p , q ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find smallest number K such that K % p = 0 and q % K = 0 | Function to return the minimum value K such that K % p = 0 and q % k = 0 ; If K is possible ; No such K is possible ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2843-2843",
        "Code": "def findPoints ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = min ( l1 , l2 ) if ( l1 != l2 ) else - 1 NEW_LINE y = max ( r1 , r2 ) if ( r1 != r2 ) else - 1 NEW_LINE print ( x , y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l1 = 5 NEW_LINE r1 = 10 NEW_LINE l2 = 1 NEW_LINE r2 = 7 NEW_LINE findPoints ( l1 , r1 , l2 , r2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Choose points from two ranges such that no point lies in both the ranges | Function to find the required points ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2844-2844",
        "Code": "import math as mt NEW_LINE def isPalindrome ( str1 , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimePalindrome ( str1 , Len ) : NEW_LINE INDENT prime = [ True for i in range ( Len + 1 ) ] NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( Len + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Len + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for j in range ( 2 , Len + 1 ) : NEW_LINE INDENT if ( prime [ j ] ) : NEW_LINE INDENT for i in range ( Len + 1 - j ) : NEW_LINE INDENT if ( isPalindrome ( str1 , i , i + j - 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE Len = len ( s ) NEW_LINE print ( countPrimePalindrome ( s , Len ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count all Prime Length Palindromic Substrings | Python3 implementation of the approach ; Function that returns True if sub - str1ing starting at i and ending at j in str1 is a palindrome ; Function to count all palindromic substr1ing whose lwngth is a prime number ; 0 and 1 are non - primes ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; To store the required number of sub - str1ings ; Starting from the smallest prime till the largest Length of the sub - str1ing possible ; If j is prime ; Check all the sub - str1ings of Length j ; If current sub - str1ing is a palindrome ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "285-285",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxPathLenUtil ( root , prev_val , prev_len ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return prev_len NEW_LINE DEDENT curr_val = root . val NEW_LINE if curr_val == prev_val + 1 : NEW_LINE INDENT return max ( maxPathLenUtil ( root . left , curr_val , prev_len + 1 ) , maxPathLenUtil ( root . right , curr_val , prev_len + 1 ) ) NEW_LINE DEDENT newPathLen = max ( maxPathLenUtil ( root . left , curr_val , 1 ) , maxPathLenUtil ( root . right , curr_val , 1 ) ) NEW_LINE return max ( prev_len , newPathLen ) NEW_LINE DEDENT def maxConsecutivePathLength ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return maxPathLenUtil ( root , root . val - 1 , 0 ) NEW_LINE DEDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 11 ) NEW_LINE root . right = Node ( 9 ) NEW_LINE root . left . left = Node ( 13 ) NEW_LINE root . left . right = Node ( 12 ) NEW_LINE root . right . left = Node ( 13 ) NEW_LINE root . right . right = Node ( 8 ) NEW_LINE print \" Maximum ▁ Consecutive ▁ Increasing ▁ Path ▁ Length ▁ is \" , NEW_LINE print maxConsecutivePathLength ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum Consecutive Increasing Path Length in Binary Tree | A binary tree node ; Returns the maximum consecutive path length ; Get the vlue of current node The value of the current node will be prev node for its left and right children ; If current node has to be a part of the consecutive path then it should be 1 greater thn the value of the previous node ; a ) Find the length of the left path b ) Find the length of the right path Return the maximum of left path and right path ; Find the length of the maximum path under subtree rooted with this node ; Take the maximum previous path and path under subtree rooted with this node ; A Wrapper over maxPathLenUtil ( ) ; Return 0 if root is None ; Else compute maximum consecutive increasing path length using maxPathLenUtil ; Driver program to test above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "2851-2851",
        "Code": "def getProbability ( p , q ) : NEW_LINE INDENT p /= 100 NEW_LINE q /= 100 NEW_LINE probability = ( p * p + q * q ) / ( p + q ) NEW_LINE return probability NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 80 NEW_LINE q = 40 NEW_LINE print ( getProbability ( p , q ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability of getting two consecutive heads after choosing a random coin among two different types of coins | Function to return the probability of getting two consecutive heads ; Formula derived from Bayes 's theorem ; Driver code ; given the probability of getting a head for both the coins",
        "Category": "Math"
    },
    {
        "ID": "2854-2854",
        "Code": "from math import gcd NEW_LINE def find_LCM ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT def CountPairs ( n , m , A , B ) : NEW_LINE INDENT cnt = 0 NEW_LINE lcm = find_LCM ( A , B ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT cnt += ( m + ( i % lcm ) ) // lcm NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , A , B = 60 , 90 , 5 , 10 NEW_LINE print ( CountPairs ( n , m , A , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs ( i , j ) such that ( i + j ) is divisible by A and B both | Python3 implementation of above approach ; Function to find the LCM ; Function to count the pairs ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2859-2859",
        "Code": "from timeit import default_timer as clock NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 800000 ; NEW_LINE t = clock ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT t = clock ( ) - t NEW_LINE print ( \" sum ▁ is : ▁ \" + str ( sum ) ) NEW_LINE print ( \" time ▁ taken ▁ by ▁ normal ▁ \" + \" loops : \" + str ( t ) ) NEW_LINE t = clock ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 , 8 ) : NEW_LINE INDENT sum += i NEW_LINE sum += ( i + 1 ) NEW_LINE sum += ( i + 2 ) NEW_LINE sum += ( i + 3 ) NEW_LINE sum += ( i + 4 ) NEW_LINE sum += ( i + 5 ) NEW_LINE sum += ( i + 6 ) NEW_LINE sum += ( i + 7 ) NEW_LINE DEDENT t = clock ( ) - t NEW_LINE print ( \" Sum ▁ is : ▁ \" + str ( sum ) ) NEW_LINE print ( \" Time ▁ taken ▁ by ▁ unrolling : ▁ \" + str ( t ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Time taken by Loop unrolling vs Normal loop | Python program to compare normal loops and loops with unrolling technique ; n is 8 lakhs ; t to note start time ; to store the sum ; Normal loop ; to mark end time ; to mark start time of unrolling ; Unrolling technique ( assuming that n is a multiple of 8 ) . ; to mark the end of loop",
        "Category": "Math"
    },
    {
        "ID": "2860-2860",
        "Code": "import math NEW_LINE def _log ( x , base ) : NEW_LINE INDENT return ( int ) ( math . log ( x ) / math . log ( base ) ) NEW_LINE DEDENT def recursiveLogStar ( n , b ) : NEW_LINE INDENT if ( n > 1.0 ) : NEW_LINE INDENT return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 NEW_LINE base = 5 NEW_LINE print ( \" Log * ( \" , n , \" ) ▁ = ▁ \" , recursiveLogStar ( n , base ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Iterated Logarithm log * ( n ) | Recursive Python3 program to find value of Iterated Logarithm ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "2861-2861",
        "Code": "def iterativeLogStar ( n , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT n = _log ( n , b ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Iterated Logarithm log * ( n ) | Iterative Python function to find value of Iterated Logarithm",
        "Category": "Math"
    },
    {
        "ID": "2870-2870",
        "Code": "def findMaximum ( arr , size ) : NEW_LINE INDENT i = 0 NEW_LINE j = size - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if ( arr [ mid ] < 0 ) : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT elif ( arr [ mid ] > 0 ) : NEW_LINE INDENT j = mid - 1 NEW_LINE DEDENT DEDENT return max ( i , size - i ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 9 , - 7 , - 4 , 1 , 5 , 8 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMaximum ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the maximum among the count of positive or negative integers in the array | Function to find the maximum of the count of positive or negative elements ; Initialize the pointers ; Find the value of mid ; If element is negative then ignore the left half ; If element is positive then ignore the right half ; Return maximum among the count of positive & negative element ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2878-2878",
        "Code": "def cal ( arr , mid ) : NEW_LINE INDENT chocolate = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i >= mid : NEW_LINE INDENT chocolate += i - mid NEW_LINE DEDENT DEDENT return chocolate NEW_LINE DEDENT def maximumCut ( arr , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = max ( arr ) NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE chocolate = cal ( arr , mid ) NEW_LINE if chocolate == K : NEW_LINE INDENT return mid NEW_LINE DEDENT elif chocolate < K : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE if mid > high : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT DEDENT return high NEW_LINE DEDENT N , K = 4 , 7 NEW_LINE arr = [ 15 , 20 , 8 , 17 ] NEW_LINE print ( maximumCut ( arr , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find maximum height to cut all chocolates horizontally such that at least K amount remains | Function to find the sum of remaining chocolate after making the horizontal cut at height mid ; Stores the sum of chocolates ; Traverse the array arr [ ] ; If the height is at least mid ; Return the possible sum ; Function to find the maximum horizontal cut made to all the chocolates such that the sum of the remaining element is at least K ; Ranges of Binary Search ; Perform the Binary Search ; Find the sum of removed after making cut at height mid ; If the chocolate removed is same as the chocolate needed then return the height ; If the chocolate removed is less than chocolate needed then shift to the left range ; Otherwise , shift to the right range ; Return the possible cut ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2879-2879",
        "Code": "from math import pow NEW_LINE def findMissingBinaryString ( nums , N ) : NEW_LINE INDENT s = set ( ) NEW_LINE counter = 0 NEW_LINE for x in nums : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT total = int ( pow ( 2 , N ) ) NEW_LINE ans = \" \" NEW_LINE for i in range ( total ) : NEW_LINE INDENT num = \" \" NEW_LINE j = N - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT num += '1' NEW_LINE DEDENT else : NEW_LINE INDENT num += '0' NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( num in s ) : NEW_LINE INDENT continue NEW_LINE counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT if ( counter == total ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE arr = [ \"101\" , \"111\" , \"001\" , \"011\" , \"100\" , \"110\" ] NEW_LINE findMissingBinaryString ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Binary permutations of given size not present in the Array | Python 3 program for the above approach ; Function to find a Binary String of same length other than the Strings present in the array ; Map all the strings present in the array ; Find all the substring that can be made ; If num already exists then increase counter ; If not found print ; If all the substrings are present then print - 1 ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "288-288",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def longestConsecutiveUtil ( root , curLength , expected , res ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . data == expected ) : NEW_LINE INDENT curLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curLength = 1 NEW_LINE DEDENT res [ 0 ] = max ( res [ 0 ] , curLength ) NEW_LINE longestConsecutiveUtil ( root . left , curLength , root . data + 1 , res ) NEW_LINE longestConsecutiveUtil ( root . right , curLength , root . data + 1 , res ) NEW_LINE DEDENT def longestConsecutive ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = [ 0 ] NEW_LINE longestConsecutiveUtil ( root , 0 , root . data , res ) NEW_LINE return res [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 6 ) NEW_LINE root . right = newNode ( 9 ) NEW_LINE root . right . left = newNode ( 7 ) NEW_LINE root . right . right = newNode ( 10 ) NEW_LINE root . right . right . right = newNode ( 11 ) NEW_LINE print ( longestConsecutive ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest consecutive sequence in Binary tree | A utility class to create a node ; Utility method to return length of longest consecutive sequence of tree ; if root data has one more than its parent then increase current length ; update the maximum by current length ; recursively call left and right subtree with expected value 1 more than root data ; method returns length of longest consecutive sequence rooted at node root ; call utility method with current length 0 ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2886-2886",
        "Code": "def check ( H , A , mid , N , M , L ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT speed = mid * A [ i ] + H [ i ] NEW_LINE if ( speed >= L ) : NEW_LINE INDENT sum += speed NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def buzzTime ( N , M , L , H , A ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1e10 NEW_LINE ans = 0 NEW_LINE while ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( check ( H , A , mid , N , M , L ) >= M ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 400 NEW_LINE L = 120 NEW_LINE H = [ 20 , 50 , 20 ] NEW_LINE A = [ 20 , 70 , 90 ] NEW_LINE N = len ( A ) NEW_LINE print ( buzzTime ( N , M , L , H , A ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum time remaining for safety alarm to start | Function to check if the value of mid as the minimum number of hours satisfies the condition ; Stores the sum of speed ; Iterate over the range [ 0 , N ] ; Find the value of speed ; If the bike is considered to be fast add it in sum ; Return the resultant sum ; Function to find the minimum number of time required ; Stores the range of Binary Search ; Stores the minimum number of time required ; Find the value of mid ; If the mid is the resultant speed required ; Update the ans and high ; Otherwise ; Return the minimum number of hours ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2887-2887",
        "Code": "def findCount ( number ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( number ) ) : NEW_LINE INDENT sum += int ( number [ i ] ) - 48 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( number ) ) : NEW_LINE INDENT remaining_sum = sum - ( int ( number [ i ] ) - 48 ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( ( remaining_sum + j ) % 3 == 0 and j != int ( number [ i ] ) - 48 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT number = \"235\" NEW_LINE findCount ( number ) NEW_LINE",
        "Type": "py",
        "NL": "Count of different numbers divisible by 3 that can be obtained by changing at most one digit | Function to count the number of possible numbers divisible by 3 ; Calculate the sum ; Store the answer ; Iterate over the range ; Decreasing the sum ; Iterate over the range ; Checking if the new sum is divisible by 3 or not ; If yes increment the value of the count ; Given number",
        "Category": "Math"
    },
    {
        "ID": "29-29",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def leftMostNode ( node ) : NEW_LINE INDENT while ( node != None and node . left != None ) : NEW_LINE INDENT node = node . left NEW_LINE DEDENT return node NEW_LINE DEDENT def rightMostNode ( node ) : NEW_LINE INDENT while ( node != None and node . right != None ) : NEW_LINE INDENT node = node . right NEW_LINE DEDENT return node NEW_LINE DEDENT def findInorderRecursive ( root , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( root == x or ( findInorderRecursive ( root . left , x ) ) or ( findInorderRecursive ( root . right , x ) ) ) : NEW_LINE INDENT if findInorderRecursive ( root . right , x ) : NEW_LINE INDENT temp = findInorderRecursive ( root . right , x ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = findInorderRecursive ( root . left , x ) NEW_LINE DEDENT if ( temp ) : NEW_LINE INDENT if ( root . left == temp ) : NEW_LINE INDENT print ( \" Inorder ▁ Successor ▁ of \" , x . data , end = \" \" ) NEW_LINE print ( \" ▁ is \" , root . data ) NEW_LINE return None NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT return None NEW_LINE DEDENT def inorderSuccesor ( root , x ) : NEW_LINE INDENT if ( x . right != None ) : NEW_LINE INDENT inorderSucc = leftMostNode ( x . right ) NEW_LINE print ( \" Inorder ▁ Successor ▁ of \" , x . data , \" is \" , end = \" ▁ \" ) NEW_LINE print ( inorderSucc . data ) NEW_LINE DEDENT if ( x . right == None ) : NEW_LINE INDENT f = 0 NEW_LINE rightMost = rightMostNode ( root ) NEW_LINE if ( rightMost == x ) : NEW_LINE INDENT print ( \" No ▁ inorder ▁ successor ! \" , \" Right ▁ most ▁ node . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT findInorderRecursive ( root , x ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE inorderSuccesor ( root , root . right ) NEW_LINE inorderSuccesor ( root , root . left . left ) NEW_LINE inorderSuccesor ( root , root . right . right ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Inorder Successor of a node in Binary Tree | A Binary Tree Node Utility function to create a new tree node ; function to find left most node in a tree ; function to find right most node in a tree ; recursive function to find the Inorder Scuccessor when the right child of node x is None ; function to find inorder successor of a node ; Case1 : If right child is not None ; Case2 : If right child is None ; case3 : If x is the right most node ; Driver Code ; Case 1 ; case 2 ; case 3",
        "Category": "Binary Tree"
    },
    {
        "ID": "290-290",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . key = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key : int ) -> Node : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . key = key NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def findLCA ( root : Node , n1 : int , n2 : int ) -> Node : NEW_LINE INDENT if root is None : NEW_LINE INDENT return None NEW_LINE DEDENT if root . key == n1 or root . key == n2 : NEW_LINE INDENT return root NEW_LINE DEDENT left_lca = findLCA ( root . left , n1 , n2 ) NEW_LINE right_lca = findLCA ( root . right , n1 , n2 ) NEW_LINE if left_lca and right_lca : NEW_LINE INDENT return root NEW_LINE DEDENT return ( left_lca if left_lca is not None else right_lca ) NEW_LINE DEDENT def countTurn ( root : Node , key : int , turn : bool ) -> bool : NEW_LINE INDENT global count NEW_LINE if root is None : NEW_LINE INDENT return False NEW_LINE DEDENT if root . key == key : NEW_LINE INDENT return True NEW_LINE DEDENT if turn is True : NEW_LINE INDENT if countTurn ( root . left , key , turn ) : NEW_LINE INDENT return True NEW_LINE DEDENT if countTurn ( root . right , key , not turn ) : NEW_LINE INDENT count += 1 NEW_LINE return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if countTurn ( root . right , key , turn ) : NEW_LINE INDENT return True NEW_LINE DEDENT if countTurn ( root . left , key , not turn ) : NEW_LINE INDENT count += 1 NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def numberOfTurn ( root : Node , first : int , second : int ) -> int : NEW_LINE INDENT global count NEW_LINE LCA = findLCA ( root , first , second ) NEW_LINE if LCA is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE if LCA . key != first and LCA . key != second : NEW_LINE INDENT if countTurn ( LCA . right , second , False ) or countTurn ( LCA . left , second , True ) : NEW_LINE INDENT pass NEW_LINE DEDENT if countTurn ( LCA . left , first , True ) or countTurn ( LCA . right , first , False ) : NEW_LINE INDENT pass NEW_LINE DEDENT return count + 1 NEW_LINE DEDENT if LCA . key == first : NEW_LINE INDENT countTurn ( LCA . right , second , False ) NEW_LINE countTurn ( LCA . left , second , True ) NEW_LINE return count NEW_LINE DEDENT else : NEW_LINE INDENT countTurn ( LCA . right , first , False ) NEW_LINE countTurn ( LCA . left , first , True ) NEW_LINE return count NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT count = 0 NEW_LINE root = Node ( ) NEW_LINE root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . right . left . left = newNode ( 9 ) NEW_LINE root . right . left . right = newNode ( 10 ) NEW_LINE turn = numberOfTurn ( root , 5 , 10 ) NEW_LINE if turn : NEW_LINE INDENT print ( turn ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Number of turns to reach from one node to other in binary tree | A Binary Tree Node ; Utility function to create a new tree Node ; Utility function to find the LCA of two given values n1 and n2 . ; Base case ; If either n1 or n2 matches with root 's key, report the presence by  returning root (Note that if a key  is ancestor of other, then the  ancestor key becomes LCA ; Look for keys in left and right subtrees ; If both of the above calls return Non - NULL , then one key is present in once subtree and other is present in other , So this node is the LCA ; Otherwise check if left subtree or right subtree is LCA ; function count number of turn need to reach given node from it 's LCA we have two way to ; if found the key value in tree ; Case 1 : ; Case 2 : ; Function to find nodes common to given two nodes ; there is no path between these two node ; case 1 : ; count number of turns needs to reached the second node from LCA ; count number of turns needs to reached the first node from LCA ; case 2 : ; count number of turns needs to reached the second node from LCA ; count number of turns needs to reached the first node from LCA1 ; Driver Code ; Let us create binary tree given in the above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "2903-2903",
        "Code": "def isMaximumMedian ( arr , N , K , mid ) : NEW_LINE INDENT Pre = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT Pre [ i + 1 ] [ j + 1 ] = ( Pre [ i + 1 ] [ j ] + Pre [ i ] [ j + 1 ] - Pre [ i ] [ j ] ) NEW_LINE if ( arr [ i ] [ j ] <= mid ) : NEW_LINE INDENT Pre [ i + 1 ] [ j + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT required = ( K * K + 1 ) // 2 NEW_LINE flag = 0 NEW_LINE for i in range ( K , N + 1 ) : NEW_LINE INDENT for j in range ( K , N + 1 ) : NEW_LINE INDENT X = ( Pre [ i ] [ j ] - Pre [ i - K ] [ j ] - Pre [ i ] [ j - K ] + Pre [ i - K ] [ j - K ] ) NEW_LINE if ( X < required ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT DEDENT return flag NEW_LINE DEDENT def maximumMedian ( arr , N , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1000000009 NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( isMaximumMedian ( arr , N , K , mid ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 5 , 12 ] , [ 6 , 7 , 11 ] , [ 8 , 9 , 10 ] ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( maximumMedian ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize median of a KxK sub | Function to determine if a given value can be median ; Stores the prefix sum array ; Traverse the matrix arr [ ] [ ] ; Update Pre [ i + 1 ] [ j + 1 ] ; If arr [ i ] [ j ] is less than or equal to mid ; Stores the count of elements should be less than mid ; Stores if the median mid can be possible or not ; Iterate over the range [ K , N ] ; Iterate over the range [ K , N ] ; Stores count of elements less than or equal to the value mid in submatrix with bottom right vertices at ( i , j ) ; If X is less than or equal to required ; Return flag ; Function to find the maximum median of a subsquare of the given size ; Stores the range of the search space ; Iterate until low is less than high ; Stores the mid value of the range [ low , high ] ; If the current median can be possible ; Update the value of low ; Update the value of high ; Return value stored in low as answer ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2904-2904",
        "Code": "def findMinDays ( arr , R , N , X , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = X NEW_LINE minDays = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = arr [ i ] + R [ i ] * mid NEW_LINE if ( temp >= K ) : NEW_LINE INDENT sum += temp NEW_LINE DEDENT DEDENT if ( sum >= X ) : NEW_LINE INDENT minDays = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT print ( minDays ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 100 NEW_LINE K = 45 NEW_LINE arr = [ 2 , 5 , 2 , 6 ] NEW_LINE R = [ 10 , 13 , 15 , 12 ] NEW_LINE N = len ( arr ) NEW_LINE findMinDays ( arr , R , N , X , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum days to make Array elements with value at least K sum at least X | Function to find the minimum number of days such that the sum of array elements >= K is at least X ; Initialize the boundaries of search space ; Perform the binary search ; Find the value of mid ; Traverse the array , arr [ ] ; Find the value of arr [ i ] after mid number of days ; Check if temp is not less than K ; Update the value of sum ; Check if the value of sum is greater than X ; Update value of high ; Update the value of low ; Print the minimum number of days ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2912-2912",
        "Code": "def numberofBoxes ( W , B , O ) : NEW_LINE INDENT low = 0 NEW_LINE high = min ( W , B ) NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT W = 3 NEW_LINE B = 3 NEW_LINE O = 1 NEW_LINE numberofBoxes ( W , B , O ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize boxes required to keep at least one black and one white shirt | Function to find the maximum number of boxes such that each box contains three shirts comprising of at least one white and black shirt ; Stores the low and high pointers for binary search ; Store the required answer ; Loop while low <= high ; Store the mid value ; Check if the mid number of boxes can be used ; Update answer and recur for the right half ; Else , recur for the left half ; Print result ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2915-2915",
        "Code": "def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * mid + mid ) // 2 NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE K = 14 NEW_LINE print ( Count ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize X such that sum of numbers in range [ 1 , X ] is at most K | Function to count the elements with sum of the first that many natural numbers less than or equal to K ; If K equals to 0 ; Stores the result ; Iterate until low is less than or equal to high ; Stores the sum of first mid natural numbers ; If sum is less than or equal to K ; Update res and low ; Otherwise , ; Update ; Return res ; Driver Code ; Input ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "2916-2916",
        "Code": "def removeLastOccurrence ( S , W , N , M ) : NEW_LINE INDENT S = [ i for i in S ] NEW_LINE W = [ i for i in W ] NEW_LINE if ( M > N ) : NEW_LINE INDENT return S NEW_LINE DEDENT for i in range ( N - M , - 1 , - 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( S [ j + i ] != W [ j ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT for j in range ( i , N - M ) : NEW_LINE INDENT S [ j ] = S [ j + M ] NEW_LINE DEDENT S = S [ : N - M ] NEW_LINE break NEW_LINE DEDENT DEDENT return \" \" . join ( S ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" This ▁ is ▁ GeeksForGeeks \" NEW_LINE W = \" Geeks \" NEW_LINE N = len ( S ) NEW_LINE M = len ( W ) NEW_LINE print ( removeLastOccurrence ( S , W , N , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove last occurrence of a word from a given sentence string | Function to remove last occurrence of W from S ; If M is greater than N ; Iterate while i is greater than or equal to 0 ; of W has been found or not ; Iterate over the range [ 0 , M ] ; If S [ j + 1 ] is not equal to W [ j ] ; Mark flag true and break ; If occurrence has been found ; Delete the subover the range [ i , i + M ] ; Resize the S ; Return S ; Driver Code ; Input ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "292-292",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . abtr = None NEW_LINE DEDENT DEDENT even_ptrs = [ ] NEW_LINE odd_ptrs = [ ] NEW_LINE def preorderTraversal ( root ) : NEW_LINE INDENT global even_ptrs , odd_ptrs NEW_LINE if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . data % 2 == 0 ) : NEW_LINE INDENT even_ptrs . append ( root ) NEW_LINE DEDENT else : NEW_LINE INDENT odd_ptrs . append ( root ) NEW_LINE DEDENT preorderTraversal ( root . left ) NEW_LINE preorderTraversal ( root . right ) NEW_LINE DEDENT def createLoops ( root ) : NEW_LINE INDENT preorderTraversal ( root ) NEW_LINE i = 1 NEW_LINE while i < len ( even_ptrs ) : NEW_LINE INDENT even_ptrs [ i - 1 ] . abtr = even_ptrs [ i ] NEW_LINE i += 1 NEW_LINE DEDENT even_ptrs [ i - 1 ] . abtr = even_ptrs [ 0 ] NEW_LINE i = 1 NEW_LINE while i < len ( odd_ptrs ) : NEW_LINE INDENT odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ i ] NEW_LINE i += 1 NEW_LINE DEDENT odd_ptrs [ i - 1 ] . abtr = odd_ptrs [ 0 ] NEW_LINE DEDENT def traverseLoop ( start ) : NEW_LINE INDENT curr = start NEW_LINE while True and curr : NEW_LINE INDENT print ( curr . data , end = \" ▁ \" ) NEW_LINE curr = curr . abtr NEW_LINE if curr == start : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE createLoops ( root ) NEW_LINE print ( \" Odd ▁ nodes : \" , end = \" ▁ \" ) NEW_LINE traverseLoop ( root . right ) NEW_LINE print ( \" Even ▁ nodes : \" , end = \" ▁ \" ) NEW_LINE traverseLoop ( root . left ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Create loops of even and odd values in a binary tree | Utility function to create a new node ; preorder traversal to place the node pointer in the respective even_ptrs or odd_ptrs list ; place node ptr in even_ptrs list if node contains even number ; else place node ptr in odd_ptrs list ; function to create the even and odd loops ; forming even loop ; for the last element ; Similarly forming odd loop ; traversing the loop from any random node in the loop ; Driver program to test above ; Binary tree formation ; traversing odd loop from any random odd node ; traversing even loop from any random even node",
        "Category": "Binary Tree"
    },
    {
        "ID": "2922-2922",
        "Code": "def calculateMax ( N , M , K ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = 0 NEW_LINE high = M NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE val = 0 NEW_LINE L = K - 1 NEW_LINE R = N - K NEW_LINE val += mid NEW_LINE if ( mid >= L ) : NEW_LINE INDENT val += ( L ) * ( 2 * mid - L - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( L - mid ) NEW_LINE DEDENT if ( mid >= R ) : NEW_LINE INDENT val += ( R ) * ( 2 * mid - R - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( R - mid ) NEW_LINE DEDENT if ( val <= M ) : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT N = 7 NEW_LINE M = 100 NEW_LINE K = 6 NEW_LINE print ( calculateMax ( N , M , K ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Maximize value at Kth index to create N size array with adjacent difference 1 and sum less than M | Function to calculate maximum value that can be placed at the Kth index in a distribution in which difference of adjacent elements is less than 1 and total sum of distribution is M . ; Variable to store final answer ; Variables for binary search ; Binary search ; Variable for binary search ; Variable to store total sum of array ; Number of indices on the left excluding the Kth index ; Number of indices on the left excluding the Kth index ; Add mid to final sum ; Distribution on left side is possible ; Sum of distribution on the left side ; Sum of distribution on the left side with ( L - mid ) 1 s ; Distribution on right side is possible ; Sum of distribution on the right side ; Sum of distribution on the left side with ( R - mid ) 1 s ; Distribution is valid ; Return answer ; Input ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "2925-2925",
        "Code": "ans = 0 NEW_LINE edges = [ [ ] for i in range ( 100000 ) ] NEW_LINE def Add_edge ( u , v ) : NEW_LINE INDENT global edges NEW_LINE edges [ u ] . append ( v ) NEW_LINE edges [ v ] . append ( u ) NEW_LINE DEDENT def minTimeToColor ( node , parent , arrival_time ) : NEW_LINE INDENT global ans NEW_LINE current_time = 0 NEW_LINE for x in edges [ node ] : NEW_LINE INDENT if ( x != parent ) : NEW_LINE INDENT current_time += 1 NEW_LINE if ( current_time == arrival_time ) : NEW_LINE INDENT current_time += 1 NEW_LINE DEDENT ans = max ( ans , current_time ) NEW_LINE minTimeToColor ( x , node , current_time ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] ] NEW_LINE for i in A : NEW_LINE INDENT Add_edge ( i [ 0 ] , i [ 1 ] ) NEW_LINE DEDENT minTimeToColor ( 1 , - 1 , 0 ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum time required to color all edges of a Tree | Stores the required answer ; Stores the graph ; Function to add edges ; Function to calculate the minimum time required to color all the edges of a tree ; Starting from time = 0 , for all the child edges ; If the edge is not visited yet . ; Time of coloring of the current edge ; If the parent edge has been colored at the same time ; Update the maximum time ; Recursively call the function to its child node ; Driver Code ; Function call ; Finally , print the answer",
        "Category": "Graph Theory"
    },
    {
        "ID": "293-293",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def isLeaf ( t ) : NEW_LINE INDENT return ( ( t . left == None ) and ( t . right == None ) ) NEW_LINE DEDENT def findFirstUnmatch ( root1 , root2 ) : NEW_LINE INDENT if ( root1 == None or root2 == None ) : NEW_LINE INDENT return NEW_LINE DEDENT s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE s1 . insert ( 0 , root1 ) NEW_LINE s2 . insert ( 0 , root2 ) NEW_LINE while ( len ( s1 ) or len ( s2 ) ) : NEW_LINE INDENT if ( len ( s1 ) == 0 or len ( s2 ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT temp1 = s1 [ 0 ] NEW_LINE s1 . pop ( 0 ) NEW_LINE while ( temp1 and not isLeaf ( temp1 ) ) : NEW_LINE INDENT s1 . insert ( 0 , temp1 . right ) NEW_LINE s1 . insert ( 0 , temp1 . left ) NEW_LINE temp1 = s1 [ 0 ] NEW_LINE s1 . pop ( 0 ) NEW_LINE DEDENT temp2 = s2 [ 0 ] NEW_LINE s2 . pop ( 0 ) NEW_LINE while ( temp2 and not isLeaf ( temp2 ) ) : NEW_LINE INDENT s2 . insert ( 0 , temp2 . right ) NEW_LINE s2 . insert ( 0 , temp2 . left ) NEW_LINE temp2 = s2 [ 0 ] NEW_LINE s2 . pop ( 0 ) NEW_LINE DEDENT if ( temp1 != None and temp2 != None ) : NEW_LINE INDENT if ( temp1 . data != temp2 . data ) : NEW_LINE INDENT print ( \" First ▁ non ▁ matching ▁ leaves ▁ : \" , temp1 . data , \" \" , temp2 . data ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 2 ) NEW_LINE root1 . right = newNode ( 7 ) NEW_LINE root1 . left . left = newNode ( 10 ) NEW_LINE root1 . left . right = newNode ( 11 ) NEW_LINE root2 = newNode ( 6 ) NEW_LINE root2 . left = newNode ( 10 ) NEW_LINE root2 . right = newNode ( 15 ) NEW_LINE findFirstUnmatch ( root1 , root2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find first non matching leaves in two binary trees | Utility function to create a new tree Node ; Prints the first non - matching leaf node in two trees if it exists , else prints nothing . ; If any of the tree is empty ; Create two stacks for preorder traversals ; If traversal of one tree is over and other tree still has nodes . ; Do iterative traversal of first tree and find first lead node in it as \" temp1\" ; pushing right childfirst so that left child comes first while popping . ; Do iterative traversal of second tree and find first lead node in it as \" temp2\" ; If we found leaves in both trees ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "2932-2932",
        "Code": "def check ( n , m , x , y , vl ) : NEW_LINE INDENT temp = m NEW_LINE if ( vl > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT ex = n - vl NEW_LINE ex *= y NEW_LINE temp += ex NEW_LINE cr = temp // x NEW_LINE if ( cr >= vl ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maximizeMangoes ( n , m , x , y ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE ans = 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( check ( n , m , x , y , mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT W = 4 NEW_LINE C = 8 NEW_LINE x = 4 NEW_LINE y = 4 NEW_LINE print ( maximizeMangoes ( W , C , x , y ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of mangoes that can be bought | ''Function to check if mid number of mangoes can be bought ; '' Store the coins ; '' If watermelons needed are greater  than given watermelons ; '' Store remaining watermelons if vl  watermelons are used to buy mangoes ; '' Store the value of coins if these  watermelon get sold ; '' Increment coins by ex ; '' Number of mangoes that can be buyed  if only x coins needed for one mango ; '' If the condition is satisfied,  return true ; '' Otherwise return false ; ''Function to find the maximum number of mangoes that can be bought by selling watermelons ; '' Initialize the boundary values ; '' Store the required result ; '' Binary Search ; '' Store the mid value ; '' Check if it is possible to  buy mid number of mangoes ; '' Otherwise, update r to mid -1 ; '' Return the result ; ''Driver Code ; '' Given Input ; '' Function Call",
        "Category": "Binary Search"
    },
    {
        "ID": "2933-2933",
        "Code": "def findElement ( A , N , X ) : NEW_LINE INDENT i = 0 NEW_LINE Comparisons = 0 NEW_LINE T = 1 NEW_LINE Found = \" No \" NEW_LINE Comparisons += 1 NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT i = 1 NEW_LINE T *= ( A [ 0 ] - X ) NEW_LINE DEDENT while ( i < N ) : NEW_LINE INDENT Comparisons += 1 NEW_LINE T *= ( A [ i ] - X ) NEW_LINE T *= ( A [ i + 1 ] - X ) NEW_LINE i += 2 NEW_LINE DEDENT Comparisons += 1 NEW_LINE if ( T == 0 ) : NEW_LINE INDENT print ( \" Yes \" , Comparisons ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ - 3 , 5 , 11 , 3 , 100 , 2 , 88 , 22 , 7 , 900 , 23 , 4 , 1 ] NEW_LINE N = len ( A ) NEW_LINE X = 1 NEW_LINE findElement ( A , N , X ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if an element is present in an array using at most floor ( N / 2 ) + 2 comparisons | Function to check whether X is present in the array A [ ] ; Initialise a pointer ; Store the number of comparisons ; Variable to store product ; Check is N is odd ; Update i and T ; Traverse the array ; Check if i < N ; Update T ; Check if T is equal to 0 ; Driver Code ; Given Input ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "294-294",
        "Code": "def maxOfLeftElement ( root ) : NEW_LINE INDENT res = - 999999999999 NEW_LINE if ( root == None ) : NEW_LINE INDENT return res NEW_LINE DEDENT if ( root . left != None ) : NEW_LINE INDENT res = root . left . data NEW_LINE DEDENT return max ( { maxOfLeftElement ( root . left ) , res , maxOfLeftElement ( root . right ) } ) NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 6 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( maxOfLeftElement ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Get maximum left node in binary tree | Get max of left element using Inorder traversal ; Return maximum of three values 1 ) Recursive max in left subtree 2 ) Value in left node 3 ) Recursive max in right subtree ; Utility class to create a new tree node ; Driver Code ; Let us create binary tree shown in above diagram ; 7 / \\ 6 5 / \\ / \\ 4 3 2 1",
        "Category": "Binary Tree"
    },
    {
        "ID": "2943-2943",
        "Code": "def binarysearch ( array , right , element ) : NEW_LINE INDENT left = 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right // 2 ) NEW_LINE if ( array [ mid ] == element ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid - 1 > 0 and array [ mid ] > element and array [ mid - 1 ] < element ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( array [ mid ] < element ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def countDistinct ( arr , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE pref = [ 0 ] * ( len ( arr ) + 1 ) NEW_LINE for i in range ( 1 , len ( arr ) + 1 ) : NEW_LINE INDENT count += arr [ i - 1 ] NEW_LINE pref [ i ] = count NEW_LINE DEDENT left = binarysearch ( pref , len ( arr ) + 1 , L ) NEW_LINE right = binarysearch ( pref , len ( arr ) + 1 , R ) NEW_LINE print ( right - left + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 6 , 7 , 1 , 8 ] NEW_LINE L = 3 NEW_LINE R = 7 NEW_LINE countDistinct ( arr , L , R ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count distinct elements from a range of a sorted sequence from a given frequency array | Function to find the first index with value is at least element ; Update the value of left ; Binary search for the element ; Find the middle element ; Check if the value lies between the elements at index mid - 1 and mid ; Check in the right subarray ; Update the value of left ; Check in left subarray ; Update the value of right ; Function to count the number of distinct elements over the range [ L , R ] in the sorted sequence ; Stores the count of distinct elements ; Create the prefix sum array ; Update the value of count ; Update the value of pref [ i ] ; Calculating the first index of L and R using binary search ; Print the resultant count ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2946-2946",
        "Code": "def ischar ( x ) : NEW_LINE INDENT if ( ( x >= ' A ' and x <= ' Z ' ) or ( x >= ' a ' and x <= ' z ' ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def isnum ( x ) : NEW_LINE INDENT if ( x >= '0' and x <= '9' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def findIdandDomain ( S , N ) : NEW_LINE INDENT ID , Domain = \" \" , \" \" NEW_LINE words = [ ] NEW_LINE curr = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' ▁ ' ) : NEW_LINE INDENT words . append ( curr ) NEW_LINE curr = \" \" NEW_LINE DEDENT else : NEW_LINE INDENT if ( S [ i ] == ' . ' ) : NEW_LINE INDENT if ( i + 1 == N or ( i + 1 < N and S [ i + 1 ] == ' ▁ ' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT curr += S [ i ] NEW_LINE DEDENT DEDENT if ( len ( curr ) ) : NEW_LINE INDENT words . append ( curr ) NEW_LINE DEDENT for ss in words : NEW_LINE INDENT if ( len ( ss ) == 10 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( j >= 5 and j < 9 ) : NEW_LINE INDENT if ( isnum ( ss [ j ] ) == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ischar ( ss [ j ] ) == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT ID = ss NEW_LINE DEDENT DEDENT if ( ss [ 0 : 3 ] == \" www \" and ss [ len ( ss ) - 3 : ] == \" com \" ) : NEW_LINE INDENT Domain = ss [ 4 : len ( ss ) ] NEW_LINE DEDENT DEDENT print ( \" ID ▁ = \" , ID ) NEW_LINE print ( \" Domain ▁ = \" , Domain ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" We ▁ thank ▁ ABCDE1234F ▁ for ▁ visiting ▁ us ▁ \" \" and ▁ buying ▁ products ▁ item ▁ AMZrr @ ! k . ▁ \" N = len ( S ) NEW_LINE findIdandDomain ( S , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Unique ID and Domain Name of a Website from a string | Function to check if a character is alphabet or not ; Function to check if a character is a numeric or not ; Function to find ID and Domain name from a given ; Stores ID and the domain names ; Stores the words of S ; Stores the temporary word ; Traverse the S ; If the current character is space ; Push the curr in words ; Update the curr ; Otherwise ; If curr is not empty ; If length of ss is 10 ; Traverse the ss ; If j is in the range [ 5 , 9 ) ; If current character is not numeric ; Mark flag 1 ; Otherwise ; If current character is not alphabet ; Mark flag 1 ; If flag is false ; Assign ss to ID ; If sub formed by the first 3 character is \" www \" and last 3 character is \" moc \" ; Update the domain name ; Print ID and Domain ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "2948-2948",
        "Code": "from bisect import bisect_left , bisect_right NEW_LINE def lower_bound ( a , low , high , element ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT middle = low + ( high - low ) // 2 NEW_LINE if ( element > a [ middle ] ) : NEW_LINE INDENT low = middle + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = middle NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT def maximumIntersections ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE L = [ 0 ] * N NEW_LINE R = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT L [ i ] = arr [ i ] [ 0 ] NEW_LINE R [ i ] = arr [ i ] [ 1 ] NEW_LINE DEDENT L . sort ( ) NEW_LINE R . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = arr [ i ] [ 0 ] NEW_LINE r = arr [ i ] [ 1 ] NEW_LINE x = lower_bound ( L , 0 , N , l ) NEW_LINE y = N - lower_bound ( R , 0 , N , r + 1 ) NEW_LINE cnt = x + y NEW_LINE cnt = N - cnt - 1 NEW_LINE count = max ( count , cnt ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 6 ] , [ 5 , 5 ] , [ 2 , 3 ] ] NEW_LINE N = len ( arr ) NEW_LINE print ( maximumIntersections ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of intersections possible for any of the N given segments | Python 3 program for the above approach ; Function to find the maximum number of intersections one segment has with all the other given segments ; Stores the resultant maximum count ; Stores the starting and the ending points ; Sort arrays points in the ascending order ; Traverse the array arr [ ] ; Find the count of segments on left of ith segment ; Find the count of segments on right of ith segment ; Find the total segments not intersecting with the current segment ; Store the count of segments that intersect with the ith segment ; Update the value of count ; Return the resultant count ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2949-2949",
        "Code": "def isValid ( weight , n , D , mx ) : NEW_LINE INDENT st = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += weight [ i ] NEW_LINE if ( sum > mx ) : NEW_LINE INDENT st += 1 NEW_LINE sum = weight [ i ] NEW_LINE DEDENT if ( st > D ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def shipWithinDays ( weight , D , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += weight [ i ] NEW_LINE DEDENT s = weight [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = max ( s , weight [ i ] ) NEW_LINE DEDENT e = sum NEW_LINE res = - 1 NEW_LINE while ( s <= e ) : NEW_LINE INDENT mid = s + ( e - s ) // 2 NEW_LINE if ( isValid ( weight , n , D , mid ) ) : NEW_LINE INDENT res = mid NEW_LINE e = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = mid + 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT weight = [ 9 , 8 , 10 ] NEW_LINE D = 3 NEW_LINE N = len ( weight ) NEW_LINE shipWithinDays ( weight , D , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Capacity To Ship Packages Within D Days | Function to check if the weights can be delivered in D days or not ; Stores the count of days required to ship all the weights if the maximum capacity is mx ; Traverse all the weights ; If total weight is more than the maximum capacity ; If days are more than D , then return false ; Return true for the days < D ; Function to find the least weight capacity of a boat to ship all the weights within D days ; Stores the total weights to be shipped ; Find the sum of weights ; Stores the maximum weight in the array that has to be shipped ; Store the ending value for the search space ; Store the required result ; Perform binary search ; Store the middle value ; If mid can be shipped , then update the result and end value of the search space ; Search for minimum value in the right part ; Print the result ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2956-2956",
        "Code": "def minDays ( P , arr ) : NEW_LINE INDENT for i in range ( 1 , len ( P ) ) : NEW_LINE INDENT P [ i ] += P [ i ] + P [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT index = binarySeach ( P , arr [ i ] ) NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( index + 1 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT def binarySeach ( P , N ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( P ) - 1 NEW_LINE index = - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if ( P [ mid ] >= N ) : NEW_LINE INDENT index = mid NEW_LINE j = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 400 , 200 , 700 , 900 , 1400 ] NEW_LINE P = [ 100 , 300 , 400 , 500 , 600 ] NEW_LINE minDays ( P , arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of working days required to achieve each of the given scores | Function to find the minimum number of days required to work to at least arr [ i ] points for every array element ; Traverse the array P [ ] ; Find the prefix sum ; Traverse the array arr [ ] ; Find the minimum index of the array having value at least arr [ i ] ; If the index is not - 1 ; Otherwise ; Function to find the lower bound of N using binary search ; Stores the lower bound ; Stores the upper bound ; Stores the minimum index having value is at least N ; Iterater while i <= j ; Stores the mid index of the range [ i , j ] ; If P [ mid ] is at least N ; Update the value of mid to index ; Update the value of j ; Update the value of i ; Return the resultant index ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "2972-2972",
        "Code": "def replaceCharacters ( s , p ) : NEW_LINE INDENT n , k = len ( s ) , len ( p ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE brr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( ' a ' ) ] = s [ i ] NEW_LINE brr [ ord ( s [ i ] ) - ord ( ' a ' ) ] = s [ i ] NEW_LINE DEDENT for j in range ( k ) : NEW_LINE INDENT a , b = p [ j ] [ 0 ] , p [ j ] [ 1 ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( arr [ i ] == a ) : NEW_LINE INDENT brr [ i ] = b NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( brr [ ord ( s [ i ] ) - ord ( ' a ' ) ] , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabbgg \" NEW_LINE P = [ [ ' a ' , ' b ' ] , [ ' b ' , ' g ' ] , [ ' g ' , ' a ' ] ] NEW_LINE replaceCharacters ( S , P ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify string by replacing all occurrences of given characters by specified replacing characters | Function to modify given string by replacing characters ; Store the size of string and the number of pairs ; Initialize 2 character arrays ; Traverse the string s Update arrays arr [ ] and brr [ ] ; Traverse the array of pairs p ; a -> Character to be replaced b -> Replacing character ; Iterate over the range [ 0 , 25 ] ; If it is equal to current character , then replace it in the array b ; Print the array brr [ ] ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "2977-2977",
        "Code": "def productOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cube_root = round ( ( N ) ** ( 1 / 3 ) ) NEW_LINE print ( cube_root ) NEW_LINE if ( cube_root * cube_root * cube_root == N ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 216 NEW_LINE productOfTwoPerfectCubes ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number can be represented as product of two positive perfect cubes | Function to check if the number N can be represented as the product of two perfect cubes or not ; If cube of cube_root is N ; Otherwise , prNo ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2981-2981",
        "Code": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def maximumProduct ( words ) : NEW_LINE INDENT bits = [ 0 for i in range ( len ( words ) ) ] NEW_LINE for i in range ( len ( words ) ) : NEW_LINE INDENT for j in range ( len ( words [ i ] ) ) : NEW_LINE INDENT bits [ i ] = bits [ i ] | 1 << ( ord ( words [ i ] [ j ] ) - 97 ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( len ( bits ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( bits ) ) : NEW_LINE INDENT if ( ( bits [ i ] & bits [ j ] ) == 0 ) : NEW_LINE INDENT L = countSetBits ( bits [ i ] ) NEW_LINE R = countSetBits ( bits [ j ] ) NEW_LINE result = max ( L * R , result ) NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" abcw \" , \" baz \" , \" foo \" , \" bar \" , \" xtfn \" , \" abcdef \" ] NEW_LINE maximumProduct ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize product of lengths of strings having no common characters | Function to count the number of set bits in the integer n ; Stores the count of set bits in n ; Return the count ; Function to find the maximum product of pair of strings having no common characters ; Stores the integer equivalent of the strings ; Traverse the array of strings ; Traverse the current string ; Store the current bit position in bits [ i ] ; Store the required result ; Traverse the array , bits [ ] to get all unique pairs ( i , j ) ; Check whether the strings have no common characters ; Update the overall maximum product ; Print the maximum product ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "2986-2986",
        "Code": "def palindrome ( string ) : NEW_LINE INDENT if ( string == string [ : : - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printReverse ( sentence ) : NEW_LINE INDENT newlist = [ ] NEW_LINE lis = list ( sentence . split ( ) ) NEW_LINE for i in lis : NEW_LINE INDENT if ( palindrome ( i ) ) : NEW_LINE INDENT newlist . append ( i ) NEW_LINE DEDENT DEDENT newlist . reverse ( ) NEW_LINE j = 0 NEW_LINE for i in range ( len ( lis ) ) : NEW_LINE INDENT if ( palindrome ( lis [ i ] ) ) : NEW_LINE INDENT lis [ i ] = newlist [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT for i in lis : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT sentence = \" mom ▁ and ▁ dad ▁ went ▁ to ▁ eye ▁ hospital \" NEW_LINE printReverse ( sentence ) NEW_LINE",
        "Type": "py",
        "NL": "Modify a sentence by reversing order of occurrences of all Palindrome Words | Function to check if a string S is a palindrome ; Function to print the modified string after reversing teh order of occurrences of all palindromic words in the sentence ; Stores the palindromic words ; Stores the words in the list ; Traversing the list ; If current word is a palindrome ; Update newlist ; Reverse the newlist ; Traverse the list ; If current word is a palindrome ; Update lis [ i ] ; Increment j ; Print the updated sentence ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "2989-2989",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . next = None NEW_LINE DEDENT DEDENT / * Constructor * / def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . next = None NEW_LINE DEDENT def intersectingNode ( headA , headB ) : NEW_LINE INDENT a = headA NEW_LINE while ( a ) : NEW_LINE INDENT a . data *= - 1 NEW_LINE a = a . next NEW_LINE DEDENT b = headB NEW_LINE while ( b ) : NEW_LINE INDENT if ( b . data < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT b = b . next NEW_LINE DEDENT return b NEW_LINE DEDENT def formLinkList ( head1 , head2 ) : NEW_LINE INDENT head1 = Node ( 3 ) NEW_LINE head1 . next = Node ( 6 ) NEW_LINE head1 . next . next = Node ( 9 ) NEW_LINE head1 . next . next . next = Node ( 15 ) NEW_LINE head1 . next . next . next . next = Node ( 30 ) NEW_LINE head2 = Node ( 10 ) NEW_LINE head2 . next = head1 . next . next . next NEW_LINE return head1 , head2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head1 , head2 = formLinkList ( None , None ) NEW_LINE print ( abs ( intersectingNode ( head1 , head2 ) . data ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Intersection point of two Linked Lists | Set 3 | Structure of a node of a Linked List ;  ; Function to find the intersection point of the two Linked Lists ; Traverse the first linked list and multiply all values by - 1 ; Update a . data ; Update a ; Traverse the second Linked List and find the value of the first node having negative value ; Intersection point ; Update b ; Function to create linked lists ; Linked List L1 ; Linked List L2 ; Driver Code",
        "Category": "Linked List"
    },
    {
        "ID": "2990-2990",
        "Code": "def maximumNumber ( arr , N , K ) : NEW_LINE INDENT minimum = min ( arr ) NEW_LINE ans = minimum + K NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ans ) > K ) : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( arr ) NEW_LINE maximumNumber ( arr , N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum value of X such that difference between any array element and X does not exceed K | Function to find maximum value of X such that | A [ i ] - X | a K ; Stores the smallest array element ; Store the possible value of X ; Traverse the array A [ ] ; If required criteria is not satisfied ; Update ans ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "2992-2992",
        "Code": "import math NEW_LINE def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p ** 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumOfPrimeSquare ( n ) : NEW_LINE INDENT flag = False NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT dif = n - i NEW_LINE if ( math . ceil ( dif ** ( 1 / 2 ) ) == math . floor ( dif ** ( 1 / 2 ) ) ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 27 NEW_LINE sumOfPrimeSquare ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number can be represented as a sum of a Prime Number and a Perfect Square | Python3 program for the above approach ; Function to store all prime numbers less than or equal to N ; Update prime [ 0 ] and prime [ 1 ] as false ; Iterate over the range [ 2 , sqrt ( N ) ] ; If p is a prime ; Update all multiples of p which are <= n as non - prime ; Function to check whether a number can be represented as the sum of a prime number and a perfect square ; Stores all the prime numbers less than or equal to n ; Update the array prime [ ] ; Iterate over the range [ 0 , n ] ; If current number is non - prime ; Update difference ; If difference is a perfect square ; If true , update flag and break out of loop ; If N can be expressed as sum of prime number and perfect square ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "30-30",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( val ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = val NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def inorderSuccessor ( root , target_node ) : NEW_LINE INDENT global next NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorderSuccessor ( root . right , target_node ) NEW_LINE if ( root . data == target_node . data ) : NEW_LINE INDENT if ( next == None ) : NEW_LINE INDENT print ( \" inorder ▁ successor ▁ of \" , root . data , \" ▁ is : ▁ None \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" inorder ▁ successor ▁ of \" , root . data , \" is : \" , next . data ) NEW_LINE DEDENT DEDENT next = root NEW_LINE inorderSuccessor ( root . left , target_node ) NEW_LINE DEDENT next = None NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE next = None NEW_LINE inorderSuccessor ( root , root . right ) NEW_LINE next = None NEW_LINE inorderSuccessor ( root , root . left . left ) NEW_LINE next = None NEW_LINE inorderSuccessor ( root , root . right . right ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Inorder Successor of a node in Binary Tree | A Binary Tree Node ; Function to create a new Node . ; function that prints the inorder successor of a target node . next will point the last tracked node , which will be the answer . ; if root is None then return ; if target node found , then enter this condition ; Driver Code ; Let 's construct the binary tree   as shown in above diagram. ; Case 1 ; case 2 ; case 3",
        "Category": "Binary Tree"
    },
    {
        "ID": "300-300",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . data = item NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def findDistance ( root , x ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist = - 1 NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return dist + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dist = findDistance ( root . left , x ) NEW_LINE if dist >= 0 : NEW_LINE INDENT return dist + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dist = findDistance ( root . right , x ) NEW_LINE if dist >= 0 : NEW_LINE INDENT return dist + 1 NEW_LINE DEDENT DEDENT DEDENT return dist NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 10 ) NEW_LINE root . right = newNode ( 15 ) NEW_LINE root . left . left = newNode ( 20 ) NEW_LINE root . left . right = newNode ( 25 ) NEW_LINE root . left . right . right = newNode ( 45 ) NEW_LINE root . right . left = newNode ( 30 ) NEW_LINE root . right . right = newNode ( 35 ) NEW_LINE print ( findDistance ( root , 45 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find distance from root to given node in a binary tree | A class to create a new Binary Tree Node ; Returns - 1 if x doesn 't exist in tree. Else returns distance of x from root ; Base case ; Initialize distance ; Check if x is present at root or in left subtree or right subtree . ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "3008-3008",
        "Code": "def findLength ( s , i , j ) : NEW_LINE INDENT required = i NEW_LINE length = 0 NEW_LINE for curr in s : NEW_LINE INDENT if ( curr == required ) : NEW_LINE INDENT length += 1 NEW_LINE if ( required == i ) : NEW_LINE INDENT required = j NEW_LINE DEDENT else : NEW_LINE INDENT required = i NEW_LINE DEDENT DEDENT DEDENT return length NEW_LINE DEDENT def minimumDeletions ( S ) : NEW_LINE INDENT len1 = 0 NEW_LINE n = len ( S ) NEW_LINE for i in range ( 0 , 26 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , 26 , 1 ) : NEW_LINE INDENT newLen = findLength ( S , chr ( i + 97 ) , chr ( j + 97 ) ) NEW_LINE len1 = max ( len1 , newLen ) NEW_LINE DEDENT DEDENT return n - len1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" adebbeeaebd \" NEW_LINE print ( minimumDeletions ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum removals required such that given string consists only of a pair of alternating characters | Function to find the maximum length of alternating occurrences of a pair of characters in a string s ; Stores the next character for alternating sequence ; Stores the length of alternating occurrences of a pair of characters ; Traverse the given string ; If current character is same as the required character ; Increase length by 1 ; Reset required character ; Return the length ; Function to find minimum characters required to be deleted from S to obtain an alternating sequence ; Stores maximum length of alternating sequence of two characters ; Stores length of the string ; Generate every pair of English alphabets ; Function call to find length of alternating sequence for current pair of characters ; Update len to store the maximum of len and newLen in len ; Return n - len as the final result ; Driver Code ; Given Input ; Function call to find minimum characters required to be removed from S to make it an alternating sequence of a pair of characters",
        "Category": "Substring"
    },
    {
        "ID": "3011-3011",
        "Code": "def removeDuplicateCharacters ( arr ) : NEW_LINE INDENT cset = set ( [ ] ) NEW_LINE n = len ( arr ) NEW_LINE out = [ ] NEW_LINE for st in arr : NEW_LINE INDENT out_curr = \" \" NEW_LINE for ch in st : NEW_LINE INDENT if ( ch in cset ) : NEW_LINE INDENT continue NEW_LINE DEDENT out_curr += ch NEW_LINE cset . add ( ch ) NEW_LINE DEDENT if ( len ( out_curr ) ) : NEW_LINE INDENT out . append ( out_curr ) NEW_LINE DEDENT DEDENT for i in range ( len ( out ) ) : NEW_LINE INDENT print ( out [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" Geeks \" , \" For \" , \" Geeks \" , \" Post \" ] NEW_LINE removeDuplicateCharacters ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify array of strings by replacing characters repeating in the same or remaining strings | Function to remove duplicate characters across the strings ; Stores distinct characters ; Size of the array ; Stores the list of modified strings ; Traverse the array ; Stores the modified string ; Iterate over the characters of the modified string ; If character is already present ; Insert character into the Set ; Print the list of modified strings ; Print each string ; Driver Code ; Given array of strings ; Function Call to modify the given array of strings",
        "Category": "Array"
    },
    {
        "ID": "3014-3014",
        "Code": "def minJumps ( arr , jump , N ) : NEW_LINE INDENT jumps = 0 NEW_LINE temp = [ 0 for i in range ( 1000 ) ] NEW_LINE vect = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT vect . append ( [ arr [ i ] , i + 1 ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT temp [ arr [ i ] ] = jump [ i ] NEW_LINE DEDENT vect . sort ( reverse = False ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT while ( vect [ i ] [ 1 ] <= vect [ i - 1 ] [ 1 ] ) : NEW_LINE INDENT vect [ i ] = [ vect [ i ] [ 0 ] , vect [ i ] [ 1 ] + temp [ vect [ i ] [ 0 ] ] ] NEW_LINE jumps += 1 NEW_LINE DEDENT DEDENT print ( jumps ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 ] NEW_LINE jump = [ 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE minJumps ( arr , jump , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of jumps required to sort the given array in ascending order | Function to count minimum number of jumps required to sort the array ; Stores minimum number of jumps ; Stores distances of jumps ; Stores the array elements with their starting indices ; Push the pairs { arr [ i ] , i + 1 } into the vector of pairs vect ; Update vect ; Populate the array temp [ ] ; Update temp [ arr [ i ] ] ; Sort the vector in the ascending order ; Jump till the previous index <= current index ; Update vect [ i ] ; Increment the number of jumps ; Print the minimum number of jumps required ; Driver Code ; Input ; Size of the array",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3015-3015",
        "Code": "def isComment ( line ) : NEW_LINE INDENT if ( line [ 0 ] == ' / ' and line [ 1 ] == ' / ' and line [ 2 ] != ' / ' ) : NEW_LINE INDENT print ( \" It ▁ is ▁ a ▁ single - line ▁ comment \" ) NEW_LINE return NEW_LINE DEDENT if ( line [ len ( line ) - 2 ] == ' * ' and line [ len ( line ) - 1 ] == ' / ' and line [ 0 ] == ' / ' and line [ 1 ] == ' * ' ) : NEW_LINE INDENT print ( \" It ▁ is ▁ a ▁ multi - line ▁ comment \" ) NEW_LINE return NEW_LINE DEDENT print ( \" It ▁ is ▁ not ▁ a ▁ comment \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT line = \" GeeksForGeeks ▁ GeeksForGeeks \" NEW_LINE isComment ( line ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given string is a comment or not | Function to check if the given string is a comment or not ; If two continuous slashes preceeds the comment ; Driver Code ; Given string ; Function call to check whether then given string is a comment or not",
        "Category": "Substring"
    },
    {
        "ID": "3029-3029",
        "Code": "def indivisibleDigits ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT num = 0 NEW_LINE print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE for j in range ( 2 , 10 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE flag = True NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( ( temp % 10 ) != 0 and ( temp % 10 ) % j == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT temp //= 10 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT print ( j , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT arr = [ 4162 , 1152 , 99842 ] NEW_LINE N = len ( arr ) NEW_LINE indivisibleDigits ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Print digits for each array element that does not divide any digit of that element | Function to find digits for each array element that doesn 't divide any digit of the that element ; Traverse the array arr [ ] ; Iterate over the range [ 2 , 9 ] ; Stores if there exists any digit in arr [ i ] which is divisible by j ; If any digit of the number is divisible by j ; If the digit j doesn 't  divide any digit of arr[i] ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "303-303",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , item , parent ) : NEW_LINE INDENT self . data = item NEW_LINE self . left = self . right = None NEW_LINE self . parent = parent NEW_LINE DEDENT DEDENT def findRightSibling ( node , level ) : NEW_LINE INDENT if ( node == None or node . parent == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT while ( node . parent . right == node or ( node . parent . right == None and node . parent . left == node ) ) : NEW_LINE INDENT if ( node . parent == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT node = node . parent NEW_LINE level -= 1 NEW_LINE DEDENT node = node . parent . right NEW_LINE while ( level < 0 ) : NEW_LINE INDENT if ( node . left != None ) : NEW_LINE INDENT node = node . left NEW_LINE DEDENT elif ( node . right != None ) : NEW_LINE INDENT node = node . right NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT level += 1 NEW_LINE DEDENT if ( level == 0 ) : NEW_LINE INDENT return node NEW_LINE DEDENT return findRightSibling ( node , level ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 , None ) NEW_LINE root . left = newNode ( 2 , root ) NEW_LINE root . right = newNode ( 3 , root ) NEW_LINE root . left . left = newNode ( 4 , root . left ) NEW_LINE root . left . right = newNode ( 6 , root . left ) NEW_LINE root . left . left . left = newNode ( 7 , root . left . left ) NEW_LINE root . left . left . left . left = newNode ( 10 , root . left . left . left ) NEW_LINE root . left . right . right = newNode ( 9 , root . left . right ) NEW_LINE root . right . right = newNode ( 5 , root . right ) NEW_LINE root . right . right . right = newNode ( 8 , root . right . right ) NEW_LINE root . right . right . right . right = newNode ( 12 , root . right . right . right ) NEW_LINE res = findRightSibling ( root . left . left . left . left , 0 ) NEW_LINE if ( res == None ) : NEW_LINE INDENT print ( \" No ▁ right ▁ sibling \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res . data ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find right sibling of a binary tree with parent pointers | A class to create a new Binary Tree Node ; Method to find right sibling ; GET Parent pointer whose right child is not a parent or itself of this node . There might be case when parent has no right child , but , current node is left child of the parent ( second condition is for that ) . ; Move to the required child , where right sibling can be present ; find right sibling in the given subtree ( from current node ) , when level will be 0 ; Iterate through subtree ; if no child are there , we cannot have right sibling in this path ; This is the case when we reach 9 node in the tree , where we need to again recursively find the right sibling ; Driver Code ; passing 10",
        "Category": "Binary Tree"
    },
    {
        "ID": "3030-3030",
        "Code": "def printt ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def makeLexicographically ( arr , N ) : NEW_LINE INDENT index = 0 NEW_LINE temp = 0 NEW_LINE check = 0 NEW_LINE condition = 0 NEW_LINE element = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( element == arr [ i ] ) : NEW_LINE INDENT check = i NEW_LINE break NEW_LINE DEDENT elif ( arr [ i ] != i + 1 and check == 0 ) : NEW_LINE INDENT index = i NEW_LINE check = 1 NEW_LINE condition = - 1 NEW_LINE element = i + 1 NEW_LINE DEDENT DEDENT if ( condition == - 1 ) : NEW_LINE INDENT temp = arr [ index ] NEW_LINE arr [ index ] = arr [ check ] NEW_LINE arr [ check ] = temp NEW_LINE DEDENT printt ( arr , N ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE makeLexicographically ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Lexicographically smallest permutation of the array possible by at most one swap | ''Function to print the elements of the array arr[] ; '' Traverse the array arr[] ; ''Function to convert given array to lexicographically smallest permutation possible by swapping at most one pair ; '' Stores the index of the first  element which is not at its  correct position ; '' Checks if any such array  element exists or not ; '' Traverse the given array ; '' If element is found at i ; '' If the first array is  not in correct position ; '' Store the index of  the first elements ; '' Store the index of  the first element ; '' Swap the pairs ; '' Print the array ; ''Given array ; ''Store the size of the array",
        "Category": "Array"
    },
    {
        "ID": "3033-3033",
        "Code": "def sumOfDigits ( s ) : NEW_LINE INDENT curr = 0 NEW_LINE ret = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ( ord ( ch ) >= 48 and ord ( ch ) <= 57 ) : NEW_LINE INDENT curr = curr * 10 + ord ( ch ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT ret += curr NEW_LINE curr = 0 NEW_LINE DEDENT DEDENT ret += curr NEW_LINE return ret NEW_LINE DEDENT S = \"11aa32bbb5\" NEW_LINE print ( sumOfDigits ( S ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of numbers formed by consecutive digits present in a given string | Function to calculate the sum of numbers formed by consecutive sequences of digits present in the string ; Stores consecutive digits present in the string ; Stores the sum ; Iterate over characters of the input string ; If current character is a digit ; Append current digit to curr ; Add curr to sum ; Reset curr ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "3035-3035",
        "Code": "from collections import defaultdict NEW_LINE def findConcatenatedNumbers ( a , b ) : NEW_LINE INDENT ans = True NEW_LINE n1 = len ( a ) NEW_LINE n2 = len ( b ) NEW_LINE cnt = defaultdict ( int ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT left = b [ i ] NEW_LINE right = 0 NEW_LINE mul = 1 NEW_LINE while ( left > 9 ) : NEW_LINE INDENT right += ( left % 10 ) * mul NEW_LINE left //= 10 NEW_LINE mul *= 10 NEW_LINE if ( cnt [ left ] == 1 and cnt [ right ] == 1 ) : NEW_LINE INDENT ans = False NEW_LINE print ( b [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if ( ans ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 34 , 4 , 5 ] NEW_LINE b = [ 26 , 24 , 345 , 4 , 22 ] NEW_LINE findConcatenatedNumbers ( a , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if an array element is concatenation of two elements from another array | Python3 program for the above approach ; Function to find elements present in the array b [ ] which are concatenation of any pair of elements in the array a [ ] ; Stores if there doesn 't any such  element in the array brr[] ; Stored the size of both the arrays ; Store the presence of an element of array a [ ] ; Traverse the array a [ ] ; Traverse the array b [ ] ; Traverse over all possible concatenations of b [ i ] ; Update right and left parts ; Check if both left and right parts are present in a [ ] ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3036-3036",
        "Code": "def isLower ( c ) : NEW_LINE INDENT return ord ( c ) >= ord ( ' a ' ) and ord ( c ) <= ord ( ' z ' ) NEW_LINE DEDENT def isUpper ( c ) : NEW_LINE INDENT return ord ( c ) >= ord ( ' A ' ) and ord ( c ) <= ord ( ' Z ' ) NEW_LINE DEDENT def detectUppercaseUseUtil ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE i = 0 NEW_LINE if ( isLower ( S [ 0 ] ) ) : NEW_LINE INDENT i = 1 NEW_LINE while ( S [ i ] and isLower ( S [ i ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return True if ( i == N ) else False NEW_LINE DEDENT else : NEW_LINE INDENT i = 1 NEW_LINE while ( S [ i ] and isUpper ( S [ i ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( i > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( S [ i ] and isLower ( S [ i ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return True if ( i == N ) else False NEW_LINE DEDENT DEDENT def detectUppercaseUse ( S ) : NEW_LINE INDENT check = detectUppercaseUseUtil ( S ) NEW_LINE if ( check ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" GeeKs \" NEW_LINE detectUppercaseUse ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if uppercase characters in a string are used correctly or not | ''Function to check if the character c is in lowercase or not ; ''Function to check if the character c is in uppercase or not ; ''Utility function to check if uppercase characters are used correctly or not ; '' Length of string ; '' If the first character is in lowercase ; '' Otherwise ; '' Check if all characters  are in uppercase or not ; '' If all characters are  in uppercase ; '' Check if all characters except  the first are in lowercase ; ''Function to check if uppercase characters are used correctly or not ; '' Stores whether the use of uppercase  characters are correct or not ; '' If correct ; '' Otherwise ; ''Driver Code ; '' Given string ; '' Function call to check if use of  uppercase characters is correct or not",
        "Category": "Substring"
    },
    {
        "ID": "3039-3039",
        "Code": "def evenproduct ( arr , length ) : NEW_LINE INDENT total_subarray = length * ( length + 1 ) // 2 NEW_LINE total_odd = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE total_odd += count_odd NEW_LINE DEDENT DEDENT print ( total_subarray - total_odd ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 5 , 4 , 9 ] NEW_LINE length = len ( arr ) NEW_LINE evenproduct ( arr , length ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of subarrays having even product | Function to count subarrays with even product ; Total number of subarrays ; Counter variables ; Traverse the array ; If current element is odd ; Update count of subarrays with odd product up to index i ; Print count of subarrays with even product ; Driver code ; Input ; Length of an array ; Function call to count even product subarrays",
        "Category": "Sliding Window"
    },
    {
        "ID": "304-304",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def nextRightNode ( root , k , level , value_level ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( root . key == k ) : NEW_LINE INDENT value_level [ 0 ] = level NEW_LINE return None NEW_LINE DEDENT elif ( value_level [ 0 ] ) : NEW_LINE INDENT if ( level == value_level [ 0 ] ) : NEW_LINE INDENT return root NEW_LINE DEDENT DEDENT leftNode = nextRightNode ( root . left , k , level + 1 , value_level ) NEW_LINE if ( leftNode ) : NEW_LINE INDENT return leftNode NEW_LINE DEDENT return nextRightNode ( root . right , k , level + 1 , value_level ) NEW_LINE DEDENT def nextRightNodeUtil ( root , k ) : NEW_LINE INDENT value_level = [ 0 ] NEW_LINE return nextRightNode ( root , k , 1 , value_level ) NEW_LINE DEDENT def test ( root , k ) : NEW_LINE INDENT nr = nextRightNodeUtil ( root , k ) NEW_LINE if ( nr != None ) : NEW_LINE INDENT print ( \" Next ▁ Right ▁ of \" , k , \" is \" , nr . key ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ next ▁ right ▁ node ▁ found ▁ for \" , k ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE test ( root , 10 ) NEW_LINE test ( root , 2 ) NEW_LINE test ( root , 6 ) NEW_LINE test ( root , 5 ) NEW_LINE test ( root , 8 ) NEW_LINE test ( root , 4 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find next right node of a given key | Set 2 | class to create a new tree node ; Function to find next node for given node in same level in a binary tree by using pre - order traversal ; return None if tree is empty ; if desired node is found , set value_level to current level ; if value_level is already set , then current node is the next right node ; recurse for left subtree by increasing level by 1 ; if node is found in left subtree , return it ; recurse for right subtree by increasing level by 1 ; Function to find next node of given node in the same level in given binary tree ; A utility function to test above functions ; Driver Code ; Let us create binary tree given in the above example",
        "Category": "Binary Tree"
    },
    {
        "ID": "3044-3044",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self , val = 0 , left = None , right = None ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = left NEW_LINE self . right = right NEW_LINE DEDENT DEDENT def convertBinaryToDecimal ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT ans = ( ans << 1 ) | i NEW_LINE DEDENT return ans NEW_LINE DEDENT def decimalEquilvalentAtEachLevel ( root ) : NEW_LINE INDENT ans = 0 NEW_LINE que = [ root ] NEW_LINE while True : NEW_LINE INDENT length = len ( que ) NEW_LINE if not length : NEW_LINE INDENT break NEW_LINE DEDENT eachLvl = [ ] NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE eachLvl . append ( temp . val ) NEW_LINE if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT ans += convertBinaryToDecimal ( eachLvl ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT root = TreeNode ( 0 ) NEW_LINE root . left = TreeNode ( 1 ) NEW_LINE root . right = TreeNode ( 0 ) NEW_LINE root . left . left = TreeNode ( 0 ) NEW_LINE root . left . right = TreeNode ( 1 ) NEW_LINE root . right . left = TreeNode ( 1 ) NEW_LINE root . right . right = TreeNode ( 1 ) NEW_LINE decimalEquilvalentAtEachLevel ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of decimal equivalents of binary node values in each level of a Binary Tree | Structure of a Tree Node ; Function to convert binary number to its equivalent decimal value ; Function to calculate sum of decimal equivalent of binary numbers of node values present at each level ; Push root node into queue ; Connect nodes at the same level to form a binary number ; Stores the front element of the queue ; Append the value of the current node to eachLvl ; Insert the Left child to queue , if its not NULL ; Insert the Right child to queue , if its not NULL ; Decrement length by one ; Add decimal equivalent of the binary number formed on the current level to ans ; Finally print ans ; Given Tree ; Function Call",
        "Category": "Binary Tree"
    },
    {
        "ID": "3045-3045",
        "Code": "def countSubstrings ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE subs = 1 NEW_LINE pre = ' ' NEW_LINE for i in s : NEW_LINE INDENT if pre == i : NEW_LINE INDENT subs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT subs = 1 NEW_LINE DEDENT ans += subs NEW_LINE pre = i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT s = ' geeksforgeeks ' NEW_LINE countSubstrings ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Count substrings made up of a single distinct character | Function to count the number of substrings made up of a single distinct character ; Stores the required count ; Stores the count of substrings possible by using current character ; Stores the previous character ; Traverse the string ; If current character is same as the previous character ; Increase count of substrings possible with current character ; Reset count of substrings possible with current character ; Update count of substrings ; Update previous character ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "3056-3056",
        "Code": "def checkAnagram ( s1 , s2 ) : NEW_LINE INDENT s2hash = [ 0 for i in range ( 26 ) ] NEW_LINE s1hash = [ 0 for i in range ( 26 ) ] NEW_LINE s1len = len ( s1 ) NEW_LINE s2len = len ( s2 ) NEW_LINE if ( s1len > s2len ) : NEW_LINE INDENT return False NEW_LINE DEDENT left = 0 NEW_LINE right = 0 NEW_LINE while ( right < s1len ) : NEW_LINE INDENT s1hash [ ord ( s1 [ right ] ) - 97 ] += 1 NEW_LINE s2hash [ ord ( s2 [ right ] ) - 97 ] += 1 NEW_LINE right += 1 NEW_LINE DEDENT right -= 1 NEW_LINE while ( right < s2len ) : NEW_LINE INDENT if ( s1hash == s2hash ) : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE if ( right != s2len ) : NEW_LINE INDENT s2hash [ ord ( s2 [ right ] ) - 97 ] += 1 NEW_LINE DEDENT s2hash [ ord ( s2 [ left ] ) - 97 ] -= 1 NEW_LINE left += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" ab \" NEW_LINE s2 = \" bbpobac \" NEW_LINE if ( checkAnagram ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string contains an anagram of another string as its substring | Function to check if string s2 contains anagram of the string s1 as its substring ; Stores frequencies of characters in substrings of s2 ; Stores frequencies of characters in s1 ; If length of s2 exceeds length of s1 ; Store frequencies of characters in first substring of length s1len in string s2 ; Perform Sliding Window technique ; If hashmaps are found to be identical for any substring ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3057-3057",
        "Code": "from bisect import bisect_left , bisect_right NEW_LINE def minSegments ( segments , n ) : NEW_LINE INDENT startPoints = [ 0 for i in range ( n ) ] NEW_LINE endPoints = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT startPoints [ i ] = segments [ i ] [ 0 ] NEW_LINE endPoints [ i ] = segments [ i ] [ 1 ] NEW_LINE DEDENT startPoints . sort ( reverse = False ) NEW_LINE endPoints . sort ( reverse = False ) NEW_LINE ans = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT f = segments [ i ] [ 0 ] NEW_LINE s = segments [ i ] [ 1 ] NEW_LINE leftDelete = bisect_left ( endPoints , f ) NEW_LINE rightDelete = max ( 0 , n - bisect_right ( startPoints , s ) ) NEW_LINE ans = min ( ans , leftDelete + rightDelete ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 10 ] , [ 8 , 9 ] ] NEW_LINE N = len ( arr ) NEW_LINE minSegments ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize segments required to be removed such that at least one segment intersects with all remaining segments | Pyhton3 program for the above approach ; Function to find the minimum number of segments required to be deleted ; Stores the start and end points ; Traverse segments and fill the startPoints and endPoints ; Sort the startPoints ; Sort the startPoints ; Store the minimum number of deletions required and initialize with ( N - 1 ) ; Traverse the array segments [ ] ; Store the starting point ; Store the ending point ; Store the number of segments satisfying the first condition of non - intersection ; Store the number of segments satisfying the second condition of non - intersection ; Update answer ; Print the answer ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "306-306",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def threelargest ( root , first , second , third ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( root . data > first [ 0 ] ) : NEW_LINE INDENT third [ 0 ] = second [ 0 ] NEW_LINE second [ 0 ] = first [ 0 ] NEW_LINE first [ 0 ] = root . data NEW_LINE DEDENT elif ( root . data > second [ 0 ] and root . data != first [ 0 ] ) : NEW_LINE INDENT third [ 0 ] = second [ 0 ] NEW_LINE second [ 0 ] = root . data NEW_LINE DEDENT elif ( root . data > third [ 0 ] and root . data != first [ 0 ] and root . data != second [ 0 ] ) : NEW_LINE INDENT third [ 0 ] = root . data NEW_LINE DEDENT threelargest ( root . left , first , second , third ) NEW_LINE threelargest ( root . right , first , second , third ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE first = [ 0 ] NEW_LINE second = [ 0 ] NEW_LINE third = [ 0 ] NEW_LINE threelargest ( root , first , second , third ) NEW_LINE print ( \" three ▁ largest ▁ elements ▁ are \" , first [ 0 ] , second [ 0 ] , third [ 0 ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Top three elements in binary tree | Helper function that allocates a new Node with the given data and None left and right pointers . ; function to find three largest element ; if data is greater than first large number update the top three list ; if data is greater than second large number and not equal to first update the bottom two list ; if data is greater than third large number and not equal to first & second update the third highest list ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "3061-3061",
        "Code": "def longestSubstring ( s , k ) : NEW_LINE INDENT ans = 0 NEW_LINE freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT unique = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT DEDENT for curr_unique in range ( 1 , unique + 1 ) : NEW_LINE INDENT Freq = [ 0 ] * 26 NEW_LINE start , end = 0 , 0 NEW_LINE cnt , count_k = 0 , 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT if ( cnt <= curr_unique ) : NEW_LINE INDENT ind = ord ( s [ end ] ) - ord ( ' a ' ) NEW_LINE if ( Freq [ ind ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT Freq [ ind ] += 1 NEW_LINE if ( Freq [ ind ] == k ) : NEW_LINE INDENT count_k += 1 NEW_LINE DEDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ind = ord ( s [ start ] ) - ord ( ' a ' ) NEW_LINE if ( Freq [ ind ] == k ) : NEW_LINE INDENT count_k -= 1 NEW_LINE DEDENT Freq [ ind ] -= 1 NEW_LINE if ( Freq [ ind ] == 0 ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT if ( ( cnt == curr_unique ) and ( count_k == curr_unique ) ) : NEW_LINE INDENT ans = max ( ans , end - start ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT / * Driver Code * / NEW_LINE S = \" aabbba \" NEW_LINE K = 3 NEW_LINE longestSubstring ( S , K ) NEW_LINE",
        "Type": "py",
        "NL": "Longest substring where all the characters appear at least K times | Set 3 | Function to find the length of the longest substring ; Store the required answer ; Create a frequency map of the characters of the string ; Store the length of the string ; Traverse the string , s ; Increment the frequency of the current character by 1 ; Stores count of unique characters ; Find the number of unique characters in string ; Iterate in range [ 1 , unique ] ; Initialize frequency of all characters as 0 ; Stores the start and the end of the window ; Stores the current number of unique characters and characters occuring atleast K times ; New unique character ; New character which occurs atleast k times ; Expand window by incrementing end by 1 ; Check if this character is present atleast k times ; Check if this character is unique ; Shrink the window by incrementing start by 1 ; If there are curr_unique characters and each character is atleast k times ; Update the overall maximum length ; Print the answer ;",
        "Category": "Sliding Window"
    },
    {
        "ID": "3069-3069",
        "Code": "def prefixArr ( arr , prefix , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT prefix [ i ] [ 0 ] = arr [ i ] NEW_LINE prefix [ i ] [ 1 ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] [ 0 ] = max ( prefix [ i - 1 ] [ 0 ] , arr [ i ] ) NEW_LINE prefix [ i ] [ 1 ] = min ( prefix [ i - 1 ] [ 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT return prefix NEW_LINE DEDENT def suffixArr ( arr , suffix , N ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT suffix [ i ] [ 0 ] = arr [ i ] NEW_LINE suffix [ i ] [ 1 ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] [ 0 ] = max ( suffix [ i + 1 ] [ 0 ] , arr [ i ] ) NEW_LINE suffix [ i ] [ 1 ] = min ( suffix [ i + 1 ] [ 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT return suffix NEW_LINE DEDENT def maxAndmin ( prefix , suffix , N , L , R ) : NEW_LINE INDENT maximum , minimum = 0 , 0 NEW_LINE if ( L == 0 and R == N - 1 ) : NEW_LINE INDENT print ( \" No ▁ maximum ▁ and ▁ minimum ▁ value \" ) NEW_LINE return NEW_LINE DEDENT elif ( L == 0 ) : NEW_LINE INDENT maximum = suffix [ R + 1 ] [ 0 ] NEW_LINE minimum = suffix [ R + 1 ] [ 1 ] NEW_LINE DEDENT elif ( R == N - 1 ) : NEW_LINE INDENT maximum = prefix [ L - 1 ] [ 0 ] NEW_LINE minimum = prefix [ R - 1 ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( prefix [ L - 1 ] [ 0 ] , suffix [ R + 1 ] [ 0 ] ) NEW_LINE minimum = min ( prefix [ L - 1 ] [ 1 ] , suffix [ R + 1 ] [ 1 ] ) NEW_LINE DEDENT print ( maximum , minimum ) NEW_LINE DEDENT def MinMaxQueries ( a , queries ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE q = len ( queries ) NEW_LINE prefix = [ [ 0 for i in range ( 2 ) ] for i in range ( N ) ] NEW_LINE suffix = [ [ 0 for i in range ( 2 ) ] for i in range ( N ) ] NEW_LINE prefix = prefixArr ( arr , prefix , N ) NEW_LINE suffix = suffixArr ( arr , suffix , N ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT L = queries [ i ] [ 0 ] NEW_LINE R = queries [ i ] [ 1 ] NEW_LINE maxAndmin ( prefix , suffix , N , L , R ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 8 , 3 , 5 , 7 , 4 ] NEW_LINE queries = [ [ 4 , 6 ] , [ 0 , 4 ] , [ 3 , 7 ] , [ 2 , 5 ] ] NEW_LINE MinMaxQueries ( arr , queries ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to find the maximum and minimum array elements excluding elements from a given range | Function to find the maximum and minimum array elements up to the i - th index ; Traverse the array ; Compare current value with maximum and minimum values up to previous index ; Function to find the maximum and minimum array elements from i - th index ; Traverse the array in reverse ; Compare current value with maximum and minimum values in the next index ; Function to find the maximum and minimum array elements for each query ; If no index remains after excluding the elements in a given range ; Find maximum and minimum from from the range [ R + 1 , N - 1 ] ; Find maximum and minimum from from the range [ 0 , N - 1 ] ; Find maximum and minimum values from the ranges [ 0 , L - 1 ] and [ R + 1 , N - 1 ] ; Print maximum and minimum value ; Function to perform queries to find the minimum and maximum array elements excluding elements from a given range ; Size of the array ; Size of query array ; prefix [ i ] [ 0 ] : Stores the maximum prefix [ i ] [ 1 ] : Stores the minimum value ; suffix [ i ] [ 0 ] : Stores the maximum suffix [ i ] [ 1 ] : Stores the minimum value ; Function calls to store maximum and minimum values for respective ranges ; Driver Code ; Given array",
        "Category": "Array"
    },
    {
        "ID": "3074-3074",
        "Code": "def check ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( N & ( N - 1 ) ) == 0 ) NEW_LINE DEDENT def build_seg_tree ( ss , se , si , tree , arr ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT tree [ si ] = check ( arr [ ss ] ) NEW_LINE return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE build_seg_tree ( ss , mid , 2 * si + 1 , tree , arr ) NEW_LINE build_seg_tree ( mid + 1 , se , 2 * si + 2 , tree , arr ) NEW_LINE tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] NEW_LINE DEDENT def update ( ss , se , si , X , V , tree , arr ) : NEW_LINE INDENT if ( ss == se ) : NEW_LINE INDENT if ( ss == X ) : NEW_LINE INDENT arr [ X ] = V NEW_LINE tree [ si ] = check ( V ) NEW_LINE DEDENT return NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE if ( X <= mid ) : NEW_LINE INDENT update ( ss , mid , 2 * si + 1 , X , V , tree , arr ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( mid + 1 , se , 2 * si + 2 , X , V , tree , arr ) NEW_LINE DEDENT tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] NEW_LINE DEDENT def query ( l , r , ss , se , si , tree ) : NEW_LINE INDENT if ( r < ss or l > se ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l <= ss and r >= se ) : NEW_LINE INDENT return tree [ si ] NEW_LINE DEDENT mid = ( ss + se ) // 2 NEW_LINE return ( query ( l , r , ss , mid , 2 * si + 1 , tree ) + query ( l , r , mid + 1 , se , 2 * si + 2 , tree ) ) NEW_LINE DEDENT def Query ( arr , N , Q ) : NEW_LINE INDENT tree = [ 0 ] * ( 4 * N ) NEW_LINE build_seg_tree ( 0 , N - 1 , 0 , tree , arr ) NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT if ( Q [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT print ( query ( Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , 0 , N - 1 , 0 , tree ) , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( 0 , N - 1 , 0 , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , tree , arr ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , 11 , 16 , 2 , 32 ] NEW_LINE Q = [ [ 1 , 0 , 2 ] , [ 2 , 4 , 24 ] , [ 1 , 1 , 4 ] ] NEW_LINE N = len ( arr ) NEW_LINE Query ( arr , N , Q ) NEW_LINE",
        "Type": "py",
        "NL": "Queries to count array elements from a given range having a single set bit | ''Check if N has only one set bit ; ''Function to build segment tree ; '' If se is leaf node ; '' Update the node ; '' Stores mid value of segment [ss, se] ; '' Recursive call for left Subtree ; '' Recursive call for right Subtree ; '' Update the Current Node ; ''Function to update a value at Xth index ; '' If ss is equal to X ; '' Update the Xth node ; '' Update the tree ; '' Stores the mid of segment [ss, se] ; '' Update current node ; ''Count of numbers having one set bit ; '' If L > se or R < ss  Invalid Range ; '' If [ss, se] lies  inside the [L, R] ; '' Stores the mid of segment [ss, se] ; '' Return the sum after recursively  traversing left and right subtree ; ''Function to solve queries ; '' Initialise Segment tree ; '' Build segment tree ; '' Perform queries ; ''Input ; ''Function call to solve queries",
        "Category": "Segment Tree"
    },
    {
        "ID": "3075-3075",
        "Code": "def numberOfPairs ( arr , N ) : NEW_LINE INDENT set_bits = [ 0 ] * 31 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE bitpos = - 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT bitpos += 1 NEW_LINE x //= 2 NEW_LINE DEDENT for j in range ( bitpos + 1 ) : NEW_LINE INDENT count += set_bits [ j ] NEW_LINE DEDENT set_bits [ bitpos ] += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 16 , 8 , 64 ] NEW_LINE N = len ( arr ) NEW_LINE numberOfPairs ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs made up of an element divisible by the other from an array consisting of powers of 2 | Function to count the number of pairs as per the given conditions ; Initialize array set_bits as 0 ; Store the total number of required pairs ; Traverse the array arr [ ] ; Store arr [ i ] in x ; Store the position of the leftmost set bit in arr [ i ] ; Increase bit position ; Divide by 2 to shift bits in right at each step ; Count of pairs for index i till its set bit position ; Increasing count of set bit position of current elelement ; Prthe answer ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "3089-3089",
        "Code": "m = 0 NEW_LINE n = 0 NEW_LINE def valid ( x , y ) : NEW_LINE INDENT global n NEW_LINE global m NEW_LINE return ( x >= 0 and x < m and y >= 0 and y < n ) NEW_LINE DEDENT def border ( x , y ) : NEW_LINE INDENT global n NEW_LINE global m NEW_LINE return ( x == 0 or x == m - 1 or y == 0 or y == n - 1 ) NEW_LINE DEDENT def minStep ( mat ) : NEW_LINE INDENT global n NEW_LINE global m NEW_LINE m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE dx = [ 1 , - 1 , 0 , 0 ] NEW_LINE dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE pQ = [ ] NEW_LINE fQ = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 2 ) : NEW_LINE INDENT fQ . append ( [ i , j ] ) NEW_LINE DEDENT elif ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if ( border ( i , j ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT pQ . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT depth = 0 NEW_LINE visited = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE while ( len ( pQ ) > 0 ) : NEW_LINE INDENT depth += 1 NEW_LINE i = len ( pQ ) NEW_LINE while ( i > 0 ) : NEW_LINE INDENT pos = pQ [ 0 ] NEW_LINE pQ . remove ( pQ [ 0 ] ) NEW_LINE if ( mat [ pos [ 0 ] ] [ pos [ 1 ] ] == 2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 4 ) : NEW_LINE INDENT x = pos [ 0 ] + dx [ j ] NEW_LINE y = pos [ 1 ] + dy [ j ] NEW_LINE if ( valid ( x , y ) and mat [ x ] [ y ] != 2 and visited [ x ] [ y ] == 0 ) : NEW_LINE INDENT visited [ x ] [ y ] = 1 NEW_LINE pQ . append ( [ x , y ] ) NEW_LINE if ( border ( x , y ) ) : NEW_LINE INDENT return depth NEW_LINE DEDENT DEDENT DEDENT i -= 1 NEW_LINE DEDENT i = len ( fQ ) NEW_LINE while ( i > 0 ) : NEW_LINE INDENT pos = fQ [ 0 ] NEW_LINE fQ . remove ( fQ [ 0 ] ) NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT x = pos [ 0 ] + dx [ j ] NEW_LINE y = pos [ 1 ] + dy [ j ] NEW_LINE if ( valid ( x , y ) and mat [ x ] [ y ] != 2 ) : NEW_LINE INDENT mat [ x ] [ y ] = 2 NEW_LINE fQ . append ( [ x , y ] ) NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 0 , 0 , 0 , 0 ] , [ 2 , 0 , 0 , 0 ] , [ 2 , 1 , 0 , 0 ] , [ 2 , 2 , 0 , 0 ] ] NEW_LINE print ( minStep ( grid ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum moves required to come out of a grid safely | ''Stores size of the grid ; ''Function to check valid cells of the grid ; ''Checks for the border sides ; ''Function to find shortest distance between two cells of the grid ; '' Rows of the grid ; '' Column of the grid ; '' Stores possible move  of the person ; '' Store possible cells visited  by the person ; '' Store possible cells which  are burning ; '' Traverse the grid ; '' If current cell is  burning ; '' If person is in  the current cell ; '' Stores shortest distance  between two cells ; '' Check if a cell is visited  by the person or not ; '' While pQ is not empty ; '' Update depth ; '' Popped all the cells from  pQ and mark all adjacent cells  of as visited ; '' Front element of  the queue pQ ; '' Remove front element of  the queue pQ ; '' If current cell is burning ; '' Find all adjacent cells ; '' Stores row number of  adjacent cell ; '' Stores column number  of adjacent cell ; '' Checks if current cell  is valid ; '' Mark the cell as visited ; '' Enqueue the cell ; '' Checks the escape condition ; '' Burn all the adjacent cells  of burning cells ; '' Front element of  the queue fQ ; '' Delete front element of  the queue fQ ; '' Find adjacent cells of  burning cell ; '' Stores row number of  adjacent cell ; '' Stores column number  of adjacent cell ; '' Checks if current  cell is valid ; '' Burn all the adjacent  cells of current cell ; ''Driver Code ; '' Given grid",
        "Category": "Breadth-First Search (BFS)"
    },
    {
        "ID": "3092-3092",
        "Code": "N = 2 * 100000 NEW_LINE prime = [ 0 ] * N NEW_LINE def Sieve ( ) : NEW_LINE INDENT p = [ True ] * ( N + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE i = 2 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( p [ i ] == True ) : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( p [ i ] != False ) : NEW_LINE INDENT prime . append ( pow ( i , 4 ) ) NEW_LINE DEDENT DEDENT DEDENT def countNumbers ( L , R ) : NEW_LINE INDENT Count = 0 NEW_LINE for p in prime : NEW_LINE INDENT if ( p >= L and p <= R ) : NEW_LINE INDENT Count += 1 NEW_LINE DEDENT DEDENT print ( Count ) NEW_LINE DEDENT L = 16 NEW_LINE R = 85000 NEW_LINE Sieve ( ) NEW_LINE countNumbers ( L , R ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers from a given range having exactly 5 distinct factors | Python3 implementation of the above approach ; Stores all prime numbers up to 2 * 10 ^ 5 ; Function to generate all prime numbers up to 2 * 10 ^ 5 using Sieve of Eratosthenes ; Mark 0 and 1 as non - prime ; If i is prime ; Mark all its factors as non - prime ; If current number is prime ; Store the prime ; Function to count numbers in the range [ L , R ] having exactly 5 factors ; Stores the required count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3098-3098",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE def newNode ( data ) : NEW_LINE INDENT Node = TreeNode ( data ) NEW_LINE return ( Node ) NEW_LINE DEDENT def sumofsubtree ( root ) : NEW_LINE INDENT global ans NEW_LINE p = [ 1 , 0 ] NEW_LINE if ( root . left != None ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT ans += p [ 1 ] NEW_LINE return p NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . left . left . right = newNode ( 9 ) NEW_LINE sumofsubtree ( root ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of subtree depths for every node of a given Binary Tree | Binary tree node ; Constructor to set the data of the newly created tree node ; Function to allocate a new node with the given data and null in its left and right pointers ; DFS function to calculate the sum of depths of all subtrees depth sum ; Store total number of node in its subtree and total sum of depth in its subtree ; Check if left is not null ; Call recursively the DFS function for left child ; Increment the sum of depths by ptemp . first + p . temp . first ; Increment p . first by count of noded in left subtree ; Check if right is not null ; Call recursively the DFS function for right child ; Increment the sum of depths by ptemp . first + p . temp . first ; Increment p . first by count of nodes in right subtree ; Increment the result by total sum of depth in current subtree ; Return p ; Given Tree ; Print the result",
        "Category": "Binary Tree"
    },
    {
        "ID": "3099-3099",
        "Code": "def finddigits ( s ) : NEW_LINE INDENT num = [ \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" ] NEW_LINE arr = [ 0 ] * ( 10 ) NEW_LINE ans = \" \" NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' z ' ) : NEW_LINE INDENT arr [ 0 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' w ' ) : NEW_LINE INDENT arr [ 2 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' g ' ) : NEW_LINE INDENT arr [ 8 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' x ' ) : NEW_LINE INDENT arr [ 6 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' v ' ) : NEW_LINE INDENT arr [ 5 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' o ' ) : NEW_LINE INDENT arr [ 1 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' s ' ) : NEW_LINE INDENT arr [ 7 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' f ' ) : NEW_LINE INDENT arr [ 4 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' h ' ) : NEW_LINE INDENT arr [ 3 ] += 1 NEW_LINE DEDENT if ( s [ i ] == ' i ' ) : NEW_LINE INDENT arr [ 9 ] += 1 NEW_LINE DEDENT DEDENT arr [ 7 ] -= arr [ 6 ] NEW_LINE arr [ 5 ] -= arr [ 7 ] NEW_LINE arr [ 4 ] -= arr [ 5 ] NEW_LINE arr [ 1 ] -= ( arr [ 2 ] + arr [ 4 ] + arr [ 0 ] ) NEW_LINE arr [ 3 ] -= arr [ 8 ] NEW_LINE arr [ 9 ] -= ( arr [ 5 ] + arr [ 6 ] + arr [ 8 ] ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans += chr ( ( i ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" owoftnuoer \" NEW_LINE print ( finddigits ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Digits whose alphabetic representations are jumbled in a given string | Function to convert the jumbled into digits ; Strings of digits 0 - 9 ; Initialize vector ; Initialize answer ; Size of the string ; Traverse the string ; Update the elements of the vector ; Print the digits into their original format ; Return answer ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3100-3100",
        "Code": "def countRemainingElements ( L1 , L2 , n ) : NEW_LINE INDENT one = 0 ; NEW_LINE zero = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( L1 [ i ] == 1 ) : NEW_LINE INDENT one += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 ; NEW_LINE DEDENT DEDENT ans = n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( L2 [ i ] == 1 ) : NEW_LINE INDENT one -= 1 ; NEW_LINE if ( one < 0 ) : NEW_LINE INDENT ans = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT zero -= 1 ; NEW_LINE if ( zero < 0 ) : NEW_LINE INDENT ans = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT print ( n - ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L1 = [ 1 , 1 , 0 , 0 ] ; NEW_LINE L2 = [ 0 , 0 , 0 , 1 ] ; NEW_LINE N = len ( L1 ) ; NEW_LINE countRemainingElements ( L1 , L2 , N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize remaining array sizes by removing equal pairs of first array elements | Function to count the remaining elements in the arrays ; Stores the count of 1 s in L1 ; Store the count of 0 s in L2 ; Traverse the array L1 ; If condition is True ; Increment one by 1 ; Increment zero by 1 ; Stores the index after which no further removals are possible ; Traverse the array L2 ; If condition is True ; Decrement one by 1 ; If one < 0 , then break out of the loop ; Decrement zero by 1 ; If zero < 0 , then break out of loop ; Print the answer ; Driver Code ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "3104-3104",
        "Code": "def check ( s1 , s2 ) : NEW_LINE INDENT s1_0 = 0 NEW_LINE s2_0 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT s1_0 += 1 NEW_LINE DEDENT if ( s2 [ i ] == '0' ) : NEW_LINE INDENT s2_0 += 1 NEW_LINE DEDENT DEDENT if ( s1_0 != s2_0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT Count1 = 0 NEW_LINE Count2 = 0 ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT Count1 += 1 NEW_LINE DEDENT if ( s2 [ i ] == '0' ) : NEW_LINE INDENT Count2 += 1 NEW_LINE DEDENT if ( Count1 < Count2 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" YES \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \"100111\" NEW_LINE s2 = \"111010\" NEW_LINE check ( s1 , s2 ) NEW_LINE s1 = \"110100\" NEW_LINE s2 = \"010101\" NEW_LINE check ( s1 , s2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if two binary strings can be made equal by swapping pairs of unequal characters | Function to check if a string s1 can be converted into s2 ; Count of '0' in strings in s1 and s2 ; Iterate both the strings and count the number of occurrences of ; Count is not equal ; Iterating over both the arrays and count the number of occurrences of '0 ; If the count of occurrences of '0' in S2 exceeds that in S1 ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "3105-3105",
        "Code": "def getCount ( rows , columns , A ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( i + 1 , rows , 1 ) : NEW_LINE INDENT if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ [ 4 , 8 ] , [ 10 , 20 ] , [ 15 , 30 ] , [ 3 , 6 ] ] NEW_LINE columns = 2 NEW_LINE rows = len ( A ) NEW_LINE print ( getCount ( rows , columns , A ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs of similar rectangles possible from a given array | Function to calculate the count of similar rectangles ; Driver Code ; Input",
        "Category": "Array"
    },
    {
        "ID": "3110-3110",
        "Code": "def isBinaryStringsEqual ( list1 , list2 ) : NEW_LINE INDENT str1 = list ( list1 ) NEW_LINE str2 = list ( list2 ) NEW_LINE str1Zeros = 0 NEW_LINE str1Ones = 0 NEW_LINE str2Zeros = 0 NEW_LINE str2Ones = 0 NEW_LINE flag = 0 NEW_LINE curStr1Ones = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == '1' ) : NEW_LINE INDENT str1Ones += 1 NEW_LINE DEDENT elif ( str1 [ i ] == '0' ) : NEW_LINE INDENT str1Zeros += 1 NEW_LINE DEDENT if ( str2 [ i ] == '1' ) : NEW_LINE INDENT str2Ones += 1 NEW_LINE DEDENT elif ( str2 [ i ] == '0' ) : NEW_LINE INDENT str2Zeros += 1 NEW_LINE DEDENT DEDENT if ( str1Zeros != str2Zeros and str1Ones != str2Ones ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT if ( str1 [ i ] == '0' and curStr1Ones > 0 ) : NEW_LINE INDENT str1 [ i ] = '1' NEW_LINE curStr1Ones -= 1 NEW_LINE DEDENT if ( str1 [ i ] == '0' and curStr1Ones == 0 ) : NEW_LINE INDENT flag += 1 NEW_LINE break NEW_LINE DEDENT if ( str1 [ i ] == '1' and str2 [ i ] == '0' ) : NEW_LINE INDENT str1 [ i ] = '0' NEW_LINE curStr1Ones += 1 NEW_LINE DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT str1 = \"0110\" NEW_LINE str2 = \"0011\" NEW_LINE isBinaryStringsEqual ( str1 , str2 ) NEW_LINE",
        "Type": "py",
        "NL": "Check if two binary strings can be made equal by swapping 1 s occurring before 0 s | Function to check if it is possible to make two binary strings equal by given operations ; Stores count of 1 ' s ▁ and ▁ 0' s of the string str1 ; Stores count of 1 ' s ▁ and ▁ 0' s of the string str2 ; Stores current count of 1 's  presenty in the string str1 ; Count the number of 1 ' s ▁ and ▁ 0' s present in the strings str1 and str2 ; If the number of 1 ' s ▁ and ▁ 0' s are not same of the strings str1 and str2 then prnot possible ; Traversing through the strings str1 and str2 ; If the str1 character not equals to str2 character ; Swaps 0 with 1 of the string str1 ; Breaks the loop as the count of 1 's is zero. Hence, no swaps possible ; Swaps 1 with 0 in the string str1 ; Prnot possible ; Given Strings ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3111-3111",
        "Code": "def maximumCount ( arr1 , arr2 , s1 , s2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( s1 ) : NEW_LINE INDENT sum1 += arr1 [ i ] NEW_LINE DEDENT for j in range ( s2 ) : NEW_LINE INDENT sum2 += arr2 [ j ] NEW_LINE DEDENT len = 0 NEW_LINE if ( s1 >= s2 ) : NEW_LINE INDENT lenn = s2 NEW_LINE DEDENT else : NEW_LINE INDENT lenn = s1 NEW_LINE DEDENT arr1 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE j = 0 NEW_LINE k = s2 - 1 NEW_LINE count = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( sum1 <= sum2 ) : NEW_LINE INDENT if ( arr2 [ k ] >= arr1 [ i ] ) : NEW_LINE INDENT dif1 = arr1 [ j ] NEW_LINE dif2 = arr2 [ k ] NEW_LINE sum1 -= dif1 NEW_LINE sum1 += dif2 NEW_LINE sum2 -= dif2 NEW_LINE sum2 += dif1 NEW_LINE j += 1 NEW_LINE k -= 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 1 , 3 , 2 , 4 ] NEW_LINE arr2 = [ 6 , 7 , 8 ] NEW_LINE N = len ( arr1 ) NEW_LINE M = len ( arr2 ) NEW_LINE print ( maximumCount ( arr1 , arr2 , N , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize swaps between two arrays such that sum of the first array exceeds sum of the second array | Function to find the minimum count of swaps required between the two arrays to make the sum of arr1 [ ] greater than that of arr2 [ ] ; Stores the sum of the two arrays ; Calculate sum of arr1 [ ] ; Calculate sum of arr2 [ ] ; Sort the arrays arr1 [ ] and arr2 [ ] ; Traverse the array arr [ ] ; If the sum1 is less than or equal to sum2 ; Swapping the elements ; Update the sum1 and sum2 ; Increment the count ; Return the final count ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3118-3118",
        "Code": "def countPairs ( L , R ) : NEW_LINE INDENT count_even = 0 NEW_LINE if ( L % 2 == 0 ) : NEW_LINE INDENT count_even = ( ( R // 2 ) - ( L // 2 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count_even = ( ( R // 2 ) - ( L // 2 ) ) NEW_LINE DEDENT count_odd = 0 NEW_LINE if ( L % 2 == 0 ) : NEW_LINE INDENT count_odd = ( ( ( R + 1 ) // 2 ) - ( ( L + 1 ) // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT count_odd = ( ( ( R + 1 ) // 2 ) - ( ( L + 1 ) // 2 ) + 1 ) NEW_LINE DEDENT count_even *= count_even NEW_LINE count_odd *= count_odd NEW_LINE print ( count_even + count_odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 1 , 3 NEW_LINE countPairs ( L , R ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs from a given range having even sum | Function to find the count of ordered pairs having even sum ; Stores count of even numbers in the range [ L , R ] ; If L is even ; Update count_even ; Update count_odd ; Stores count of odd numbers in the range [ L , R ] ; Update count_odd ; Update count_odd ; Stores count of pairs whose sum is even and both elements of the pairs are also even ; Stores count of pairs whose sum is even and both elements of the pairs are odd ; Print total ordered pairs whose sum is even ; Driver Code ; Given L & R ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "3141-3141",
        "Code": "import math NEW_LINE def LCM ( A , B ) : NEW_LINE INDENT return ( A * B // math . gcd ( A , B ) ) NEW_LINE DEDENT def findSmallestNumber ( X ) : NEW_LINE INDENT lcm = 1 NEW_LINE temp = X NEW_LINE while ( temp ) : NEW_LINE INDENT last = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( not last ) : NEW_LINE INDENT continue NEW_LINE DEDENT lcm = LCM ( lcm , last ) NEW_LINE DEDENT answer = ( ( X + lcm - 1 ) // lcm ) * lcm NEW_LINE print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 280 NEW_LINE findSmallestNumber ( X ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest number not less than N which is divisible by all digits of N | Python3 program for the above approach ; Function to calculate the LCM ; Function to find the smallest number satisfying given constraints ; LCM value is 1 initially ; Finding the LCM of all non zero digits ; Update the value lcm ; Stores ceil value ; Print the answer ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "3143-3143",
        "Code": "def minSum ( N ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1000000000 NEW_LINE while ( low + 1 < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( mid * mid >= N ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT first = high NEW_LINE low = 0 NEW_LINE high = 1000000000 NEW_LINE while ( low + 1 < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( first * mid > N ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT second = high NEW_LINE print ( round ( first + second ) ) NEW_LINE DEDENT N = 10 NEW_LINE minSum ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum sum of two integers whose product is strictly greater than N | Function to find the minimum sum of two integers such that their product is strictly greater than N ; Initialise low as 0 and high as 1e9 ; Iterate to find the first number ; Find the middle value ; If mid ^ 2 is greater than equal to A , then update high to mid ; Otherwise update low ; Store the first number ; Again , set low as 0 and high as 1e9 ; Iterate to find the second number ; Find the middle value ; If first number * mid is greater than N then update high to mid ; Else , update low to mid ; Store the second number ; Print the result ; Driver Code ; Function Call",
        "Category": "Binary Search"
    },
    {
        "ID": "3144-3144",
        "Code": "import math NEW_LINE def minSum ( N ) : NEW_LINE INDENT ans = math . ceil ( 2 * math . sqrt ( N + 1 ) ) NEW_LINE print ( math . trunc ( ans ) ) NEW_LINE DEDENT N = 10 NEW_LINE minSum ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum sum of two integers whose product is strictly greater than N | Python3 program for the above approach ; Function to find the minimum sum of two integers such that their product is strictly greater than N ; Store the answer using the AP - GP inequality ; Print the result ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "3149-3149",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . val = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def find_ht ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return max ( find_ht ( root . left ) , find_ht ( root . right ) ) + 1 NEW_LINE DEDENT def find_node ( root ) : NEW_LINE INDENT global req_node NEW_LINE if ( not root ) : NEW_LINE INDENT return NEW_LINE DEDENT left_ht = find_ht ( root . left ) NEW_LINE right_ht = find_ht ( root . right ) NEW_LINE if ( left_ht > right_ht ) : NEW_LINE INDENT find_node ( root . left ) NEW_LINE DEDENT elif ( right_ht > left_ht ) : NEW_LINE INDENT find_node ( root . right ) NEW_LINE DEDENT else : NEW_LINE INDENT req_node = root NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE req_node = None NEW_LINE find_node ( root ) NEW_LINE print ( req_node . val ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest Subtree with all the Deepest Nodes | Structure of a Node ; Function to return depth of the Tree from root ; If current node is a leaf node ; Function to find the root of the smallest subtree consisting of all deepest nodes ; Stores height of left subtree ; Stores height of right subtree ; If height of left subtree exceeds that of the right subtree ; Traverse left subtree ; If height of right subtree exceeds that of the left subtree ; Otherwise ; Return current node ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "3151-3151",
        "Code": "def findOverlapSegement ( N , a , b ) : NEW_LINE INDENT tup = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE tup . append ( ( ( x , y ) , i ) ) NEW_LINE DEDENT tup . sort ( ) NEW_LINE curr = tup [ 0 ] [ 0 ] [ 1 ] NEW_LINE currPos = tup [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Q = tup [ i - 1 ] [ 0 ] [ 0 ] NEW_LINE R = tup [ i ] [ 0 ] [ 0 ] NEW_LINE if Q == R : NEW_LINE INDENT if tup [ i - 1 ] [ 0 ] [ 1 ] < tup [ i ] [ 0 ] [ 1 ] : NEW_LINE INDENT print ( tup [ i - 1 ] [ 1 ] , tup [ i ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( tup [ i ] [ 1 ] , tup [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT T = tup [ i ] [ 0 ] [ 1 ] NEW_LINE if ( T <= curr ) : NEW_LINE INDENT print ( tup [ i ] [ 1 ] , currPos ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT curr = T NEW_LINE currPos = tup [ i ] [ 1 ] NEW_LINE DEDENT DEDENT print ( \" - 1\" , \" - 1\" , end = \" \" ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 2 , 2 ] NEW_LINE b = [ 5 , 10 , 10 , 2 , 15 ] NEW_LINE N = len ( a ) NEW_LINE findOverlapSegement ( N , a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Find a pair of overlapping intervals from a given Set | Function to find a pair ( i , j ) such that i - th interval lies within the j - th interval ; Store interval and index of the interval in the form of { { l , r } , index } ; Traverse the array , arr [ ] [ ] ; Stores l - value of the interval ; Stores r - value of the interval ; Push current interval and index into tup ; Sort the vector based on l - value of the intervals ; Stores r - value of current interval ; Stores index of current interval ; Traverse the vector , tup [ ] ; Stores l - value of previous interval ; Stores l - value of current interval ; If Q and R are equal ; Print the index of interval ; Stores r - value of current interval ; If T is less than or equal to curr ; Update curr ; Update currPos ; If such intervals found ; Given l - value of segments ; Given r - value of segments ; Given size ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "3168-3168",
        "Code": "def getcount ( n , k ) : NEW_LINE INDENT res = ( n >> ( k + 1 ) ) << k NEW_LINE if ( ( n >> k ) & 1 ) : NEW_LINE INDENT res += n & ( ( 1 << k ) - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 14 NEW_LINE K = 2 NEW_LINE print ( getcount ( N + 1 , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers up to N having Kth bit set | Function to return the count of number of 1 's at ith bit in a range [1, n - 1] ; Store count till nearest power of 2 less than N ; If K - th bit is set in N ; Add to result the nearest power of 2 less than N ; Return result ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "3175-3175",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . children = [ ] NEW_LINE DEDENT DEDENT ans = 0.0 NEW_LINE def MaxAverage ( root ) : NEW_LINE INDENT global ans NEW_LINE if ( root != None and len ( root . children ) == 0 ) : NEW_LINE INDENT ans = max ( ans , ( root . val ) ) NEW_LINE return [ root . val , 1 ] NEW_LINE DEDENT childResult = [ 0 for i in range ( 2 ) ] NEW_LINE for child in root . children : NEW_LINE INDENT childTotal = MaxAverage ( child ) NEW_LINE childResult [ 0 ] = childResult [ 0 ] + childTotal [ 0 ] NEW_LINE childResult [ 1 ] = childResult [ 1 ] + childTotal [ 1 ] NEW_LINE DEDENT sum = childResult [ 0 ] + root . val NEW_LINE count = childResult [ 1 ] + 1 NEW_LINE ans = max ( ans , sum / count ) NEW_LINE return [ sum , count ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 20 ) NEW_LINE left = TreeNode ( 12 ) NEW_LINE right = TreeNode ( 18 ) NEW_LINE root . children . append ( left ) NEW_LINE root . children . append ( right ) NEW_LINE left . children . append ( TreeNode ( 11 ) ) NEW_LINE left . children . append ( TreeNode ( 3 ) ) NEW_LINE right . children . append ( TreeNode ( 15 ) ) NEW_LINE right . children . append ( TreeNode ( 8 ) ) NEW_LINE MaxAverage ( root ) NEW_LINE print ( ans * 1.0 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum average of subtree values in a given Binary Tree | Structure of the Tree node ; Stores the result ; Function for finding maximum subtree average ; Checks if current node is not None and doesn 't have any children ; Stores sum of its subtree in index 0 and count number of nodes in index 1 ; Traverse all children of the current node ; Recursively calculate max average of subtrees among its children ; Increment sum by sum of its child 's subtree ; Increment number of nodes by its child 's node ; Increment sum by current node 's value ; Increment number of nodes by one ; Take maximum of ans and current node 's average ; Finally return pair of { sum , count } ; Driver Code ; Given tree ; Function call ; Print answer",
        "Category": "Binary Tree"
    },
    {
        "ID": "3180-3180",
        "Code": "def make_string_S_to_T ( S , T ) : NEW_LINE INDENT possible = False NEW_LINE M = len ( T ) NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , M + 1 ) : NEW_LINE INDENT prefix_length = i NEW_LINE suffix_length = M - i NEW_LINE prefix = S [ : prefix_length ] NEW_LINE suffix = S [ N - suffix_length : N ] NEW_LINE if ( prefix + suffix == T ) : NEW_LINE INDENT possible = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( possible ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT S = \" ababcdcd \" NEW_LINE T = \" abcd \" NEW_LINE print ( make_string_S_to_T ( S , T ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a string can be converted to another given string by removal of a substring | Function to check if S can be converted to T by removing at most one substring from S ; Check if S can be converted to T by removing at most one substring from S ; Stores length of string T ; Stores length of string S ; Iterate over the range [ 0 , M - 1 ] ; Stores Length of the substring S [ 0 ] , ... , S [ i ] ; Stores Length of the substring S [ 0 ] , ... , S [ i ] ; Stores prefix substring ; Stores suffix substring ; Checking if prefix + suffix == T ; Given String S and T ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3181-3181",
        "Code": "def findSum ( a ) : NEW_LINE INDENT ans = 0 NEW_LINE for low in range ( 0 , len ( a ) ) : NEW_LINE INDENT for high in range ( low , len ( a ) ) : NEW_LINE count = 0 NEW_LINE maxNumber = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( a [ i ] == maxNumber ) : NEW_LINE count += 1 NEW_LINE elif ( a [ i ] > maxNumber ) : NEW_LINE maxNumber = a [ i ] NEW_LINE count = 1 NEW_LINE DEDENT if count % 2 : NEW_LINE INDENT ans += maxNumber NEW_LINE DEDENT else : NEW_LINE INDENT ans += maxNumber * 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT arr = [ 2 , 1 , 4 , 4 , 2 ] NEW_LINE findSum ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of maximum of all subarrays by adding even frequent maximum twice | Function to calculate sum of maximum of all subarrays ; Stores the sum of maximums ; Traverse the array ; Store the frequency of the maximum element in subarray ; Finding maximum ; Increment frequency by 1 ; If new maximum is obtained ; If frequency of maximum is even , then add 2 * maxNumber . Otherwise , add maxNumber ; Print the sum obtained ; Driver Code ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "3184-3184",
        "Code": "def isMagic ( num ) : NEW_LINE INDENT return ( num % 9 == 1 ) NEW_LINE DEDENT def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def find ( L , R , q ) : NEW_LINE INDENT dp = [ 0 ] * 1000005 NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 0 NEW_LINE for i in range ( 1 , 1000005 ) : NEW_LINE INDENT if ( isComposite ( i ) and isMagic ( i ) ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT print ( dp [ R [ i ] ] - dp [ L [ i ] - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = [ 10 , 3 ] NEW_LINE R = [ 100 , 2279 ] NEW_LINE Q = 2 NEW_LINE find ( L , R , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to count Composite Magic Numbers from a given range [ L , R ] | Check if a number is magic number or not ; Check number is composite number or not ; Corner cases ; Check if the number is a multiple of 2 or 3 ; Check for multiples of remaining primes ; Function to find Composite Magic Numbers in given ranges ; dp [ i ] : Stores the count of composite Magic numbers up to i ; Traverse in the range [ 1 , 1e5 ) ; Check if number is Composite number as well as a Magic number or not ; Print results for each query ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "32-32",
        "Code": "class createNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT flag = [ 0 ] NEW_LINE def NthPostordernode ( root , N ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( flag [ 0 ] <= N [ 0 ] ) : NEW_LINE INDENT NthPostordernode ( root . left , N ) NEW_LINE NthPostordernode ( root . right , N ) NEW_LINE flag [ 0 ] += 1 NEW_LINE if ( flag [ 0 ] == N [ 0 ] ) : NEW_LINE INDENT print ( root . data ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = createNode ( 25 ) NEW_LINE root . left = createNode ( 20 ) NEW_LINE root . right = createNode ( 30 ) NEW_LINE root . left . left = createNode ( 18 ) NEW_LINE root . left . right = createNode ( 22 ) NEW_LINE root . right . left = createNode ( 24 ) NEW_LINE root . right . right = createNode ( 32 ) NEW_LINE N = [ 6 ] NEW_LINE NthPostordernode ( root , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find n | A Binary Tree Node Utility function to create a new tree node ; function to find the N - th node in the postorder traversal of a given binary tree ; left recursion ; right recursion ; prints the n - th node of preorder traversal ; Driver Code ; prints n - th node found",
        "Category": "Binary Tree"
    },
    {
        "ID": "3201-3201",
        "Code": "def checkString ( X , Y ) : NEW_LINE INDENT L = - 1 NEW_LINE R = - 1 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if ( X [ i ] != Y [ i ] ) : NEW_LINE INDENT L = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( X ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( X [ i ] != Y [ i ] ) : NEW_LINE INDENT R = i NEW_LINE break NEW_LINE DEDENT DEDENT X = list ( X ) NEW_LINE X = X [ : L ] + X [ R : L - 1 : - 1 ] + X [ R + 1 : ] NEW_LINE if ( X == list ( Y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" adcbef \" NEW_LINE Y = \" abcdef \" NEW_LINE checkString ( X , Y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if two strings can be made equal by reversing a substring of one of the strings | Function to check if the strings can be made equal or not by reversing a substring of X ; Store the first index from the left which contains unequal characters in both the strings ; Store the first element from the right which contains unequal characters in both the strings ; Checks for the first index from left in which characters in both the strings are unequal ; Store the current index ; Break out of the loop ; Checks for the first index from right in which characters in both the strings are unequal ; Store the current index ; Break out of the loop ; Reverse the subString X [ L , R ] ; If X and Y are equal ; Otherwise ; Driver Code ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "3205-3205",
        "Code": "def maxLength ( a , b , n , c ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_length = 0 NEW_LINE low = 0 NEW_LINE high = n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( low + ( high - low ) / 2 ) NEW_LINE if ( possible ( a , b , n , c , mid ) ) : NEW_LINE INDENT max_length = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT def possible ( a , b , n , c , k ) : NEW_LINE INDENT dq = [ ] NEW_LINE Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE while ( len ( dq ) > 0 and b [ i ] > b [ dq [ len ( dq ) - 1 ] ] ) : NEW_LINE INDENT dq . pop ( len ( dq ) - 1 ) NEW_LINE DEDENT dq . append ( i ) NEW_LINE DEDENT total_cost = Sum * k + b [ dq [ 0 ] ] NEW_LINE if ( total_cost <= c ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE Sum -= a [ i - k ] NEW_LINE while ( len ( dq ) > 0 and dq [ 0 ] <= i - k ) : NEW_LINE INDENT dq . pop ( 0 ) NEW_LINE DEDENT while ( len ( dq ) > 0 and b [ i ] > b [ dq [ len ( dq ) - 1 ] ] ) : NEW_LINE INDENT dq . pop ( len ( dq ) - 1 ) NEW_LINE DEDENT dq . append ( i ) NEW_LINE total_cost = Sum * k + b [ dq [ 0 ] ] NEW_LINE if ( total_cost <= c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT A = [ 1 , 2 , 1 , 6 , 5 , 5 , 6 , 1 ] NEW_LINE B = [ 14 , 8 , 15 , 15 , 9 , 10 , 7 , 12 ] NEW_LINE N = len ( A ) NEW_LINE C = 40 NEW_LINE print ( maxLength ( A , B , N , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum length of same indexed subarrays from two given arrays satisfying the given condition | Function to find maximum length of subarray such that sum of maximum element in subarray in brr [ ] and sum of subarray in [ ] arr * K is at most C ; Base Case ; Let maximum length be 0 ; Perform Binary search ; Find mid value ; Check if the current mid satisfy the given condition ; If yes , then store length ; Otherwise ; Return maximum length stored ; Function to check if it is possible to have such a subarray of length K ; Finds the maximum element in each window of size k ; Check for window of size K ; For all possible subarrays of length k ; Until deque is empty ; Calculate the total cost and check if less than equal to c ; Find sum of current subarray and the total cost ; Include the new element of current subarray ; Discard the element of last subarray ; Remove all the elements in the old window ; Calculate total cost and check <= c ; If current subarray length satisfies ; If it is not possible ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3212-3212",
        "Code": "def SmallestElementLeft ( arr , N ) : NEW_LINE INDENT totalSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE DEDENT req = totalSum // 2 NEW_LINE dp = [ False for i in range ( req + 1 ) ] NEW_LINE memset ( dp , false , sizeof ( dp ) ) ; NEW_LINE dp [ 0 ] = True NEW_LINE reach = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = req NEW_LINE while j >= arr [ i ] : NEW_LINE INDENT dp [ j ] = dp [ j ] or dp [ j - arr [ i ] ] NEW_LINE if ( dp [ j ] ) : NEW_LINE INDENT reach = max ( reach , j ) NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT return totalSum - ( 2 * reach ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE print ( SmallestElementLeft ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize remaining array element by removing pairs and replacing them by their absolute difference | Function to find minimize the remaining array element by removing pairs and replacing them by their absolute difference ; Stores sum of array elements ; Traverse the array ; Update totalSum ; Stores half of totalSum ; dp [ i ] : True if sum i can be obtained as a subset sum ; Base case ; Stores closest sum that can be obtained as a subset sum ; Traverse the array ; Iterate over all possible value of sum ; Update dp [ j ] ; If sum i can be obtained from array elements ; Update reach ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "3220-3220",
        "Code": "def SmallestString ( s , c ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if s [ i ] > c : NEW_LINE INDENT s = s [ : i ] + c + s [ i : ] NEW_LINE return s NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s = s + c NEW_LINE return s NEW_LINE DEDENT S = ' abd ' NEW_LINE C = ' c ' NEW_LINE print ( SmallestString ( S , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Lexicographically smallest string possible by inserting given character | Function to obtain lexicographically smallest string possible by inserting character c in the string s ; Traverse the string ; Check if current character is greater than the given character ; Insert the character before the first greater character ; Return the string ; Append the character at the end ; Return the string ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3224-3224",
        "Code": "def findIntersectingRange ( tup , N , ranges ) : NEW_LINE INDENT curr = 0 NEW_LINE currPos = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = ranges [ i ] [ 0 ] NEW_LINE y = ranges [ i ] [ 1 ] NEW_LINE tup . append ( [ [ x , y ] , i + 1 ] ) NEW_LINE DEDENT tup = sorted ( tup ) NEW_LINE curr = tup [ 0 ] [ 0 ] [ 1 ] NEW_LINE currPos = tup [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Q = tup [ i - 1 ] [ 0 ] [ 0 ] NEW_LINE R = tup [ i ] [ 0 ] [ 0 ] NEW_LINE if ( Q == R ) : NEW_LINE INDENT if ( tup [ i - 1 ] [ 0 ] [ 1 ] < tup [ i ] [ 0 ] [ 1 ] ) : NEW_LINE INDENT print ( tup [ i - 1 ] [ 1 ] , tup [ i ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( tup [ i ] [ 1 ] , tup [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT T = tup [ i ] [ 0 ] [ 1 ] NEW_LINE if ( T <= curr ) : NEW_LINE INDENT print ( tup [ i ] [ 1 ] , currPos ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT curr = T NEW_LINE currPos = tup [ i ] [ 1 ] NEW_LINE DEDENT DEDENT print ( \" - 1 ▁ - 1\" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE ranges = [ [ 1 , 5 ] , [ 2 , 10 ] , [ 3 , 10 ] , [ 2 , 2 ] , [ 2 , 15 ] ] NEW_LINE findIntersectingRange ( [ ] , N , ranges ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a pair of intersecting ranges from a given array | Function to find a pair of intersecting ranges ; Stores ending po of every range ; Stores the maximum ending poobtained ; Iterate from 0 to N - 1 ; Starting point of the current range ; End point of the current range ; Push pairs into tup ; Sort the tup vector ; Iterate over the ranges ; If starting points are equal ; Prthe indices of the intersecting ranges ; If no such pair of segments exist ; Driver Code ; Given N ; Given 2d ranges [ ] [ ] array ; Function call",
        "Category": "Array"
    },
    {
        "ID": "3225-3225",
        "Code": "def countShifts ( str ) : NEW_LINE ' NEW_LINE INDENT firstOne = - 1 NEW_LINE DEDENT ' NEW_LINE INDENT lastOne = - 1 NEW_LINE count = 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT if ( firstOne == - 1 ) : NEW_LINE INDENT firstOne = i NEW_LINE DEDENT lastOne = i NEW_LINE DEDENT DEDENT if ( ( firstOne == - 1 ) or ( firstOne == lastOne ) ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT for i in range ( firstOne , lastOne + 1 , 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT str = \"00110111011\" NEW_LINE countShifts ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum shifts of substrings of 1 s required to group all 1 s together in a given Binary string | Function to count indices substrings of 1 s need to be shifted such that all 1 s in the string are grouped together ; Stores first occurrence of '1 ; Stores last occurrence of '1 ; Count of 0 s between firstOne and lastOne ; Traverse the string to find the first and last occurrences of '1 ; Count number of 0 s present between firstOne and lastOne ; Print minimum operations ; Given string",
        "Category": "Substring"
    },
    {
        "ID": "3233-3233",
        "Code": "def findNthNum ( N ) : NEW_LINE INDENT last_num = 0 NEW_LINE left = 1 NEW_LINE right = N NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE t = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( t < N ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT elif ( t == N ) : NEW_LINE INDENT a = mid NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT t = a - 1 NEW_LINE b = N - ( t * ( t + 1 ) ) // 2 - 1 NEW_LINE print ( ( 1 << a ) + ( 1 << b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 15 NEW_LINE findNthNum ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Nth natural number with exactly two bits set | Set 2 | Function to find the Nth number with exactly two bits set ; Initialize variables ; Initialize the range in which the value of ' a ' is present ; Perform Binary Search ; Find the mid value ; Update the range using the mid value t ; Find b value using a and N ; Print the value 2 ^ a + 2 ^ b ; Driver Code ; Function Call",
        "Category": "Binary Search"
    },
    {
        "ID": "3241-3241",
        "Code": "def countString ( S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in S : NEW_LINE INDENT if ( i == '0' and count > 0 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ( 1 << count ) - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"1001\" NEW_LINE countString ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count binary strings of length same as given string after removal of substrings \"01\" and \"00\" that consists of at least one '1' | Function to count the strings consisting of at least 1 set bit ; Initialize count ; Iterate through string ; The answer is 2 ^ N - 1 ; Driver Code ; Given string ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3243-3243",
        "Code": "def nextAvailableChar ( charset , start ) : NEW_LINE INDENT for i in range ( start - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( charset [ i ] > 0 ) : NEW_LINE INDENT charset [ i ] -= 1 NEW_LINE return chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT return ' \\0' NEW_LINE DEDENT def newString ( originalLabel , limit ) : NEW_LINE INDENT n = len ( originalLabel ) NEW_LINE charset = [ 0 ] * ( 26 ) NEW_LINE newStrings = \" \" NEW_LINE for i in originalLabel : NEW_LINE INDENT charset [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( charset [ i ] > 0 ) : NEW_LINE INDENT newStrings += chr ( i + ord ( ' a ' ) ) NEW_LINE charset [ i ] -= 1 NEW_LINE count += 1 NEW_LINE if ( charset [ i ] > 0 and count == limit ) : NEW_LINE INDENT next = nextAvailableChar ( charset , i ) NEW_LINE if ( next == ' \\0' ) : NEW_LINE INDENT return newStrings NEW_LINE DEDENT newStrings += next NEW_LINE count = 0 NEW_LINE DEDENT DEDENT DEDENT return newStrings NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ccbbb \" NEW_LINE K = 2 NEW_LINE print ( newString ( S , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically largest string possible consisting of at most K consecutive similar characters | Function to return nearest lower character ; Traverse charset from start - 1 ; If no character can be appended ; Function to find largest string ; Stores the frequency of characters ; Traverse the string ; Append larger character ; Decrease count in charset ; Increase count ; Check if count reached to charLimit ; Find nearest lower char ; If no character can be appended ; Append nearest lower character ; Reset count for next calculation ; Return new largest string ; Driver code ; Given string s",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3244-3244",
        "Code": "def replaceDuplicates ( names ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( 0 , len ( names ) ) : NEW_LINE INDENT if names [ i ] not in hash : NEW_LINE INDENT hash [ names [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hash [ names [ i ] ] NEW_LINE hash [ names [ i ] ] += 1 NEW_LINE names [ i ] += str ( count ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( names ) ) : NEW_LINE INDENT print ( names [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = [ \" aa \" , \" bb \" , \" cc \" , \" bb \" , \" aa \" , \" aa \" , \" aa \" ] NEW_LINE replaceDuplicates ( str1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Append digits to the end of duplicate strings to make all strings in an array unique | Function to replace duplicate strings by alphanumeric strings to make all strings in the array unique ; Store the frequency of strings ; Iterate over the array ; For the first occurrence , update the frequency count ; Otherwise ; Append frequency count to end of the string ; Print the modified array ; Driver Code ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "3246-3246",
        "Code": "import math NEW_LINE def simpleSieve ( lmt , prime ) : NEW_LINE INDENT Sieve = [ True ] * ( lmt + 1 ) NEW_LINE Sieve [ 0 ] = Sieve [ 1 ] = False NEW_LINE for i in range ( 2 , lmt + 1 ) : NEW_LINE INDENT if ( Sieve [ i ] == True ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE for j in range ( i * i , int ( math . sqrt ( lmt ) ) + 1 , i ) : NEW_LINE INDENT Sieve [ j ] = false NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def SegmentedSieveFn ( low , high ) : NEW_LINE INDENT lmt = int ( math . sqrt ( high ) ) + 1 NEW_LINE prime = [ ] NEW_LINE prime = simpleSieve ( lmt , prime ) NEW_LINE n = high - low + 1 NEW_LINE segmentedSieve = [ True ] * ( n + 1 ) NEW_LINE for i in range ( 0 , len ( prime ) ) : NEW_LINE INDENT lowLim = int ( low // prime [ i ] ) * prime [ i ] NEW_LINE if ( lowLim < low ) : NEW_LINE INDENT lowLim += prime [ i ] NEW_LINE for j in range ( lowLim , high + 1 , prime [ i ] ) : NEW_LINE INDENT if ( j != prime [ i ] ) : NEW_LINE INDENT segmentedSieve [ j - low ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT return segmentedSieve NEW_LINE DEDENT def countPairsWhoseSumPrimeL_R ( L , R ) : NEW_LINE INDENT segmentedSieve = SegmentedSieveFn ( L , R ) NEW_LINE cntPairs = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( segmentedSieve [ i - L ] == True ) : NEW_LINE INDENT cntPairs += i / 2 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 5 NEW_LINE print ( countPairsWhoseSumPrimeL_R ( L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs from a given range whose sum is a Prime Number in that range | Python program to implement the above approach ; Function to find all prime numbers in range [ 1 , lmt ] using sieve of Eratosthenes ; segmentedSieve [ i ] : Stores if i is a prime number ( True ) or not ( False ) ; Set 0 and 1 as non - prime ; Iterate over the range [ 2 , lmt ] ; If i is a prime number ; Append i into prime ; Set all multiple of i non - prime ; Update Sieve [ j ] ; Function to find all the prime numbers in the range [ low , high ] ; Stores square root of high + 1 ; Stores all the prime numbers in the range [ 1 , lmt ] ; Find all the prime numbers in the range [ 1 , lmt ] ; Stores count of elements in the range [ low , high ] ; segmentedSieve [ i ] : Check if ( i - low ) is a prime number or not ; Traverse the array prime [ ] ; Store smallest multiple of prime [ i ] in the range [ low , high ] ; If lowLim is less than low ; Update lowLim ; Iterate over all multiples of prime [ i ] ; If j not equal to prime [ i ] ; Update segmentedSieve [ j - low ] ; Function to count the number of pairs in the range [ L , R ] whose sum is a prime number in the range [ L , R ] ; segmentedSieve [ i ] : Check if ( i - L ) is a prime number or not ; Stores count of pairs whose sum of elements is a prime and in range [ L , R ] ; Iterate over [ L , R ] ; If ( i - L ) is a prime ; Update cntPairs ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3262-3262",
        "Code": "MOD = 10 ** 9 + 7 NEW_LINE def minJumps ( seats ) : NEW_LINE INDENT position = [ ] NEW_LINE count = 0 NEW_LINE lenn = len ( seats ) NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( seats [ i ] == ' x ' ) : NEW_LINE INDENT position . append ( i - count ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( count == lenn or count == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT med_index = ( count - 1 ) // 2 NEW_LINE med_val = position [ med_index ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( position ) ) : NEW_LINE INDENT ans = ( ans % MOD + abs ( position [ i ] - med_val ) % MOD ) % MOD NEW_LINE DEDENT return ans % MOD NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" . . . . x . . xx . . . x . . \" NEW_LINE print ( minJumps ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum jumps required to make a group of persons sit together | Python3 program for the above approach ; Function to find the minimum jumps required to make the whole group sit adjacently ; Store the indexes ; Stores the count of occupants ; Length of the string ; Traverse the seats ; If current place is occupied ; Push the current position in the vector ; Base Case : ; The index of the median element ; The value of the median element ; Traverse the position [ ] ; Update the ans ; Return the final count ; Driver Code ; Given arrange of seats ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3266-3266",
        "Code": "def MincntBothPalin ( str1 , str2 , N ) : NEW_LINE INDENT i = 0 NEW_LINE j = N - 1 NEW_LINE cntOp = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ j ] and str2 [ i ] != str2 [ j ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] and str2 [ i ] == str2 [ j ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] and str2 [ i ] != str2 [ j ] ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ j ] and str2 [ i ] == str1 [ j ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOp += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return cntOp NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" dbba \" NEW_LINE str2 = \" abcd \" NEW_LINE N = len ( str1 ) NEW_LINE print ( MincntBothPalin ( str1 , str2 , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize replacements or swapping of same indexed characters required to make two given strings palindromic | Function to find minimum operations to make both the strings palindromic ; Stores index of the left pointer ; Stores index of the right pointer ; Stores count of minimum operations to make both the strings palindromic ; if str1 [ i ] equal to str1 [ j ] and str2 [ i ] not equal to str2 [ j ] ; Update cntOp ; If str1 [ i ] not equal to str1 [ j ] and str2 [ i ] equal to str2 [ j ] ; Update cntOp ; If str1 [ i ] is not equal to str1 [ j ] and str2 [ i ] is not equal to str2 [ j ] ; If str1 [ i ] is equal to str2 [ j ] and str2 [ i ] is equal to str1 [ j ] ; Update cntOp ; Update cntOp ; Update i and j ; Driver Code ; Stores length of str1",
        "Category": "Substring"
    },
    {
        "ID": "3267-3267",
        "Code": "from math import log2 NEW_LINE def power ( x , N ) : NEW_LINE INDENT res = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT res = ( res * x ) NEW_LINE DEDENT x = ( x * x ) NEW_LINE N = N >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def findValX_Y ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE print ( - 1 ) NEW_LINE return NEW_LINE xMax = 0 NEW_LINE xMax = int ( log2 ( N ) ) NEW_LINE yMax = 0 NEW_LINE yMax = int ( log2 ( N ) / log2 ( 5.0 ) ) NEW_LINE for i in range ( 1 , xMax + 1 ) : NEW_LINE INDENT for j in range ( 1 , yMax + 1 ) : NEW_LINE INDENT a = power ( 2 , i ) NEW_LINE b = power ( 5 , j ) NEW_LINE if ( a + b == N ) : NEW_LINE INDENT print ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 129 NEW_LINE findValX_Y ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find an integral solution of the non | Python3 program to implement the above approach ; Function to find the value of power ( X , N ) ; Stores the value of ( X ^ N ) ; Calculate the value of power ( x , N ) ; If N is odd ; Update res ; Update x ; Update N ; Function to find the value of X and Y that satisfy the condition ; Base Case ; Stores maximum possible of X ; Update xMax ; Stores maximum possible of Y ; Update yMax ; Iterate over all possible values of X ; Iterate over all possible values of Y ; Stores value of 2 ^ i ; Stores value of 5 ^ j ; If the pair ( i , j ) satisfy the equation ; If no solution exists ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "327-327",
        "Code": "import queue NEW_LINE def printLevels ( graph , V , x ) : NEW_LINE INDENT level = [ None ] * V NEW_LINE marked = [ False ] * V NEW_LINE que = queue . Queue ( ) NEW_LINE que . put ( x ) NEW_LINE level [ x ] = 0 NEW_LINE marked [ x ] = True NEW_LINE while ( not que . empty ( ) ) : NEW_LINE INDENT x = que . get ( ) NEW_LINE for i in range ( len ( graph [ x ] ) ) : NEW_LINE INDENT b = graph [ x ] [ i ] NEW_LINE if ( not marked [ b ] ) : NEW_LINE INDENT que . put ( b ) NEW_LINE level [ b ] = level [ x ] + 1 NEW_LINE marked [ b ] = True NEW_LINE DEDENT DEDENT DEDENT print ( \" Nodes \" , \" ▁ \" , \" Level \" ) NEW_LINE for i in range ( V ) : NEW_LINE INDENT print ( \" ▁ \" , i , \" ▁ - - > ▁ \" , level [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V = 8 NEW_LINE graph = [ [ ] for i in range ( V ) ] NEW_LINE graph [ 0 ] . append ( 1 ) NEW_LINE graph [ 0 ] . append ( 2 ) NEW_LINE graph [ 1 ] . append ( 3 ) NEW_LINE graph [ 1 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE graph [ 2 ] . append ( 5 ) NEW_LINE graph [ 2 ] . append ( 6 ) NEW_LINE graph [ 6 ] . append ( 7 ) NEW_LINE printLevels ( graph , V , 0 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Level of Each node in a Tree from source node ( using BFS ) | Python3 Program to determine level of each node and print level ; function to determine level of each node starting from x using BFS ; array to store level of each node ; create a queue ; enqueue element x ; initialize level of source node to 0 ; marked it as visited ; do until queue is empty ; get the first element of queue ; traverse neighbors of node x ; b is neighbor of node x ; if b is not marked already ; enqueue b in queue ; level of b is level of x + 1 ; mark b ; display all nodes and their levels ; Driver Code ; adjacency graph for tree ; call levels function with source as 0",
        "Category": "Graph Theory"
    },
    {
        "ID": "3271-3271",
        "Code": "def maxSumSubarr ( A , N , K , X ) : NEW_LINE INDENT sum_K = 0 NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT sum_K += A [ i ] NEW_LINE DEDENT Max_Sum = 0 NEW_LINE if ( sum_K < X ) : NEW_LINE INDENT Max_Sum = sum_K NEW_LINE DEDENT for i in range ( K , N ) : NEW_LINE INDENT sum_K -= ( A [ i - K ] - A [ i ] ) NEW_LINE if ( sum_K < X ) : NEW_LINE INDENT Max_Sum = max ( Max_Sum , sum_K ) NEW_LINE DEDENT DEDENT print ( Max_Sum ) NEW_LINE DEDENT arr = [ - 5 , 8 , 7 , 2 , 10 , 1 , 20 , - 4 , 6 , 9 ] NEW_LINE K = 5 NEW_LINE X = 30 NEW_LINE N = len ( arr ) NEW_LINE maxSumSubarr ( arr , N , K , X ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum sum subarray of size K with sum less than X | Function to calculate maximum sum among all subarrays of size K with the sum less than X ; Initialize sum_K to 0 ; Calculate sum of first K elements ; If sum_K is less than X ; Initialize MaxSum with sum_K ; Iterate over the array from ( K + 1 ) - th index ; Subtract the first element from the previous K elements and add the next element ; If sum_K is less than X ; Update the Max_Sum ; Driver Code ; Size of Array ; Function Call",
        "Category": "Sliding Window"
    },
    {
        "ID": "3277-3277",
        "Code": "def toggleQuery ( strr , Q , M ) : NEW_LINE INDENT strr = [ i for i in strr ] NEW_LINE N = len ( strr ) NEW_LINE prefixCnt = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT prefixCnt [ Q [ i ] [ 0 ] ] += 1 NEW_LINE prefixCnt [ Q [ i ] [ 1 ] + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT prefixCnt [ i ] += prefixCnt [ i - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( prefixCnt [ i ] % 2 ) : NEW_LINE INDENT strr [ i ] = ( chr ( ord ( '1' ) - ord ( strr [ i ] ) + ord ( '0' ) ) ) NEW_LINE DEDENT DEDENT return \" \" . join ( strr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \"101010\" ; NEW_LINE Q = [ [ 0 , 1 ] , [ 2 , 5 ] , [ 2 , 3 ] , [ 1 , 4 ] , [ 0 , 5 ] ] NEW_LINE M = len ( Q ) NEW_LINE print ( toggleQuery ( strr , Q , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to flip characters of a binary string in given range | Function to find the binary by performing all the given queries ; Stores length of the string ; prefixCnt [ i ] : Stores number of times strr [ i ] toggled by performing all the queries ; Update prefixCnt [ Q [ i ] [ 0 ] ] ; Update prefixCnt [ Q [ i ] [ 1 ] + 1 ] ; Calculate prefix sum of prefixCnt [ i ] ; Traverse prefixCnt [ ] array ; If ith element toggled odd number of times ; Toggled i - th element of binary string ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "3304-3304",
        "Code": "def printIndexes ( strr ) : NEW_LINE INDENT N = len ( strr ) NEW_LINE cntFreq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntFreq [ ord ( strr [ i ] ) ] += 1 NEW_LINE DEDENT cntLeftFreq = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntLeft = 0 NEW_LINE cntRight = 0 NEW_LINE for j in range ( ord ( strr [ i ] ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT cntLeft += cntLeftFreq [ j ] NEW_LINE cntRight += ( cntFreq [ j ] - cntLeftFreq [ j ] ) NEW_LINE DEDENT cntLeftFreq [ ord ( strr [ i ] ) ] += 1 NEW_LINE if ( cntLeft == cntRight and cntLeft != 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" aabacdabbb \" NEW_LINE printIndexes ( strr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all positions of a given string having count of smaller characters equal on both sides | Function to find indexes of the given that satisfy the condition ; Stores length of given string ; Stores frequency of each character of strr ; Update frequency of current character ; cntLeftFreq [ i ] Stores frequency of characters present on the left side of index i . ; Traverse the given string ; Stores count of smaller characters on left side of i . ; Stores count of smaller characters on Right side of i . ; Traverse smaller characters on left side of index i . ; Update cntLeft ; Update cntRight ; Update cntLeftFreq [ strr [ i ] ] ; If count of smaller elements on both sides equal ; Print current index ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "3306-3306",
        "Code": "def Count_Number ( x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( x % 99 != 0 ) : NEW_LINE INDENT ans = - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT diff = x / 99 ; NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i - j ) == diff ) : NEW_LINE INDENT ans += 10 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 792 ; NEW_LINE print ( Count_Number ( x ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count three | Function to count three - digit numbers having difference x with its reverse ; If x is not multiple of 99 ; No solution exists ; Generate all possible pairs of digits [ 1 , 9 ] ; If any pair is obtained with difference x / 99 ; Increase count ; Return the count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3314-3314",
        "Code": "def minSubarray ( arr , N ) : NEW_LINE INDENT result = [ 0 ] * N NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( len ( l ) != 0 and l [ - 1 ] [ 0 ] > arr [ i ] ) : NEW_LINE INDENT count += l [ - 1 ] [ 1 ] NEW_LINE l . pop ( ) NEW_LINE DEDENT l . append ( [ arr [ i ] , count ] ) NEW_LINE result [ i ] = count ; NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( len ( r ) != 0 and r [ - 1 ] [ 0 ] >= arr [ i ] ) : NEW_LINE INDENT count += r [ - 1 ] [ 1 ] NEW_LINE r . pop ( ) ; NEW_LINE DEDENT r . append ( [ arr [ i ] , count ] ) ; NEW_LINE result [ i ] *= count NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( result [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE minSubarray ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count subarrays for every array element in which they are the minimum | Set 2 | Function to count subarrays for each element where it is the minimum ; For the length of strictly larger numbers on the left of A [ i ] ; Storing x in result [ i ] ; For the length of strictly larger numbers on the right of A [ i ] ; Store x * y in result array ; Print the result ; Driver Code ; Function Call",
        "Category": "Stack"
    },
    {
        "ID": "3315-3315",
        "Code": "def isPrime ( num ) : NEW_LINE INDENT if ( num <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , num + 1 ) : NEW_LINE INDENT if i * i > num : NEW_LINE INDENT break NEW_LINE DEDENT if ( num % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFulPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( not ( rem == 2 or rem == 3 or rem == 5 or rem == 7 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countFulPrime ( L , R ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 and isFulPrime ( i ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 100 NEW_LINE ans = 0 NEW_LINE if ( L < 3 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans + countFulPrime ( L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count Full Prime numbers in a given range | Function to check if a number is prime or not ; If a divisor of n exists ; Function to check if a number is Full Prime or not ; If n is not a prime ; Otherwise ; Extract digit ; If any digit of n is non - prime ; Function to prcount of Full Primes in a range [ L , R ] ; Stores count of full primes ; Check if i is full prime ; Driver Code ; Stores count of full primes",
        "Category": "Math"
    },
    {
        "ID": "3322-3322",
        "Code": "def isPower ( x ) : NEW_LINE INDENT if ( x != 0 and ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def maximumlength ( arr , N ) : NEW_LINE INDENT max_length = 0 ; NEW_LINE max_len_subarray = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( isPower ( arr [ i ] ) ) : NEW_LINE INDENT max_length += 1 ; NEW_LINE max_len_subarray = max ( max_length , max_len_subarray ) ; NEW_LINE DEDENT else : NEW_LINE INDENT max_length = 0 ; NEW_LINE DEDENT DEDENT print ( max_len_subarray ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 5 , 4 , 6 , 8 , 8 , 2 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE maximumlength ( arr , N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of longest subarray with product equal to a power of 2 | Function to check whether a number is power of 2 or not ; Function to find maximum length subarray having product of element as a perfect power of 2 ; Stores current subarray length ; Stores maximum subarray length ; Traverse the given array ; If arr [ i ] is power of 2 ; Increment max_length ; Update max_len_subarray ; Otherwise ; Prthe maximum length ; Driver Code ; Given arr ; Function Call",
        "Category": "Sliding Window"
    },
    {
        "ID": "3325-3325",
        "Code": "def isPalindrome ( st ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( st ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def formPalindrome ( a , b , n ) : NEW_LINE INDENT aa = [ ' ▁ ' ] * ( n + 2 ) NEW_LINE bb = [ ' ▁ ' ] * ( n + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT aa [ i ] = a [ i - 1 ] NEW_LINE bb [ i ] = b [ i - 1 ] NEW_LINE DEDENT ok = False NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT la = \" \" NEW_LINE ra = \" \" NEW_LINE lb = \" \" NEW_LINE rb = \" \" NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT if ( aa [ j ] == ' ▁ ' ) : NEW_LINE INDENT la += \" \" NEW_LINE DEDENT else : NEW_LINE INDENT la += aa [ j ] NEW_LINE DEDENT if ( bb [ j ] == ' ▁ ' ) : NEW_LINE INDENT lb += \" \" NEW_LINE DEDENT else : NEW_LINE INDENT lb += bb [ j ] NEW_LINE DEDENT DEDENT for j in range ( i , n + 2 ) : NEW_LINE INDENT if ( aa [ j ] == ' ▁ ' ) : NEW_LINE INDENT ra += \" \" NEW_LINE DEDENT else : NEW_LINE INDENT ra += aa [ j ] NEW_LINE DEDENT if ( bb [ j ] == ' ▁ ' ) : NEW_LINE INDENT rb += \" \" NEW_LINE DEDENT else : NEW_LINE INDENT rb += bb [ j ] NEW_LINE DEDENT DEDENT if ( isPalindrome ( str ( la ) + str ( rb ) ) or isPalindrome ( str ( lb ) + str ( ra ) ) ) : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = \" bdea \" NEW_LINE B = \" abbb \" NEW_LINE N = 4 NEW_LINE formPalindrome ( A , B , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a palindromic string can be obtained by concatenating substrings split from same indices of two given strings | Function to check if a string is palindrome or not ; Start and end of the string ; Iterate the string until i > j ; If there is a mismatch ; Increment first pointer and decrement the other ; Given string is a palindrome ; Function two check if the strings can be combined to form a palindrome ; Initialize array of characters ; Stores character of string in the character array ; Find left and right parts of strings a and b ; Substring a [ j ... i - 1 ] ; Substring b [ j ... i - 1 ] ; Substring a [ i ... n ] ; Substring b [ i ... n ] ; Check is left part of a + right part of b or vice versa is a palindrome ; Print the result ; Otherwise ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "3328-3328",
        "Code": "def isPerfect ( N ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N // i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += i + N // i NEW_LINE DEDENT DEDENT DEDENT if ( sum == N and N != 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def maxSum ( arr , N , K ) : NEW_LINE INDENT if ( N < K ) : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT curr_sum = res NEW_LINE for i in range ( K , N ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - K ] NEW_LINE res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT def max_PerfectNumbers ( arr , N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if isPerfect ( arr [ i ] ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT return maxSum ( arr , N , K ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 28 , 2 , 3 , 6 , 496 , 99 , 8128 , 24 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) NEW_LINE print ( max_PerfectNumbers ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of Perfect Numbers present in a subarray of size K | Function to check a number is Perfect Number or not ; Stores sum of divisors ; Find all divisors and add them ; If sum of divisors is equal to N ; Function to return maximum sum of a subarray of size K ; If k is greater than N ; Compute sum of first window of size K ; Compute sums of remaining windows by removing first element of previous window and adding last element of current window ; Return the answer ; Function to find all the perfect numbers in the array ; The given array is converted into binary array ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3331-3331",
        "Code": "def minElements ( A , B , N , M ) : NEW_LINE INDENT map = { } NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT map [ A [ i ] ] = i NEW_LINE DEDENT subseq = [ ] NEW_LINE l = 0 NEW_LINE r = - 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if B [ i ] in map : NEW_LINE INDENT e = map [ B [ i ] ] NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( subseq [ m ] < e ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT if ( r + 1 < len ( subseq ) ) : NEW_LINE INDENT subseq [ r + 1 ] = e NEW_LINE DEDENT else : NEW_LINE INDENT subseq . append ( e ) NEW_LINE DEDENT l = 0 NEW_LINE r = len ( subseq ) - 1 NEW_LINE DEDENT DEDENT return N - len ( subseq ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE B = [ 2 , 5 , 6 , 4 , 9 , 12 ] NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE print ( minElements ( A , B , M , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize elements to be added to a given array such that it contains another given array as its subsequence | Set 2 | Function to return minimum element to be added in array B so that array A become subsequence of array B ; Stores indices of the array elements ; Iterate over the array ; Store the indices of the array elements ; Stores the LIS ; Check if element B [ i ] is in array A [ ] ; Perform Binary Search ; Find the value of mid m ; Update l and r ; If found better element ' e ' for pos r + 1 ; Otherwise , extend the current subsequence ; Return the answer ; Driver Code ; Given arrays ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "3340-3340",
        "Code": "import sys NEW_LINE def minLength ( a , b ) : NEW_LINE INDENT Char = { } NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT Char [ b [ i ] ] = Char . get ( b [ i ] , 0 ) + 1 NEW_LINE DEDENT CharacterIndex = { } NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x in Char ) : NEW_LINE INDENT CharacterIndex [ x ] = CharacterIndex . get ( x , [ ] ) NEW_LINE CharacterIndex [ x ] . append ( i ) NEW_LINE DEDENT DEDENT l = sys . maxsize NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 NEW_LINE firstVar = 0 NEW_LINE lastVar = 0 NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( b [ i ] not in CharacterIndex ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT x = CharacterIndex [ b [ i ] ] [ 0 ] NEW_LINE CharacterIndex [ b [ i ] ] . remove ( CharacterIndex [ b [ i ] ] [ 0 ] ) NEW_LINE firstVar = x NEW_LINE lastVar = x NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT elementFound = 0 NEW_LINE for e in CharacterIndex [ b [ i ] ] : NEW_LINE INDENT if ( e > lastVar ) : NEW_LINE INDENT elementFound = 1 NEW_LINE lastVar = e NEW_LINE break NEW_LINE DEDENT DEDENT if ( elementFound == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT l = min ( l , abs ( lastVar - firstVar ) + 1 ) NEW_LINE DEDENT return l NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" abcdefababaef \" NEW_LINE b = \" abf \" NEW_LINE l = minLength ( a , b ) NEW_LINE if ( l != sys . maxsize ) : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Length of smallest substring of a given string which contains another string as subsequence | Python3 program to implement the above approach ; Function to find the length of smallest substring of a having string b as a subsequence ; Stores the characters present in string b ; Find index of characters of a that are also present in string b ; If character is present in string b ; Store the index of character ; Flag is used to check if substring is possible ; Assume that substring is possible ; Stores first and last indices of the substring respectively ; For first character of string b ; If the first character of b is not present in a ; If the first character of b is present in a ; Remove the index from map ; Update indices of the substring ; For the remaining characters of b ; If index possible for current character ; If no index is possible ; If no more substring is possible ; Update the minimum length of substring ; Return the result ; Driver Code ; Given two string",
        "Category": "Substring"
    },
    {
        "ID": "3342-3342",
        "Code": "maxn = int ( 1e6 ) + 5 NEW_LINE BITree = [ 0 ] * ( maxn ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def update_bitree ( index , value ) : NEW_LINE INDENT while ( index <= maxn ) : NEW_LINE INDENT BITree [ index ] += value NEW_LINE index += ( index & ( - index ) ) NEW_LINE DEDENT DEDENT def sum_bitree ( index ) : NEW_LINE INDENT s = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT s += BITree [ index ] NEW_LINE index -= ( index & ( - index ) ) NEW_LINE DEDENT return s NEW_LINE DEDENT def countSmallerPrimes ( ar , N ) : NEW_LINE INDENT ans = [ 0 ] * ( N ) NEW_LINE global BITree NEW_LINE for i in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT ans [ i ] = sum_bitree ( ar [ i ] ) NEW_LINE if ( is_prime ( ar [ i ] ) ) : NEW_LINE INDENT update_bitree ( ar [ i ] , 1 ) NEW_LINE DEDENT DEDENT ans [ 0 ] = 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ 5 , 5 , 17 , 9 , 12 , 15 , 11 , 7 , 39 , 3 ] NEW_LINE N = len ( ar ) NEW_LINE countSmallerPrimes ( ar , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count smaller primes on the right of each array element | ''Python3 program for the above approach ; ''Function to check if a number is prime or not ; ''Function to update a Binary Tree ; ''Function to find the sum of all the elements which are less than or equal to index ; ''Function to find the number of smaller primes on the right for every array element ; '' Iterate the array in backwards ; '' Calculating the required  number of primes ; '' If current array  element is prime ; '' Update the Fenwick tree ; ''Driver Code ; '' Function call",
        "Category": "Binary Tree"
    },
    {
        "ID": "3343-3343",
        "Code": "def checkConcat ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE if ( N % M != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i % M ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abcabcabc \" NEW_LINE str2 = \" abc \" NEW_LINE if ( checkConcat ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string is concatenation of another given string | Function to check if a is concatenation of another string ; Stores the length of str2 ; Stores the length of str1 ; If M is not multiple of N ; Traverse both the strings ; If str1 is not concatenation of str2 ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "3344-3344",
        "Code": "def MinLen ( str , K ) : NEW_LINE INDENT N = len ( str ) NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == N - 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( 1 , N - K ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" aabc \" NEW_LINE K = 1 NEW_LINE print ( MinLen ( str , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize length of string by replacing K pairs of distinct adjacent characters | Function to minimize the length of the by replacing distinct pairs of adjacent characters ; Stores the length of the given string ; Stores the index of the given string ; Traverse the given string ; If two adjacent haracters are distinct ; If all characters are equal ; If all characters are distinct ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3347-3347",
        "Code": "from math import floor , exp NEW_LINE def temp ( n , x ) : NEW_LINE INDENT return pow ( x * 1 / n , n ) NEW_LINE DEDENT def check ( n , y , x ) : NEW_LINE INDENT v = temp ( n , x ) NEW_LINE return ( v >= y ) NEW_LINE DEDENT def find ( x , y ) : NEW_LINE INDENT high = floor ( x / exp ( 1.0 ) ) NEW_LINE low = 1 NEW_LINE if ( x == y ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( not check ( high , y , x ) ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( high - low > 1 ) : NEW_LINE INDENT mid = ( high + low ) // 2 NEW_LINE if ( check ( mid , y , x ) ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT print ( high ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 9 NEW_LINE y = 8 NEW_LINE find ( x , y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of smallest sequence having sum X and product Y | Python3 program for the above approach ; Function for checking valid or not ; Function for checking boundary of binary search ; Function to calculate the minimum sequence size using binary search ; Initialize high and low ; Base case ; Print - 1 if a sequence cannot be generated ; Otherwise ; Iterate until difference between high and low exceeds 1 ; Calculate mid ; Reset values of high and low accordingly ; Print the answer ; Driver Code ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "3350-3350",
        "Code": "def display ( countLeftGreater , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( countLeftGreater [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def countGreater ( arr , N ) : NEW_LINE INDENT St = set ( ) NEW_LINE countLeftGreater = [ 0 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT St . add ( arr [ i ] ) NEW_LINE it = 0 NEW_LINE for st in St : NEW_LINE INDENT if ( arr [ i ] < st ) : NEW_LINE INDENT break NEW_LINE DEDENT it += 1 NEW_LINE DEDENT countLeftGreater [ i ] = abs ( it - len ( St ) ) NEW_LINE DEDENT display ( countLeftGreater , N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 1 , 2 , 3 , 0 , 11 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE countGreater ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count greater elements on the left side of every array element | Function to print the count of greater elements on left of each array element ; Function to get the count of greater elements on left of each array element ; Store distinct array elements in sorted order ; Stores the count of greater elements on the left side ; Traverse the array ; Insert array elements into the set ; Find previous greater element ; Find the distance between the previous greater element of arr [ i ] and last element of the set ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "3355-3355",
        "Code": "import math NEW_LINE def PrintIndexes ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT currSubSum = 0 NEW_LINE for j in range ( i , N , 1 ) : NEW_LINE INDENT currSubSum += arr [ j ] NEW_LINE sq = int ( math . sqrt ( currSubSum ) ) NEW_LINE if ( sq * sq == currSubSum ) : NEW_LINE INDENT print ( \" ( \" , i , \" , \" , j , \" ) \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 65 , 79 , 81 ] NEW_LINE N = len ( arr ) NEW_LINE PrintIndexes ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Subarrays whose sum is a perfect square | Python3 program to implement the above approach ; Function to print the start and end indices of all subarrays whose sum is a perfect square ; Stores the current subarray sum ; Update current subarray sum ; Stores the square root of currSubSum ; Check if currSubSum is a perfect square or not ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "3362-3362",
        "Code": "INF = 99999 NEW_LINE def floyd_warshall ( graph , V ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( V ) ] for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE DEDENT DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( i + 1 , V ) : NEW_LINE INDENT sum += dist [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def sumOfshortestPath ( N , E , edges ) : NEW_LINE INDENT g = [ [ INF for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] NEW_LINE v = edges [ i ] [ 1 ] NEW_LINE w = edges [ i ] [ 2 ] NEW_LINE g [ u ] [ v ] = w NEW_LINE g [ v ] [ u ] = w NEW_LINE DEDENT return floyd_warshall ( g , N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE E = 3 NEW_LINE Edges = [ [ 0 , 1 , 1 ] , [ 1 , 2 , 2 ] , [ 2 , 3 , 3 ] ] NEW_LINE print ( sumOfshortestPath ( N , E , Edges ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all pair shortest paths in a Tree | Python3 program for the above approach ; Function that performs the Floyd Warshall to find all shortest paths ; Initialize the distance matrix ; Pick all vertices as source one by one ; Pick all vertices as destination for the above picked source ; If vertex k is on the shortest path from i to j then update dist [ i ] [ j ] ; Sum the upper diagonal of the shortest distance matrix ; Traverse the given dist [ ] [ ] ; Add the distance ; Return the final sum ; Function to generate the tree ; Add edges ; Get source and destination with weight ; Add the edges ; Perform Floyd Warshal Algorithm ; Driver code ; Number of Vertices ; Number of Edges ; Given Edges with weight ; Function Call",
        "Category": "Graph Theory"
    },
    {
        "ID": "3366-3366",
        "Code": "def print_kth_string ( s , K ) : NEW_LINE INDENT N = len ( s ) ; NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' ) : NEW_LINE INDENT K -= 1 ; NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT while ( i < N ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"10 ▁ 20 ▁ 30 ▁ 40\" ; NEW_LINE K = 4 ; NEW_LINE print_kth_string ( s , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Kth space | Function to prkth integer in a given string ; Size of the string ; If space char found decrement K ; If K becomes 1 , the next string is the required one ; Print required number ; Driver Code ; Given string ; Given K ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3383-3383",
        "Code": "def isPrefixOfWord ( sentence , word ) : NEW_LINE INDENT a = sentence . split ( \" ▁ \" ) NEW_LINE v = [ ] NEW_LINE for i in a : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT for j in range ( len ( v [ i ] ) ) : NEW_LINE INDENT if ( v [ i ] [ j ] != word [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( j == len ( word ) - 1 ) : NEW_LINE INDENT return v [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT s = \" Welcome ▁ to ▁ Geeksforgeeks \" NEW_LINE word = \" Gee \" NEW_LINE print ( isPrefixOfWord ( s , word ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the word from a given sentence having given word as prefix | Function to find the position of the string having word as prefix ; Initialize an List ; Extract words from the sentence ; Traverse each word ; Traverse the characters of word ; If prefix does not match ; Otherwise ; Return the word ; Return - 1 if not present ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "3386-3386",
        "Code": "def EvenLIS ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if abs ( arr [ i ] ) > abs ( arr [ j ] ) and abs ( arr [ i ] % 2 ) == 0 and abs ( arr [ j ] % 2 ) == 0 and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxlen = max ( maxlen , lis [ i ] ) NEW_LINE DEDENT print ( maxlen ) NEW_LINE DEDENT arr = [ 11 , - 22 , 43 , - 54 , 66 , 5 ] NEW_LINE EvenLIS ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Length of longest increasing absolute even subsequence | Function to find the longest increasing absolute even subsequence ; Length of arr ; Stores length of required subsequence ; Traverse the array ; Traverse prefix of current array element ; Check if the subsequence is LIS and have even absolute difference of adjacent pairs ; Update lis [ ] ; Stores maximum length ; Find the length of longest absolute even subsequence ; Return the maximum length of absolute even subsequence ; Given arr [ ] ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "3392-3392",
        "Code": "import math ; NEW_LINE def minDigits ( N , K ) : NEW_LINE ' ▁ Find ▁ the ▁ number ▁ of ▁ digits ' ' ' NEW_LINE digits_num = int ( math . floor ( math . log ( N ) + 1 ) ) ; NEW_LINE INDENT temp_sum = 0 ; NEW_LINE temp = digits_num ; NEW_LINE result = 0 ; NEW_LINE X = 0 ; var = 0 ; NEW_LINE sum1 = 0 ; NEW_LINE num2 = N ; NEW_LINE DEDENT ' Calculate ▁ sum ▁ of ▁ the ▁ digits ' ' ' NEW_LINE INDENT while ( num2 != 0 ) : NEW_LINE sum1 += num2 % 10 ; NEW_LINE num2 /= 10 ; NEW_LINE DEDENT if ( sum1 <= K ) : NEW_LINE INDENT X = 0 ; NEW_LINE else : NEW_LINE DEDENT while ( temp > 0 ) : NEW_LINE var = int ( N // ( pow ( 10 , temp - 1 ) ) ) ; NEW_LINE INDENT temp_sum += var % 10 ; NEW_LINE if ( temp_sum >= K ) : NEW_LINE var = var // 10 ; NEW_LINE var += 1 ; NEW_LINE result = var * int ( pow ( 10 , temp ) ) ; NEW_LINE break ; NEW_LINE temp -= 1 ; NEW_LINE X = result - N ; NEW_LINE return X ; NEW_LINE DEDENT return - 1 ; NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 ; NEW_LINE K = 1 ; NEW_LINE DEDENT print ( minDigits ( N , K ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Minimum value of X that can be added to N to minimize sum of the digits to Ã ¢ â €°¤ K | ''Python program for the above approach ; ''Function to find the minimum number needed to be added so that the sum of the digits does not exceed K ;  ;  ; '' Add the digits of num2 ; ''If the sum of the digits of N  is less than or equal to K ; '' No number needs to  be added ; '' Otherwise ; '' Calculate the sum of digits  from least significant digit ; '' If sum exceeds K ; '' Increase previous  digit by 1 ; '' Add zeros to the end ; '' Calculate difference  between the result and N ; '' Return the result ; ''Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3394-3394",
        "Code": "def convertBfromA ( a , b ) : NEW_LINE INDENT moves = 0 NEW_LINE x = abs ( a - b ) NEW_LINE for i in range ( 10 , 0 , - 1 ) : NEW_LINE INDENT moves += x // i NEW_LINE x = x % i NEW_LINE DEDENT print ( moves , end = \" ▁ \" ) NEW_LINE DEDENT A = 188 NEW_LINE B = 4 NEW_LINE convertBfromA ( A , B ) NEW_LINE",
        "Type": "py",
        "NL": "Count minimum moves required to convert A to B | Function to find minimum number of moves to obtained B from A ; Stores the minimum number of moves ; Absolute difference ; K is in range [ 0 , 10 ] ; Print the required moves ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3395-3395",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . data = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def Sum ( root ) : NEW_LINE INDENT global res NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT leftSubSum = Sum ( root . left ) NEW_LINE rightSubSum = Sum ( root . right ) NEW_LINE if ( root . left and root . right and leftSubSum == rightSubSum ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return ( root . data + leftSubSum + rightSubSum ) NEW_LINE DEDENT root = Node ( 9 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . left . left = Node ( - 1 ) NEW_LINE root . left . right = Node ( 3 ) NEW_LINE root . right = Node ( 4 ) NEW_LINE root . right . right = Node ( 0 ) NEW_LINE global res NEW_LINE res = 0 NEW_LINE Sum ( root ) NEW_LINE print ( res ) NEW_LINE",
        "Type": "py",
        "NL": "Count balanced nodes present in a binary tree | Structure of a Tree Node ; Function to get the sum of left subtree and right subtree ; Base case ; Store the sum of left subtree ; Store the sum of right subtree ; Check if node is balanced or not ; Increase count of balanced nodes ; Return subtree sum ; Insert nodes in tree ; Store the count of balanced nodes",
        "Category": "Binary Tree"
    },
    {
        "ID": "3396-3396",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . data = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def PrintAlternate ( root ) : NEW_LINE INDENT Q = [ ] NEW_LINE Q . append ( root ) NEW_LINE while ( len ( Q ) ) : NEW_LINE INDENT N = len ( Q ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT Q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT Q . append ( temp . right ) NEW_LINE DEDENT DEDENT print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 71 ) NEW_LINE root . left = newNode ( 88 ) NEW_LINE root . right = newNode ( 99 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . left . left . right = newNode ( 9 ) NEW_LINE root . left . right . left = newNode ( 10 ) NEW_LINE root . left . right . right = newNode ( 11 ) NEW_LINE root . right . left . right = newNode ( 13 ) NEW_LINE root . right . right . left = newNode ( 14 ) NEW_LINE PrintAlternate ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print alternate nodes from all levels of a Binary Tree | Structure of a Node ; Print alternate nodes of a binary tree ; Store nodes of each level ; Store count of nodes of current level ; Print alternate nodes of the current level ; If left child exists ; Store left child ; If right child exists ; Store right child ; Driver Code ; Create a tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "3400-3400",
        "Code": "def sieve ( prime ) : NEW_LINE INDENT for i in range ( 1000000 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE for i in range ( 2 , 1000 + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , 1000000 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def subPrimeSum ( N , K , arr , prime ) : NEW_LINE INDENT currSum = 0 NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT currSum += arr [ i ] NEW_LINE DEDENT if ( prime [ currSum ] ) : NEW_LINE INDENT for i in range ( K ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT st = 1 NEW_LINE en = K NEW_LINE while ( en < N ) : NEW_LINE INDENT currSum += arr [ en ] - arr [ st - 1 ] NEW_LINE if ( prime [ currSum ] ) : NEW_LINE INDENT for i in range ( st , en + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT en += 1 NEW_LINE st += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 20 , 7 , 5 , 4 , 3 , 11 , 99 , 87 , 23 , 45 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) NEW_LINE prime = [ False ] * 1000000 NEW_LINE prime = sieve ( prime ) NEW_LINE subPrimeSum ( N , K , arr , prime ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Subarray of size K with prime sum | Generate all prime numbers in the range [ 1 , 1000000 ] ; Set all numbers as prime initially ; Mark 0 and 1 as non - prime ; If current element is prime ; Mark all its multiples as non - prime ; Function to prthe subarray whose sum of elements is prime ; Store the current subarray of size K ; Calculate the sum of first K elements ; Check if currSum is prime ; Store the start and last index of subarray of size K ; Iterate over remaining array ; Check if currSum ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3406-3406",
        "Code": "def lexicographicRank ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE alphaIndex = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT x = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE alphaIndex [ x ] . append ( i ) NEW_LINE DEDENT rank = - 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ord ( ' a ' ) + i >= ord ( s [ 0 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if len ( alphaIndex [ i ] ) > 0 : NEW_LINE INDENT for j in range ( len ( alphaIndex [ i ] ) ) : NEW_LINE INDENT rank = rank + ( n - alphaIndex [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT strr = [ ] NEW_LINE for i in range ( len ( alphaIndex [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] ) ) : NEW_LINE INDENT substring = [ ] NEW_LINE jj = alphaIndex [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] [ i ] NEW_LINE for j in range ( jj , n ) : NEW_LINE INDENT substring . append ( s [ j ] ) NEW_LINE strr . append ( substring ) NEW_LINE DEDENT DEDENT strr = sorted ( strr ) NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if ( strr [ i ] != s ) : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return rank + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" enren \" NEW_LINE print ( lexicographicRank ( strr ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographic rank of a string among all its substrings | Function to find lexicographic rank of among all its substring ; Length of string ; Traverse the given string and store the indices of each character ; Extract the index ; Store it in the vector ; Traverse the alphaIndex array lesser than the index of first character of given string ; If alphaIndex [ i ] size exceeds 0 ; Traverse over the indices ; Add count of substring equal to n - alphaIndex [ i ] [ j ] ; Store all substrings in a vector strr starting with the first character of the given string ; Insert the current character to substring ; Store the subformed ; Sort the substring in the lexicographical order ; Find the rank of given string ; Increase the rank until the given is same ; If substring is same as the given string ; Add 1 to rank of the given string ; Driver Code ; Given string ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3420-3420",
        "Code": "def reorderString ( A , B ) : NEW_LINE INDENT size_a = len ( A ) NEW_LINE size_b = len ( B ) NEW_LINE freq = [ 0 ] * 300 NEW_LINE for i in range ( size_b ) : NEW_LINE INDENT freq [ ord ( B [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( size_a ) : NEW_LINE INDENT freq [ ord ( A [ i ] ) ] -= 1 NEW_LINE DEDENT for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if ( freq [ j ] < 0 ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT DEDENT answer = [ ] NEW_LINE for j in range ( ord ( ' a ' ) , ord ( A [ 0 ] ) ) : NEW_LINE INDENT while ( freq [ j ] > 0 ) : NEW_LINE INDENT answer . append ( j ) NEW_LINE freq [ j ] -= 1 NEW_LINE DEDENT DEDENT first = A [ 0 ] NEW_LINE for j in range ( size_a ) : NEW_LINE INDENT if ( A [ j ] > A [ 0 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( A [ j ] < A [ 0 ] ) : NEW_LINE INDENT answer += A NEW_LINE A = \" \" NEW_LINE break NEW_LINE DEDENT DEDENT while ( freq [ ord ( first ) ] > 0 ) : NEW_LINE INDENT answer . append ( first ) NEW_LINE freq [ ord ( first ) ] -= 1 NEW_LINE DEDENT answer += A NEW_LINE for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT while ( freq [ j ] ) : NEW_LINE INDENT answer . append ( chr ( j ) ) NEW_LINE freq [ j ] -= 1 NEW_LINE DEDENT DEDENT return \" \" . join ( answer ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" aa \" NEW_LINE B = \" ababab \" NEW_LINE print ( reorderString ( A , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest permutation of a string that contains all substrings of another string | Function to reorder the B to contain all the substrings of A ; Find length of strings ; Initialize array to count the frequencies of the character ; Counting frequencies of character in B ; Find remaining character in B ; Declare the reordered string ; Loop until freq [ j ] > 0 ; Decrement the value from freq array ; Check if A [ j ] > A [ 0 ] ; Check if A [ j ] < A [ 0 ] ; Append the remaining characters to the end of the result ; Push all the values from frequency array in the answer ; Return the answer ; Driver Code ; Given strings A and B ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3421-3421",
        "Code": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def GcdPair ( arr , k ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = len ( arr ) - 1 NEW_LINE ans = [ - 1 , 0 ] NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = lo + ( hi - lo ) // 2 NEW_LINE if ( GCD ( arr [ mid ] [ 0 ] , arr [ mid ] [ 1 ] ) > k ) : NEW_LINE INDENT ans = arr [ mid ] NEW_LINE hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( len ( ans ) == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ( \" , ans [ 0 ] , \" , \" , ans [ 1 ] , \" ) \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 3 , 6 ] , [ 15 , 30 ] , [ 25 , 75 ] , [ 30 , 120 ] ] NEW_LINE K = 16 NEW_LINE GcdPair ( arr , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Pair of integers having least GCD among all given pairs having GCD exceeding K | Function to calculate the GCD of two numbers ; Function to print the pair having a gcd value just greater than the given integer ; Initialize variables ; Iterate until low less than equal to high ; Calculate mid ; Reducing the search space ; Print the answer ; Driver Code ; Given array and K ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "3431-3431",
        "Code": "def checkEqual ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * 256 NEW_LINE M = len ( arr [ 0 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT hash [ ord ( arr [ i ] [ j ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( hash [ i ] % N != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ \" fdd \" , \" fhh \" ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkEqual ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if all strings of an array can be made same by interchanging characters | Function to check if all strings are equal after swap operations ; Stores the frequency of characters ; Stores the length of string ; Traverse the array ; Traverse each string ; Check if frequency of character is divisible by N ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3448-3448",
        "Code": "def palindromePrefix ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr = S [ 0 : i + 1 ] NEW_LINE l = 0 NEW_LINE r = len ( curr ) - 1 NEW_LINE is_palindrome = 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( curr [ l ] != curr [ r ] ) : NEW_LINE INDENT is_palindrome = 0 NEW_LINE break NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( is_palindrome ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT return \" \" NEW_LINE DEDENT def maxPalindrome ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return S NEW_LINE DEDENT pre = \" \" NEW_LINE suff = \" \" NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( S [ i ] == S [ j ] and i < j ) : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE j += 1 NEW_LINE pre = S [ 0 : i + 1 ] NEW_LINE suff = S [ j : ] NEW_LINE if ( j - i == 1 ) : NEW_LINE INDENT return pre + suff NEW_LINE DEDENT if ( j - i == 2 ) : NEW_LINE INDENT mid_char = S [ i + 1 : i + 2 ] NEW_LINE return pre + mid_char + suff NEW_LINE DEDENT rem_str = S [ i + 1 : j ] NEW_LINE pre_of_rem_str = palindromePrefix ( rem_str ) NEW_LINE list1 = list ( rem_str ) NEW_LINE list1 . reverse ( ) NEW_LINE rem_str = ' ' . join ( list1 ) NEW_LINE suff_of_rem_str = palindromePrefix ( rem_str ) NEW_LINE if ( len ( pre_of_rem_str ) >= len ( suff_of_rem_str ) ) : NEW_LINE INDENT return ( pre + pre_of_rem_str + suff ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( pre + suff_of_rem_str + suff ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" geeksforskeeg \" NEW_LINE print ( maxPalindrome ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum size substring to be removed to make a given string palindromic | Function to find palindromic prefix of maximum length ; Finding palindromic prefix of maximum length ; Checking if curr substring is palindrome or not . ; Condition to check if the prefix is a palindrome ; if no palindrome exist ; Function to find the maximum size palindrome such that after removing minimum size substring ; Finding prefix and suffix of same length ; Matching the ranges ; Case 1 : Length is even and whole string is palindrome ; Case 2 : Length is odd and whole string is palindrome ; Adding that mid character ; Add prefix or suffix of the remaining string or suffix , whichever is longer ; Reverse the remaining string to find the palindromic suffix ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "3449-3449",
        "Code": "import math NEW_LINE def checkSumOfNatural ( n ) : NEW_LINE INDENT i = 1 NEW_LINE flag = False NEW_LINE while i * ( i + 1 ) < n * 2 : NEW_LINE INDENT X = i * ( i + 1 ) NEW_LINE t = n * 2 - X NEW_LINE k = int ( math . sqrt ( t ) ) NEW_LINE if k * ( k + 1 ) == t : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 25 NEW_LINE checkSumOfNatural ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given number can be expressed as pair | Python3 program of the above approach ; Function to check if the number is pair - sum of sum of first X natural numbers ; Check if the given number is sum of pair of special numbers ; X is the sum of first i natural numbers ; t = 2 * Y ; Condition to check if Y is a special number ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "3450-3450",
        "Code": "from math import log10 NEW_LINE def countNumEnds ( A , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE digits = int ( log10 ( A ) + 1 ) NEW_LINE temp = int ( pow ( 10 , digits ) ) NEW_LINE cycle = temp NEW_LINE while ( temp <= R ) : NEW_LINE INDENT if ( temp >= L ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT temp += cycle NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT A = 2 NEW_LINE L = 2 NEW_LINE R = 20 NEW_LINE countNumEnds ( A , L , R ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers from a given range that contains a given number as the suffix | Python3 program of the above approach ; Function to count the number ends with given number in range ; Find number of digits in A ; Find the power of 10 ; Incrementing the A ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "3457-3457",
        "Code": "def isValid ( n , m , k ) : NEW_LINE INDENT step2 = n - m NEW_LINE cnt = ( step2 * ( step2 + 1 ) ) // 2 NEW_LINE if ( cnt - m == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( cnt - m > k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def countOfOperations ( n , k ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE ok = 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE temp = isValid ( n , mid , k ) NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT ok = 0 NEW_LINE print ( mid ) NEW_LINE break NEW_LINE DEDENT elif ( temp == 1 ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT if ( ok ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE K = 4 NEW_LINE countOfOperations ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Count of decrement operations required to obtain K in N steps | Function to check whether m number of steps of type 1 are valid or not ; If m and n are the count of operations of type 1 and type 2 respectively , then n - m operations are performed ; Find the value of S after step 2 ; If m steps of type 1 is valid ; Function to find the number of operations of type 1 required ; Iterate over the range ; Find the value of mid ; Check if m steps of type 1 are valid or not ; If mid is the valid number of steps ; If no valid number of steps exist ; Given and N , K ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "3458-3458",
        "Code": "def nonLower ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if not s [ i ] . islower ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printCodes ( output ) : NEW_LINE INDENT for i in range ( len ( output ) ) : NEW_LINE INDENT if ( nonLower ( output [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( output [ i ] ) NEW_LINE DEDENT DEDENT def getChar ( n ) : NEW_LINE INDENT return chr ( n + 96 ) NEW_LINE DEDENT def getCode ( str ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT ans = [ \" \" ] NEW_LINE return ans NEW_LINE DEDENT output1 = getCode ( str [ 1 : ] ) NEW_LINE output2 = [ ] NEW_LINE firstDigit = ( ord ( str [ 0 ] ) - ord ( '0' ) ) NEW_LINE firstTwoDigit = 0 NEW_LINE if ( len ( str ) >= 2 ) : NEW_LINE firstTwoDigit = ( ( ord ( str [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( str [ 1 ] ) - ord ( '0' ) ) ) NEW_LINE if ( firstTwoDigit >= 10 and firstTwoDigit <= 26 ) : NEW_LINE INDENT output2 = getCode ( str [ 2 : ] ) NEW_LINE DEDENT output = [ ' ' for i in range ( len ( output1 ) + len ( output2 ) ) ] NEW_LINE k = 0 NEW_LINE for i in range ( len ( output1 ) ) : NEW_LINE INDENT ch = getChar ( firstDigit ) NEW_LINE output [ i ] = ch + output1 [ i ] NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( len ( output2 ) ) : NEW_LINE INDENT ch = getChar ( firstTwoDigit ) NEW_LINE output [ k ] = ch + output2 [ i ] NEW_LINE k += 1 NEW_LINE DEDENT return output NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = \"101\" NEW_LINE output = getCode ( input ) NEW_LINE printCodes ( output ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all Possible Decodings of a given Digit Sequence | Function to check if all the characters are lowercase or not ; Traverse the string ; If any character is not found to be in lowerCase ; Function to print the decodings ; If all characters are not in lowercase ; Function to return the character corresponding to given integer ; Function to return the decodings ; Base case ; Recursive call ; Stores the characters of two digit numbers ; Extract first digit and first two digits ; Check if it lies in the range of alphabets ; Next recursive call ; Combine both the output in a single readonly output array ; Index of readonly output array ; Store the elements of output1 in readonly output array ; Store the elements of output2 in readonly output array ; Result the result ; Driver Code ; Function call ; Print function call",
        "Category": "Backtracking"
    },
    {
        "ID": "3467-3467",
        "Code": "def findString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = \" \" NEW_LINE st = [ ] NEW_LINE vis = [ False ] * n NEW_LINE count = 0 NEW_LINE List < bool > vis ( n , false ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT st . append ( i ) NEW_LINE DEDENT if ( count < k and s [ i ] == ' ) ' ) : NEW_LINE INDENT vis [ st [ - 1 ] ] = 1 NEW_LINE del st [ - 1 ] NEW_LINE vis [ i ] = True NEW_LINE count += 2 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == True ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ( ) ( ) ( ) \" NEW_LINE K = 2 NEW_LINE print ( findString ( s , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a valid parenthesis sequence of length K from a given valid parenthesis sequence | Function to find the subsequence of length K forming valid sequence ; Stores the resultant string ; Check whether character at index i is visited or not ; Traverse the string ; Push index of open bracket ; Pop and mark visited ; Increment count by 2 ; Append the characters and create the resultant string ; Return the resultant string ; Driver Code ; Function call",
        "Category": "Stack"
    },
    {
        "ID": "3470-3470",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . data = item NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT result = 0 NEW_LINE def dfs ( root , distance ) : NEW_LINE INDENT global result NEW_LINE if ( root == None ) : NEW_LINE INDENT res = [ 0 for i in range ( distance + 1 ) ] NEW_LINE return res NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT res = [ 0 for i in range ( distance + 1 ) ] NEW_LINE res [ 1 ] += 1 NEW_LINE return res NEW_LINE DEDENT left = dfs ( root . left , distance ) NEW_LINE right = dfs ( root . right , distance ) NEW_LINE res = [ 0 for i in range ( distance + 1 ) ] NEW_LINE i = len ( res ) - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT res [ i + 1 ] = left [ i ] + right [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT for l in range ( 1 , len ( left ) ) : NEW_LINE INDENT for r in range ( len ( right ) ) : NEW_LINE INDENT if ( l + r <= distance ) : NEW_LINE INDENT result += left [ l ] * right [ r ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE K = 3 NEW_LINE dfs ( root , K ) NEW_LINE print ( result ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs of leaf nodes in a Binary Tree which are at most K distance apart | ''Structure of a Node ; ''Stores the count of required pairs ; ''Function to perform dfs to find pair of leaf nodes at most K distance apart ; '' Return empty array if node is None ; '' If node is a leaf node and return res ; '' Traverse to the left ; '' Traverse to the right ; '' Update the distance between left  and right leaf node ; '' Count all pair of leaf nodes  which are at most K distance apart ; '' Return res to parent node ; ''Driver Code ; ''  1  / \\  2 3  /  4   ; '' Given distance K ; '' Function call",
        "Category": "Binary Tree"
    },
    {
        "ID": "3473-3473",
        "Code": "from math import sqrt , ceil , floor NEW_LINE def isPerfectSquare ( n ) : NEW_LINE INDENT sr = sqrt ( n ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def SubarrayHavingPerfectSquare ( arr , k ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE while i < k : NEW_LINE INDENT sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT found = False NEW_LINE if ( isPerfectSquare ( sum ) ) : NEW_LINE INDENT ans [ 0 ] = 0 NEW_LINE ans [ 1 ] = i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( i , len ( arr ) ) : NEW_LINE INDENT sum = sum + arr [ j ] - arr [ j - k ] NEW_LINE if ( isPerfectSquare ( sum ) ) : NEW_LINE INDENT found = True NEW_LINE ans [ 0 ] = j - k + 1 NEW_LINE ans [ 1 ] = j NEW_LINE DEDENT DEDENT for k in range ( ans [ 0 ] , ans [ 1 ] + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 20 , 34 , 51 , 10 , 99 , 87 , 23 , 45 ] NEW_LINE K = 3 NEW_LINE SubarrayHavingPerfectSquare ( arr , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a subarray of size K whose sum is a perfect square | Python3 program for the above approach ; Function to check if a given number is a perfect square or not ; Find square root of n ; Check if the square root is an integer or not ; Function to print the subarray whose sum is a perfect square ; Sum of first K elements ; If the first k elements have a sum as perfect square ; Iterate through the array ; If sum is perfect square ; If subarray not found ; Driver Code ; Given array ; Given subarray size K ; Function call",
        "Category": "Sliding Window"
    },
    {
        "ID": "3474-3474",
        "Code": "def checkForPerfectSquare ( arr , i , j ) : NEW_LINE INDENT mid , sum = 0 , 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT sum += arr [ m ] NEW_LINE DEDENT low = 0 NEW_LINE high = sum // 2 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid * mid == sum ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid * mid > sum ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 19 , 33 , 48 , 90 , 100 ] NEW_LINE L = 1 NEW_LINE R = 3 NEW_LINE print ( checkForPerfectSquare ( arr , L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the sum of a subarray within a given range is a perfect square or not | Function to calculate the square root of the sum of a subarray in a given range ; Calculate the sum of array elements within a given range ; Finding the square root ; If a perfect square is found ; Reduce the search space if the value is greater than sum ; Reduce the search space if the value if smaller than sum ; Driver Code ; Given Array ; Given range ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "3477-3477",
        "Code": "TEN = 10 NEW_LINE def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * ( TEN ) NEW_LINE freqB = [ 0 ] * ( TEN ) NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPowerOf2 ( N ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if ( areAnagrams ( 1 << i , N ) ) : NEW_LINE INDENT print ( 1 << i ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 46 NEW_LINE if ( isPowerOf2 ( N ) == 0 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if any permutation of a number without any leading zeros is a power of 2 or not | Python3 program for the above approach ; Function to update the frequency array such that freq [ i ] stores the frequency of digit i to n ; While there are digits left to process ; Update the frequency of the current digit ; Remove the last digit ; Function that returns true if a and b are anagrams of each other ; To store the frequencies of the digits in a and b ; Update the frequency of the digits in a ; Update the frequency of the digits in b ; Match the frequencies of the common digits ; If frequency differs for any digit then the numbers are not anagrams of each other ; Function to check if any permutation of a number is a power of 2 or not ; Iterate over all possible perfect power of 2 ; Print that number ; Given number N ; Function call",
        "Category": "Math"
    },
    {
        "ID": "3486-3486",
        "Code": "def Maxcost ( s , cost ) : NEW_LINE INDENT count = 0 NEW_LINE maxcost = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT if cost [ i ] > cost [ i + 1 ] : NEW_LINE INDENT maxcost += cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxcost += cost [ i + 1 ] NEW_LINE cost [ i + 1 ] = cost [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return maxcost NEW_LINE DEDENT s = \" abaac \" NEW_LINE cost = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE print ( Maxcost ( s , cost ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize cost of deletions to obtain string having no pair of similar adjacent characters | Function to find maximum cost to remove consecutive characters ; Initialize the count ; Maximum cost ; Traverse from 0 to len ( s ) - 2 ; If characters are identical ; Add cost [ i ] if its maximum ; Add cost [ i + 1 ] if its maximum ; Increment i ; Return the final max count ; Given string s ; Given cost of removal ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "349-349",
        "Code": "import sys NEW_LINE def dfs ( g , disRev , visit , u ) : NEW_LINE INDENT visit [ u ] = True NEW_LINE totalRev = 0 NEW_LINE for i in range ( len ( g [ u ] ) ) : NEW_LINE INDENT v = g [ u ] [ i ] [ 0 ] NEW_LINE if ( not visit [ v ] ) : NEW_LINE INDENT disRev [ v ] [ 0 ] = disRev [ u ] [ 0 ] + 1 NEW_LINE disRev [ v ] [ 1 ] = disRev [ u ] [ 1 ] NEW_LINE if ( g [ u ] [ i ] [ 1 ] ) : NEW_LINE INDENT disRev [ v ] [ 1 ] = disRev [ u ] [ 1 ] + 1 NEW_LINE totalRev += 1 NEW_LINE DEDENT totalRev += dfs ( g , disRev , visit , v ) NEW_LINE DEDENT DEDENT return totalRev NEW_LINE DEDENT def printMinEdgeReverseForRootNode ( edges , e ) : NEW_LINE INDENT V = e + 1 NEW_LINE g = [ [ ] for i in range ( V ) ] NEW_LINE disRev = [ [ 0 , 0 ] for i in range ( V ) ] NEW_LINE visit = [ False for i in range ( V ) ] NEW_LINE for i in range ( e ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] NEW_LINE v = edges [ i ] [ 1 ] NEW_LINE g [ u ] . append ( [ v , 0 ] ) NEW_LINE g [ v ] . append ( [ u , 1 ] ) NEW_LINE DEDENT for i in range ( V ) : NEW_LINE INDENT visit [ i ] = False NEW_LINE disRev [ i ] [ 0 ] = disRev [ i ] [ 1 ] = 0 NEW_LINE DEDENT root = 0 NEW_LINE totalRev = dfs ( g , disRev , visit , root ) NEW_LINE res = sys . maxsize NEW_LINE for i in range ( V ) : NEW_LINE INDENT edgesToRev = ( ( totalRev - disRev [ i ] [ 1 ] ) + ( disRev [ i ] [ 0 ] - disRev [ i ] [ 1 ] ) ) NEW_LINE if ( edgesToRev < res ) : NEW_LINE INDENT res = edgesToRev NEW_LINE root = i NEW_LINE DEDENT DEDENT print ( root , res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT edges = [ [ 0 , 1 ] , [ 2 , 1 ] , [ 3 , 2 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 6 ] , [ 7 , 6 ] ] NEW_LINE e = len ( edges ) NEW_LINE printMinEdgeReverseForRootNode ( edges , e ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum edge reversals to make a root | Python3 program to find min edge reversal to make every node reachable from root ; Method to dfs in tree and populates disRev values ; Visit current node ; Looping over all neighbors ; Distance of v will be one more than distance of u ; Initialize back edge count same as parent node 's count ; If there is a reverse edge from u to i , then only update ; Return total reversal in subtree rooted at u ; Method prints root and minimum number of edge reversal ; Number of nodes are one more than number of edges ; Data structure to store directed tree ; disRev stores two values - distance and back edge count from root node ; Add 0 weight in direction of u to v ; Add 1 weight in reverse direction ; Initialize all variables ; dfs populates disRev data structure and store total reverse edge counts ; for ( i = 0 i < V i ++ ) { cout < < i < < \" ▁ : ▁ \" << disRev [ i ] [ 0 ] << \" ▁ \" << disRev [ i ] [ 1 ] << endl } ; Loop over all nodes to choose minimum edge reversal ; ( reversal in path to i ) + ( reversal in all other tree parts ) ; Choose minimum among all values ; Print the designated root and total edge reversal made ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "3493-3493",
        "Code": "from math import log2 NEW_LINE def count_numbers ( L , R ) : NEW_LINE INDENT ans = 0 NEW_LINE for n in range ( L , R + 1 ) : NEW_LINE INDENT no_of_bits = int ( log2 ( n ) + 1 ) NEW_LINE no_of_set_bits = bin ( n ) . count ( '1' ) NEW_LINE if ( no_of_bits - no_of_set_bits == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 4 NEW_LINE R = 9 NEW_LINE print ( count_numbers ( L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of numbers having only one unset bit in a range [ L , R ] | Python3 program for the above approach ; Function to count numbers in the range [ l , r ] having exactly one unset bit ; Stores the required count ; Iterate over the range ; Calculate number of bits ; Calculate number of set bits ; If count of unset bits is 1 ; Increment answer ; Return the answer ; Driver Code ; Function call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "3494-3494",
        "Code": "import math NEW_LINE def count_numbers ( L , R ) : NEW_LINE INDENT ans = 0 ; NEW_LINE LogR = ( int ) ( math . log ( R ) + 1 ) ; NEW_LINE for zero_bit in range ( LogR ) : NEW_LINE INDENT cur = 0 ; NEW_LINE for j in range ( zero_bit ) : NEW_LINE INDENT cur |= ( 1 << j ) ; NEW_LINE DEDENT for j in range ( zero_bit + 1 , LogR ) : NEW_LINE INDENT cur |= ( 1 << j ) ; NEW_LINE if ( cur >= L and cur <= R ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 4 ; NEW_LINE R = 9 ; NEW_LINE print ( count_numbers ( L , R ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of numbers having only one unset bit in a range [ L , R ] | Python3 program for the above approach ; Function to count numbers in the range [ L , R ] having exactly one unset bit ; Stores the count elements having one zero in binary ; Stores the maximum number of bits needed to represent number ; Loop over for zero bit position ; Number having zero_bit as unset and remaining bits set ; Sets all bits before zero_bit ; Set the bit at position j ; Set the bit position at j ; If cur is in the range [ L , R ] , then increment ans ; Return ans ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "3504-3504",
        "Code": "from collections import deque NEW_LINE def reachesBottom ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( a [ 0 ] ) NEW_LINE q = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] [ j ] == 1 ) : NEW_LINE INDENT q . appendleft ( [ i , j , 1 ] ) NEW_LINE DEDENT elif ( a [ i ] [ j ] == 2 ) : NEW_LINE INDENT q . append ( [ i , j , 2 ] ) NEW_LINE DEDENT a [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT dx = [ - 1 , 0 , 1 , 0 ] NEW_LINE dy = [ 0 , 1 , 0 , - 1 ] NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT front = q . popleft ( ) NEW_LINE i = front [ 0 ] NEW_LINE j = front [ 1 ] NEW_LINE t = front [ 2 ] NEW_LINE if ( a [ i ] [ j ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT a [ i ] [ j ] = 1 NEW_LINE if ( t == 1 and ( i == n - 1 and j == m - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for d in range ( 4 ) : NEW_LINE INDENT ni = i + dx [ d ] NEW_LINE nj = j + dy [ d ] NEW_LINE if ( ni >= 0 and ni < n and nj >= 0 and nj < m ) : NEW_LINE INDENT q . append ( [ ni , nj , t ] ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT matrix = [ [ 0 , 2 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 2 , 0 ] ] NEW_LINE if ( reachesBottom ( matrix ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a path exists for a cell valued 1 to reach the bottom right corner of a Matrix before any cell valued 2 | Python3 program for the above approach ; Function to check if cell with value 1 doesn 't reaches the bottom right cell or not ; Number of rows and columns ; Initialise the deque ; Traverse the matrix ; Push 1 to front of queue ; Push 2 to back of queue ; Store all the possible direction of the current cell ; Run multi - source BFS ; Get the front element ; If 1 reached corner first ; Insert new poin queue ; If 1 can 't reach the bottom  right then return false ; Driver Code ; Given matrix ; Function call",
        "Category": "Graph Theory"
    },
    {
        "ID": "3508-3508",
        "Code": "def longestGP ( A , N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT length = 1 NEW_LINE common_ratio = 1 NEW_LINE maxlength = 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] % A [ i ] == 0 ) : NEW_LINE INDENT if ( A [ i + 1 ] // A [ i ] == common_ratio ) : NEW_LINE INDENT length = length + 1 NEW_LINE maxlength = max ( maxlength , length ) NEW_LINE DEDENT else : NEW_LINE INDENT common_ratio = A [ i + 1 ] // A [ i ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxlength = max ( maxlength , length ) NEW_LINE length = 1 NEW_LINE DEDENT DEDENT maxlength = max ( maxlength , length ) NEW_LINE return maxlength NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 7 , 14 , 28 , 56 , 89 ] NEW_LINE N = len ( arr ) NEW_LINE print ( longestGP ( arr , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Longest subarray forming a Geometic Progression ( GP ) | Function to return the length of the longest subarray forming a GP in a sorted array ; Base Case ; Stores the length of GP and the common ratio ; Stores the maximum length of the GP ; Traverse the array ; Check if the common ratio is valid for GP ; If the current common ratio is equal to previous common ratio ; Increment the length of the GP ; Store the max length of GP ; Otherwise ; Update the common ratio ; Update the length of GP ; Store the max length of GP ; Update the length of GP ; Store the max length of GP ; Return the max length of GP ; Given array ; Length of the array ; Function call",
        "Category": "Sliding Window"
    },
    {
        "ID": "3511-3511",
        "Code": "def find_kth_largest ( strr , k ) : NEW_LINE INDENT strr = sorted ( strr ) NEW_LINE strr = strr [ : : - 1 ] NEW_LINE return strr [ k - 1 ] NEW_LINE DEDENT def printCharacter ( strr , l , r , k ) : NEW_LINE INDENT l = l - 1 NEW_LINE r = r - 1 NEW_LINE temp = strr [ l : r - l + 1 ] NEW_LINE ans = find_kth_largest ( temp , k ) NEW_LINE return ans NEW_LINE DEDENT def updateString ( strr , pos , s ) : NEW_LINE INDENT index = pos - 1 NEW_LINE c = s NEW_LINE strr [ index ] = c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" abcddef \" NEW_LINE strr = [ i for i in strr ] NEW_LINE Q = 3 NEW_LINE print ( printCharacter ( strr , 1 , 2 , 2 ) ) NEW_LINE updateString ( strr , 4 , ' g ' ) NEW_LINE print ( printCharacter ( strr , 1 , 5 , 4 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to find Kth greatest character in a range [ L , R ] from a string with updates | Python3 Program to implement the above approach Function to find the kth greatest character from the string ; Sorting the in non - increasing Order ; Function to prthe K - th character from the subS [ l ] . . S [ r ] ; 0 - based indexing ; Subof strr from the indices l to r . ; Extract kth Largest character ; Function to replace character at pos of strr by the character s ; Index of S to be updated . ; Character to be replaced at index in S ; Driver Code ; Given string ; Count of queries ; Queries",
        "Category": "Array"
    },
    {
        "ID": "3512-3512",
        "Code": "maxn = 100005 NEW_LINE BITree = [ [ 0 for x in range ( maxn ) ] for y in range ( 26 ) ] NEW_LINE N = 0 NEW_LINE def update_BITree ( index , C , val ) : NEW_LINE INDENT while ( index <= N ) : NEW_LINE INDENT BITree [ ord ( C ) - ord ( ' a ' ) ] [ index ] += val NEW_LINE index += ( index & - index ) NEW_LINE DEDENT DEDENT def sum_BITree ( index , C ) : NEW_LINE INDENT s = 0 NEW_LINE while ( index ) : NEW_LINE INDENT s += BITree [ ord ( C ) - ord ( ' a ' ) ] [ index ] NEW_LINE index -= ( index & - index ) NEW_LINE DEDENT return s NEW_LINE DEDENT def buildTree ( st ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT update_BITree ( i , st [ i ] , 1 ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printCharacter ( st , l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for C in range ( ord ( ' z ' ) , ord ( ' a ' ) - 1 , - 1 ) : NEW_LINE INDENT times = ( sum_BITree ( r , chr ( C ) ) - sum_BITree ( l - 1 , chr ( C ) ) ) NEW_LINE count += times NEW_LINE if ( count >= k ) : NEW_LINE INDENT ans = chr ( C ) NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def updateTree ( st , pos , s ) : NEW_LINE INDENT index = pos ; NEW_LINE update_BITree ( index , st [ index ] , - 1 ) NEW_LINE st . replace ( st [ index ] , s , 1 ) NEW_LINE update_BITree ( index , s , 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" abcddef \" NEW_LINE N = len ( st ) NEW_LINE Q = 3 NEW_LINE buildTree ( st ) NEW_LINE print ( printCharacter ( st , 1 , 2 , 2 ) ) NEW_LINE updateTree ( st , 4 , ' g ' ) NEW_LINE print ( printCharacter ( st , 1 , 5 , 4 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to find Kth greatest character in a range [ L , R ] from a string with updates | Maximum Size of a String ; Fenwick Tree to store the frequencies of 26 alphabets ; Size of the String . ; Function to update Fenwick Tree for Character c at index val ; Add val to current node Fenwick Tree ; Move index to parent node in update View ; Function to get sum of frequencies of character c till index ; Stores the sum ; Add current element of Fenwick tree to sum ; Move index to parent node in getSum View ; Function to create the Fenwick tree ; Function to print the kth largest character in the range of l to r ; Stores the count of characters ; Stores the required character ; Calculate frequency of C in the given range ; Increase count ; If count exceeds K ; Required character found ; Function to update character at pos by character s ; 0 based index system ; Driver Code ; Number of queries ; Construct the Fenwick Tree",
        "Category": "Fenwick Tree"
    },
    {
        "ID": "3514-3514",
        "Code": "def lcmpair ( l , r ) : NEW_LINE INDENT x = l NEW_LINE y = 2 * l NEW_LINE if ( y > r ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" X ▁ = ▁ { } ▁ Y ▁ = ▁ { } \" . format ( x , y ) ) NEW_LINE DEDENT DEDENT l = 13 NEW_LINE r = 69 NEW_LINE lcmpair ( l , r ) NEW_LINE",
        "Type": "py",
        "NL": "Generate a pair of integers from a range [ L , R ] whose LCM also lies within the range | Python3 implementation of the above approach ; Checking if any pair is possible or not in range ( l , r ) ; If not possible print ( - 1 ) ; Print LCM pair ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "3516-3516",
        "Code": "def revNum ( N ) : NEW_LINE INDENT x = 0 NEW_LINE while ( N ) : NEW_LINE INDENT x = x * 10 + N % 10 NEW_LINE N = N // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def ctNonPalin ( arr , N ) : NEW_LINE INDENT Res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = revNum ( arr [ i ] ) NEW_LINE if ( x == arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Res += ( arr [ i ] % 10 == N % 10 ) NEW_LINE DEDENT DEDENT return Res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 121 , 134 , 2342 , 4514 ] NEW_LINE N = len ( arr ) NEW_LINE print ( ctNonPalin ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count non | Function to reverse a number ; Store the reverse of N ; Return reverse of N ; Function to get the count of non - palindromic numbers having same first and last digit ; Store the required count ; Traverse the array ; Store reverse of arr [ i ] ; Check for palindrome ; IF non - palindromic ; Check if first and last digits are equal ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3519-3519",
        "Code": "def GCD ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return GCD ( b % a , a ) NEW_LINE DEDENT def LCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // GCD ( a , b ) NEW_LINE DEDENT def checkPairwiseCoPrime ( A , n ) : NEW_LINE INDENT prod = 1 NEW_LINE lcm = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= A [ i ] NEW_LINE lcm = LCM ( A [ i ] , lcm ) NEW_LINE DEDENT if ( prod == lcm ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 3 , 5 ] NEW_LINE n = len ( A ) NEW_LINE checkPairwiseCoPrime ( A , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if all array elements are pairwise co | Function to calculate GCD ; Function to calculate LCM ; Function to check if aelements in the array are pairwise coprime ; Initialize variables ; Iterate over the array ; Calculate product of array elements ; Calculate LCM of array elements ; If the product of array elements is equal to LCM of the array ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "3533-3533",
        "Code": "def countRooks ( n , k , pos ) : NEW_LINE INDENT row = [ 0 for i in range ( n ) ] NEW_LINE col = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT row [ pos [ i ] [ 0 ] - 1 ] = 1 NEW_LINE col [ pos [ i ] [ 1 ] - 1 ] = 1 NEW_LINE DEDENT res = n - k NEW_LINE print ( res ) NEW_LINE ri = 0 NEW_LINE ci = 0 NEW_LINE while ( res > 0 ) : NEW_LINE INDENT while ( row [ ri ] == 1 ) : NEW_LINE INDENT ri += 1 NEW_LINE DEDENT while ( col [ ci ] == 1 ) : NEW_LINE INDENT ci += 1 NEW_LINE DEDENT print ( ( ri + 1 ) , ( ci + 1 ) ) NEW_LINE ri += 1 NEW_LINE ci += 1 NEW_LINE res -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE K = 2 NEW_LINE pos = [ [ 1 , 4 ] , [ 2 , 2 ] ] NEW_LINE countRooks ( N , K , pos ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum non | Function to prthe maximum rooks and their positions ; Marking the location of already placed rooks ; Print number of non - attacking rooks that can be placed ; To store the placed rook location ; Print lexographically smallest order ; Driver Code ; Size of board ; Number of rooks already placed ; Position of rooks ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3534-3534",
        "Code": "def min_flips ( strr , k ) : NEW_LINE INDENT if ( len ( strr ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE cnt_zeros = 0 NEW_LINE for ch in strr : NEW_LINE INDENT if ( ch == '0' ) : NEW_LINE INDENT cnt_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_zeros = 0 NEW_LINE DEDENT if ( cnt_zeros == k ) : NEW_LINE INDENT ans += 1 NEW_LINE cnt_zeros = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \"11100000011\" NEW_LINE k = 3 NEW_LINE print ( min_flips ( strr , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize count of flips required such that no substring of 0 s have length exceeding K | Function to return minimum number of flips required ; Base Case ; Stores the count of minimum number of flips ; Stores the count of zeros in current sub ; If current character is 0 ; Continue ongoing sub ; Start a new sub ; If k consecutive zeroes are obtained ; End segment ; Return the result ; Driver Code ; Function call",
        "Category": "Sliding Window"
    },
    {
        "ID": "3536-3536",
        "Code": "def dailyTemperatures ( T ) : NEW_LINE INDENT n = len ( T ) NEW_LINE daysOfWait = [ - 1 ] * n NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( s ) != 0 and T [ s [ - 1 ] ] < T [ i ] ) : NEW_LINE INDENT daysOfWait [ s [ - 1 ] ] = i - s [ - 1 ] NEW_LINE s . pop ( - 1 ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( daysOfWait [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 73 , 74 , 75 , 71 , 69 , 72 , 76 , 73 ] NEW_LINE dailyTemperatures ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Count of days remaining for the next day with higher temperature | Function to determine how many days required to wait for the next warmer temperature ; To store the answer ; Traverse all the temperatures ; Check if current index is the next warmer temperature of any previous indexes ; Pop the element ; Push the current index ; Print waiting days ; Given temperatures ; Function call",
        "Category": "Stack"
    },
    {
        "ID": "3538-3538",
        "Code": "def solve ( D , N , X , Y ) : NEW_LINE INDENT T = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = D [ i ] [ 0 ] NEW_LINE y = D [ i ] [ 1 ] NEW_LINE speed = D [ i ] [ 2 ] NEW_LINE time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) NEW_LINE T . append ( time ) NEW_LINE DEDENT T . sort ( ) NEW_LINE i = 0 NEW_LINE total = 0 NEW_LINE while i < len ( T ) - 1 : NEW_LINE INDENT count = 1 NEW_LINE while i < len ( T ) - 1 and T [ i ] == T [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT total += ( count * ( count - 1 ) ) / 2 NEW_LINE i += 1 NEW_LINE DEDENT return total NEW_LINE DEDENT N = 5 NEW_LINE D = [ [ 5 , 12 , 1 ] , [ 16 , 63 , 5 ] , [ - 10 , 24 , 2 ] , [ 7 , 24 , 2 ] , [ - 24 , 7 , 2 ] ] NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE print ( solve ( D , N , X , Y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of collisions at a point ( X , Y ) | Function to find the count of possible pairs of collisions ; Stores the time at which points reach the origin ; Calculate time for each point ; Sort the times ; Counting total collisions ; Count of elements arriving at a given point at the same time ; Driver Code ; Given set of points with speed ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "3543-3543",
        "Code": "def uniqueElement ( arr , n ) : NEW_LINE INDENT s = set ( arr ) NEW_LINE if ( len ( s ) == 1 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 9 , 9 , 9 , 9 , 9 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE uniqueElement ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if an array contains only one distinct element | Function to find if the array contains only one distinct element ; Create a set ; Compare and print the result ; Driver code ; Function call",
        "Category": "Hash Table"
    },
    {
        "ID": "3546-3546",
        "Code": "ans = 0 NEW_LINE allsum = 0 NEW_LINE edges = [ [ ] for i in range ( 100001 ) ] NEW_LINE def addedge ( a , b ) : NEW_LINE INDENT global edges NEW_LINE edges [ a ] . append ( b ) NEW_LINE edges [ b ] . append ( a ) NEW_LINE DEDENT def findCost ( r , p , arr ) : NEW_LINE INDENT global edges NEW_LINE global ans NEW_LINE global allsum NEW_LINE i = 0 NEW_LINE for i in range ( len ( edges [ r ] ) ) : NEW_LINE INDENT cur = edges [ r ] [ i ] NEW_LINE if ( cur == p ) : NEW_LINE INDENT continue NEW_LINE DEDENT findCost ( cur , r , arr ) NEW_LINE arr [ r ] += arr [ cur ] NEW_LINE DEDENT t1 = arr [ r ] NEW_LINE t2 = allsum - t1 NEW_LINE if ( t1 * t2 > ans ) : NEW_LINE INDENT ans = t1 * t2 NEW_LINE DEDENT DEDENT def maximumCost ( r , p , N , M , arr , Edges ) : NEW_LINE INDENT global allsum NEW_LINE for i in range ( N ) : NEW_LINE INDENT allsum += arr [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT addedge ( Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) NEW_LINE DEDENT findCost ( r , p , arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE arr = [ 13 , 8 , 7 , 4 , 5 , 9 ] NEW_LINE M = 5 NEW_LINE Edges = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 1 , 4 ] , [ 3 , 4 ] , [ 4 , 5 ] ] NEW_LINE maximumCost ( 1 , - 1 , N , M , arr , Edges ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum cost of splitting given Binary Tree into two halves | To store the results and sum of all nodes in the array ; To create adjacency list ; Function to add edges into the adjacency list ; Recursive function that calculate the value of the cost of splitting the tree recursively ; Fetch the child of node - r ; Neglect if cur node is parent ; Add all values of nodes which are decendents of r ; The two trees formed are rooted at ' r ' with its decendents ; Check and replace if current product t1 * t2 is large ; Function to find the maximum cost after splitting the tree in 2 halves ; Find sum of values in all nodes ; Traverse edges to create adjacency list ; Function Call ; Driver Code ; Values in each node ; Given Edges",
        "Category": "Binary Tree"
    },
    {
        "ID": "355-355",
        "Code": "def dfs ( u , parent , totalSum , edge , subtree , res ) : NEW_LINE INDENT Sum = subtree [ u ] NEW_LINE for i in range ( len ( edge [ u ] ) ) : NEW_LINE INDENT v = edge [ u ] [ i ] NEW_LINE if ( v != parent ) : NEW_LINE INDENT dfs ( v , u , totalSum , edge , subtree , res ) NEW_LINE Sum += subtree [ v ] NEW_LINE DEDENT DEDENT subtree [ u ] = Sum NEW_LINE if ( u != 0 and abs ( totalSum - 2 * Sum ) < res [ 0 ] ) : NEW_LINE INDENT res [ 0 ] = abs ( totalSum - 2 * Sum ) NEW_LINE DEDENT DEDENT def getMinSubtreeSumDifference ( vertex , edges , N ) : NEW_LINE INDENT totalSum = 0 NEW_LINE subtree = [ None ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT subtree [ i ] = vertex [ i ] NEW_LINE totalSum += vertex [ i ] NEW_LINE DEDENT edge = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT edge [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE edge [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT res = [ 999999999999 ] NEW_LINE dfs ( 0 , - 1 , totalSum , edge , subtree , res ) NEW_LINE return res [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT vertex = [ 4 , 2 , 1 , 6 , 3 , 5 , 2 ] NEW_LINE edges = [ [ 0 , 1 ] , [ 0 , 2 ] , [ 0 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 3 , 6 ] ] NEW_LINE N = len ( vertex ) NEW_LINE print ( getMinSubtreeSumDifference ( vertex , edges , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Delete Edge to minimize subtree sum difference | DFS method to traverse through edges , calculating subtree Sum at each node and updating the difference between subtrees ; loop for all neighbors except parent and aggregate Sum over all subtrees ; store Sum in current node 's  subtree index ; at one side subtree Sum is ' Sum ' and other side subtree Sum is ' totalSum ▁ - ▁ Sum ' so their difference will be totalSum - 2 * Sum , by which we 'll update res ; Method returns minimum subtree Sum difference ; Calculating total Sum of tree and initializing subtree Sum 's  by vertex values ; filling edge data structure ; calling DFS method at node 0 , with parent as - 1 ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "3553-3553",
        "Code": "def possible ( T , arr , n , d ) : NEW_LINE INDENT partition = 1 ; NEW_LINE total = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total + arr [ i ] ; NEW_LINE if ( total > T ) : NEW_LINE INDENT partition = partition + 1 ; NEW_LINE total = arr [ i ] ; NEW_LINE if ( partition > d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT def calcT ( n , d , arr ) : NEW_LINE INDENT mx = - 1 ; sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , arr [ i ] ) ; NEW_LINE sum = sum + arr [ i ] ; NEW_LINE DEDENT lb = mx ; NEW_LINE ub = sum ; NEW_LINE while ( lb < ub ) : NEW_LINE INDENT T_mid = lb + ( ub - lb ) // 2 ; NEW_LINE if ( possible ( T_mid , arr , n , d ) == True ) : NEW_LINE INDENT ub = T_mid ; NEW_LINE DEDENT else : NEW_LINE INDENT lb = T_mid + 1 ; NEW_LINE DEDENT DEDENT print ( lb ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = 2 ; NEW_LINE arr = [ 1 , 1 , 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE calcT ( n , d , arr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum possible value T such that at most D Partitions of the Array having at most sum T is possible | Function to check if the array can be partitioned into atmost d subarray with sum atmost T ; Initial partition ; Current sum ; If current sum exceeds T ; Create a new partition ; If count of partitions exceed d ; Function to find the minimum possible value of T ; Stores the maximum and total sum of elements ; Maximum element ; Sum of all elements ; Calculate median T ; If atmost D partitions possible ; Check for smaller T ; Otherwise ; Check for larger T ; Print the minimum T required ; Driver code ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "3556-3556",
        "Code": "def minimum_required_operations ( arr , n , k ) : NEW_LINE INDENT answer = 0 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > k : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT answer += ( arr [ i ] - k ) NEW_LINE arr [ i ] = k NEW_LINE DEDENT answer += ( arr [ i ] + arr [ i + 1 ] ) - k NEW_LINE arr [ i + 1 ] = ( k - arr [ i ] ) NEW_LINE answer %= mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT a = [ 9 , 50 , 4 , 14 , 42 , 89 ] NEW_LINE k = 10 NEW_LINE print ( minimum_required_operations ( a , len ( a ) , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum decrements required such that sum of all adjacent pairs in an Array does not exceed K | Function to calculate the minimum number of operations required ; Stores the total number of operations ; Iterate over the array ; If the sum of pair of adjacent elements exceed k . ; If current element exceeds k ; Reduce arr [ i ] to k ; Update arr [ i + 1 ] accordingly ; Update answer ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3568-3568",
        "Code": "def determineWinner ( str ) : NEW_LINE INDENT A = [ 0 for i in range ( 9 ) ] ; NEW_LINE sum1 = 0 ; sum2 = 0 ; NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT A [ int ( str [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT sum1 = sum1 + A [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sum2 = sum2 + A [ i ] ; NEW_LINE DEDENT DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT elif ( sum1 > sum2 ) : NEW_LINE INDENT print ( \" Player ▁ 1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Player ▁ 2\" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"78787\" ; NEW_LINE determineWinner ( str ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Determine the winner of a game of deleting Characters from a String | Function to find the winner of the game when both players play optimally ; Stores the frequency of all digit ; Stores the scores of player1 and player2 respectively ; Iterate to store frequencies ; Turn for the player1 ; Add score of player1 ; Add score of player2 ; Check if its a draw ; If score of player 1 is greater ; Otherwise ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "3604-3604",
        "Code": "ctr = 0 NEW_LINE def find ( parent , x ) : NEW_LINE INDENT if ( parent [ x ] == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT parent [ x ] = find ( parent , parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT def setUnion ( parent , rank , x , y ) : NEW_LINE INDENT global ctr NEW_LINE parentx = find ( parent , x ) NEW_LINE parenty = find ( parent , y ) NEW_LINE if ( parenty == parentx ) : NEW_LINE INDENT return NEW_LINE DEDENT ctr -= 1 NEW_LINE if ( rank [ parentx ] < rank [ parenty ] ) : NEW_LINE INDENT parent [ parentx ] = parenty NEW_LINE DEDENT elif ( rank [ parentx ] > rank [ parenty ] ) : NEW_LINE INDENT parent [ parenty ] = parentx NEW_LINE DEDENT else : NEW_LINE INDENT parent [ parentx ] = parenty NEW_LINE rank [ parenty ] += 1 NEW_LINE DEDENT DEDENT def solve ( n , m , query ) : NEW_LINE INDENT global ctr NEW_LINE result = [ 0 ] * len ( query ) NEW_LINE parent = [ 0 ] * ( n * m ) NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE DEDENT rank = [ 1 ] * ( n * m ) NEW_LINE grid = [ 0 ] * ( n * m ) NEW_LINE for i in range ( len ( query ) ) : NEW_LINE INDENT x = query [ i ] [ 0 ] NEW_LINE y = query [ i ] [ 1 ] NEW_LINE if ( grid [ m * x + y ] == 1 ) : NEW_LINE INDENT result [ i ] = ctr NEW_LINE continue NEW_LINE DEDENT grid [ m * x + y ] = 1 NEW_LINE ctr += 1 NEW_LINE if ( x > 0 and grid [ m * ( x - 1 ) + y ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) NEW_LINE DEDENT if ( y > 0 and grid [ m * ( x ) + y - 1 ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) NEW_LINE DEDENT if ( x < n - 1 and grid [ m * ( x + 1 ) + y ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) NEW_LINE DEDENT if ( y < m - 1 and grid [ m * ( x ) + y + 1 ] == 1 ) : NEW_LINE INDENT setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) NEW_LINE DEDENT result [ i ] = ctr NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 4 NEW_LINE query = [ [ 0 , 0 ] , [ 1 , 1 ] , [ 1 , 0 ] , [ 1 , 2 ] ] NEW_LINE result = solve ( N , M , query ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT print ( result [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Queries to find the count of connected Non | Count of connected cells ; Function to return the representative of the Set to which x belongs ; If x is parent of itself ; x is representative of the Set ; Otherwise ; Path Compression ; Unites the set that includes x and the set that includes y ; Find the representatives ( or the root nodes ) for x an y ; If both are in the same set ; Decrement count ; If x ' s ▁ rank ▁ is ▁ less ▁ than ▁ y ' s rank ; Otherwise ; Then move x under y ( doesn 't matter which one goes where) ; And increment the result tree 's rank by 1 ; Function to count the number of connected cells in the matrix ; Store result for queries ; Store representative of each element ; Initially , all elements are in their own set ; Stores the rank ( depth ) of each node ; If the grid [ x * m + y ] is already set , store the result ; Set grid [ x * m + y ] to 1 ; Increment count . ; Check for all adjacent cells to do a Union with neighbour 's  set if neighbour is also 1 ; Store result . ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "3616-3616",
        "Code": "def reverse ( num ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT r = int ( num % 10 ) ; NEW_LINE rev = rev * 10 + r ; NEW_LINE num = num // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def count ( N , A , B ) : NEW_LINE INDENT l = int ( pow ( 10 , N - 1 ) ) ; NEW_LINE r = int ( pow ( 10 , N ) - 1 ) ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT l = 0 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT even_sum = 0 ; NEW_LINE odd_sum = 0 ; NEW_LINE itr = 0 ; NEW_LINE num = reverse ( i ) ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( itr % 2 == 0 ) : NEW_LINE INDENT odd_sum += num % 10 ; NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += num % 10 ; NEW_LINE DEDENT num = num // 10 ; NEW_LINE itr += 1 ; NEW_LINE DEDENT if ( even_sum % A == 0 and odd_sum % B == 0 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 ; NEW_LINE A = 5 ; NEW_LINE B = 3 ; NEW_LINE print ( count ( N , A , B ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of N | Function to calculate and return the reverse of the number ; Function to calculate the total count of N - digit numbers satisfying the necessary conditions ; Initialize two variables ; Calculate the sum of odd and even positions ; Check for divisibility ; Return the answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "3620-3620",
        "Code": "def checkPossible ( A , B , n ) : NEW_LINE INDENT values = set ( [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT values . add ( B [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( A [ i ] + A [ j ] ) in values ) : NEW_LINE INDENT values . remove ( A [ i ] + A [ j ] ) NEW_LINE if ( len ( values ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( len ( values ) == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE A = [ 3 , 5 , 1 , 4 , 2 ] NEW_LINE B = [ 3 , 4 , 5 , 6 , 7 ] NEW_LINE print ( checkPossible ( A , B , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if each element of an Array is the Sum of any two elements of another Array | Function to check if each element of B [ ] can be formed by adding two elements of array A [ ] ; Store each element of B [ ] ; Traverse all possible pairs of array ; If A [ i ] + A [ j ] is present in the set ; Remove A [ i ] + A [ j ] from the set ; If set is empty ; Otherwise ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3623-3623",
        "Code": "import sys NEW_LINE def countElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE next_greater = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( i ) NEW_LINE continue NEW_LINE DEDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] < arr [ i ] ) : NEW_LINE INDENT next_greater [ s [ - 1 ] ] = i NEW_LINE s . pop ( - 1 ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT count = 0 NEW_LINE maxi = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( next_greater [ i ] - i > k and maxi < arr [ i ] ) : NEW_LINE INDENT maxi = max ( maxi , arr [ i ] ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 3 , 6 , 4 , 3 , 2 ] NEW_LINE K = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countElements ( arr , n , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Array elements greater than all elements on its left and next K elements on its right | Python3 program to implement the above approach ; Function to print the count of Array elements greater than all elements on its left and next K elements on its right ; Iterate over the array ; If the stack is not empty and the element at the top of the stack is smaller than arr [ i ] ; Store the index of next greater element ; Pop the top element ; Insert the current index ; Stores the count ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "3624-3624",
        "Code": "import math NEW_LINE N = 200000 NEW_LINE V = 500 NEW_LINE def solve ( n , d , input1 ) : NEW_LINE INDENT a = [ 0 ] * N NEW_LINE cnt = [ 0 ] * ( V + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = input1 [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT cnt [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( d , n ) : NEW_LINE INDENT acc = 0 NEW_LINE low_median = - 1 NEW_LINE high_median = - 1 NEW_LINE for v in range ( V + 1 ) : NEW_LINE INDENT acc += cnt [ v ] NEW_LINE if ( low_median == - 1 and acc >= int ( math . floor ( ( d + 1 ) / 2.0 ) ) ) : NEW_LINE INDENT low_median = v NEW_LINE DEDENT if ( high_median == - 1 and acc >= int ( math . ceil ( ( d + 1 ) / 2.0 ) ) ) : NEW_LINE INDENT high_median = v NEW_LINE DEDENT DEDENT double_median = low_median + high_median NEW_LINE if ( a [ i ] >= double_median ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT cnt [ a [ i - d ] ] -= 1 NEW_LINE cnt [ a [ i ] ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input1 = [ 1 , 2 , 2 , 4 , 5 ] NEW_LINE n = len ( input1 ) NEW_LINE k = 3 NEW_LINE solve ( n , k , input1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Array elements greater than or equal to twice the Median of K trailing Array elements | Python3 program to implement the above approach ; Function to find the count of array elements >= twice the median of K trailing array elements ; Stores frequencies ; Stores the array elements ; Count the frequencies of the array elements ; Iterating from d to n - 1 index means ( d + 1 ) th element to nth element ; To check the median ; Iterate over the frequencies of the elements ; Add the frequencies ; Check if the low_median value is obtained or not , if yes then do not change as it will be minimum ; Check if the high_median value is obtained or not , if yes then do not change it as it will be maximum ; Store 2 * median of K trailing elements ; If the current >= 2 * median ; Decrease the frequency for ( k - 1 ) - th element ; Increase the frequency of the current element ; Print the count ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3625-3625",
        "Code": "from math import log2 NEW_LINE def equalXORandOR ( n ) : NEW_LINE INDENT m = 0 NEW_LINE MSB = int ( log2 ( n ) ) NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT if ( not ( n & ( 1 << i ) ) ) : NEW_LINE INDENT m += ( 1 << i ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT n = 14 NEW_LINE print ( equalXORandOR ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest possible value of M not exceeding N having equal Bitwise OR and XOR between them | Python3 program to implement the above approach ; Function to find required number M ; Initialising m ; Finding the index of the most significant bit of N ; Calculating required number ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "363-363",
        "Code": "def isStepNum ( n ) : NEW_LINE INDENT prevDigit = - 1 NEW_LINE while ( n ) : NEW_LINE INDENT curDigit = n % 10 NEW_LINE if ( prevDigit == - 1 ) : NEW_LINE INDENT prevDigit = curDigit NEW_LINE DEDENT else : NEW_LINE INDENT if ( abs ( prevDigit - curDigit ) != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT prevDigit = curDigit NEW_LINE n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def displaySteppingNumbers ( n , m ) : NEW_LINE INDENT for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( isStepNum ( i ) ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , m = 0 , 21 NEW_LINE displaySteppingNumbers ( n , m ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Stepping Numbers | This function checks if an integer n is a Stepping Number ; Initalize prevDigit with - 1 ; Iterate through all digits of n and compare difference between value of previous and current digits ; Get Current digit ; Single digit is consider as a Stepping Number ; Check if absolute difference between prev digit and current digit is 1 ; A brute force approach based function to find all stepping numbers . ; Iterate through all the numbers from [ N , M ] and check if its a stepping number . ; Driver code ; Display Stepping Numbers in the range [ n , m ]",
        "Category": "Math"
    },
    {
        "ID": "3636-3636",
        "Code": "def maxLengthOf1s ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i - 2 ] == 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = 0 NEW_LINE DEDENT DEDENT suffix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i + 2 ] == 1 ) : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = max ( ans , prefix [ i + 1 ] + suffix [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT n = 6 NEW_LINE arr = [ 1 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE maxLengthOf1s ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize length of Subarray of 1 's after removal of a pair of consecutive Array elements | Python program to find the maximum count of 1 s ; If arr [ i - 2 ] = = 1 then we increment the count of occurences of 1 's ; Else we initialise the count with 0 ; If arr [ i + 2 ] = = 1 then we increment the count of occurences of 1 's ; Else we initialise the count with 0 ; We get the maximum count by skipping the current and the next element . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "3637-3637",
        "Code": "t = 0 NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE a = 0 NEW_LINE s = [ ] NEW_LINE tsort = [ ] NEW_LINE adj = [ [ ] for i in range ( 100001 ) ] NEW_LINE visited = [ False for i in range ( 100001 ) ] NEW_LINE def dfs ( u ) : NEW_LINE INDENT visited [ u ] = 1 NEW_LINE for it in adj [ u ] : NEW_LINE INDENT if ( visited [ it ] == 0 ) : NEW_LINE INDENT dfs ( it ) NEW_LINE DEDENT DEDENT s . append ( u ) NEW_LINE DEDENT def check_cycle ( ) : NEW_LINE INDENT pos = dict ( ) NEW_LINE ind = 0 NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT pos [ s [ - 1 ] ] = ind NEW_LINE tsort . append ( s [ - 1 ] ) NEW_LINE ind += 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for it in adj [ i ] : NEW_LINE INDENT first = 0 if i not in pos else pos [ i ] NEW_LINE second = 0 if it not in pos else pos [ it ] NEW_LINE if ( first > second ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE addEdge ( 0 , 1 ) NEW_LINE addEdge ( 0 , 2 ) NEW_LINE addEdge ( 1 , 2 ) NEW_LINE addEdge ( 2 , 0 ) NEW_LINE addEdge ( 2 , 3 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT if ( check_cycle ( ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Detect cycle in Directed Graph using Topological Sort | Python3 program to implement the above approach ; Stack to store the visited vertices in the Topological Sort ; Store Topological Order ; Adjacency list to store edges ; To ensure visited vertex ; Function to perform DFS ; Set the vertex as visited ; Visit connected vertices ; Push into the stack on complete visit of vertex ; Function to check and return if a cycle exists or not ; Stores the position of vertex in topological order ; Pop all elements from stack ; Push element to get Topological Order ; Pop from the stack ; If parent vertex does not appear first ; Cycle exists ; Return false if cycle does not exist ; Function to add edges from u to v ; Driver Code ; Insert edges ; If cycle exist",
        "Category": "Graph Theory"
    },
    {
        "ID": "3643-3643",
        "Code": "def bs ( a , n , ele ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ch = ' @ ' NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 ; NEW_LINE if ( ar [ mid ] == ele ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ( ar [ mid ] < ele ) : NEW_LINE INDENT ch = ar [ mid ] NEW_LINE start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ ' e ' , ' g ' , ' t ' , ' y ' ] NEW_LINE n = len ( ar ) NEW_LINE K = ' u ' ; NEW_LINE ch = bs ( ar , n , K ) ; NEW_LINE if ( ch == ' @ ' ) : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ch ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Nearest smaller character to a character K from a Sorted Array | Function to return the nearest smaller character ; Stores the nearest smaller character ; Iterate till starts cross end ; Find the mid element ; Check if K is found ; Check if current character is less than K ; Increment the start ; Otherwise ; Increment end ; Return the character ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3649-3649",
        "Code": "def proofreadSpell ( str ) : NEW_LINE INDENT result = [ ] NEW_LINE for c in str : NEW_LINE INDENT result . append ( c ) NEW_LINE n = len ( result ) NEW_LINE if ( n >= 3 ) : NEW_LINE INDENT if ( result [ n - 1 ] == result [ n - 2 ] and result [ n - 1 ] == result [ n - 3 ] ) : NEW_LINE INDENT result . pop ( ) NEW_LINE DEDENT DEDENT n = len ( result ) NEW_LINE if ( n >= 4 ) : NEW_LINE INDENT if ( result [ n - 1 ] == result [ n - 2 ] and result [ n - 3 ] == result [ n - 4 ] ) : NEW_LINE INDENT result . pop ( ) NEW_LINE DEDENT DEDENT DEDENT resultStr = \" \" NEW_LINE for c in result : NEW_LINE INDENT resultStr += c NEW_LINE DEDENT return resultStr NEW_LINE DEDENT str = \" hello \" NEW_LINE print ( proofreadSpell ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Change the given string according to the given conditions | Function to proofread the spells ; Loop to iterate over the characters of the string ; Push the current character c in the stack ; Check for Rule 1 ; Check for Rule 2 ; To store the resultant string ; Loop to iterate over the characters of stack ; Return the resultant string ; Given string str ; Function Call",
        "Category": "Stack"
    },
    {
        "ID": "3650-3650",
        "Code": "def getPrefixLength ( srcStr , targetStr ) : NEW_LINE INDENT if ( len ( targetStr ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT srcStr = srcStr . lower ( ) NEW_LINE targetStr = targetStr . lower ( ) NEW_LINE dictCount = dict ( [ ] ) NEW_LINE nUnique = 0 NEW_LINE for ch in targetStr : NEW_LINE INDENT if ( ch not in dictCount ) : NEW_LINE INDENT nUnique += 1 NEW_LINE dictCount [ ch ] = 0 NEW_LINE DEDENT dictCount [ ch ] += 1 NEW_LINE DEDENT for i in range ( len ( srcStr ) ) : NEW_LINE INDENT ch = srcStr [ i ] NEW_LINE if ( ch not in dictCount ) : NEW_LINE INDENT continue NEW_LINE DEDENT dictCount [ ch ] -= 1 NEW_LINE if ( dictCount [ ch ] == 0 ) : NEW_LINE INDENT nUnique -= 1 NEW_LINE DEDENT if ( nUnique == 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" MarvoloGaunt \" NEW_LINE T = \" Tom \" NEW_LINE print ( getPrefixLength ( S , T ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize length of prefix of string S containing all characters of another string T | Python3 program for the above approach ; Base Case - if T is empty , it matches 0 length prefix ; Convert strings to lower case for uniformity ; Update dictCount to the letter count of T ; If new character is found , initialize its entry , and increase nUnique ; Increase count of ch ; Iterate from 0 to N ; i - th character ; Skip if ch not in targetStr ; Decrease Count ; If the count of ch reaches 0 , we do not need more ch , and can decrease nUnique ; If nUnique reaches 0 , we have found required prefix ; Otherwise ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3653-3653",
        "Code": "import sys NEW_LINE MAX = 10 NEW_LINE adj = [ [ ] for i in range ( MAX ) ] NEW_LINE def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( v , cost , vis , min_cost_node ) : NEW_LINE INDENT vis [ v ] = True NEW_LINE min_cost_node = min ( min_cost_node , cost [ v - 1 ] ) NEW_LINE for i in range ( len ( adj [ v ] ) ) : NEW_LINE INDENT if ( vis [ adj [ v ] [ i ] ] == False ) : NEW_LINE INDENT min_cost_node = dfs ( adj [ v ] [ i ] , cost , vis , min_cost_node ) NEW_LINE DEDENT DEDENT return min_cost_node NEW_LINE DEDENT def minimumCost ( V , cost ) : NEW_LINE INDENT vis = [ False for i in range ( V + 1 ) ] NEW_LINE min_cost = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT min_cost_node = sys . maxsize NEW_LINE min_cost_node = dfs ( i , cost , vis , min_cost_node ) NEW_LINE min_cost += min_cost_node NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT V = 6 NEW_LINE E = 5 NEW_LINE cost = [ 12 , 25 , 8 , 11 , 10 , 7 ] NEW_LINE addEdge ( 1 , 2 ) NEW_LINE addEdge ( 1 , 3 ) NEW_LINE addEdge ( 3 , 2 ) NEW_LINE addEdge ( 2 , 5 ) NEW_LINE addEdge ( 4 , 6 ) NEW_LINE min_cost = minimumCost ( V , cost ) NEW_LINE print ( min_cost ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize cost to color all the vertices of an Undirected Graph using given operation | Python3 program to find the minimum cost to color all vertices of an Undirected Graph ; Function to add edge in the given graph ; Function to perform DFS traversal and find the node with minimum cost ; Update the minimum cost ; Recur for all connected nodes ; Function to calculate and return the minimum cost of coloring all vertices of the Undirected Graph ; Marks if a vertex is visited or not ; Perform DFS traversal ; If vertex is not visited ; Update minimum cost ; Return the final cost ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "3654-3654",
        "Code": "def check ( st , mid , a ) : NEW_LINE INDENT n = len ( st ) NEW_LINE previous = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == chr ( a ) ) : NEW_LINE INDENT if ( i - previous > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT previous = i NEW_LINE DEDENT DEDENT if ( i - previous > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def possible ( st , mid ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( check ( st , mid , i + ord ( ' a ' ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findMinLength ( st ) : NEW_LINE INDENT low = 1 NEW_LINE high = len ( st ) NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( possible ( st , mid ) ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return high + 1 NEW_LINE DEDENT def ifAllDistinct ( st ) : NEW_LINE INDENT s = [ ] NEW_LINE for c in st : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT return len ( set ( s ) ) == len ( st ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" geeksforgeeks \" NEW_LINE if ( ifAllDistinct ( st ) ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( findMinLength ( st ) ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Minimize length of Substrings containing at least one common Character | Function to check and return if substrings of length mid has a common character a ; Length of the string ; Initialise the first occurrence of character a ; Check that distance b / w the current and previous occurrence of character a is less than or equal to mid ; If distance exceeds mid ; Function to check for all the alphabets , if substrings of length mid have a character common ; Check for all 26 alphabets ; Check that char i + a is common in all the substrings of length mid ; If no characters is common ; Function to calculate and return the minm length of substrings ; Initialise low and high ; Perform binary search ; Update mid ; Check if one common character is present in the length of the mid ; Returns the minimum length that contain one common character ; Function to check if all characters are distinct ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "3656-3656",
        "Code": "from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def findLevel ( root : Node , k : int , level : int ) -> int : NEW_LINE INDENT qt = deque ( ) NEW_LINE qt . append ( [ root , 0 ] ) NEW_LINE count = 1 NEW_LINE b = 0 NEW_LINE a = 0 NEW_LINE while qt : NEW_LINE INDENT temp = qt . popleft ( ) NEW_LINE if ( count == 1 ) : NEW_LINE INDENT b = temp [ 1 ] NEW_LINE DEDENT if ( temp [ 0 ] . left ) : NEW_LINE INDENT qt . append ( [ temp [ 0 ] . left , 2 * temp [ 1 ] ] ) NEW_LINE DEDENT if ( temp [ 0 ] . right ) : NEW_LINE INDENT qt . append ( [ temp [ 0 ] . right , 2 * temp [ 1 ] + 1 ] ) NEW_LINE DEDENT count -= 1 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT if ( b - a + 1 == k ) : NEW_LINE INDENT return level NEW_LINE DEDENT secondLabel = qt [ 0 ] NEW_LINE a = secondLabel [ 1 ] NEW_LINE level += 1 NEW_LINE count = len ( qt ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 5 ) NEW_LINE root . left = Node ( 6 ) NEW_LINE root . right = Node ( 2 ) NEW_LINE root . right . right = Node ( 8 ) NEW_LINE root . left . left = Node ( 7 ) NEW_LINE root . left . left . left = Node ( 5 ) NEW_LINE root . left . right = Node ( 3 ) NEW_LINE root . left . right . right = Node ( 4 ) NEW_LINE k = 4 NEW_LINE print ( findLevel ( root , k , 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Level of a Binary Tree with Width K | Python3 program to implement the above approach ; Structure of a Tree node ; Function to create new node ; Function returns required level of width k , if found else - 1 ; To store the node and the label and perform traversal ; Taking the last label of each level of the tree ; Check width of current level ; If the width is equal to k then return that level ; Taking the first label of each level of the tree ; If any level does not has width equal to k , return - 1 ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "3660-3660",
        "Code": "def countLessThanMid ( mid , N , M , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , min ( N , mid ) + 1 ) : NEW_LINE INDENT count = count + min ( mid // i , M ) NEW_LINE DEDENT if ( count >= K ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def findKthElement ( N , M , K ) : NEW_LINE INDENT low = 1 NEW_LINE high = N * M NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( countLessThanMid ( mid , N , M , K ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return high + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 2 NEW_LINE M = 3 NEW_LINE K = 5 NEW_LINE print ( findKthElement ( N , M , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Kth Smallest Element of a Matrix of given dimensions filled with product of indices | Function that returns true if the count of elements is less than mid ; To store count of elements less than mid ; Loop through each row ; Count elements less than mid in the ith row ; Function that returns the Kth smallest element in the NxM Matrix after sorting in an array ; Initialize low and high ; Perform binary search ; Find the mid ; Check if the count of elements is less than mid ; Return Kth smallest element of the matrix ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "3665-3665",
        "Code": "def findLargest ( beg , end , arr , n ) : NEW_LINE INDENT if ( beg == end ) : NEW_LINE INDENT compared = [ 0 ] * n NEW_LINE compared [ 0 ] = 1 NEW_LINE compared [ 1 ] = arr [ beg ] NEW_LINE return compared NEW_LINE DEDENT compared1 = findLargest ( beg , ( beg + end ) // 2 , arr , n ) NEW_LINE compared2 = findLargest ( ( beg + end ) // 2 + 1 , end , arr , n ) NEW_LINE if ( compared1 [ 1 ] > compared2 [ 1 ] ) : NEW_LINE INDENT k = compared1 [ 0 ] + 1 NEW_LINE compared1 [ 0 ] = k NEW_LINE compared1 [ k ] = compared2 [ 1 ] NEW_LINE return compared1 NEW_LINE DEDENT else : NEW_LINE INDENT k = compared2 [ 0 ] + 1 NEW_LINE compared2 [ 0 ] = k NEW_LINE compared2 [ k ] = compared1 [ 1 ] NEW_LINE return compared2 NEW_LINE DEDENT DEDENT def findSecondLargest ( end , arr ) : NEW_LINE INDENT compared1 = findLargest ( 0 , end - 1 , arr , end ) NEW_LINE compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) NEW_LINE print ( compared2 [ 1 ] ) NEW_LINE DEDENT N = 10 NEW_LINE arr = [ 20 , 1990 , 12 , 1110 , 1 , 59 , 12 , 15 , 120 , 1110 ] NEW_LINE findSecondLargest ( N , arr ) NEW_LINE",
        "Type": "py",
        "NL": "Find Second largest element in an array | Set 2 | Function to find the largest element in the array arr [ ] ; Base Condition ; Initialize an empty list ; Divide the array into two equal length subarrays and recursively find the largest among the two ; Store length of compared1 [ ] in the first index ; Store the maximum element ; Return compared1 which contains the maximum element ; Store length of compared2 [ ] in the first index ; Store the maximum element ; Return compared2 [ ] which contains the maximum element ; Function to print the second largest element in the array arr [ ] ; Find the largest element in arr [ ] ; Find the second largest element in arr [ ] ; Print the second largest element ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "3668-3668",
        "Code": "def checkPalindrome ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE first_half = True NEW_LINE second_half = True NEW_LINE cnt = ( n // 2 ) - 1 NEW_LINE for i in range ( 0 , int ( ( n / 2 ) / 2 ) ) : NEW_LINE INDENT if ( S [ i ] != S [ cnt ] ) : NEW_LINE INDENT first_half = False NEW_LINE break NEW_LINE DEDENT if ( S [ n // 2 + i ] != S [ n // 2 + cnt ] ) : NEW_LINE INDENT second_half = False NEW_LINE break NEW_LINE DEDENT cnt -= 1 NEW_LINE DEDENT if ( first_half and second_half ) : NEW_LINE INDENT print ( ' Yes ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' , end = ' ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = ' momdad ' NEW_LINE checkPalindrome ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if both halves of a string are Palindrome or not | Function to check if both halves of a string are palindrome or not ; Length of string ; Initialize both part as true ; If first half is not palindrome ; If second half is not palindrome ; If both halves are palindrome ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "368-368",
        "Code": "def isSafe ( M , row , col , visited ) : NEW_LINE INDENT global ROW , COL NEW_LINE return ( ( row >= 0 ) and ( row < ROW ) and ( col >= 0 ) and ( col < COL ) and ( M [ row ] [ col ] and not visited [ row ] [ col ] ) ) NEW_LINE DEDENT def DFS ( M , row , col , visited , count ) : NEW_LINE INDENT rowNbr = [ - 1 , - 1 , - 1 , 0 , 0 , 1 , 1 , 1 ] NEW_LINE colNbr = [ - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 ] NEW_LINE visited [ row ] [ col ] = True NEW_LINE for k in range ( 8 ) : NEW_LINE INDENT if ( isSafe ( M , row + rowNbr [ k ] , col + colNbr [ k ] , visited ) ) : NEW_LINE INDENT count [ 0 ] += 1 NEW_LINE DFS ( M , row + rowNbr [ k ] , col + colNbr [ k ] , visited , count ) NEW_LINE DEDENT DEDENT DEDENT def largestRegion ( M ) : NEW_LINE INDENT global ROW , COL NEW_LINE visited = [ [ 0 ] * COL for i in range ( ROW ) ] NEW_LINE result = - 999999999999 NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if ( M [ i ] [ j ] and not visited [ i ] [ j ] ) : NEW_LINE INDENT count = [ 1 ] NEW_LINE DFS ( M , i , j , visited , count ) NEW_LINE result = max ( result , count [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT ROW = 4 NEW_LINE COL = 5 NEW_LINE M = [ [ 0 , 0 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 , 0 ] , [ 0 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 ] ] NEW_LINE print ( largestRegion ( M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find length of the largest region in Boolean Matrix | A function to check if a given cell ( row , col ) can be included in DFS ; row number is in range , column number is in range and value is 1 and not yet visited ; A utility function to do DFS for a 2D boolean matrix . It only considers the 8 neighbours as adjacent vertices ; These arrays are used to get row and column numbers of 8 neighbours of a given cell ; Mark this cell as visited ; Recur for all connected neighbours ; increment region length by one ; The main function that returns largest length region of a given boolean 2D matrix ; Make a bool array to mark visited cells . Initially all cells are unvisited ; Initialize result as 0 and travesle through the all cells of given matrix ; If a cell with value 1 is not ; visited yet , then new region found ; maximum region ; Driver Code ; Function call",
        "Category": "Graph Theory"
    },
    {
        "ID": "3680-3680",
        "Code": "from collections import defaultdict NEW_LINE def getCount ( N , s ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = [ 0 ] * 26 NEW_LINE for j in range ( len ( s [ i ] ) ) : NEW_LINE INDENT a [ ord ( s [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for j in range ( 26 ) : NEW_LINE INDENT a [ j ] = a [ j ] % 2 NEW_LINE DEDENT ans += mp [ tuple ( a ) ] NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT changedCount = a [ : ] NEW_LINE if ( a [ j ] == 0 ) : NEW_LINE INDENT changedCount [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT changedCount [ j ] = 0 NEW_LINE DEDENT ans += mp [ tuple ( changedCount ) ] NEW_LINE DEDENT mp [ tuple ( a ) ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE A = [ \" aab \" , \" abcac \" , \" dffe \" , \" ed \" , \" aa \" , \" aade \" ] NEW_LINE print ( getCount ( N , A ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of pairs of strings whose concatenation forms a palindromic string | Python3 program to find palindromic string ; Stores frequency array and its count ; Total number of pairs ; Initializing array of size 26 to store count of character ; Counting occurrence of each character of current string ; Convert each count to parity ( 0 or 1 ) on the basis of its frequency ; Adding to answer ; Frequency of single character can be possibly changed , so change its parity ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "3684-3684",
        "Code": "kth_smallest = 0 NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . key = item NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if ( key < node . key ) : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif ( key > node . key ) : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def KSmallestPerfectBST ( root , k , treeSize ) : NEW_LINE INDENT global kth_smallest NEW_LINE if ( root == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT median_loc = ( treeSize // 2 ) + 1 NEW_LINE if ( k == median_loc ) : NEW_LINE INDENT kth_smallest = root . key NEW_LINE return True NEW_LINE DEDENT newTreeSize = treeSize // 2 NEW_LINE if ( k < median_loc ) : NEW_LINE INDENT return KSmallestPerfectBST ( root . left , k , newTreeSize ) NEW_LINE DEDENT newK = k - median_loc NEW_LINE return KSmallestPerfectBST ( root . right , newK , newTreeSize ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 50 ) NEW_LINE insert ( root , 30 ) NEW_LINE insert ( root , 20 ) NEW_LINE insert ( root , 40 ) NEW_LINE insert ( root , 70 ) NEW_LINE insert ( root , 60 ) NEW_LINE insert ( root , 80 ) NEW_LINE insert ( root , 14 ) NEW_LINE insert ( root , 25 ) NEW_LINE insert ( root , 35 ) NEW_LINE insert ( root , 45 ) NEW_LINE insert ( root , 55 ) NEW_LINE insert ( root , 65 ) NEW_LINE insert ( root , 75 ) NEW_LINE insert ( root , 85 ) NEW_LINE n = 15 NEW_LINE k = 5 NEW_LINE if ( KSmallestPerfectBST ( root , k , n ) ) : NEW_LINE INDENT print ( kth_smallest , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Kth Smallest element in a Perfect Binary Search Tree | Python3 program to find K - th smallest element in a perfect BST ; A BST node ; A utility function to create a new BST node ; A utility function to insert a new node with given key in BST ; If the tree is empty ; Recur down the left subtree for smaller values ; Recur down the right subtree for smaller values ; Return the ( unchanged ) node pointer ; FUnction to find Kth Smallest element in a perfect BST ; Find the median ( division operation is floored ) ; If the element is at the median ; Calculate the number of nodes in the right and left sub - trees ( division operation is floored ) ; If median is located higher ; If median is located lower ; Driver Code ; Let us create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 / \\ / \\ / \\ / \\ 14 25 35 45 55 65 75 85 ; Function call",
        "Category": "Binary Tree"
    },
    {
        "ID": "3687-3687",
        "Code": "def checkrules ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ 0 ] != '1' : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( s ) > 2 : NEW_LINE INDENT if s [ 1 ] == '0' and s [ 2 ] == '0' : NEW_LINE INDENT return checkrules ( s [ 3 : ] ) NEW_LINE DEDENT DEDENT return checkrules ( s [ 1 : ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = '1111' NEW_LINE if checkrules ( s ) : NEW_LINE INDENT print ( ' valid ▁ string ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' invalid ▁ string ' ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given Binary string follows then given condition or not | Function to check if the string follows rules or not ; Check for the first condition ; Check for the third condition ; Check for the second condition ; Driver code ; Given string ; Function call",
        "Category": "Backtracking"
    },
    {
        "ID": "3697-3697",
        "Code": "def get_submaxarr ( arr , n , y ) : NEW_LINE INDENT j = 0 NEW_LINE stk = [ ] NEW_LINE maxarr = [ 0 ] * n NEW_LINE stk . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( stk ) > 0 and arr [ i ] > arr [ stk [ - 1 ] ] ) : NEW_LINE INDENT maxarr [ stk [ - 1 ] ] = i - 1 NEW_LINE stk . pop ( ) NEW_LINE DEDENT stk . append ( i ) NEW_LINE DEDENT while ( stk ) : NEW_LINE INDENT maxarr [ stk [ - 1 ] ] = n - 1 NEW_LINE stk . pop ( ) NEW_LINE DEDENT submax = [ ] NEW_LINE for i in range ( n - y + 1 ) : NEW_LINE INDENT while ( maxarr [ j ] < i + y - 1 or j < i ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT submax . append ( arr [ j ] ) NEW_LINE DEDENT return submax NEW_LINE DEDENT def get_subminarr ( arr , n , y ) : NEW_LINE INDENT j = 0 NEW_LINE stk = [ ] NEW_LINE minarr = [ 0 ] * n NEW_LINE stk . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( stk and arr [ i ] < arr [ stk [ - 1 ] ] ) : NEW_LINE INDENT minarr [ stk [ - 1 ] ] = i NEW_LINE stk . pop ( ) NEW_LINE DEDENT stk . append ( i ) NEW_LINE DEDENT while ( stk ) : NEW_LINE INDENT minarr [ stk [ - 1 ] ] = n NEW_LINE stk . pop ( ) NEW_LINE DEDENT submin = [ ] NEW_LINE for i in range ( n - y + 1 ) : NEW_LINE INDENT while ( minarr [ j ] <= i + y - 1 or j < i ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT submin . append ( arr [ j ] ) NEW_LINE DEDENT return submin NEW_LINE DEDENT def getMinDifference ( Arr , N , Y ) : NEW_LINE INDENT submin = get_subminarr ( Arr , N , Y ) NEW_LINE submax = get_submaxarr ( Arr , N , Y ) NEW_LINE minn = submax [ 0 ] - submin [ 0 ] NEW_LINE b = len ( submax ) NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT diff = submax [ i ] - submin [ i ] NEW_LINE minn = min ( minn , diff ) NEW_LINE DEDENT print ( minn ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 3 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Y = 4 NEW_LINE getMinDifference ( arr , N , Y ) NEW_LINE",
        "Type": "py",
        "NL": "Min difference between maximum and minimum element in all Y size subarrays | Function to get the maximum of all the subarrays of size Y ; ith index of maxarr array will be the index upto which Arr [ i ] is maximum ; Stack is used to find the next larger element and keeps track of index of current iteration ; Loop for remaining indexes ; j < i used to keep track whether jth element is inside or outside the window ; Return submax ; Function to get the minimum for all subarrays of size Y ; ith index of minarr array will be the index upto which Arr [ i ] is minimum ; Stack is used to find the next smaller element and keeping track of index of current iteration ; Loop for remaining indexes ; j < i used to keep track whether jth element is inside or outside the window ; Return submin ; Function to get minimum difference ; Create submin and submax arrays ; Store initial difference ; Calculate temporary difference ; Final minimum difference ; Given array arr [ ] ; Given subarray size ; Function call",
        "Category": "Stack"
    },
    {
        "ID": "3712-3712",
        "Code": "def longestSubstring ( str , X , Y ) : NEW_LINE INDENT N = len ( str ) NEW_LINE start = 0 NEW_LINE end = N - 1 NEW_LINE xPos = 0 NEW_LINE yPos = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( str [ start ] == X ) : NEW_LINE INDENT xPos = start NEW_LINE break NEW_LINE DEDENT start += 1 NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT if ( str [ end ] == Y ) : NEW_LINE INDENT yPos = end NEW_LINE break NEW_LINE DEDENT end -= 1 NEW_LINE DEDENT length = ( yPos - xPos ) + 1 NEW_LINE print ( length ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" HASFJGHOGAKZZFEGA \" NEW_LINE X = ' A ' NEW_LINE Y = ' Z ' NEW_LINE longestSubstring ( str , X , Y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest substring that starts with X and ends with Y | Function returns length of longest substring starting with X and ending with Y ; Length of string ; Find the length of the string starting with X from the beginning ; Find the length of the string ending with Y from the end ; Longest substring ; Print the length ; Driver Code ; Given string str ; Starting and Ending characters ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "3720-3720",
        "Code": "def rowWise ( v , n , m , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT countcons = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( v [ i ] [ j ] == '1' ) : NEW_LINE INDENT countcons = 0 NEW_LINE DEDENT else : NEW_LINE INDENT countcons += 1 NEW_LINE DEDENT if ( countcons >= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def colWise ( v , n , m , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT countcons = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( v [ j ] [ i ] == '1' ) : NEW_LINE INDENT countcons = 0 NEW_LINE DEDENT else : NEW_LINE INDENT countcons += 1 NEW_LINE DEDENT if ( countcons >= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 1 NEW_LINE v = [ [ '0' , '0' , '0' ] , [ '0' , '0' , '0' ] , [ '0' , '0' , '0' ] ] NEW_LINE if ( k == 1 ) : NEW_LINE INDENT print ( rowWise ( v , n , m , k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( colWise ( v , n , m , k ) + rowWise ( v , n , m , k ) ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Count of ways to select K consecutive empty cells from a given Matrix | Function to Traverse the matrix row wise ; Initialize ans ; Traverse row wise ; Initialize no of consecutive empty cells ; Check if blocked cell is encountered then reset countcons to 0 ; Check if empty cell is encountered , then increment countcons ; Check if number of empty consecutive cells is greater or equal to K , increment the ans ; Return the count ; Function to Traverse the matrix column wise ; Initialize ans ; Traverse column wise ; Initialize no of consecutive empty cells ; Check if blocked cell is encountered then reset countcons to 0 ; Check if empty cell is encountered , increment countcons ; Check if number of empty consecutive cells is greater than or equal to K , increment the ans ; Return the count ; Driver Code ; If k = 1 only traverse row wise ; Traverse both row and column wise",
        "Category": "Matrix"
    },
    {
        "ID": "3737-3737",
        "Code": "def countFac ( n ) : NEW_LINE INDENT m = n NEW_LINE count = 0 NEW_LINE i = 2 NEW_LINE while ( ( i * i ) <= m ) : NEW_LINE INDENT total = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n /= i NEW_LINE total += 1 NEW_LINE DEDENT temp = 0 NEW_LINE j = 1 NEW_LINE while ( ( temp + j ) <= total ) : NEW_LINE INDENT temp += j NEW_LINE count += 1 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 24 NEW_LINE print ( countFac ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of distinct power of prime factor of N | Function to count the number of distinct positive power of prime factor of integer N ; Iterate for all prime factor ; If it is a prime factor , count the total number of times it divides n . ; Find the Number of distinct possible positive numbers ; Return the final count ; Given number N ; Function call",
        "Category": "Math"
    },
    {
        "ID": "3739-3739",
        "Code": "def minimumSum ( a , b , c , n ) : NEW_LINE INDENT dp = [ [ 1e6 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = b [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = min ( dp [ i ] [ 0 ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) NEW_LINE dp [ i ] [ 0 ] = min ( dp [ i ] [ 0 ] , dp [ i - 1 ] [ 1 ] + a [ i ] + c ) NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + b [ i ] + c ) NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + b [ i ] ) NEW_LINE DEDENT print ( min ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 7 , 6 , 18 , 6 , 16 , 18 , 1 , 17 , 17 ] NEW_LINE arr2 = [ 6 , 9 , 3 , 10 , 9 , 1 , 10 , 1 , 5 ] NEW_LINE C = 2 NEW_LINE N = len ( arr1 ) NEW_LINE minimumSum ( arr1 , arr2 , C , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum total sum from the given two arrays | Function that prints minimum sum after selecting N elements ; Initialise the dp array ; Base Case ; Adding the element of array a if previous element is also from array a ; Adding the element of array a if previous element is from array b ; Adding the element of array b if previous element is from array a with an extra penalty of integer C ; Adding the element of array b if previous element is also from array b ; Print the minimum sum ; Driver code ; Given array arr [ ] ; Given cost ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "3746-3746",
        "Code": "arr = [ ' a ' , ' b ' , ' c ' ] NEW_LINE def findString ( n , k , s1 , s2 ) : NEW_LINE INDENT s3 = s2 NEW_LINE s3 = list ( s3 ) NEW_LINE d = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT if ( ( d + 1 ) // 2 > k ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= d ) : NEW_LINE INDENT X = d - k NEW_LINE T = 2 * k - d NEW_LINE for i in range ( len ( s3 ) ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT if ( T > 0 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if ( arr [ j ] != s1 [ i ] and arr [ j ] != s2 [ i ] ) : NEW_LINE INDENT s3 [ i ] = arr [ j ] NEW_LINE T -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT elif ( X > 0 ) : NEW_LINE INDENT s3 [ i ] = s1 [ i ] NEW_LINE X -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" \" . join ( s3 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] != s3 [ i ] ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if ( arr [ j ] != s1 [ i ] and arr [ j ] != s3 [ i ] ) : NEW_LINE INDENT s3 [ i ] = arr [ j ] NEW_LINE k -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s3 [ i ] and k ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if ( arr [ j ] != s1 [ i ] and arr [ j ] != s3 [ i ] ) : NEW_LINE INDENT s3 [ i ] = arr [ j ] NEW_LINE k -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" \" . join ( s3 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE k = 2 NEW_LINE S1 = \" zzyy \" NEW_LINE S2 = \" zxxy \" NEW_LINE findString ( N , k , S1 , S2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest string which differs from given strings at exactly K indices | Python3 program for the above approach ; Function to find the string which differ at exactly K positions ; Initialise s3 as s2 ; Number of places at which s3 differ from s2 ; Minimum possible value is ceil ( d / 2 ) if it is not possible then - 1 ; Case 2 when K is less equal d ; X show the modification such that this position only differ from only one string ; Modify the position such that this differ from both S1 & S2 & decrease the T at each step ; Finding the character which is different from both S1 and S2 ; After we done T start modification to meet our requirement for X type ; Resultant string ; Case 1 when K > d In first step , modify all the character which are not same in S1 and S3 ; Finding character which is different from both S1 and S2 ; Our requirement not satisfied by performing step 1. We need to modify the position which matches in both string ; Finding the character which is different from both S1 and S2 ; Resultant string ; Driver Code ; Given two strings ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "3749-3749",
        "Code": "def check ( A , B , C , D , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE ans = ( A * x * x * x + B * x * x + C * x + D ) ; NEW_LINE return ans ; NEW_LINE DEDENT def findSolution ( A , B , C , D , E ) : NEW_LINE INDENT start = 0 ; end = 100000 ; NEW_LINE mid = 0 ; NEW_LINE ans = 0 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 ; NEW_LINE ans = check ( A , B , C , D , mid ) ; NEW_LINE if ( ans == E ) : NEW_LINE INDENT print ( mid ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ans < E ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT DEDENT print ( \" NA \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 1 ; B = 0 ; C = 0 ; NEW_LINE D = 0 ; E = 27 ; NEW_LINE findSolution ( A , B , C , D , E ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the integral roots of a given Cubic equation | Function to find the value at x of the given equation ; Find the value equation at x ; Return the value of ans ; Function to find the integral solution of the given equation ; Initialise start and end ; Implement Binary Search ; Find mid ; Find the value of f ( x ) using current mid ; Check if current mid satisfy the equation ; Print mid and return ; Print \" NA \" if not found any integral solution ; Driver Code ; Function Call",
        "Category": "Binary Search"
    },
    {
        "ID": "375-375",
        "Code": "V = 5 NEW_LINE def DFS ( graph , marked , n , vert , start , count ) : NEW_LINE INDENT marked [ vert ] = True NEW_LINE if n == 0 : NEW_LINE INDENT marked [ vert ] = False NEW_LINE if graph [ vert ] [ start ] == 1 : NEW_LINE INDENT count = count + 1 NEW_LINE return count NEW_LINE DEDENT else : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT for i in range ( V ) : NEW_LINE INDENT if marked [ i ] == False and graph [ vert ] [ i ] == 1 : NEW_LINE INDENT count = DFS ( graph , marked , n - 1 , i , start , count ) NEW_LINE DEDENT DEDENT marked [ vert ] = False NEW_LINE return count NEW_LINE DEDENT def countCycles ( graph , n ) : NEW_LINE INDENT marked = [ False ] * V NEW_LINE count = 0 NEW_LINE for i in range ( V - ( n - 1 ) ) : NEW_LINE INDENT count = DFS ( graph , marked , n - 1 , i , i , count ) NEW_LINE marked [ i ] = True NEW_LINE DEDENT return int ( count / 2 ) NEW_LINE DEDENT graph = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 1 , 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 , 0 ] , [ 1 , 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 , 0 ] ] NEW_LINE n = 4 NEW_LINE print ( \" Total ▁ cycles ▁ of ▁ length ▁ \" , n , \" ▁ are ▁ \" , countCycles ( graph , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Cycles of length n in an undirected and connected graph | Number of vertices ; mark the vertex vert as visited ; if the path of length ( n - 1 ) is found ; mark vert as un - visited to make it usable again . ; Check if vertex vert can end with vertex start ; For searching every possible path of length ( n - 1 ) ; DFS for searching path by decreasing length by 1 ; marking vert as unvisited to make it usable again . ; Counts cycles of length N in an undirected and connected graph . ; all vertex are marked un - visited initially . ; Searching for cycle by using v - n + 1 vertices ; ith vertex is marked as visited and will not be visited again . ; main :",
        "Category": "Backtracking"
    },
    {
        "ID": "3754-3754",
        "Code": "def countTriplets ( color ) : NEW_LINE INDENT result = 0 ; Blue_Count = 0 ; NEW_LINE Red_Count = 0 ; NEW_LINE for c in color : NEW_LINE INDENT if ( c == ' B ' ) : NEW_LINE INDENT Blue_Count += 1 ; NEW_LINE DEDENT DEDENT for c in color : NEW_LINE INDENT if ( c == ' B ' ) : NEW_LINE INDENT Blue_Count -= 1 ; NEW_LINE DEDENT if ( c == ' R ' ) : NEW_LINE INDENT Red_Count += 1 ; NEW_LINE DEDENT if ( c == ' G ' ) : NEW_LINE INDENT result += Red_Count * Blue_Count ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT color = \" RRGGBBRGGBB \" ; NEW_LINE print ( countTriplets ( color ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of ordered triplets ( R , G , B ) in a given original string | function to count the ordered triplets ( R , G , B ) ; count the B ( blue ) colour ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "376-376",
        "Code": "V = 4 NEW_LINE INF = 99999 NEW_LINE def negCyclefloydWarshall ( graph ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE DEDENT DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ i ] < 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT graph = [ [ 0 , 1 , INF , INF ] , [ INF , 0 , - 1 , INF ] , [ INF , INF , 0 , - 1 ] , [ - 1 , INF , INF , 0 ] ] NEW_LINE if ( negCyclefloydWarshall ( graph ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Detecting negative cycle using Floyd Warshall | Number of vertices in the graph ; Define Infinite as a large enough value . This value will be used for vertices not connected to each other ; Returns true if graph has negative weight cycle else false . ; dist [ ] [ ] will be the output matrix that will finally have the shortest distances between every pair of vertices ; Initialize the solution matrix same as input graph matrix . Or we can say the initial values of shortest distances are based on shortest paths considering no intermediate vertex . ; Add all vertices one by one to the set of intermediate vertices . -- -> Before start of a iteration , we have shortest distances between all pairs of vertices such that the shortest distances consider only the vertices in set { 0 , 1 , 2 , . . k - 1 } as intermediate vertices . -- -- > After the end of a iteration , vertex no . k is added to the set of intermediate vertices and the set becomes { 0 , 1 , 2 , . . k } ; Pick all vertices as source one by one ; Pick all vertices as destination for the above picked source ; If vertex k is on the shortest path from i to j , then update the value of dist [ i ] [ j ] ; If distance of any vertex from itself becomes negative , then there is a negative weight cycle . ; Let us create the following weighted graph 1 ( 0 ) -- -- -- -- -- -> ( 1 ) / | \\ | | | - 1 | | - 1 | \\ | / ( 3 ) < -- -- -- -- -- - ( 2 ) - 1",
        "Category": "Graph Theory"
    },
    {
        "ID": "3768-3768",
        "Code": "def findNumbers ( N , M ) : NEW_LINE INDENT m = M NEW_LINE remLen = { } NEW_LINE for len1 in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT remainder = M % N NEW_LINE if ( remLen . get ( remainder ) == None ) : NEW_LINE INDENT remLen [ remainder ] = len1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT M = M * 10 + m NEW_LINE M = M % N NEW_LINE DEDENT LenA = len1 NEW_LINE LenB = remLen [ remainder ] NEW_LINE for i in range ( LenB ) : NEW_LINE INDENT print ( m , end = \" \" ) NEW_LINE DEDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE for i in range ( LenA ) : NEW_LINE INDENT print ( m , end = \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE M = 2 NEW_LINE findNumbers ( N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find two numbers made up of a given digit such that their difference is divisible by N | Function to implement the above approach ; Hashmap to store remainder - length of the number as key - value pairs ; Iterate till N + 1 length ; Search remainder in the map ; If remainder is not already present insert the length for the corresponding remainder ; Keep increasing M ; To keep M in range of integer ; Length of one number is the current Length ; Length of the other number is the length paired with current remainder in map ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "3774-3774",
        "Code": "def maxSubstring ( S , K , N ) : NEW_LINE INDENT def maxSubstring ( S , K , N ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ ord ( S [ i ] ) - 97 ] = 1 NEW_LINE DEDENT answer = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ch = chr ( i + 97 ) NEW_LINE count = 0 NEW_LINE index = - 1 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( S [ j ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == K ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT answer . append ( [ ch , index ] ) NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( len ( answer ) ) : NEW_LINE INDENT if ( answer [ i ] [ 1 ] > - 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE print ( answer [ i ] [ 0 ] , answer [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" cbaabaacbcd \" NEW_LINE K = 2 NEW_LINE N = len ( S ) NEW_LINE maxSubstring ( S , K , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest index for each distinct character in given string with frequency K | Python3 implementation of the approach Function to find largest index for each distinct character occuring exactly K times . ; Function to find largest index for each distinct character occuring exactly K times ; Finding all characters present in S ; Finding all distinct characters in S ; To store result for each character ; Loop through each lower case English character ; If current character is absent in s ; Getting current character ; Finding count of character ch in S ; To store max Index encountred so far ; Printing required result ; If no such character exists , print - 1 ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "3777-3777",
        "Code": "def distanceSort ( arr , K , n ) : NEW_LINE INDENT vd = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT pos = i NEW_LINE break NEW_LINE DEDENT DEDENT i = pos - 1 NEW_LINE j = pos + 1 NEW_LINE vd [ 0 ] . append ( arr [ pos ] ) NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT vd [ pos - i ] . append ( arr [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT vd [ j - pos ] . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( max ( pos , n - pos - 1 ) + 1 ) : NEW_LINE INDENT vd [ i ] . sort ( reverse = False ) NEW_LINE for element in vd [ i ] : NEW_LINE INDENT print ( element , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 14 , 1101 , 10 , 35 , 0 ] NEW_LINE K = 35 NEW_LINE n = len ( arr ) NEW_LINE distanceSort ( arr , K , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort integers in array according to their distance from the element K | Function to get sorted array based on their distance from given integer K ; Vector to store respective elements with their distance from integer K ; Find the position of integer K ; Insert the elements with their distance from K in vector ; Element at distance 0 ; Elements at left side of K ; Elements at right side of K ; Print the vector content in sorted order ; Sort elements at same distance ; Print elements at distance i from K ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3782-3782",
        "Code": "from math import log10 , ceil , log NEW_LINE def log1 ( a , b ) : NEW_LINE INDENT return log10 ( a ) // log10 ( b ) NEW_LINE DEDENT def get ( a , b , n ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = 1e6 NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE dig = ceil ( ( mid * log ( mid , b ) + log ( a , b ) ) ) NEW_LINE if ( dig > n ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE n = 6 NEW_LINE print ( int ( get ( a , b , n ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest value of x such that axx is N | Python3 implementation of the above approach ; Function to find log_b ( a ) ; Set two pointer for binary search ; Calculating number of digits of a * mid ^ mid in base b ; If number of digits > n we can simply ignore it and decrease our pointer ; if number of digits <= n , we can go higher to reach value exactly equal to n ; return the largest value of x ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "3791-3791",
        "Code": "MAX = 1000005 NEW_LINE fibUpto = [ 0 ] * ( MAX + 1 ) NEW_LINE def compute ( sz ) : NEW_LINE INDENT isFib = [ False ] * ( sz + 1 ) NEW_LINE prev = 0 NEW_LINE curr = 1 NEW_LINE isFib [ prev ] = True NEW_LINE isFib [ curr ] = True NEW_LINE while ( curr <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp <= sz ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT fibUpto [ 0 ] = 1 NEW_LINE for i in range ( 1 , sz + 1 ) : NEW_LINE INDENT fibUpto [ i ] = fibUpto [ i - 1 ] NEW_LINE if ( isFib [ i ] ) : NEW_LINE INDENT fibUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT compute ( N ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - fibUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ( N - ans + 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of numbers whose difference with Fibonacci count upto them is atleast K | Python 3 program to find the count of numbers whose difference with Fibonacci count upto them is atleast K ; fibUpto [ i ] denotes the count of fibonacci numbers upto i ; Function to compute all the Fibonacci numbers and update fibUpto array ; Store the first two Fibonacci numbers ; Compute the Fibonacci numbers and store them in isFib array ; Compute fibUpto array ; Function to return the count of valid numbers ; Compute fibUpto array ; Binary search to find the minimum number that follows the condition ; Check if the number is valid , try to reduce it ; Ans is the minimum valid number ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "3792-3792",
        "Code": "N = 100001 NEW_LINE f = [ [ 0 for x in range ( N ) ] for y in range ( 26 ) ] NEW_LINE def precompute ( s , n ) : NEW_LINE ' NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT f [ ord ( s [ i ] ) - ord ( ' a ' ) ] [ i ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT f [ i ] [ j ] += f [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def palindromicSubsequencesUtil ( L , R ) : NEW_LINE INDENT ok = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt = f [ i ] [ R ] NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= f [ i ] [ L - 1 ] NEW_LINE DEDENT if ( cnt > 1 ) : NEW_LINE INDENT ok = 1 NEW_LINE c = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def palindromicSubsequences ( Q , l ) : NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT x = palindromicSubsequencesUtil ( Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) NEW_LINE if ( x == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = ord ( ' a ' ) + x NEW_LINE print ( 2 * chr ( c ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" dbdeke \" NEW_LINE Q = [ [ 0 , 5 ] , [ 1 , 5 ] , [ 1 , 3 ] ] NEW_LINE n = len ( st ) NEW_LINE l = len ( Q ) NEW_LINE precompute ( st , n ) NEW_LINE palindromicSubsequences ( Q , l ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest Palindromic Subsequence of Even Length in Range [ L , R ] | Python3 program to find lexicographically smallest palindromic subsequence of even length ; Frequency array for each character ; Preprocess the frequency array calculation ; Frequency array to track each character in position 'i ; Calculating prefix sum over this frequency array to get frequency of a character in a range [ L , R ] . ; Util function for palindromic subsequences ; Find frequency of all characters ; For each character find it 's frequency  in range [L, R] ; If frequency in this range is > 1 , then we must take this character , as it will give lexicographically smallest one ; There is no character in range [ L , R ] such that it 's frequency is > 1. ; Return the character 's value ; Function to find lexicographically smallest palindromic subsequence of even length ; Find in the palindromic subsequences ; No such subsequence exists ; Driver Code ; Function calls",
        "Category": "Array"
    },
    {
        "ID": "3794-3794",
        "Code": "from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N < 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( N & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 5 NEW_LINE s = sqrt ( N ) NEW_LINE while ( curr <= s ) : NEW_LINE INDENT if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 2 NEW_LINE if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 4 NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( s , p , prefix_sum , n ) : NEW_LINE INDENT satisfies = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + s - 1 >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT x = prefix_sum [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT if ( prefix_sum [ i + s - 1 ] - x < p ) : NEW_LINE INDENT satisfies = False NEW_LINE DEDENT DEDENT return satisfies NEW_LINE DEDENT def minimumWindowSize ( x , y , p ) : NEW_LINE INDENT prefix_sum = [ 0 ] * ( y - x + 1 ) NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT prefix_sum [ i - x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , y - x + 1 ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT low = 1 NEW_LINE high = y - x + 1 NEW_LINE while ( high - low > 1 ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( check ( mid , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT if ( check ( low , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT return low NEW_LINE DEDENT return high NEW_LINE DEDENT x = 12 NEW_LINE y = 42 NEW_LINE p = 3 NEW_LINE print ( minimumWindowSize ( x , y , p ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum window size containing atleast P primes in every window of given range | Python3 implementation to find the minimum window size in the range such that each window of that size contains atleast P primes ; Function to check that a number is a prime or not in O ( sqrt ( N ) ) ; Loop to check if any number number is divisible by any other number or not ; Function to check whether window size satisfies condition or not ; Loop to check each window of size have atleast P primes ; Checking condition using prefix sum ; Function to find the minimum window size possible for the given range in X and Y ; Prefix array ; Mark those numbers which are primes as 1 ; Convert to prefix sum ; Applying binary search over window size ; Check whether mid satisfies the condition or not ; If satisfies search in first half ; Else search in second half ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "38-38",
        "Code": "from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def modifiedLevelOrder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( node . left == None and node . right == None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT myQueue = deque ( ) NEW_LINE myStack = [ ] NEW_LINE temp = None NEW_LINE sz = 0 NEW_LINE ct = 0 NEW_LINE rightToLeft = False NEW_LINE myQueue . append ( node ) NEW_LINE while ( len ( myQueue ) > 0 ) : NEW_LINE INDENT ct += 1 NEW_LINE sz = len ( myQueue ) NEW_LINE for i in range ( sz ) : NEW_LINE INDENT temp = myQueue . popleft ( ) NEW_LINE if ( rightToLeft == False ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT myStack . append ( temp ) NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT myQueue . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT myQueue . append ( temp . right ) NEW_LINE DEDENT DEDENT if ( rightToLeft == True ) : NEW_LINE INDENT while ( len ( myStack ) > 0 ) : NEW_LINE INDENT temp = myStack [ - 1 ] NEW_LINE del myStack [ - 1 ] NEW_LINE print ( temp . data , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( ct == 2 ) : NEW_LINE INDENT rightToLeft = not rightToLeft NEW_LINE ct = 0 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . left . left . left = Node ( 8 ) NEW_LINE root . left . left . right = Node ( 9 ) NEW_LINE root . left . right . left = Node ( 3 ) NEW_LINE root . left . right . right = Node ( 1 ) NEW_LINE root . right . left . left = Node ( 4 ) NEW_LINE root . right . left . right = Node ( 2 ) NEW_LINE root . right . right . left = Node ( 7 ) NEW_LINE root . right . right . right = Node ( 2 ) NEW_LINE root . left . right . left . left = Node ( 16 ) NEW_LINE root . left . right . left . right = Node ( 17 ) NEW_LINE root . right . left . right . left = Node ( 18 ) NEW_LINE root . right . right . left . right = Node ( 19 ) NEW_LINE modifiedLevelOrder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Level order traversal with direction change after every two levels | A Binary Tree Node ; Function to prthe level order of given binary tree . Direction of printing level order traversal of binary tree changes after every two levels ; For null root ; Maintain a queue for normal level order traversal ; Maintain a stack for printing nodes in reverse order after they are popped out from queue . ; sz is used for storing the count of nodes in a level ; Used for changing the direction of level order traversal ; Used for changing the direction of level order traversal ; Push root node to the queue ; Run this while loop till queue got empty ; Do a normal level order traversal ; For printing nodes from left to right , simply prthe nodes in the order in which they are being popped out from the queue . ; For printing nodes from right to left , push the nodes to stack instead of printing them . ; for printing the nodes in order from right to left ; Change the direction of printing nodes after every two levels . ; Driver program to test above functions ; Let us create binary tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "380-380",
        "Code": "def find ( parent , i ) : NEW_LINE INDENT if ( parent [ i ] == - 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT return find ( parent , parent [ i ] ) NEW_LINE DEDENT def Union ( parent , x , y ) : NEW_LINE INDENT xset = find ( parent , x ) NEW_LINE yset = find ( parent , y ) NEW_LINE parent [ xset ] = yset NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Union | Naive implementation of find ; Naive implementation of union ( )",
        "Category": "Graph Theory"
    },
    {
        "ID": "3816-3816",
        "Code": "MAX = 10 NEW_LINE def isDigit ( ch ) : NEW_LINE INDENT ch = ord ( ch ) NEW_LINE if ( ch >= ord ( '0' ) and ch <= ord ( '9' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def allDigits ( st , le ) : NEW_LINE INDENT present = [ False for i in range ( MAX ) ] NEW_LINE for i in range ( le ) : NEW_LINE INDENT if ( isDigit ( st [ i ] ) ) : NEW_LINE INDENT digit = ord ( st [ i ] ) - ord ( '0' ) NEW_LINE present [ digit ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( present [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = \" Geeks12345for69708\" NEW_LINE le = len ( st ) NEW_LINE if ( allDigits ( st , le ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if given string contains all the digits | Python3 implementation of the approach ; Function that returns true if ch is a digit ; Function that returns true if st contains all the digits from 0 to 9 ; To mark the present digits ; For every character of the string ; If the current character is a digit ; Mark the current digit as present ; For every digit from 0 to 9 ; If the current digit is not present in st ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "382-382",
        "Code": "MAX_VERTEX = 101 NEW_LINE Arr = [ None ] * MAX_VERTEX NEW_LINE size = [ None ] * MAX_VERTEX NEW_LINE def initialize ( n ) : NEW_LINE INDENT global Arr , size NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT Arr [ i ] = i NEW_LINE size [ i ] = 1 NEW_LINE DEDENT DEDENT def find ( i ) : NEW_LINE INDENT global Arr , size NEW_LINE while ( Arr [ i ] != i ) : NEW_LINE INDENT Arr [ i ] = Arr [ Arr [ i ] ] NEW_LINE i = Arr [ i ] NEW_LINE DEDENT return i NEW_LINE DEDENT def _union ( xr , yr ) : NEW_LINE INDENT global Arr , size NEW_LINE DEDENT if ( size [ xr ] < size [ yr ] ) : NEW_LINE INDENT Arr [ xr ] = Arr [ yr ] NEW_LINE size [ yr ] += size [ xr ] NEW_LINE DEDENT else : NEW_LINE INDENT Arr [ yr ] = Arr [ xr ] NEW_LINE size [ xr ] += size [ yr ] NEW_LINE DEDENT def isCycle ( adj , V ) : NEW_LINE INDENT global Arr , size NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( len ( adj [ i ] ) ) : NEW_LINE DEDENT DEDENT x = find ( i ) NEW_LINE y = find ( adj [ i ] [ j ] ) NEW_LINE INDENT if ( x == y ) : NEW_LINE DEDENT return 1 NEW_LINE _union ( x , y ) NEW_LINE INDENT return 0 NEW_LINE DEDENT V = 3 NEW_LINE initialize ( V ) NEW_LINE adj = [ [ ] for i in range ( V ) ] NEW_LINE adj [ 0 ] . append ( 1 ) NEW_LINE adj [ 0 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE if ( isCycle ( adj , V ) ) : NEW_LINE INDENT print ( \" Graph ▁ contains ▁ Cycle . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Graph ▁ does ▁ not ▁ contain ▁ Cycle . \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Union | Python3 program to implement Union - Find with union by rank and path compression . ; Arr to represent parent of index i ; Size to represent the number of nodes in subgxrph rooted at index i ; set parent of every node to itself and size of node to one ; Each time we follow a path , find function compresses it further until the path length is greater than or equal to 1. ; while we reach a node whose parent is equal to itself ; Skip one level ; Move to the new level ; A function that does union of two nodes x and y where xr is root node of x and yr is root node of y ; Make yr parent of xr ; Make xr parent of yr ; The main function to check whether a given graph contains cycle or not ; Itexrte through all edges of gxrph , find nodes connecting them . If root nodes of both are same , then there is cycle in gxrph . ; find root of i ; find root of adj [ i ] [ j ] ; If same parent ; Make them connect ; Driver Code ; Initialize the values for arxry Arr and Size ; Adjacency list for graph ; call is_cycle to check if it contains cycle",
        "Category": "Graph Theory"
    },
    {
        "ID": "3821-3821",
        "Code": "from math import gcd as __gcd , log , floor NEW_LINE / * int a [ 100001 ] ; * / NEW_LINE SparseTable = [ [ 0 for i in range ( 51 ) ] for i in range ( 100001 ) ] NEW_LINE def buildSparseTable ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT SparseTable [ i ] [ 0 ] = a [ i ] NEW_LINE DEDENT for j in range ( 1 , 20 ) : NEW_LINE INDENT for i in range ( n - ( 1 << j ) + 1 ) : NEW_LINE INDENT SparseTable [ i ] [ j ] = __gcd ( SparseTable [ i ] [ j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def queryForGCD ( L , R ) : NEW_LINE INDENT j = floor ( log ( R - L + 1 , 2 ) ) NEW_LINE returnValue = __gcd ( SparseTable [ L ] [ j ] , SparseTable [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE return returnValue NEW_LINE DEDENT def nextPosition ( tempGCD , startPointer , prevEndPointer , n ) : NEW_LINE INDENT high = n - 1 NEW_LINE low = prevEndPointer NEW_LINE mid = prevEndPointer NEW_LINE nextPos = prevEndPointer NEW_LINE while ( high >= low ) : NEW_LINE INDENT mid = ( ( high + low ) >> 1 ) NEW_LINE if ( queryForGCD ( startPointer , mid ) == tempGCD ) : NEW_LINE INDENT nextPos = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return nextPos + 1 NEW_LINE DEDENT def calculateSum ( a , n ) : NEW_LINE INDENT buildSparseTable ( a , n ) NEW_LINE tempAns = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT endPointer = i NEW_LINE startPointer = i NEW_LINE prevEndPointer = i NEW_LINE tempGCD = a [ i ] NEW_LINE while ( endPointer < n ) : NEW_LINE INDENT endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) NEW_LINE tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) NEW_LINE prevEndPointer = endPointer NEW_LINE if ( endPointer < n ) : NEW_LINE INDENT tempGCD = __gcd ( tempGCD , a [ endPointer ] ) NEW_LINE DEDENT DEDENT DEDENT return tempAns NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 2 , 2 , 3 , 5 , 5 ] NEW_LINE print ( calculateSum ( a , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Calculate the Sum of GCD over all subarrays | Python3 program to find Sum of GCD over all subarrays ;  ; Build Sparse Table ; Building the Sparse Table for GCD [ L , R ] Queries ; Utility Function to calculate GCD in range [ L , R ] ; Calculating where the answer is stored in our Sparse Table ; Utility Function to find next - farther position where gcd is same ; BinarySearch for Next Position for EndPointer ; Utility function to calculate sum of gcd ; Initializing all the values ; Finding the next position for endPointer ; Adding the suitable sum to our answer ; Changing prevEndPointer ; Recalculating tempGCD ; Driver code",
        "Category": "Sparse Table"
    },
    {
        "ID": "3827-3827",
        "Code": "def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def kthSmallest ( a , left , right , k ) : NEW_LINE INDENT while left <= right : NEW_LINE INDENT pivotIndex = partition ( a , left , right ) NEW_LINE if pivotIndex == k - 1 : NEW_LINE INDENT return a [ pivotIndex ] NEW_LINE DEDENT elif pivotIndex > k - 1 : NEW_LINE INDENT right = pivotIndex - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = pivotIndex + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 4 , 5 , 8 , 11 , 6 , 26 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( \" K - th ▁ smallest ▁ element ▁ is \" , kthSmallest ( arr , 0 , n - 1 , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "QuickSelect ( A Simple Iterative Implementation ) | Standard Lomuto partition function ; Implementation of QuickSelect ; Partition a [ left . . right ] around a pivot and find the position of the pivot ; If pivot itself is the k - th smallest element ; If there are more than k - 1 elements on left of pivot , then k - th smallest must be on left side . ; Else k - th smallest is on right side . ; Driver Code",
        "Category": "QuickSelect"
    },
    {
        "ID": "3836-3836",
        "Code": "import math NEW_LINE def Square ( n , i , j ) : NEW_LINE INDENT mid = ( i + j ) / 2 ; NEW_LINE mul = mid * mid ; NEW_LINE if ( ( mul == n ) or ( abs ( mul - n ) < 0.00001 ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( mul < n ) : NEW_LINE INDENT return Square ( n , mid , j ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return Square ( n , i , mid ) ; NEW_LINE DEDENT DEDENT def findSqrt ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE found = False ; NEW_LINE while ( found == False ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT print ( i ) ; NEW_LINE found = True ; NEW_LINE DEDENT elif ( i * i > n ) : NEW_LINE INDENT res = Square ( n , i - 1 , i ) ; NEW_LINE print ( \" { 0 : . 5f } \" . format ( res ) ) NEW_LINE found = True NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE findSqrt ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Square root of a number without using sqrt ( ) function | Python3 implementation of the approach ; Recursive function that returns square root of a number with precision upto 5 decimal places ; If mid itself is the square root , return mid ; If mul is less than n , recur second half ; Else recur first half ; Function to find the square root of n ; While the square root is not found ; If n is a perfect square ; Square root will lie in the interval i - 1 and i ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3837-3837",
        "Code": "def Max_Sum ( arr , n , k ) : NEW_LINE INDENT p = n NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] >= k ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT maxsum = 0 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 0 , p ) : NEW_LINE INDENT for j in range ( i + 1 , p ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < k and arr [ i ] + arr [ j ] > maxsum ) : NEW_LINE INDENT maxsum = arr [ i ] + arr [ j ] NEW_LINE a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( a , b ) NEW_LINE DEDENT arr = [ 5 , 20 , 110 , 100 , 10 ] NEW_LINE k = 85 NEW_LINE n = len ( arr ) NEW_LINE Max_Sum ( arr , n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Pair with largest sum which is less than K in the array | Function to find pair with largest sum which is less than K in the array ; To store the break point ; Sort the given array ; Find the break point ; No need to look beyond i 'th index ; Find the required pair ; Print the required answer ; Driver code ; Function call",
        "Category": "Two Pointers"
    },
    {
        "ID": "3848-3848",
        "Code": "def isPalindrome ( str , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def maxLenPalindrome ( str , n , ch ) : NEW_LINE INDENT maxLen = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( str [ j ] == ch ) : NEW_LINE INDENT if ( isPalindrome ( str , i , j ) ) : NEW_LINE INDENT maxLen = max ( maxLen , j - i + 1 ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxLen ; NEW_LINE DEDENT str = \" lapqooqpqpl \" ; NEW_LINE n = len ( str ) ; NEW_LINE ch = ' p ' ; NEW_LINE print ( maxLenPalindrome ( str , n , ch ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Maximum length palindromic substring such that it starts and ends with given char | Function that returns true if str [ i ... j ] is a palindrome ; Function to return the length of the longest palindromic sub - string such that it starts and ends with the character ch ; If current character is a valid starting index ; Instead of finding the ending index from the beginning , find the index from the end This is because if the current sub - string is a palindrome then there is no need to check the sub - strings of smaller length and we can skip to the next iteration of the outer loop ; If current character is a valid ending index ; If str [ i ... j ] is a palindrome then update the length of the maximum palindrome so far ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "3849-3849",
        "Code": "from bisect import bisect_left as lower_bound NEW_LINE MAX = 26 NEW_LINE def findCount ( a , b , n , m ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE smallestFreq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = a [ i ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for j in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for j in range ( MAX ) : NEW_LINE INDENT if ( freq [ j ] ) : NEW_LINE INDENT smallestFreq . append ( freq [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT smallestFreq = sorted ( smallestFreq ) NEW_LINE ans = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT s = b [ i ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for j in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT frequency = 0 NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT if ( freq [ j ] ) : NEW_LINE INDENT frequency = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT ind = lower_bound ( smallestFreq , frequency ) NEW_LINE ans . append ( ind ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def printAnswer ( a , b , n , m ) : NEW_LINE INDENT ans = findCount ( a , b , n , m ) NEW_LINE for it in ans : NEW_LINE INDENT print ( it , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = [ \" aaa \" , \" aa \" , \" bdc \" ] NEW_LINE B = [ \" cccch \" , \" cccd \" ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE printAnswer ( A , B , n , m ) NEW_LINE",
        "Type": "py",
        "NL": "Count of strings in the first array which are smaller than every string in the second array | Python3 implementation of the approach ; Function to count the number of smaller strings in A for every in B ; Count the frequency of all characters ; Iterate for all possible strings in A ; Increase the frequency of every character ; Check for the smallest character 's frequency ; Get the smallest character frequency ; Insert it in the vector ; Sort the count of all the frequency of the smallest character in every string ; Iterate for every in B ; Hash set every frequency 0 ; Count the frequency of every character ; Find the frequency of the smallest character ; Count the number of strings in A which has the frequency of the smaller character less than the frequency of the smaller character of the in B ; Store the answer ; Function to print the answer ; Get the answer ; Print the number of strings for every answer ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "3850-3850",
        "Code": "def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE startindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] . isalpha ( ) ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == '1' : NEW_LINE INDENT sum = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = - 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] == 0 : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( maxsize , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , ( startindex + maxsize - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ ' A ' , ' B ' , ' X ' , '4' , '6' , ' X ' , ' a ' ] NEW_LINE size = len ( arr ) NEW_LINE findSubArray ( arr , size ) NEW_LINE",
        "Type": "py",
        "NL": "Longest sub | Function to find the starting and the ending index of the sub - array with equal number of alphabets and numeric digits ; If its an alphabet ; Else its a number ; Pick a starting poas i ; Consider all sub - arrays starting from i ; If this is a 0 sum sub - array then compare it with maximum size sub - array calculated so far ; If no valid sub - array found ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "3859-3859",
        "Code": "MAX = 26 NEW_LINE def countingsort ( s ) : NEW_LINE INDENT count = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < count [ i ] ) : NEW_LINE INDENT s = s . replace ( s [ index ] , chr ( 97 + i ) ) NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def isPossible ( v , str1 ) : NEW_LINE INDENT countingsort ( str1 ) ; NEW_LINE for i in range ( len ( v ) - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( v ) , 1 ) : NEW_LINE INDENT temp = v [ i ] + v [ j ] NEW_LINE countingsort ( temp ) NEW_LINE if ( temp == str1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" amazon \" NEW_LINE v = [ \" fds \" , \" oxq \" , \" zoa \" , \" epw \" , \" amn \" ] NEW_LINE if ( isPossible ( v , str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given string can be formed by two other strings or their permutations | Python 3 implementation of the approach ; Function to sort the given string using counting sort ; Array to store the count of each character ; Insert characters in the string in increasing order ; Function that returns true if str can be generated from any permutation of the two strings selected from the given vector ; Sort the given string ; Select two strings at a time from given vector ; Get the concatenated string ; Sort the resultant string ; If the resultant string is equal to the given string str ; No valid pair found ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "3874-3874",
        "Code": "NO_OF_CHARS = 256 NEW_LINE def firstRepeating ( string ) : NEW_LINE INDENT visited = [ False ] * NO_OF_CHARS ; NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT visited [ i ] = False ; NEW_LINE DEDENT res = - 1 ; NEW_LINE for i in range ( len ( string ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( visited [ string . index ( string [ i ] ) ] == False ) : NEW_LINE INDENT visited [ string . index ( string [ i ] ) ] = True ; NEW_LINE DEDENT else : NEW_LINE INDENT res = i ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE index = firstRepeating ( string ) ; NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT print ( \" Either ▁ all ▁ characters ▁ are \" , \" distinct ▁ or ▁ string ▁ is ▁ empty \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" First ▁ Repeating ▁ character ▁ is : \" , string [ index ] ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Repeated Character Whose First Appearance is Leftmost | Python3 program to find first repeating character ; The function returns index of the first repeating character in a string . If all characters are repeating then returns - 1 ; Mark all characters as not visited ; Traverse from right and update res as soon as we see a visited character . ; Driver program to test above function",
        "Category": "Hash Table"
    },
    {
        "ID": "3879-3879",
        "Code": "from math import * NEW_LINE def divisorcount ( elem ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( elem ) ) + 1 ) : NEW_LINE INDENT if ( elem % i == 0 ) : NEW_LINE INDENT if ( i * i == elem ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def findwinner ( A , B , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT A [ i ] = divisorcount ( A [ i ] ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT B [ i ] = divisorcount ( B [ i ] ) NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE winA = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = A [ i ] NEW_LINE start = 0 NEW_LINE end = M - 1 NEW_LINE index = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( B [ mid ] <= val ) : NEW_LINE INDENT index = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT winA += ( index + 1 ) NEW_LINE DEDENT winB = N * M - winA NEW_LINE if ( winA > winB ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT elif ( winB > winA ) : NEW_LINE INDENT return \" B \" NEW_LINE DEDENT return \" Draw \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 4 , 12 , 24 ] NEW_LINE N = len ( A ) NEW_LINE B = [ 25 , 28 , 13 , 45 ] NEW_LINE M = len ( B ) NEW_LINE print ( findwinner ( A , B , N , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the winner of the game based on greater number of divisors | Python3 implementation of the approach ; Function to return the count of divisors of elem ; Function to return the winner of the game ; Convert every element of A [ ] to their divisor count ; Convert every element of B [ ] to their divisor count ; Sort both the arrays ; For every element of A [ ] apply binary search to find number of pairs where A wins ; B wins if A doesnot win ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3880-3880",
        "Code": "def isPossible ( box , truck , n , m , min_time ) : NEW_LINE INDENT temp = 0 NEW_LINE count = 0 NEW_LINE while ( count < m ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < min_time and temp < n and truck [ count ] >= box [ temp ] ) : NEW_LINE INDENT temp += 1 NEW_LINE j += 2 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( temp == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def minTime ( box , truck , n , m ) : NEW_LINE INDENT box . sort ( ) ; NEW_LINE truck . sort ( ) ; NEW_LINE l = 0 NEW_LINE h = 2 * n NEW_LINE min_time = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( isPossible ( box , truck , n , m , mid ) ) : NEW_LINE INDENT min_time = mid NEW_LINE h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return min_time NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT box = [ 10 , 2 , 16 , 19 ] NEW_LINE truck = [ 29 , 25 ] NEW_LINE n = len ( box ) NEW_LINE m = len ( truck ) NEW_LINE print ( minTime ( box , truck , n , m ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum time required to transport all the boxes from source to the destination under the given constraints | Function that returns true if it is possible to transport all the boxes in the given amount of time ; If all the boxes can be transported in the given time ; If all the boxes can 't be  transported in the given time ; Function to return the minimum time required ; Sort the two arrays ; Stores minimum time in which all the boxes can be transported ; Check for the minimum time in which all the boxes can be transported ; If it is possible to transport all the boxes in mid amount of time ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3881-3881",
        "Code": "def solve ( interval , N , Q ) : NEW_LINE INDENT Mark = [ 0 for i in range ( Q ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE for j in range ( l , r + 1 ) : NEW_LINE INDENT Mark [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( Q ) : NEW_LINE INDENT if ( Mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count1 = [ 0 for i in range ( Q ) ] NEW_LINE if ( Mark [ 0 ] == 1 ) : NEW_LINE INDENT count1 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , Q ) : NEW_LINE INDENT if ( Mark [ i ] == 1 ) : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] NEW_LINE DEDENT DEDENT maxindex = 0 NEW_LINE maxcoverage = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE elem1 = 0 NEW_LINE if ( l != 0 ) : NEW_LINE INDENT elem1 = count1 [ r ] - count1 [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT elem1 = count1 [ r ] NEW_LINE DEDENT if ( count - elem1 >= maxcoverage ) : NEW_LINE INDENT maxcoverage = count - elem1 NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT print ( \" Maximum ▁ Coverage ▁ is \" , maxcoverage , \" after ▁ removing ▁ interval ▁ at ▁ index \" , maxindex ) NEW_LINE DEDENT interval = [ [ 1 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 3 , 5 ] ] NEW_LINE N = len ( interval ) NEW_LINE Q = 7 NEW_LINE solve ( interval , N , Q ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum points covered after removing an Interval | Function To find the required interval ; Total Count of covered numbers ; Array to store numbers that occur exactly in one interval till ith interval ; Calculate New count by removing all numbers in range [ l , r ] occurring exactly once ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "3882-3882",
        "Code": "def isPossible ( arr , n , dist , k ) : NEW_LINE INDENT req = 0 NEW_LINE curr = 0 NEW_LINE prev = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( curr != n and ( arr [ curr ] - arr [ prev ] ) <= dist ) : NEW_LINE INDENT curr = curr + 1 NEW_LINE DEDENT req = req + 1 NEW_LINE if ( curr == n ) : NEW_LINE INDENT break NEW_LINE DEDENT prev = curr - 1 NEW_LINE DEDENT if ( curr != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( req <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def minDistance ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE h = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 ; NEW_LINE if ( isPossible ( arr , n , m , k ) ) : NEW_LINE INDENT ans = m NEW_LINE h = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 15 , 36 , 43 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( minDistance ( arr , n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the minimum of maximum length of a jump required to reach the last island in exactly k jumps | Function that returns true if it is possible to reach end of the array in exactly k jumps ; Variable to store the number of steps required to reach the end ; If it is possible to reach the end in exactly k jumps ; Returns the minimum maximum distance required to reach the end of the array in exactly k jumps ; Stores the answer ; Binary search to calculate the result ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3888-3888",
        "Code": "def preCalculate ( binary , n , left ) : NEW_LINE INDENT count1 , count0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] [ 0 ] = count1 NEW_LINE left [ i ] [ 1 ] = count0 NEW_LINE if ( binary [ i ] ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT DEDENT binary = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( binary ) NEW_LINE left = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE preCalculate ( binary , n , left ) NEW_LINE queries = [ 0 , 1 , 2 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( left [ queries [ i ] ] [ 0 ] , \" ones \" , left [ queries [ i ] ] [ 1 ] , \" zeros \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to answer the number of ones and zero to the left of given index | Function to pre - calculate the left [ ] array ; Iterate in the binary array ; Initialize the number of 1 and 0 ; Increase the count ; Driver code ; Queries ; Solve queries",
        "Category": "Array"
    },
    {
        "ID": "3895-3895",
        "Code": "MAX = 1001 NEW_LINE prefix = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE ar = [ 0 for i in range ( MAX ) ] NEW_LINE def cal_prefix ( n , arr ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ar [ i + 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , 1001 , 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT prefix [ i ] [ j ] = 0 NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ar [ j ] <= i : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + k NEW_LINE DEDENT DEDENT DEDENT def ksub ( l , r , n , k ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = 1000 NEW_LINE while ( lo + 1 < hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = lo NEW_LINE DEDENT return hi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 3 , 5 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE cal_prefix ( n , arr ) NEW_LINE queries = [ [ 1 , n , 1 ] , [ 2 , n - 2 , 2 ] , [ 3 , n - 1 , 3 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Given an array and two integers l and r , find the kth largest element in the range [ l , r ] | Python3 implementation of the approach ; Function to calculate the prefix ; Creating one based indexing ; Initializing and creating prefix array ; Creating a prefix array for every possible value in a given range ; Function to return the kth largest element in the index range [ l , r ] ; Binary searching through the 2d array and only checking the range in which the sub array is a part ; Driver code ; Creating the prefix array for the given array ; Queries ; Perform queries",
        "Category": "Binary Search"
    },
    {
        "ID": "3896-3896",
        "Code": "MAX_SIZE = 1000 NEW_LINE lookup_table = [ 0 ] * MAX_SIZE NEW_LINE def create_table ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE co = 0 NEW_LINE while True : NEW_LINE INDENT pow <<= 1 NEW_LINE lookup_table [ co ] = ( n + ( pow >> 1 ) ) // pow NEW_LINE if lookup_table [ co ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT co += 1 NEW_LINE DEDENT DEDENT def binary ( arr , v ) : NEW_LINE INDENT index = lookup_table [ 0 ] - 1 NEW_LINE co = 0 NEW_LINE while lookup_table [ co ] != 0 : NEW_LINE INDENT if v == arr [ index ] : NEW_LINE INDENT return index NEW_LINE DEDENT elif v < arr [ index ] : NEW_LINE INDENT co += 1 NEW_LINE index -= lookup_table [ co ] NEW_LINE DEDENT else : NEW_LINE INDENT co += 1 NEW_LINE index += lookup_table [ co ] NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE create_table ( n ) NEW_LINE print ( \" Position ▁ of ▁ 3 ▁ in ▁ array ▁ = ▁ \" , binary ( arr , 3 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Uniform Binary Search | Python3 implementation of above approach ; lookup table ; create the lookup table for an array of length n ; power and count variable ; multiply by 2 ; initialize the lookup table ; binary search ; mid point of the array ; count ; if the value is found ; if value is less than the mid value ; if value is greater than the mid value ; main function ; create the lookup table ; print the position of the array",
        "Category": "Binary Search"
    },
    {
        "ID": "3898-3898",
        "Code": "def equiSumUtil ( arr , pos1 , pos2 ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE pre = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE pre [ i ] = sum ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE suf [ i ] = sum ; NEW_LINE DEDENT total_sum = sum ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i < j - 1 ) : NEW_LINE INDENT if ( pre [ i ] == total_sum // 3 ) : NEW_LINE INDENT pos1 = i ; NEW_LINE DEDENT if ( suf [ j ] == total_sum // 3 ) : NEW_LINE INDENT pos2 = j ; NEW_LINE DEDENT if ( pos1 != - 1 and pos2 != - 1 ) : NEW_LINE INDENT if ( suf [ pos1 + 1 ] - suf [ pos2 ] == total_sum // 3 ) : NEW_LINE INDENT return [ True , pos1 , pos2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT return [ False , pos1 , pos2 ] ; NEW_LINE DEDENT DEDENT if ( pre [ i ] < suf [ j ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT DEDENT return [ False , pos1 , pos2 ] ; NEW_LINE DEDENT def equiSum ( arr ) : NEW_LINE INDENT pos1 = - 1 ; NEW_LINE pos2 = - 1 ; NEW_LINE ans = equiSumUtil ( arr , pos1 , pos2 ) ; NEW_LINE pos1 = ans [ 1 ] ; NEW_LINE pos2 = ans [ 2 ] ; NEW_LINE if ( ans [ 0 ] ) : NEW_LINE INDENT print ( \" First ▁ Segment ▁ : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( pos1 + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Second ▁ Segment ▁ : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( pos1 + 1 , pos2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE print ( \" Third ▁ Segment ▁ : ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( pos2 , len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT println ( \" Array ▁ cannot ▁ be ▁ divided ▁ into \" , \" three ▁ equal ▁ sum ▁ segments \" ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 ] ; NEW_LINE equiSum ( arr ) ; NEW_LINE",
        "Type": "py",
        "NL": "Partition the array into three equal sum segments | This function returns true if the array can be divided into three equal sum segments ; Prefix Sum Array ; Suffix Sum Array ; Stores the total sum of the array ; We can also take pre [ pos2 - 1 ] - pre [ pos1 ] == total_sum / 3 here . ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "3901-3901",
        "Code": "def findpair ( l , r ) : NEW_LINE INDENT ans1 = l NEW_LINE ans2 = 2 * l NEW_LINE print ( ans1 , \" , ▁ \" , ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a distinct pair ( x , y ) in given range such that x divides y | Function to return the possible pair ; ans1 , ans2 store value of x and y respectively ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "3910-3910",
        "Code": "def findRing ( arr , x ) : NEW_LINE INDENT if arr [ 0 ] [ 0 ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l , r = 0 , ( n + 1 ) // 2 - 1 NEW_LINE if n % 2 == 1 and arr [ r ] [ r ] < x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n % 2 == 0 and arr [ r + 1 ] [ r ] < x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while l < r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ mid ] [ mid ] <= x : NEW_LINE INDENT if ( mid == ( n + 1 ) // 2 - 1 or arr [ mid + 1 ] [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def binarySearchRowInc ( arr , row , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ row ] [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ row ] [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def binarySearchColumnInc ( arr , col , t , b , x ) : NEW_LINE INDENT while t <= b : NEW_LINE INDENT mid = ( t + b ) // 2 NEW_LINE if arr [ mid ] [ col ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] [ col ] < x : NEW_LINE INDENT t = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT b = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def binarySearchRowDec ( arr , row , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ row ] [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ row ] [ mid ] < x : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def binarySearchColumnDec ( arr , col , t , b , x ) : NEW_LINE INDENT while t <= b : NEW_LINE INDENT mid = ( t + b ) // 2 NEW_LINE if arr [ mid ] [ col ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] [ col ] < x : NEW_LINE INDENT b = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def spiralBinary ( arr , x ) : NEW_LINE INDENT f1 = findRing ( arr , x ) NEW_LINE r , c = None , None NEW_LINE if f1 == - 1 : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT if n % 2 == 1 and f1 == ( n + 1 ) // 2 - 1 : NEW_LINE INDENT print ( f1 , f1 ) NEW_LINE return NEW_LINE DEDENT if x < arr [ f1 ] [ n - f1 - 1 ] : NEW_LINE INDENT c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) NEW_LINE r = f1 NEW_LINE DEDENT elif x < arr [ n - f1 - 1 ] [ n - f1 - 1 ] : NEW_LINE INDENT c = n - f1 - 1 NEW_LINE r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) NEW_LINE DEDENT elif x < arr [ n - f1 - 1 ] [ f1 ] : NEW_LINE INDENT c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) NEW_LINE r = n - f1 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) NEW_LINE c = f1 NEW_LINE DEDENT if c == - 1 or r == - 1 : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { 0 } ▁ { 1 } \" . format ( r , c ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ [ 1 , 2 , 3 , 4 ] , [ 12 , 13 , 14 , 5 ] , [ 11 , 16 , 15 , 6 ] , [ 10 , 9 , 8 , 7 ] ] NEW_LINE spiralBinary ( arr , 7 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Search element in a Spirally sorted Matrix | Function to return the ring , the number x belongs to . ; Returns - 1 if number x is smaller than least element of arr ; l and r represent the diagonal elements to search in ; Returns - 1 if number x is greater than the largest element of arr ; Function to perform binary search on an array sorted in increasing order l and r represent the left and right index of the row to be searched ; Function to perform binary search on a particular column of the 2D array t and b represent top and bottom rows ; Function to perform binary search on an array sorted in decreasing order ; Function to perform binary search on a particular column of the 2D array ; Function to find the position of the number x ; Finding the ring ; To store row and column ; Edge case if n is odd ; Check which of the 4 sides , the number x lies in ; Printing the position ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3911-3911",
        "Code": "def minIndex ( arr , n , pos ) : NEW_LINE INDENT num = arr [ pos ] NEW_LINE i = pos - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return i + 1 NEW_LINE DEDENT arr = [ 2 , 1 , 1 , 1 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE pos = 4 NEW_LINE print ( minIndex ( arr , n , pos ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum index i such that all the elements from index i to given index are equal | Function to return the minimum required index ; Start from arr [ pos - 1 ] ; All elements are equal from arr [ i + 1 ] to arr [ pos ] ; Driver code ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "3912-3912",
        "Code": "def minIndex ( arr , pos ) : NEW_LINE INDENT low = 0 NEW_LINE high = pos NEW_LINE i = pos NEW_LINE while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] != arr [ pos ] : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE i = mid NEW_LINE if mid > 0 and arr [ mid - 1 ] != arr [ pos ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return low if arr [ low ] == arr [ pos ] else i NEW_LINE DEDENT arr = [ 2 , 1 , 1 , 1 , 5 , 2 ] NEW_LINE",
        "Type": "py",
        "NL": "Minimum index i such that all the elements from index i to given index are equal | Function to return the minimum required index ; Short - circuit more comparisions as found the border point ; For cases were high = low + 1 and arr [ high ] will match with arr [ pos ] but not arr [ low ] or arr [ mid ] . In such iteration the if condition will satisfy and loop will break post that low will be updated . Hence i will not point to the correct index . ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3926-3926",
        "Code": "def nameRank ( names , marks , updates , n ) : NEW_LINE INDENT x = [ [ 0 for j in range ( 3 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] [ 0 ] = names [ i ] NEW_LINE x [ i ] [ 1 ] = marks [ i ] + updates [ i ] NEW_LINE x [ i ] [ 2 ] = i + 1 NEW_LINE DEDENT highest = x [ 0 ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( x [ j ] [ 1 ] >= highest [ 1 ] ) : NEW_LINE INDENT highest = x [ j ] NEW_LINE DEDENT DEDENT print ( \" Name : ▁ \" , highest [ 0 ] , \" , ▁ Jump : ▁ \" , abs ( highest [ 2 ] - 1 ) , sep = \" \" ) NEW_LINE DEDENT names = [ \" sam \" , \" ram \" , \" geek \" ] NEW_LINE marks = [ 80 , 79 , 75 ] NEW_LINE updates = [ 0 , 5 , - 9 ] NEW_LINE n = len ( marks ) NEW_LINE nameRank ( names , marks , updates , n ) NEW_LINE",
        "Type": "py",
        "NL": "Jump in rank of a student after updating marks | Function to print the name of student who stood first after updation in rank ; Array of students ; Store the name of the student ; Update the marks of the student ; Store the current rank of the student ; Print the name and jump in rank ; Names of the students ; Marks of the students ; Updates that are to be done ; Number of students",
        "Category": "Array"
    },
    {
        "ID": "3928-3928",
        "Code": "def findMinDifference ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT min__ = secondMax = arr [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT min__ = secondMax = arr [ 1 ] NEW_LINE DEDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT max__ = secondMin = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max__ = secondMin = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max__ ) : NEW_LINE INDENT secondMax = max__ NEW_LINE max__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min__ ) : NEW_LINE INDENT secondMin = min__ NEW_LINE min__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max__ - secondMin , secondMax - min__ ) NEW_LINE return diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize the maximum minimum difference after one removal from array | Function to return the minimum required difference ; If current element is greater than max ; max will become secondMax ; Update the max ; If current element is greater than secondMax but smaller than max ; Update the secondMax ; If current element is smaller than min ; min will become secondMin ; Update the min ; If current element is smaller than secondMin but greater than min ; Update the secondMin ; Minimum of the two possible differences ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "3929-3929",
        "Code": "def minimal ( a , n ) : NEW_LINE INDENT lo , hi = 0 , n - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if a [ mid ] < a [ mid + 1 ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT return lo NEW_LINE return lo NEW_LINE DEDENT DEDENT a = [ 8 , 5 , 4 , 3 , 4 , 10 ] NEW_LINE n = len ( a ) NEW_LINE ind = minimal ( a , n ) NEW_LINE print ( a [ ind ] ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum in an array which is first decreasing then increasing | function to find the smallest number 's index ; Do a binary search ; find the mid element ; Check for break point ; Return the index ; Driver code ; print the smallest number",
        "Category": "Binary Search"
    },
    {
        "ID": "3930-3930",
        "Code": "def checkDistinct ( x ) : NEW_LINE INDENT last = x % 10 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x % 10 != last ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( checkDistinct ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Integers from the range that are composed of a single distinct digit | Boolean function to check distinct digits of a number ; Take last digit ; Check if all other digits are same as last digit ; Remove last digit ; Function to return the count of integers that are composed of a single distinct digit only ; If i has single distinct digit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "3931-3931",
        "Code": "def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L // pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R // pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Integers from the range that are composed of a single distinct digit | Function to return the count of digits of a number ; Function to return a number that contains only digit ' d ' repeated exactly count times ; Function to return the count of integers that are composed of a single distinct digit only ; Count of digits in L and R ; First digits of L and R ; If L has lesser number of digits than R ; If the number that starts with firstDigitL and has number of digits = countDigitsL is within the range include the number ; Exclude the number ; If the number that starts with firstDigitR and has number of digits = countDigitsR is within the range include the number ; Exclude the number ; If both L and R have equal number of digits ; Include the number greater than L upto the maximum number whose digit = coutDigitsL ; Exclude the numbers which are greater than R ; Return the count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "3933-3933",
        "Code": "def findIndices ( arr , n ) : NEW_LINE INDENT leftMin , rightMin = 0 , 0 NEW_LINE leftMax , rightMax = 0 , 0 NEW_LINE min_element = arr [ 0 ] NEW_LINE max_element = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT leftMin = rightMin = i NEW_LINE min_element = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] == min_element ) : NEW_LINE INDENT rightMin = i NEW_LINE DEDENT if ( arr [ i ] > max_element ) : NEW_LINE INDENT leftMax = rightMax = i NEW_LINE max_element = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] == max_element ) : NEW_LINE INDENT rightMax = i NEW_LINE DEDENT DEDENT print ( \" Minimum ▁ left ▁ : ▁ \" , leftMin ) NEW_LINE print ( \" Minimum ▁ right ▁ : ▁ \" , rightMin ) NEW_LINE print ( \" Maximum ▁ left ▁ : ▁ \" , leftMax ) NEW_LINE print ( \" Maximum ▁ right ▁ : ▁ \" , rightMax ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findIndices ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Leftmost and rightmost indices of the maximum and the minimum element of an array | Python3 implementation of the approach ; If found new minimum ; If arr [ i ] = min then rightmost index for min will change ; If found new maximum ; If arr [ i ] = max then rightmost index for max will change ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "3934-3934",
        "Code": "def getRightMin ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE rightMin = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == min ) : NEW_LINE INDENT rightMin = i NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT i = rightMin + 1 NEW_LINE while ( i < n and arr [ i ] == min ) : NEW_LINE INDENT rightMin = i NEW_LINE i += 1 NEW_LINE DEDENT return rightMin NEW_LINE DEDENT def getLeftMax ( arr , n ) : NEW_LINE INDENT max = arr [ n - 1 ] NEW_LINE leftMax = n - 1 NEW_LINE i = n - 2 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] == max ) : NEW_LINE INDENT leftMax = i NEW_LINE DEDENT i = int ( i / 2 ) NEW_LINE DEDENT i = leftMax - 1 NEW_LINE while ( i >= 0 and arr [ i ] == max ) : NEW_LINE INDENT leftMax = i NEW_LINE i -= 1 NEW_LINE DEDENT return leftMax NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ left ▁ : \" , 0 ) NEW_LINE print ( \" Minimum ▁ right ▁ : \" , getRightMin ( arr , n ) ) NEW_LINE print ( \" Maximum ▁ left ▁ : \" , getLeftMax ( arr , n ) ) NEW_LINE print ( \" Maximum ▁ right ▁ : \" , ( n - 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Leftmost and rightmost indices of the maximum and the minimum element of an array | Function to return the index of the rightmost minimum element from the array ; First element is the minimum in a sorted array ; While the elements are equal to the minimum update rightMin ; Final check whether there are any elements which are equal to the minimum ; Function to return the index of the leftmost maximum element from the array ; Last element is the maximum in a sorted array ; While the elements are equal to the maximum update leftMax ; Final check whether there are any elements which are equal to the maximum ; Driver code ; First element is the leftmost minimum in a sorted array ; Last element is the rightmost maximum in a sorted array",
        "Category": "Array"
    },
    {
        "ID": "3935-3935",
        "Code": "MAX = 1000001 NEW_LINE MAX_sqrt = MAX ** ( 0.5 ) NEW_LINE primeUpto = [ 0 ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) NEW_LINE isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( MAX_sqrt ) ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ( N - ans + 1 ) if ans else 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers < = N whose difference with the count of primes upto them is > = K | Python3 implementation of the above approach ; primeUpto [ i ] denotes count of prime numbers upto i ; Function to compute all prime numbers and update primeUpto array ; 0 and 1 are not primes ; If i is prime ; Set all multiples of i as non - prime ; Compute primeUpto array ; Function to return the count of valid numbers ; Compute primeUpto array ; Check if the number is valid , try to reduce it ; ans is the minimum valid number ; Driver Code",
        "Category": "SieveOfEratosthenes is used in the code to compute prime numbers and populate the primeUpto array, which keeps track of the count of primes up to each number. This is a classic example of the **Sieve of Er"
    },
    {
        "ID": "3955-3955",
        "Code": "M = 3 NEW_LINE N = 4 NEW_LINE def binarySearch1D ( arr , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = N - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + int ( ( high - low ) / 2 ) NEW_LINE if ( arr [ mid ] == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ mid ] < K ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def searchMatrix ( matrix , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = M - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + int ( ( high - low ) / 2 ) NEW_LINE if ( K >= matrix [ mid ] [ 0 ] and K <= matrix [ mid ] [ N - 1 ] ) : NEW_LINE INDENT return binarySearch1D ( matrix [ mid ] , K ) NEW_LINE DEDENT if ( K < matrix [ mid ] [ 0 ] ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT matrix = [ [ 1 , 3 , 5 , 7 ] , [ 10 , 11 , 16 , 20 ] , [ 23 , 30 , 34 , 50 ] ] NEW_LINE K = 3 NEW_LINE if ( searchMatrix ( matrix , K ) ) : NEW_LINE INDENT print ( \" Found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ found \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Search in a sorted 2D matrix ( Stored in row major order ) | Python 3 program to find whether a given element is present in the given 2 - D matrix ; Basic binary search to find an element in a 1 - D array ; if element found return true ; if middle less than K then skip the left part of the array else skip the right part ; if not found return false ; Function to search an element in a matrix based on Divide and conquer approach ; if the element lies in the range of this row then call 1 - D binary search on this row ; if the element is less then the starting element of that row then search in upper rows else search in the lower rows ; if not found ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3957-3957",
        "Code": "def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ] NEW_LINE n = len ( a ) NEW_LINE x = 13 NEW_LINE print ( countSegments ( a , n , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of segments where all elements are greater than X | Function to count number of segments ; Iterate in the array ; check if array element greater then X or not ; if flag is true ; After iteration complete check for the last segment ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "3968-3968",
        "Code": "def numberOfElements ( height , n ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE coun = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max_so_far : NEW_LINE INDENT max_so_far = height [ i ] NEW_LINE coun = coun + 1 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE height = [ 4 , 8 , 2 , 0 , 0 , 5 ] NEW_LINE print ( numberOfElements ( height , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of elements that can be seen from right side | Python3 program to find number of elements that can be seen from right side ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "3971-3971",
        "Code": "def findPairs ( arr , size ) : NEW_LINE INDENT Map = { } NEW_LINE for i in range ( 0 , size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE if Sum in Map : NEW_LINE INDENT for pair in Map [ Sum ] : NEW_LINE INDENT m , n = pair NEW_LINE if ( ( m != i and m != j ) and ( n != i and n != j ) ) : NEW_LINE INDENT print ( \" Pair ▁ First ▁ ( { } , ▁ { } ) \" . format ( arr [ i ] , arr [ j ] ) ) NEW_LINE print ( \" Pair ▁ Second ▁ ( { } , ▁ { } ) \" . format ( arr [ m ] , arr [ n ] ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if Sum not in Map : NEW_LINE INDENT Map [ Sum ] = [ ] NEW_LINE DEDENT Map [ Sum ] . append ( ( i , j ) ) NEW_LINE DEDENT DEDENT print ( \" No ▁ such ▁ non - overlapping ▁ pairs ▁ present \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 4 , 7 , 8 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE findPairs ( arr , size ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find two non | Function to find two non - overlapping with same Sum in an array ; first create an empty Map key -> which is Sum of a pair of elements in the array value -> vector storing index of every pair having that Sum ; consider every pair ( arr [ i ] , arr [ j ] ) and where ( j > i ) ; calculate Sum of current pair ; if Sum is already present in the Map ; check every pair having equal Sum ; if pairs don 't overlap,  print them and return ; Insert current pair into the Map ; If no such pair found ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3972-3972",
        "Code": "def kthSmallestLargest ( arr , n , k ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT hash = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT while ( hash [ i ] > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT hash [ i ] -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 6 , 2 , 9 , 4 , 3 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( \" kth ▁ smallest ▁ number ▁ is : \" , kthSmallestLargest ( arr , n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "kth smallest / largest in a small range unsorted array | Python 3 program of kth smallest / largest in a small range unsorted array ; Storing counts of elements ; Traverse hash array build above until we reach k - th smallest element . ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3979-3979",
        "Code": "def majorityInMatrix ( arr ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 7 ) } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT countMajority = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value >= ( int ( ( N * M ) / 2 ) ) ) : NEW_LINE INDENT countMajority += 1 NEW_LINE DEDENT DEDENT return countMajority NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 2 ] , [ 1 , 3 , 2 ] , [ 1 , 2 , 6 ] ] NEW_LINE print ( majorityInMatrix ( mat ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count majority element in a matrix | Function to find count of all majority elements in a Matrix ; Store frequency of elements in matrix ; loop to iteratre through map ; check if frequency is greater than or equal to ( N * M ) / 2 ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "3980-3980",
        "Code": "def getMin ( arr , n ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def getMax ( arr , n ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( arr , n ) : NEW_LINE INDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE return min + max NEW_LINE DEDENT def findProduct ( arr , n ) : NEW_LINE INDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE return min * max NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 1234 , 45 , 67 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum ▁ = ▁ \" , findSum ( arr , n ) ) NEW_LINE print ( \" Product ▁ = ▁ \" , findProduct ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum and Product of minimum and maximum element of an Array | Function to find minimum element ; Function to find maximum element ; Function to get Sum ; Function to get product ; Driver Code ; Sum of min and max element ; Product of min and max element",
        "Category": "Array"
    },
    {
        "ID": "3982-3982",
        "Code": "N = 4 NEW_LINE M = 4 NEW_LINE def isPairWithDiff ( mat , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if mat [ i ] [ j ] > k : NEW_LINE INDENT m = mat [ i ] [ j ] - k NEW_LINE if m in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m = k - mat [ i ] [ j ] NEW_LINE if m in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s . add ( mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n , m = 4 , 4 NEW_LINE mat = [ [ 5 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 100 ] ] NEW_LINE k = 85 NEW_LINE if isPairWithDiff ( mat , k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a pair with given absolute difference exists in a Matrix | Python 3 program to check for pairs with given difference exits in the matrix or not ; Function to check if a pair with given difference exist in the matrix ; Store elements in a hash ; Loop to iterate over the elements of the matrix ; Input matrix ; given difference",
        "Category": "Hash Table"
    },
    {
        "ID": "3984-3984",
        "Code": "import math NEW_LINE def bsearch ( A , key_to_search ) : NEW_LINE INDENT n = len ( A ) NEW_LINE lg = int ( math . log2 ( n - 1 ) ) + 1 ; NEW_LINE pos = 0 NEW_LINE for i in range ( lg - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ pos ] == key_to_search ) : NEW_LINE INDENT return pos NEW_LINE DEDENT new_pos = pos | ( 1 << i ) NEW_LINE if ( ( new_pos < n ) and ( A [ new_pos ] <= key_to_search ) ) : NEW_LINE INDENT pos = new_pos NEW_LINE DEDENT DEDENT return ( pos if ( A [ pos ] == key_to_search ) else - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ - 2 , 10 , 100 , 250 , 32315 ] NEW_LINE print ( bsearch ( A , 10 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Meta Binary Search | One | Function to show the working of Meta binary search ; Set number of bits to represent ; largest array index while ( ( 1 << lg ) < n - 1 ) : lg += 1 ; Incrementally construct the index of the target value ; find the element in one direction and update position ; if element found return pos otherwise - 1 ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "3985-3985",
        "Code": "N = 6 NEW_LINE Tree = [ 0 ] * ( 6 * N ) NEW_LINE for i in range ( 6 * N ) : NEW_LINE INDENT Tree [ i ] = set ( ) NEW_LINE DEDENT def buildTree ( arr : list , idx : int , s : int , e : int ) -> None : NEW_LINE INDENT global Tree NEW_LINE if s == e : NEW_LINE INDENT Tree [ idx ] . add ( arr [ s ] ) NEW_LINE return NEW_LINE DEDENT mid = ( s + e ) // 2 NEW_LINE buildTree ( arr , 2 * idx , s , mid ) NEW_LINE buildTree ( arr , 2 * idx + 1 , mid + 1 , e ) NEW_LINE for it in Tree [ 2 * idx ] : NEW_LINE INDENT Tree [ idx ] . add ( it ) NEW_LINE DEDENT for it in Tree [ 2 * idx + 1 ] : NEW_LINE INDENT Tree [ idx ] . add ( it ) NEW_LINE DEDENT DEDENT def query ( idx : int , s : int , e : int , qs : int , qe : int , x : int ) -> bool : NEW_LINE INDENT global Tree NEW_LINE if qs <= s and e <= qe : NEW_LINE INDENT if list ( Tree [ idx ] ) . count ( x ) != 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if qe < s or e < qs : NEW_LINE INDENT return False NEW_LINE DEDENT mid = ( s + e ) // 2 NEW_LINE leftAns = query ( 2 * idx , s , mid , qs , qe , x ) NEW_LINE rightAns = query ( 2 * idx + 1 , mid + 1 , e , qs , qe , x ) NEW_LINE return ( leftAns or rightAns ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 9 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE buildTree ( arr , 1 , 0 , n - 1 ) NEW_LINE l = 0 NEW_LINE r = 3 NEW_LINE x = 2 NEW_LINE if query ( 1 , 0 , n - 1 , l , r , x ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT l = 2 NEW_LINE r = 5 NEW_LINE x = 3 NEW_LINE if query ( 1 , 0 , n - 1 , l , r , x ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Queries to check whether a given digit is present in the given Range | Python3 program to answer Queries to check whether a given digit is present in the given range ; Segment Tree with set at each node ; Funtiom to build the segment tree ; Left child node ; Right child node ; Merging child nodes to get parent node . Since set is used , it will remove redundant digits . ; Function to query a range ; Complete Overlapp condition return true if digit is present . else false . ; No Overlapp condition Return false ; If digit is found in any child return true , else False ; Driver Code ; Build the tree ; Query 1 ; Query 2",
        "Category": "Segment Tree"
    },
    {
        "ID": "4002-4002",
        "Code": "def deleteElement ( A , L , R , N ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i <= L or i >= R : NEW_LINE INDENT A [ j ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ] NEW_LINE L , R = 2 , 7 NEW_LINE n = len ( A ) NEW_LINE res_size = deleteElement ( A , L , R , n ) NEW_LINE for i in range ( res_size ) : NEW_LINE INDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Delete array element in given index range [ L | Function to delete L to R element ; Return size of Array after delete element ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4004-4004",
        "Code": "def search ( arr , n , x ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res = i NEW_LINE DEDENT DEDENT if ( res == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = arr [ res ] NEW_LINE i = res NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = temp NEW_LINE return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 ] NEW_LINE q = [ 63 , 63 , 86 , 63 , 78 ] NEW_LINE n = len ( arr ) NEW_LINE m = len ( q ) NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( search ( arr , n , q [ i ] ) ) : NEW_LINE INDENT print ( \" Yes \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Reallocation of elements based on Locality of Reference | A function to perform sequential search . ; Linearly search the element ; If not found ; Shift elements before one position ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4016-4016",
        "Code": "import math NEW_LINE def findFirst ( arr , n , x ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ptr = lowerBound ( arr , 0 , n , x ) NEW_LINE return 1 if ( ptr != x ) else ( ptr - arr ) NEW_LINE DEDENT def lowerBound ( a , low , high , element ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT middle = low + ( high - low ) // 2 NEW_LINE if ( element > a [ middle ] ) : NEW_LINE INDENT low = middle + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = middle NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 20 NEW_LINE arr = [ 10 , 30 , 20 , 50 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findFirst ( arr , n , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find index of first occurrence when an unsorted array is sorted | Python3 program to find index of first occurrence of x when array is sorted . ; lower_bound returns iterator pointing to first element that does not compare less to x . ; If x is not present return - 1. ;  ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "402-402",
        "Code": "n = 8 NEW_LINE def isSafe ( x , y , board ) : NEW_LINE INDENT if ( x >= 0 and y >= 0 and x < n and y < n and board [ x ] [ y ] == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def printSolution ( n , board ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( board [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def solveKT ( n ) : NEW_LINE INDENT board = [ [ - 1 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE move_x = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE move_y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE board [ 0 ] [ 0 ] = 0 NEW_LINE pos = 1 NEW_LINE if ( not solveKTUtil ( n , board , 0 , 0 , move_x , move_y , pos ) ) : NEW_LINE INDENT print ( \" Solution ▁ does ▁ not ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT printSolution ( n , board ) NEW_LINE DEDENT DEDENT def solveKTUtil ( n , board , curr_x , curr_y , move_x , move_y , pos ) : NEW_LINE INDENT if ( pos == n ** 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 8 ) : NEW_LINE INDENT new_x = curr_x + move_x [ i ] NEW_LINE new_y = curr_y + move_y [ i ] NEW_LINE if ( isSafe ( new_x , new_y , board ) ) : NEW_LINE INDENT board [ new_x ] [ new_y ] = pos NEW_LINE if ( solveKTUtil ( n , board , new_x , new_y , move_x , move_y , pos + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT board [ new_x ] [ new_y ] = - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solveKT ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "The Knight 's tour problem | Backtracking | Python3 program to solve Knight Tour problem using Backtracking Chessboard Size ; A utility function to check if i , j are valid indexes for N * N chessboard ; A utility function to print Chessboard matrix ; This function solves the Knight Tour problem using Backtracking . This function mainly uses solveKTUtil ( ) to solve the problem . It returns false if no complete tour is possible , otherwise return true and prints the tour . Please note that there may be more than one solutions , this function prints one of the feasible solutions . ; Initialization of Board matrix ; move_x and move_y define next move of Knight . move_x is for next value of x coordinate move_y is for next value of y coordinate ; Since the Knight is initially at the first block ; Checking if solution exists or not ; A recursive utility function to solve Knight Tour problem ; Try all next moves from the current coordinate x , y ; Backtracking ; Driver Code ; Function Call",
        "Category": "Backtracking"
    },
    {
        "ID": "4032-4032",
        "Code": "def pairedElements ( arr , sum ) : NEW_LINE INDENT low = 0 ; NEW_LINE high = len ( arr ) - 1 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( arr [ low ] + arr [ high ] == sum ) : NEW_LINE INDENT print ( \" The ▁ pair ▁ is ▁ : ▁ ( \" , arr [ low ] , \" , ▁ \" , arr [ high ] , \" ) \" ) ; NEW_LINE DEDENT if ( arr [ low ] + arr [ high ] > sum ) : NEW_LINE INDENT high -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low += 1 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , - 2 , 6 , 8 , 9 , 11 ] ; NEW_LINE arr . sort ( ) ; NEW_LINE pairedElements ( arr , 6 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all pairs with given sum | Python3 program for the above approach ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "4046-4046",
        "Code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" geeksforgeeks \" ; NEW_LINE result = s2 . endswith ( s1 ) ; NEW_LINE if ( result ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string is suffix of another | Python3 program to find if a string is suffix of another ; Test case - sensitive implementation of endsWith function",
        "Category": "Substring"
    },
    {
        "ID": "4054-4054",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , length = None , suffixEdge = None ) : NEW_LINE INDENT self . start = None NEW_LINE self . end = None NEW_LINE self . length = length NEW_LINE self . insertionEdge = [ 0 ] * 26 NEW_LINE self . suffixEdge = suffixEdge NEW_LINE DEDENT tree = [ Node ( ) for i in range ( MAXN ) ] NEW_LINE currNode , ptr = 1 , 2 NEW_LINE tree [ 1 ] = root1 NEW_LINE tree [ 2 ] = root2 NEW_LINE s = \" forgeeksskeegfor \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT insert ( i ) NEW_LINE DEDENT DEDENT def insert ( currIndex ) : NEW_LINE INDENT global currNode , ptr NEW_LINE temp = currNode NEW_LINE while True : NEW_LINE INDENT currLength = tree [ temp ] . length NEW_LINE if ( currIndex - currLength >= 1 and ( s [ currIndex ] == s [ currIndex - currLength - 1 ] ) ) : NEW_LINE INDENT break NEW_LINE DEDENT temp = tree [ temp ] . suffixEdge NEW_LINE DEDENT if tree [ temp ] . insertionEdge [ ord ( s [ currIndex ] ) - ord ( ' a ' ) ] != 0 : NEW_LINE INDENT currNode = tree [ temp ] . insertionEdge [ ord ( s [ currIndex ] ) - ord ( ' a ' ) ] NEW_LINE return NEW_LINE DEDENT ptr += 1 NEW_LINE tree [ temp ] . insertionEdge [ ord ( s [ currIndex ] ) - ord ( ' a ' ) ] = ptr NEW_LINE tree [ ptr ] . end = currIndex NEW_LINE tree [ ptr ] . length = tree [ temp ] . length + 2 NEW_LINE tree [ ptr ] . start = ( tree [ ptr ] . end - tree [ ptr ] . length + 1 ) NEW_LINE currNode = ptr NEW_LINE temp = tree [ temp ] . suffixEdge NEW_LINE if tree [ currNode ] . length == 1 : NEW_LINE INDENT tree [ currNode ] . suffixEdge = 2 NEW_LINE return NEW_LINE DEDENT while True : NEW_LINE INDENT currLength = tree [ temp ] . length NEW_LINE if ( currIndex - currLength >= 1 and s [ currIndex ] == s [ currIndex - currLength - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT temp = tree [ temp ] . suffixEdge NEW_LINE DEDENT tree [ currNode ] . suffixEdge = tree [ temp ] . insertionEdge [ ord ( s [ currIndex ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT MAXN = 1000 NEW_LINE root1 = Node ( - 1 , 1 ) NEW_LINE root2 = Node ( 0 , 1 ) NEW_LINE last = ptr NEW_LINE for i in range ( tree [ last ] . start , tree [ last ] . end + 1 ) : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Longest Palindromic Substring using Palindromic Tree | Set 3 | Python3 code for Longest Palindromic substring using Palindromic Tree data structure ; store start and end indexes of current Node inclusively ; Stores length of substring ; stores insertion Node for all characters a - z ; stores the Maximum Palindromic Suffix Node for the current Node ; Stores Node information for constant time access ; Keeps track the Current Node while insertion ; Function to insert edge in tree ; Finding X , such that s [ currIndex ] + X + s [ currIndex ] is palindrome . ; Check if s [ currIndex ] + X + s [ currIndex ] is already Present in tree . ; Else Create new node ; Setting suffix edge for newly Created Node . ; Longest Palindromic suffix for a string of length 1 is a Null string . ; Else ; Driver code ; Imaginary root 's suffix edge points to   itself, since for an imaginary string   of length = -1 has an imaginary suffix   string. Imaginary root. ; NULL root 's suffix edge points to   Imaginary root, since for a string of   length = 0 has an imaginary suffix string.  ; last will be the index of our last substring",
        "Category": "Substring"
    },
    {
        "ID": "4055-4055",
        "Code": "MAX_STR_LEN = 1000 ; NEW_LINE P = [ [ 0 for x in range ( MAX_STR_LEN ) ] for y in range ( MAX_STR_LEN ) ] ; NEW_LINE for i in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT for j in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT P [ i ] [ j ] = False ; NEW_LINE DEDENT DEDENT Kpal = [ 0 ] * MAX_STR_LEN ; NEW_LINE def checkSubStrPal ( str , n ) : NEW_LINE INDENT global P , Kpal , MAX_STR_LEN ; NEW_LINE for i in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT for j in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT P [ i ] [ j ] = False ; NEW_LINE DEDENT Kpal [ i ] = 0 ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT P [ i ] [ i ] = True ; NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True ; NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 0 , n - gap ) : NEW_LINE INDENT j = gap + i ; NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def countKPalindromes ( i , j , k ) : NEW_LINE INDENT global Kpal , P ; NEW_LINE if ( i == j ) : NEW_LINE INDENT Kpal [ k ] = Kpal [ k ] + 1 ; NEW_LINE return ; NEW_LINE DEDENT if ( P [ i ] [ j ] == False ) : NEW_LINE INDENT return ; NEW_LINE DEDENT Kpal [ k ] = Kpal [ k ] + 1 ; NEW_LINE mid = int ( ( i + j ) / 2 ) ; NEW_LINE if ( ( j - i + 1 ) % 2 == 1 ) : NEW_LINE INDENT mid = mid - 1 ; NEW_LINE DEDENT countKPalindromes ( i , mid , k + 1 ) ; NEW_LINE DEDENT def printKPalindromes ( s ) : NEW_LINE INDENT global P , Kpal , MAX_STR_LEN ; NEW_LINE n = len ( s ) ; NEW_LINE checkSubStrPal ( s , n ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT countKPalindromes ( j , j + i , 1 ) ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Kpal [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT s = \" abacaba \" ; NEW_LINE printKPalindromes ( s ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count palindromic characteristics of a String | Python program which counts different palindromic characteristics of a string . ; function which checks whether a substr [ i . . j ] of a given is a palindrome or not . ; P [ i , j ] = True if substr [ i . . j ] is palindrome , else False ; palindrome of single length ; palindrome of length 2 ; Palindromes of length more then 2. This loop is similar to Matrix Chain Multiplication . We start with a gap of length 2 and fill P table in a way that gap between starting and ending indexes increases one by one by outer loop . ; Pick starting point for current gap ; Set ending point ; If current string is palindrome ; function which recursively counts if a str [ i . . j ] is a k - palindromic or not . ; terminating condition for a which is a k - palindrome . ; terminating condition for a which is not a k - palindrome . ; increases the counter for the if it is a k - palindrome . ; mid is middle pointer of the str [ i ... j ] . ; if length of which is ( j - i + 1 ) is odd than we have to subtract one from mid else if even then no change . ; if the is k - palindrome then we check if it is a ( k + 1 ) - palindrome or not by just sending any of one half of the to the Count_k_Palindrome def . ; Finding all palindromic substrings of given string ; counting k - palindromes for each and every sub of given string . . ; Output the number of K - palindromic substrings of a given string . ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "406-406",
        "Code": "def printSolution ( color ) : NEW_LINE INDENT print ( \" Solution ▁ Exists : \" \" ▁ Following ▁ are ▁ the ▁ assigned ▁ colors ▁ \" ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT print ( color [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def isSafe ( graph , color ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( i + 1 , 4 ) : NEW_LINE INDENT if ( graph [ i ] [ j ] and color [ j ] == color [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def graphColoring ( graph , m , i , color ) : NEW_LINE INDENT if ( i == 4 ) : NEW_LINE INDENT if ( isSafe ( graph , color ) ) : NEW_LINE INDENT printSolution ( color ) NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT color [ i ] = j NEW_LINE if ( graphColoring ( graph , m , i + 1 , color ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT color [ i ] = 0 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT graph = [ [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 , 0 ] , [ 1 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 0 ] , ] NEW_LINE m = 3 NEW_LINE color = [ 0 for i in range ( 4 ) ] NEW_LINE if ( not graphColoring ( graph , m , 0 , color ) ) : NEW_LINE INDENT print ( \" Solution ▁ does ▁ not ▁ exist \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "m Coloring Problem | Backtracking | A utility function to prsolution ; check if the colored graph is safe or not ; check for every edge ; This function solves the m Coloring problem using recursion . It returns false if the m colours cannot be assigned , otherwise , return true and prints assignments of colours to all vertices . Please note that there may be more than one solutions , this function prints one of the feasible solutions . ; if current index reached end ; if coloring is safe ; Prthe solution ; Assign each color from 1 to m ; Recur of the rest vertices ; Driver code ; Create following graph and test whether it is 3 colorable ( 3 ) -- - ( 2 ) | / | | / | | / | ( 0 ) -- - ( 1 ) ; Number of colors ; Initialize all color values as 0. This initialization is needed correct functioning of isSafe ( )",
        "Category": "Backtracking"
    },
    {
        "ID": "4062-4062",
        "Code": "def sortString ( st , n ) : NEW_LINE ' NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE new_str = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( st [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT new_str += chr ( i + ord ( ' a ' ) ) NEW_LINE arr [ i ] -= 1 NEW_LINE DEDENT DEDENT return new_str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" geeksforgeeks \" NEW_LINE n = len ( st ) NEW_LINE print ( sortString ( st , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort the given string using character search | Python 3 implementation to sort the given string without using any sorting technique ; A character array to store the no . of occurrences of each character between ' a ' to 'z ; to store the final sorted string ; To store each occurrence of character by relative indexing ; To traverse the character array and append it to new_str ; Driver program to test above",
        "Category": "Hash Table"
    },
    {
        "ID": "4065-4065",
        "Code": "N = 3 NEW_LINE def getGreatestSum ( a ) : NEW_LINE INDENT prev_max = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max < a [ N - 1 ] [ j ] ) : NEW_LINE INDENT prev_max = a [ N - 1 ] [ j ] NEW_LINE DEDENT DEDENT sum = prev_max NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr_max = - 2147483648 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max > a [ i ] [ j ] and a [ i ] [ j ] > curr_max ) : NEW_LINE INDENT curr_max = a [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( curr_max == - 2147483648 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev_max = curr_max NEW_LINE sum = sum + prev_max NEW_LINE DEDENT return sum NEW_LINE DEDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( getGreatestSum ( a ) ) NEW_LINE b = [ [ 4 , 5 , 6 ] , [ 4 , 5 , 6 ] , [ 4 , 5 , 6 ] ] NEW_LINE print ( getGreatestSum ( b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum sum of elements from each row in the matrix | Python Program to find row - wise maximum element sum considering elements in increasing order . ; Function to perform given task ; Getting the maximum element from last row ; Comparing it with the elements of above rows ; Maximum of current row . ; If we could not an element smaller than prev_max . ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "4070-4070",
        "Code": "import math NEW_LINE def occurrenceDays ( n , firstday ) : NEW_LINE INDENT days = [ \" Monday \" , \" Tuesday \" , \" Wednesday \" , \" Thursday \" , \" Friday \" , \" Saturday \" , \" Sunday \" ] NEW_LINE count = [ 4 for i in range ( 0 , 7 ) ] NEW_LINE pos = - 1 NEW_LINE for i in range ( 0 , 7 ) : NEW_LINE INDENT if ( firstday == days [ i ] ) : NEW_LINE INDENT pos = i NEW_LINE break NEW_LINE DEDENT DEDENT inc = n - 28 NEW_LINE for i in range ( pos , pos + inc ) : NEW_LINE INDENT if ( i > 6 ) : NEW_LINE INDENT count [ i % 7 ] = 5 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 5 NEW_LINE DEDENT DEDENT for i in range ( 0 , 7 ) : NEW_LINE INDENT print ( days [ i ] , \" ▁ \" , count [ i ] ) NEW_LINE DEDENT DEDENT n = 31 NEW_LINE firstday = \" Tuesday \" NEW_LINE occurrenceDays ( n , firstday ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number of times every day occurs in a month | Python program to count occurrence of days in a month ; function to find occurrences ; stores days in a week ; Initialize all counts as 4. ; find index of the first day ; number of days whose occurrence will be 5 ; mark the occurrence to be 5 of n - 28 days ; print the days ; driver program to test the above function",
        "Category": "Math"
    },
    {
        "ID": "4071-4071",
        "Code": "import math NEW_LINE def findElement ( n , k ) : NEW_LINE INDENT left = 1 NEW_LINE right = math . pow ( 2 , n ) - 1 NEW_LINE while 1 : NEW_LINE INDENT mid = int ( ( left + right ) / 2 ) NEW_LINE if k == mid : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT ans -= 1 NEW_LINE if k < mid : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE k = 8 NEW_LINE findElement ( n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Value of k | Python3 code to find k - th element after append and insert middle operations ; ans = n Middle element of the sequence ; length of the resulting sequence . ; Updating the middle element of next sequence ; Moving to the left side of the middle element . ; Moving to the right side of the middle element . ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "4072-4072",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def firstCommon ( head1 , head2 ) : NEW_LINE INDENT while ( head1 != None ) : NEW_LINE INDENT p = head2 NEW_LINE while ( p != None ) : NEW_LINE INDENT if ( p . data == head1 . data ) : NEW_LINE INDENT return head1 . data NEW_LINE DEDENT p = p . next NEW_LINE DEDENT head1 = head1 . next NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head1 = None NEW_LINE head1 = push ( head1 , 20 ) NEW_LINE head1 = push ( head1 , 5 ) NEW_LINE head1 = push ( head1 , 15 ) NEW_LINE head1 = push ( head1 , 10 ) NEW_LINE head2 = None NEW_LINE head2 = push ( head2 , 10 ) NEW_LINE head2 = push ( head2 , 2 ) NEW_LINE head2 = push ( head2 , 15 ) NEW_LINE head2 = push ( head2 , 8 ) NEW_LINE print ( firstCommon ( head1 , head2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "First common element in two linked lists | Python3 program to find first common element in two unsorted linked list ; Link list node ; A utility function to insert a node at the beginning of a linked list ; Returns the first repeating element in linked list ; Traverse through every node of first list ; If current node is present in second list ; If no common node ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "4084-4084",
        "Code": "def countCountries ( ans , N ) : NEW_LINE INDENT total_countries = 0 NEW_LINE i = 0 NEW_LINE invalid = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT curr_size = ans [ i ] NEW_LINE num = ans [ i ] NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( ans [ i ] != curr_size ) : NEW_LINE INDENT print ( \" Invalid ▁ Answer \" ) NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT num = num - 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT total_countries = total_countries + 1 ; NEW_LINE DEDENT print ( \" There ▁ are ▁ \" , total_countries , \" ▁ distinct ▁ companies ▁ in ▁ the ▁ group . \" ) NEW_LINE DEDENT ans = [ 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 ] ; NEW_LINE n = len ( ans ) ; NEW_LINE countCountries ( ans , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Grouping Countries | Python3 program to count no of distinct countries from a given group of people ; Answer is valid if adjacent sitting num people give same answer ; someone gives different answer ; check next person ; one valid country group has been found ; Driven code",
        "Category": "Array"
    },
    {
        "ID": "4085-4085",
        "Code": "' NEW_LINE def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number whose set bits are maximum in a given range | Python code to find number whose set bits are maximum among ' l ' and 'r ; Returns smallest number whose set bits are maximum in given range . ; Initialize the maximum count and final answer as ' num ' ; Traverse for every bit of ' i ' number ; If count is greater than previous calculated max_count , update it ; driver code",
        "Category": "Math"
    },
    {
        "ID": "4086-4086",
        "Code": "def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number whose set bits are maximum in a given range | Returns smallest number whose set bits are maximum in given range . ; driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "4091-4091",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . key = item NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if ( key < node . key ) : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif ( key > node . key ) : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def findFloor ( root , key ) : NEW_LINE INDENT curr = root NEW_LINE ans = None NEW_LINE while ( curr ) : NEW_LINE INDENT if ( curr . key <= key ) : NEW_LINE INDENT ans = curr NEW_LINE curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT curr = curr . left NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return ans . key NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE root = None NEW_LINE root = insert ( root , 19 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 12 ) NEW_LINE insert ( root , 9 ) NEW_LINE insert ( root , 21 ) NEW_LINE insert ( root , 19 ) NEW_LINE insert ( root , 25 ) NEW_LINE print ( findFloor ( root , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest number less than or equal to N in BST ( Iterative Approach ) | Python3 code to find the largest value smaller than or equal to N ; To create new BST Node ; To insert a new node in BST ; If tree is empty return new node ; If key is less then or greater then node value then recur down the tree ; Return the ( unchanged ) node pointer ; Returns largest value smaller than or equal to key . If key is smaller than the smallest , it returns - 1. ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "4095-4095",
        "Code": "import math NEW_LINE def calcSafe ( pos ) : NEW_LINE INDENT j = pos % 10 NEW_LINE i = pos / 10 NEW_LINE dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) NEW_LINE dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) NEW_LINE dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) NEW_LINE dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) NEW_LINE sum = ( dis_11 + dis_18 + dis_81 + dis_88 + 1 ) NEW_LINE return ( 64 - sum ) NEW_LINE DEDENT pos = 34 NEW_LINE print ( \" Safe ▁ Positions ▁ = ▁ \" , math . ceil ( calcSafe ( pos ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Save from Bishop in chessboard | python program to find total safe position to place your Bishop ; function to calc total safe position ; i , j denotes row and column of position of bishop ; calc distance in four direction ; calc total sum of distance + 1 for unsafe positions ; return total safe positions ; driver function",
        "Category": "Math"
    },
    {
        "ID": "4109-4109",
        "Code": "def rem_vowel ( string ) : NEW_LINE INDENT vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE result = [ letter for letter in string if letter . lower ( ) not in vowels ] NEW_LINE result = ' ' . join ( result ) NEW_LINE print ( result ) NEW_LINE DEDENT string = \" GeeksforGeeks ▁ - ▁ A ▁ Computer ▁ Science ▁ Portal ▁ for ▁ Geeks \" NEW_LINE rem_vowel ( string ) NEW_LINE string = \" Loving ▁ Python ▁ LOL \" NEW_LINE rem_vowel ( string ) NEW_LINE",
        "Type": "py",
        "NL": "Program to remove vowels from a String | Python program to remove vowels from a string Function to remove vowels ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "4110-4110",
        "Code": "import re NEW_LINE def rem_vowel ( string ) : NEW_LINE INDENT return ( re . sub ( \" [ aeiouAEIOU ] \" , \" \" , string ) ) NEW_LINE DEDENT string = \" GeeksforGeeks ▁ - ▁ A ▁ Computer ▁ Science ▁ Portal ▁ for ▁ Geeks \" NEW_LINE print rem_vowel ( string ) NEW_LINE",
        "Type": "py",
        "NL": "Program to remove vowels from a String | Python program to remove vowels from a string Function to remove vowels ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "4114-4114",
        "Code": "def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return str1 [ i ] < str2 [ i ] NEW_LINE DEDENT def searchStr ( arr , string , first , last ) : NEW_LINE INDENT if first > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if len ( arr [ mid ] ) == 0 : NEW_LINE INDENT left , right = mid - 1 , mid + 1 NEW_LINE while True : NEW_LINE INDENT if left < first and right > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if right <= last and len ( arr [ right ] ) != 0 : NEW_LINE INDENT mid = right NEW_LINE break NEW_LINE DEDENT if left >= first and len ( arr [ left ] ) != 0 : NEW_LINE INDENT mid = left NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT if compareStrings ( string , arr [ mid ] ) == 0 : NEW_LINE INDENT return mid NEW_LINE DEDENT if compareStrings ( string , arr [ mid ] ) < 0 : NEW_LINE INDENT return searchStr ( arr , string , mid + 1 , last ) NEW_LINE DEDENT return searchStr ( arr , string , first , mid - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" for \" , \" \" , \" \" , \" \" , \" geeks \" , \" ide \" , \" \" , \" practice \" , \" \" , \" \" , \" quiz \" , \" \" , \" \" ] NEW_LINE string = \" quiz \" NEW_LINE n = len ( arr ) NEW_LINE print ( searchStr ( arr , string , 0 , n - 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Search in an array of strings where non | Compare two string equals are not ; Main function to find string location ; Move mid to the middle ; If mid is empty , find closest non - empty string ; If mid is empty , search in both sides of mid and find the closest non - empty string , and set mid accordingly . ; If str is found at mid ; If str is greater than mid ; If str is smaller than mid ; Driver Code ; Input arr of Strings . ; input Search String",
        "Category": "Binary Search"
    },
    {
        "ID": "4116-4116",
        "Code": "def computeCost ( arr , N , X ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cost += abs ( arr [ i ] - X ) NEW_LINE DEDENT return cost NEW_LINE DEDENT def minCostToMakeElementEqual ( arr , N ) : NEW_LINE INDENT low = high = arr [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( low > arr [ i ] ) : low = arr [ i ] NEW_LINE if ( high < arr [ i ] ) : high = arr [ i ] NEW_LINE DEDENT while ( ( high - low ) > 2 ) : NEW_LINE INDENT mid1 = low + ( high - low ) // 3 NEW_LINE mid2 = high - ( high - low ) // 3 NEW_LINE cost1 = computeCost ( arr , N , mid1 ) NEW_LINE cost2 = computeCost ( arr , N , mid2 ) NEW_LINE if ( cost1 < cost2 ) : NEW_LINE INDENT high = mid2 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid1 NEW_LINE DEDENT DEDENT return computeCost ( arr , N , ( low + high ) // 2 ) NEW_LINE DEDENT arr = [ 1 , 100 , 101 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minCostToMakeElementEqual ( arr , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Make all array elements equal with minimum cost | Utility method to compute cost , when all values of array are made equal to X ; Method to find minimum cost to make all elements equal ; Setting limits for ternary search by smallest and largest element ; loop until difference between low and high become less than 3 , because after that mid1 and mid2 will start repeating ; mid1 and mid2 are representative array equal values of search space ; if mid2 point gives more total cost , skip third part ; if mid1 point gives more total cost , skip first part ; computeCost gets optimum cost by sending average of low and high as X ; Driver code",
        "Category": "Ternary Search"
    },
    {
        "ID": "4120-4120",
        "Code": "def keyFunc ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rev = rev << 1 NEW_LINE if ( n & 1 == 1 ) : NEW_LINE INDENT rev = rev ^ 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return rev NEW_LINE DEDENT def getNew ( arr ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in arr : NEW_LINE INDENT ans . append ( [ keyFunc ( i ) , i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getArr ( arr ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in arr : NEW_LINE INDENT ans . append ( i [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def sortArray ( arr ) : NEW_LINE INDENT newArr = getNew ( arr ) NEW_LINE newArr . sort ( ) NEW_LINE arr = getArr ( newArr ) NEW_LINE print ( arr ) NEW_LINE DEDENT arr = [ 43 , 52 , 61 , 41 ] NEW_LINE sortArray ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Rearrange array to make decimal equivalents of reversed binary representations of array elements sorted | Function to reverse the bits of a number ; Stores the reversed number ; Divide rev by 2 ; If the value of N is odd ; Update the value of N ; Return the final value of rev ; Function for rearranging the array element according to the given rules ; Stores the new array elements ; Function for rearranging the array ; Stores the new array ; Function to sort the array by reversing the binary representation ; Creating a new array ; Sort the array with the key ; Get arr from newArr ; Print the sorted array ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "4124-4124",
        "Code": "def maxConsecutiveRopes ( ropes , N ) : NEW_LINE INDENT curSize = 0 NEW_LINE ropes = sorted ( ropes ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ropes [ i ] <= curSize + 1 ) : NEW_LINE INDENT curSize = curSize + ropes [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return curSize NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE ropes = [ 1 , 2 , 7 , 1 , 1 ] NEW_LINE print ( maxConsecutiveRopes ( ropes , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize ropes of consecutive length possible by connecting given ropes | Function to find maximized count of ropes of consecutive length ; Stores the maximum count of ropes of consecutive length ; Sort the ropes by their length ; Traverse the array ; If size of the current rope is less than or equal to current maximum possible size + 1 , update the range to curSize + ropes [ i ] ; If a rope of size ( curSize + 1 ) cannot be obtained ; Driver Code ; Input ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4143-4143",
        "Code": "def maximumSum ( arr , S , N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) [ : : - 1 ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT S = sorted ( S ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( S [ i ] == 1 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT S [ i ] -= 1 NEW_LINE DEDENT counter = K - 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT counter = counter + S [ i ] NEW_LINE if ( S [ i ] != 0 ) : NEW_LINE INDENT ans += arr [ counter ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 13 , 7 , 17 ] NEW_LINE S = [ 1 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = len ( S ) NEW_LINE print ( maximumSum ( arr , S , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split array into K non | Function find maximum sum of minimum and maximum of K subsets ; Stores the result ; Sort the array arr [ ] in decreasing order ; Traverse the range [ 0 , K ] ; Sort the array S [ ] in ascending order ; Traverse the array S [ ] ; If S { i ] is 1 ; Stores the index of the minimum element of the i - th subset ; Traverse the array S [ ] ; Update the counter ; Return the resultant sum ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4146-4146",
        "Code": "def isSorted ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE return False NEW_LINE DEDENT return True NEW_LINE DEDENT def sortPoss ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT idx = - 1 NEW_LINE minVar = arr [ i ] NEW_LINE for j in range ( i , len ( arr ) , 2 ) : NEW_LINE if arr [ j ] < minVar : NEW_LINE INDENT minVar = arr [ j ] NEW_LINE idx = j NEW_LINE DEDENT if idx != - 1 : NEW_LINE arr [ i ] , arr [ idx ] = arr [ idx ] , arr [ i ] NEW_LINE DEDENT if isSorted ( arr ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT arr = [ 3 , 5 , 1 , 2 , 6 ] NEW_LINE print ( sortPoss ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if an array can be sorted by rearranging odd and even | Function to check if array can be sorted or not ; Function to check if given array can be sorted or not ; Traverse the array ; Traverse remaining elements at indices separated by 2 ; If current element is the minimum ; If any smaller minimum exists ; Swap with current element ; If array is sorted ; Otherwise ; Given array",
        "Category": "Array"
    },
    {
        "ID": "4147-4147",
        "Code": "def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE length = len ( num ) NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT def decimalToBinary ( n ) : NEW_LINE INDENT binstr = \" \" NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binstr += chr ( n % 2 + 48 ) NEW_LINE n = n // 2 NEW_LINE DEDENT return binstr NEW_LINE DEDENT def reversedBinaryDecimal ( N ) : NEW_LINE INDENT decimal_to_binar = decimalToBinary ( N ) NEW_LINE binary_to_decimal = binaryToDecimal ( decimal_to_binar ) NEW_LINE return binary_to_decimal NEW_LINE DEDENT def printSortedArray ( arr , size ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def modifyArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT arr [ i ] = reversedBinaryDecimal ( arr [ i ] ) NEW_LINE DEDENT printSortedArray ( arr , size ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 98 , 43 , 66 , 83 ] NEW_LINE n = len ( arr ) NEW_LINE modifyArray ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify an array by sorting after reversal of bits of each array element | Function to convert binary number to equivalent decimal ; Set base value to 1 , i . e 2 ^ 0 ; Function to convert a decimal to equivalent binary representation ; Stores the binary representation ; Since ASCII value of '0' , '1' are 48 and 49 ; As the string is already reversed , no further reversal is required ; Function to convert the reversed binary representation to equivalent integer ; Stores reversed binary representation of given decimal ; Stores equivalent decimal value of the binary representation ; Return the resultant integer ; Utility function to print the sorted array ; Sort the array ; Traverse the array ; Print the array elements ; Utility function to reverse the binary representations of all array elements and sort the modified array ; Traverse the array ; Passing array elements to reversedBinaryDecimal function ; Pass the array to the sorted array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4149-4149",
        "Code": "import sys NEW_LINE def minimumDeletion ( s , n ) : NEW_LINE INDENT countMap = { } NEW_LINE for i in s : NEW_LINE INDENT countMap [ i ] = countMap . get ( i , 0 ) + 1 NEW_LINE DEDENT countMultiset = [ ] NEW_LINE for it in countMap : NEW_LINE INDENT countMultiset . append ( countMap [ it ] ) NEW_LINE DEDENT ans = sys . maxsize + 1 NEW_LINE i = 0 NEW_LINE m = len ( countMultiset ) NEW_LINE for j in sorted ( countMultiset ) : NEW_LINE INDENT ans = min ( ans , n - ( m - i ) * j ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" geeksforgeeks \" NEW_LINE N = len ( S ) NEW_LINE print ( minimumDeletion ( S , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of characters required to be removed such that every character occurs same number of times | Python3 program for the above approach ; Function to find minimum number of character removals required to make frequency of all distinct characters the same ; Stores the frequency of each character ; Traverse the string ; Stores the frequency of each charachter in sorted order ; Traverse the Map ; Insert the frequency in multiset ; Stores the count of elements required to be removed ; Stores the size of multiset ; Traverse the multiset ; Update the ans ; Increment i by 1 ; Return ; Driver Code ; Input",
        "Category": "Hash Table"
    },
    {
        "ID": "415-415",
        "Code": "V = 4 NEW_LINE INF = 999999999999 NEW_LINE def shortestPath ( graph , u , v , k ) : NEW_LINE INDENT if k == 0 and u == v : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 1 and graph [ u ] [ v ] != INF : NEW_LINE INDENT return graph [ u ] [ v ] NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return INF NEW_LINE DEDENT res = INF NEW_LINE for i in range ( V ) : NEW_LINE INDENT if graph [ u ] [ i ] != INF and u != i and v != i : NEW_LINE INDENT rec_res = shortestPath ( graph , i , v , k - 1 ) NEW_LINE if rec_res != INF : NEW_LINE INDENT res = min ( res , graph [ u ] [ i ] + rec_res ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT INF = 999999999999 NEW_LINE graph = [ [ 0 , 10 , 3 , 2 ] , [ INF , 0 , INF , 7 ] , [ INF , INF , 0 , 6 ] , [ INF , INF , INF , 0 ] ] NEW_LINE u = 0 NEW_LINE v = 3 NEW_LINE k = 2 NEW_LINE print ( \" Weight ▁ of ▁ the ▁ shortest ▁ path ▁ is \" , shortestPath ( graph , u , v , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Shortest path with exactly k edges in a directed and weighted graph | Define number of vertices in the graph and inifinite value ; A naive recursive function to count walks from u to v with k edges ; Base cases ; Initialize result ; Go to all adjacents of u and recur ; Driver Code ; Let us create the graph shown in above diagram",
        "Category": "Graph Theory"
    },
    {
        "ID": "4150-4150",
        "Code": "def maxLenSubset ( a , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE index = 0 NEW_LINE maxlen = - 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i NEW_LINE len1 = 1 NEW_LINE while ( j < n - 1 ) : NEW_LINE INDENT if ( 2 * a [ j ] >= a [ j + 1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( maxlen < len1 ) : NEW_LINE INDENT maxlen = len1 NEW_LINE index = i NEW_LINE DEDENT j += 1 NEW_LINE i = j NEW_LINE DEDENT i = index NEW_LINE while ( maxlen > 0 ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE maxlen -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 1 , 5 , 11 ] NEW_LINE n = len ( a ) NEW_LINE maxLenSubset ( a , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of longest strictly increasing subset with each pair of adjacent elements satisfying the condition 2 * A [ i ] â ‰¥ A [ i + 1 ] | Function to find the length of the longest subset satisfying given conditions ; Sort the array in ascending order ; Stores the starting index and maximum length of the required subset ; Pointer to traverse the array ; Iterate while i < n ; Stores end point of current subset ; Store the length of the current subset ; Continue adding elements to the current subset till the condition satisfies ; Increment length of the current subset ; Increment the pointer j ; If length of the current subset exceeds overall maximum length ; Update maxlen ; Update index ; Increment j ; Update i ; Store the starting index of the required subset in i ; Print the required subset ; Print the array element ; Decrement maxlen ; Increment i ; Driver Code ; Given array ; Store the size of the array",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4153-4153",
        "Code": "from bisect import bisect_left NEW_LINE def solve ( N , X , Y ) : NEW_LINE INDENT p = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT p . append ( [ X [ i ] , Y [ i ] ] ) NEW_LINE DEDENT p = sorted ( p ) NEW_LINE s = { } NEW_LINE s [ p [ 0 ] [ 1 ] ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr = list ( s . keys ( ) ) NEW_LINE it = bisect_left ( arr , p [ i ] [ 1 ] ) NEW_LINE if ( it == len ( s ) ) : NEW_LINE INDENT s [ p [ i ] [ 1 ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT del s [ arr [ it ] ] NEW_LINE s [ p [ i ] [ 1 ] ] = 1 NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE X = [ 1 , 2 , 0 ] NEW_LINE Y = [ 2 , 0 , 1 ] NEW_LINE maxintersection = solve ( N , X , Y ) NEW_LINE print ( maxintersection ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize count of intersecting line segments | Python3 program for the above approach ; Function to find the maximum number of intersecting line segments possible ; Stores pairs of line segments { X [ i ] , Y [ i ] ) ; Push { X [ i ] , Y [ i ] } into p ; Sort p in ascending order of points on X number line ; Stores the points on Y number line in descending order ; Insert the first Y pofrom p ; Binary search to find the lower bound of p [ i ] [ 1 ] ; If lower_bound doesn 't exist ; Insert p [ i ] [ 1 ] into the set ; Erase the next lower _bound from the set ; Insert p [ i ] [ 1 ] into the set ; Return the size of the set as the final result ; Driver Code ; Given Input ; Function call to find the maximum number of intersecting line segments",
        "Category": "Binary Search"
    },
    {
        "ID": "4154-4154",
        "Code": "def calculateDistance ( arr , N ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v . append ( [ arr [ i ] , i ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE ans = 0 NEW_LINE last = 0 NEW_LINE for j in v : NEW_LINE INDENT ans += abs ( j [ 1 ] - last ) NEW_LINE last = j [ 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE print ( calculateDistance ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Calculate cost of visiting all array elements in increasing order | Function to calculate total cost of visiting array elements in increasing order ; Stores the pair of element and their positions ; Traverse the array arr [ ] ; Push the pair { arr [ i ] , i } in v ; Sort the vector in ascending order . ; Stores the total cost ; Stores the index of last element visited ; Traverse the vector v ; Increment ans ; Assign ; Return ans ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4158-4158",
        "Code": "def mergeStrings ( s1 , s2 ) : NEW_LINE INDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE pntr1 = 0 NEW_LINE pntr2 = 0 NEW_LINE ans = \" \" NEW_LINE while ( pntr1 < len1 and pntr2 < len2 ) : NEW_LINE INDENT if ( s1 [ pntr1 ] < s2 [ pntr2 ] ) : NEW_LINE INDENT ans += s1 [ pntr1 ] NEW_LINE pntr1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += s2 [ pntr2 ] NEW_LINE pntr2 += 1 NEW_LINE DEDENT DEDENT if ( pntr1 < len1 ) : NEW_LINE INDENT ans += s1 [ pntr1 : pntr1 + len1 ] NEW_LINE DEDENT if ( pntr2 < len2 ) : NEW_LINE INDENT ans += s2 [ pntr2 : pntr2 + len2 ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 = \" abdcdtx \" NEW_LINE S2 = \" achilp \" NEW_LINE mergeStrings ( S1 , S2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest string possible by merging two sorted strings | Function to find lexicographically smallest possible by merging two sorted strings ; Stores length of s1 ; Stores length of s2 ; Pointer to beginning of string1 i . e . , s1 ; Pointer to beginning of string2 i . e . , s2 ; Stores the final string ; Traverse the strings ; Append the smaller of the two current characters ; Append the remaining characters of any of the two strings ; Print the final string ; Driver Code ; Function Call",
        "Category": "Two Pointers"
    },
    {
        "ID": "4159-4159",
        "Code": "import math NEW_LINE def sortArr ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT s = str ( arr [ i ] ) NEW_LINE list1 = list ( s ) NEW_LINE list1 . sort ( reverse = True ) NEW_LINE s = ' ' . join ( list1 ) NEW_LINE arr [ i ] = int ( s ) NEW_LINE sr = int ( math . sqrt ( arr [ i ] ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE INDENT arr [ i ] = a NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = b NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 29 , 43 , 28 , 12 ] NEW_LINE N = len ( arr ) NEW_LINE sortArr ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify array by sorting nearest perfect squares of array elements having their digits sorted in decreasing order | Python 3 program of the above approach ; Function to sort array in ascending order after replacing array elements by nearest perfect square of decreasing order of digits ; Traverse the array of strings ; Convert the current array element to a string ; Sort each string in descending order ; Convert the string to equivalent integer ; Calculate square root of current array element ; Calculate perfect square ; Find the nearest perfect square ; Sort the array in ascending order ; Print the array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4161-4161",
        "Code": "def sortStr ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE temp = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] != ' a ' and S [ i ] != ' e ' and S [ i ] != ' i ' and S [ i ] != ' o ' and S [ i ] != ' u ' ) : NEW_LINE INDENT temp += S [ i ] NEW_LINE DEDENT DEDENT if ( len ( temp ) ) : NEW_LINE INDENT p = list ( temp ) NEW_LINE p . sort ( ) NEW_LINE temp = ' ' . join ( p ) NEW_LINE DEDENT ptr = 0 NEW_LINE for i in range ( N ) : NEW_LINE S = list ( S ) NEW_LINE if ( S [ i ] != ' a ' and S [ i ] != ' e ' and S [ i ] != ' i ' and S [ i ] != ' o ' and S [ i ] != ' u ' ) : NEW_LINE INDENT S [ i ] = temp [ ptr ] NEW_LINE ptr += 1 NEW_LINE DEDENT print ( ' ' . join ( S ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" geeksforgeeks \" NEW_LINE sortStr ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort a string without altering the position of vowels | Function to sort the string leaving the vowels unchanged ; Length of string S ; Traverse the string S ; Sort the string temp ; Pointer to traverse the sorted string of consonants ; Traverse the string S ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4177-4177",
        "Code": "def sameChar ( S , N ) : NEW_LINE INDENT S = ' ' . join ( sorted ( S ) ) NEW_LINE mid = ord ( S [ N // 2 ] ) NEW_LINE total_operations = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total_operations += abs ( ord ( S [ i ] ) - mid ) NEW_LINE DEDENT print ( total_operations ) NEW_LINE DEDENT S = \" geeks \" NEW_LINE N = len ( S ) NEW_LINE sameChar ( S , N ) NEW_LINE",
        "Type": "py",
        "NL": "Make all characters of a string same by minimum number of increments or decrements of ASCII values of characters | Function to check if all characters of the string can be made the same ; Sort the string ; Calculate ASCII value of the median character ; Stores the minimum number of operations required to make all characters equal ; Traverse the string ; Calculate absolute value of current character and median character ; Print the minimum number of operations required ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4198-4198",
        "Code": "temp = [ 0 ] * 100000 NEW_LINE def merge ( A , left , mid , right ) : NEW_LINE INDENT swaps = 0 NEW_LINE i , j , k = left , mid , left NEW_LINE while ( i < mid and j <= right ) : NEW_LINE INDENT if ( A [ i ] <= A [ j ] ) : NEW_LINE INDENT temp [ k ] = A [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = A [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE swaps += mid - i NEW_LINE DEDENT DEDENT while ( i < mid ) : NEW_LINE INDENT temp [ k ] = A [ i ] NEW_LINE k , i = k + 1 , i + 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = A [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT while ( left <= right ) : NEW_LINE INDENT A [ left ] = temp [ left ] NEW_LINE left += 1 NEW_LINE DEDENT return swaps NEW_LINE DEDENT def mergeInsertionSwap ( A , left , right ) : NEW_LINE INDENT swaps = 0 NEW_LINE if ( left < right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE swaps += mergeInsertionSwap ( A , left , mid ) NEW_LINE swaps += mergeInsertionSwap ( A , mid + 1 , right ) NEW_LINE swaps += merge ( A , left , mid + 1 , right ) NEW_LINE DEDENT return swaps NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 1 , 3 , 1 , 2 ] NEW_LINE N = len ( A ) NEW_LINE print ( mergeInsertionSwap ( A , 0 , N - 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count swaps required to sort an array using Insertion Sort | Stores the sorted array elements ; Function to count the number of swaps required to merge two sorted subarray in a sorted form ; Stores the count of swaps ; Function to count the total number of swaps required to sort the array ; Stores the total count of swaps required ; Find the middle index splitting the two halves ; Count the number of swaps required to sort the left subarray ; Count the number of swaps required to sort the right subarray ; Count the number of swaps required to sort the two sorted subarrays ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "422-422",
        "Code": "class edge : NEW_LINE INDENT def __init__ ( self , u , w ) : NEW_LINE INDENT self . From = u NEW_LINE self . weight = w NEW_LINE DEDENT DEDENT def addedge ( u , v , w ) : NEW_LINE INDENT edges [ v ] . append ( edge ( u , w ) ) NEW_LINE DEDENT V = 4 NEW_LINE edges = [ [ ] for i in range ( V ) ] NEW_LINE def shortestpath ( dp ) : NEW_LINE INDENT for i in range ( V + 1 ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT for k in range ( len ( edges [ j ] ) ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ edges [ j ] [ k ] . From ] != - 1 ) : NEW_LINE INDENT curr_wt = ( dp [ i - 1 ] [ edges [ j ] [ k ] . From ] + edges [ j ] [ k ] . weight ) NEW_LINE if ( dp [ i ] [ j ] == - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = curr_wt NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , curr_wt ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def minAvgWeight ( ) : NEW_LINE INDENT dp = [ [ None ] * V for i in range ( V + 1 ) ] NEW_LINE shortestpath ( dp ) NEW_LINE avg = [ - 1 ] * V NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( dp [ V ] [ i ] != - 1 ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dp [ j ] [ i ] != - 1 ) : NEW_LINE INDENT avg [ i ] = max ( avg [ i ] , ( dp [ V ] [ i ] - dp [ j ] [ i ] ) / ( V - j ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT result = avg [ 0 ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( avg [ i ] != - 1 and avg [ i ] < result ) : NEW_LINE INDENT result = avg [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT addedge ( 0 , 1 , 1 ) NEW_LINE addedge ( 0 , 2 , 10 ) NEW_LINE addedge ( 1 , 2 , 3 ) NEW_LINE addedge ( 2 , 3 , 2 ) NEW_LINE addedge ( 3 , 1 , 0 ) NEW_LINE addedge ( 3 , 0 , 8 ) NEW_LINE print ( minAvgWeight ( ) ) NEW_LINE",
        "Type": "py",
        "NL": "Karp 's minimum mean (or average) weight cycle algorithm | a struct to represent edges ; vector to store edges @ SuppressWarnings ( \" unchecked \" ) ; calculates the shortest path ; initializing all distances as - 1 ; shortest distance From first vertex to in tself consisting of 0 edges ; filling up the dp table ; Returns minimum value of average weight of a cycle in graph . ; array to store the avg values ; Compute average values for all vertices using weights of shortest paths store in dp . ; Find minimum value in avg [ ] ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "4225-4225",
        "Code": "from math import ceil , sqrt NEW_LINE def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 5 , ceil ( sqrt ( n ) ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def digitProduct ( number ) : NEW_LINE INDENT product = 1 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT product *= ( number % 10 ) NEW_LINE number //= 10 NEW_LINE DEDENT return product NEW_LINE DEDENT def compositedigitProduct ( num ) : NEW_LINE INDENT res = digitProduct ( num ) NEW_LINE if ( res == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isComposite ( res ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestCompositeDigitProduct ( a , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % k ) == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( compositedigitProduct ( a [ i ] ) ) : NEW_LINE INDENT b = digitProduct ( a [ i ] ) NEW_LINE pq . append ( [ b , a [ i ] ] ) NEW_LINE DEDENT DEDENT pq = sorted ( pq ) NEW_LINE return pq [ - 1 ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 233 , 144 , 89 , 71 , 13 , 21 , 11 , 34 , 55 , 23 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE ans = largestCompositeDigitProduct ( arr , n , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the array element from indices not divisible by K having largest composite product of digits | Python3 program to implement the above approach ; Function to check if a number is a composite number or not ; Corner cases ; Check if number is divisible by 2 or 3 ; Check if number is a multiple of any other prime number ; Function to calculate the product of digits of a number ; Stores the product of digits ; Extract digits of a number ; Calculate product of digits ; Function to check if the product of digits of a number is a composite number or not ; Stores product of digits ; If product of digits is equal to 1 ; If product of digits is not prime ; Function to find the number with largest composite product of digits from the indices not divisible by k from the given array ; Traverse the array ; If index is divisible by k ; Check if product of digits is a composite number or not ; Sort the products ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4239-4239",
        "Code": "def Selection_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT min_index = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_index ] ) : NEW_LINE INDENT min_index = j NEW_LINE DEDENT DEDENT arr [ i ] , arr [ min_index ] = arr [ min_index ] , arr [ i ] NEW_LINE DEDENT DEDENT n = 5 NEW_LINE arr = [ 2 , 0 , 1 , 4 , 3 ] NEW_LINE Selection_Sort ( arr , n ) NEW_LINE print ( \" The ▁ Sorted ▁ Array ▁ by ▁ using ▁ \"   \\ \" Selection ▁ Sort ▁ is ▁ : ▁ \" , end = ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Selection Sort VS Bubble Sort |  ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4244-4244",
        "Code": "def checkSubsetSum ( A , B , N , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( reverse = True ) NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum1 += A [ i ] NEW_LINE sum2 += B [ i ] NEW_LINE DEDENT if ( sum1 > sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT A = [ 12 , 11 , 10 , 13 ] NEW_LINE B = [ 7 , 10 , 6 , 2 ] NEW_LINE N = len ( A ) NEW_LINE K = 3 NEW_LINE if ( checkSubsetSum ( A , B , N , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if all K | Function to check all subset - sums of K - length subsets in A [ ] is greater that that in the array B [ ] or not ; Sort the array in ascending order ; Sort the array in descending order ; Stores sum of first K elements of A [ ] ; Stores sum of first K elements of B [ ] ; Traverse both the arrays ; Update sum1 ; Update sum2 ; If sum1 exceeds sum2 ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4259-4259",
        "Code": "def convert_to_words ( n ) : NEW_LINE INDENT num = str ( n ) NEW_LINE length = len ( num ) NEW_LINE ans = \" \" NEW_LINE if ( length == 0 ) : NEW_LINE INDENT ans += \" Empty ▁ String \" NEW_LINE return ans NEW_LINE DEDENT single_digits = [ \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" ] NEW_LINE two_digits = [ \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" ] NEW_LINE tens_multiple = [ \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" ] NEW_LINE tens_power = [ \" hundred \" , \" thousand \" ] NEW_LINE if ( length == 1 ) : NEW_LINE INDENT ans += single_digits [ ord ( num [ 0 ] ) - ord ( '0' ) ] NEW_LINE return ans NEW_LINE DEDENT x = 0 NEW_LINE while ( x < len ( num ) ) : NEW_LINE INDENT if ( length >= 3 ) : NEW_LINE INDENT if ( num [ x ] - '0' != 0 ) : NEW_LINE INDENT ans += single_digits [ ord ( num [ x ] ) - ord ( '0' ) ] NEW_LINE ans += \" ▁ \" NEW_LINE ans += tens_power [ len - 3 ] NEW_LINE ans += \" ▁ \" NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ord ( num [ x ] ) - ord ( '0' ) == 1 ) : NEW_LINE INDENT sum = ( ord ( num [ x ] ) - ord ( '0' ) + ord ( num [ x ] ) - ord ( '0' ) ) NEW_LINE ans += two_digits [ sum ] NEW_LINE return ans NEW_LINE DEDENT elif ( ord ( num [ x ] ) - ord ( '0' ) == 2 and ord ( num [ x + 1 ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT ans += \" twenty \" NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT i = ( ord ( num [ x ] ) - ord ( '0' ) ) NEW_LINE if ( i > 0 ) : NEW_LINE INDENT ans += tens_multiple [ i ] NEW_LINE ans += \" ▁ \" NEW_LINE DEDENT else : NEW_LINE ans += \" \" NEW_LINE x += 1 NEW_LINE if ( ord ( num [ x ] ) - ord ( '0' ) != 0 ) : NEW_LINE INDENT ans += single_digits [ ord ( num [ x ] ) - ord ( '0' ) ] NEW_LINE DEDENT DEDENT DEDENT x += 1 NEW_LINE DEDENT return \" \" NEW_LINE DEDENT def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( convert_to_words ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT print ( ans [ n - 1 ] , end = \" \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE lexNumbers ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all numbers up to N in words in lexicographical order | Function to convert a number to words ; Stores the digits ; Base cases ; Stores strings of unit place ; Stores strings for corner cases ; Stores strings for ten 's place digits ; Stores strings for powers of 10 ; If given number contains a single digit ; Iterate over all the digits ; Represent first 2 digits in words ; Represent last 2 digits in words ; Explicitly handle corner cases [ 10 , 19 ] ; Explicitly handle corner case 20 ; For rest of the two digit numbers i . e . , 21 to 99 ; Function to print all the numbers up to n in lexicographical order ; Convert all numbers in words ; Sort all strings ; Print answer ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4275-4275",
        "Code": "def checkArrangement ( A1 , A2 , n , k ) : NEW_LINE INDENT A1 = sorted ( A1 ) NEW_LINE A2 = sorted ( A2 ) NEW_LINE A2 = A2 [ : : - 1 ] NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( A1 [ i ] + A2 [ i ] > k ) or ( A1 [ i ] + A2 [ i ] < k // 2 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 1 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 2 , 0 , 1 , 1 ] NEW_LINE K = 6 NEW_LINE N = len ( arr1 ) NEW_LINE checkArrangement ( arr1 , arr2 , N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange two given arrays such that sum of same indexed elements lies within given range | Function to check if there exists any arrangements of the arrays such that sum of element lie in the range [ K / 2 , K ] ; Sort the array arr1 [ ] in increasing order ; Sort the array arr2 [ ] in decreasing order ; Traverse the array ; If condition is not satisfied break the loop ; Print the result ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4283-4283",
        "Code": "def firstSubsequence ( s ) : NEW_LINE INDENT allsubseq = [ ] NEW_LINE k = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = [ i for i in s ] NEW_LINE del k [ i ] NEW_LINE allsubseq . append ( \" \" . join ( k ) ) NEW_LINE DEDENT allsubseq = sorted ( allsubseq ) NEW_LINE print ( allsubseq [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" geeksforgeeks \" NEW_LINE firstSubsequence ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest subsequence possible by removing a character from given string | Function to find the lexicographically smallest subsequence of length N - 1 ; Generate all subsequence of length N - 1 ; Store main value of string str ; Erasing element at position i ; Sort the vector ; Print first element of vector ; Driver Code ; Given string S ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "4291-4291",
        "Code": "def eraseSubdirectory ( dir ) : NEW_LINE INDENT res = [ ] NEW_LINE dir . sort ( ) NEW_LINE res . append ( dir [ 0 ] ) NEW_LINE print ( \" { \" , dir [ 0 ] , end = \" , ▁ \" ) NEW_LINE for i in range ( 1 , len ( dir ) ) : NEW_LINE INDENT curr = dir [ i ] NEW_LINE prev = res [ len ( res ) - 1 ] NEW_LINE l = len ( prev ) NEW_LINE if ( len ( curr ) > l and curr [ l ] == ' / ' and prev == curr [ : l ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( curr ) NEW_LINE print ( curr , end = \" , ▁ \" ) NEW_LINE DEDENT print ( \" } \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT dir = [ \" / a \" , \" / a / j \" , \" / c / d / e \" , \" / c / d \" , \" / b \" ] NEW_LINE eraseSubdirectory ( dir ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove Sub | Function to remove sub - directories from the given lists dir ; Store final result ; Sort the given directories ; Insert 1 st directory ; Iterating in directory ; Current directory ; Our previous valid directory ; Find length of previous directory ; If subdirectory is found ; Else store it in result valid directory ; Driver Code ; Given lists of directories dir [ ] ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "4298-4298",
        "Code": "import sys NEW_LINE def minCost ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE raised = 1 / ( n - 1 ) NEW_LINE temp = pow ( arr [ n - 1 ] , raised ) NEW_LINE r = round ( temp ) + 1 NEW_LINE min_cost = sys . maxsize NEW_LINE common_ratio = 1 NEW_LINE for j in range ( 1 , r + 1 ) : NEW_LINE INDENT curr_cost = 0 NEW_LINE prod = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT curr_cost += abs ( arr [ i ] - prod ) NEW_LINE prod *= j NEW_LINE if ( curr_cost >= min_cost ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT min_cost = min ( min_cost , curr_cost ) NEW_LINE common_ratio = j NEW_LINE DEDENT DEDENT print ( min_cost , common_ratio ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE arr = [ 1 , 11 , 4 , 27 , 15 , 33 ] NEW_LINE minCost ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of operations to convert a given sequence into a Geometric Progression | Set 2 | Python3 program for above approach ; Function to find minimum cost ; Sort the array ; Maximum possible common ratios ; Iterate over all possible common ratios ; Calculate operations required for the current common ratio ; Calculate minimum cost ; Driver Code ; Given N ; Given arr [ ] ; Function calling",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "43-43",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def reverseTreePathUtil ( root , data , temp , level , nextpos ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None , temp , nextpos ; NEW_LINE DEDENT if ( data == root . data ) : NEW_LINE INDENT temp [ level ] = root . data ; NEW_LINE root . data = temp [ nextpos ] ; NEW_LINE nextpos += 1 NEW_LINE return root , temp , nextpos ; NEW_LINE DEDENT temp [ level ] = root . data ; NEW_LINE right = None NEW_LINE left , temp , nextpos = reverseTreePathUtil ( root . left , data , temp , level + 1 , nextpos ) ; NEW_LINE if ( left == None ) : NEW_LINE INDENT right , temp , nextpos = reverseTreePathUtil ( root . right , data , temp , level + 1 , nextpos ) ; NEW_LINE DEDENT if ( left or right ) : NEW_LINE INDENT root . data = temp [ nextpos ] ; NEW_LINE nextpos += 1 NEW_LINE return ( left if left != None else right ) , temp , nextpos ; NEW_LINE DEDENT return None , temp , nextpos ; NEW_LINE DEDENT def reverseTreePath ( root , data ) : NEW_LINE INDENT temp = dict ( ) NEW_LINE nextpos = 0 ; NEW_LINE reverseTreePathUtil ( root , data , temp , 0 , nextpos ) ; NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT inorder ( root . left ) ; NEW_LINE print ( root . data , end = ' ▁ ' ) NEW_LINE inorder ( root . right ) ; NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE return temp ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 7 ) ; NEW_LINE root . left = newNode ( 6 ) ; NEW_LINE root . right = newNode ( 5 ) ; NEW_LINE root . left . left = newNode ( 4 ) ; NEW_LINE root . left . right = newNode ( 3 ) ; NEW_LINE root . right . left = newNode ( 2 ) ; NEW_LINE root . right . right = newNode ( 1 ) ; NEW_LINE data = 4 ; NEW_LINE reverseTreePath ( root , data ) ; NEW_LINE inorder ( root ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse tree path | A Binary Tree Node ; ' data ' is input . We need to reverse path from root to data . level ' ▁ is ▁ current ▁ level . ▁ ▁ temp ' that stores path nodes . nextpos ' used to pick next item for reversing. ; return None if root None ; Final condition if the node is found then ; store the value in it 's level ; change the root value with the current next element of the map ; increment in k for the next element ; store the data in perticular level ; We go to right only when left does not contain given data . This way we make sure that correct path node is stored in temp [ ] ; If current node is part of the path , then do reversing . ; return None if not element found ; Reverse Tree path ; store per level data ; it is for replacing the data ; reverse tree path ; INORDER ; Utility function to create a new tree node ; Driver code ; Let us create binary tree shown in above diagram ; 7 / \\ 6 5 / \\ / \\ 4 3 2 1 ; Reverse Tree Path ; Traverse inorder",
        "Category": "Binary Tree"
    },
    {
        "ID": "4300-4300",
        "Code": "maxN = 10 NEW_LINE def calculateFib ( fib , n ) : NEW_LINE INDENT fib [ 0 ] = fib [ 1 ] = 1 NEW_LINE for x in range ( 2 , n ) : NEW_LINE INDENT fib [ x ] = ( fib [ x - 1 ] + fib [ x - 2 ] ) NEW_LINE DEDENT DEDENT def find_mth_bit ( n , m , fib ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len_left = fib [ n - 2 ] NEW_LINE len_right = fib [ n - 1 ] NEW_LINE if ( m <= len_left ) : NEW_LINE INDENT return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) NEW_LINE DEDENT else : NEW_LINE INDENT return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) NEW_LINE DEDENT DEDENT def find_mth_bitUtil ( n , m ) : NEW_LINE INDENT fib = [ 0 for i in range ( maxN ) ] NEW_LINE calculateFib ( fib , maxN ) NEW_LINE ans = find_mth_bit ( n , m , fib ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE find_mth_bitUtil ( n , m ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Mth bit in Nth binary string from a sequence generated by the given operations | Python3 program for above approach ; Function to calculate N Fibonacci numbers ; Function to find the mth bit in the string Sn ; Base case ; Length of left half ; Length of the right half ; Recursive check in the left half ; Recursive check in the right half ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "4302-4302",
        "Code": "def KthSmallestNum ( arr , n , k ) : NEW_LINE INDENT pq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . append ( [ arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ] ) NEW_LINE DEDENT cnt = 1 NEW_LINE while ( cnt < k ) : NEW_LINE INDENT pq . sort ( reverse = True ) NEW_LINE interval = pq [ 0 ] NEW_LINE pq . remove ( pq [ 0 ] ) NEW_LINE if ( interval [ 0 ] < interval [ 1 ] ) : NEW_LINE INDENT pq . append ( [ interval [ 0 ] + 1 , interval [ 1 ] ] ) NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT pq . sort ( reverse = True ) NEW_LINE return pq [ 0 ] [ 0 ] + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 5 , 11 ] , [ 10 , 15 ] , [ 12 , 20 ] ] NEW_LINE n = len ( arr ) NEW_LINE k = 12 NEW_LINE print ( KthSmallestNum ( arr , n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Kth smallest element from an array of intervals | Function to get the Kth smallest element from an array of intervals ; Store all the intervals so that it returns the minimum element in O ( 1 ) ; Insert all Intervals into the MinHeap ; Stores the count of popped elements ; Iterate over MinHeap ; Stores minimum element from all remaining intervals ; Remove minimum element ; Check if the minimum of the current interval is less than the maximum of the current interval ; Insert new interval ; Driver Code ; Intervals given ; Size of the arr",
        "Category": "Heap"
    },
    {
        "ID": "4304-4304",
        "Code": "from collections import defaultdict NEW_LINE def findSubsets ( arr ) : NEW_LINE INDENT M = defaultdict ( int ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT subsets = [ 0 ] * len ( M ) NEW_LINE i = 0 NEW_LINE for j in M : NEW_LINE INDENT subsets [ i ] = M [ j ] NEW_LINE i += 1 NEW_LINE DEDENT return subsets NEW_LINE DEDENT def subsetSum ( subsets , target ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( target + 1 ) ] for y in range ( len ( subsets ) + 1 ) ] NEW_LINE for i in range ( len ( dp ) ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , len ( subsets ) + 1 ) : NEW_LINE INDENT for j in range ( 1 , target + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if ( j >= subsets [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] |= ( dp [ i - 1 ] [ j - subsets [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ len ( subsets ) ] [ target ] NEW_LINE DEDENT def divideInto2Subset ( arr ) : NEW_LINE INDENT subsets = findSubsets ( arr ) NEW_LINE if ( len ( arr ) % 2 == 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT isPossible = subsetSum ( subsets , len ( arr ) // 2 ) NEW_LINE if ( isPossible ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 3 ] NEW_LINE divideInto2Subset ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split array into two equal length subsets such that all repetitions of a number lies in a single subset | Python3 program for the above approach ; Function to create the frequency array of the given array arr [ ] ; Hashmap to store the frequencies ; Store freq for each element ; Get the total frequencies ; Store frequencies in subset [ ] array ; Return frequency array ; Function to check is sum N / 2 can be formed using some subset ; dp [ i ] [ j ] store the answer to form sum j using 1 st i elements ; Initialize dp [ ] [ ] with true ; Fill the subset table in the bottom up manner ; If current element is less than j ; Update current state ; Return the result ; Function to check if the given array can be split into required sets ; Store frequencies of arr [ ] ; If size of arr [ ] is odd then print \" Yes \" ; Check if answer is true or not ; Print the result ; Driver Code ; Given array arr ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "4308-4308",
        "Code": "def maxArea ( point_x , point_y , n , length , width ) : NEW_LINE INDENT point_x . sort ( ) NEW_LINE point_y . sort ( ) NEW_LINE dx = point_x [ 0 ] NEW_LINE dy = point_y [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) NEW_LINE dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) NEW_LINE DEDENT dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) NEW_LINE dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) NEW_LINE print ( ( dx - 1 ) * ( dy - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT length = 15 NEW_LINE width = 8 NEW_LINE n = 3 NEW_LINE point_x = [ 3 , 11 , 8 ] NEW_LINE point_y = [ 8 , 2 , 6 ] NEW_LINE maxArea ( point_x , point_y , n , length , width ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest area in a grid unbounded by towers | Function to calculate the largest area unguarded by towers ; Sort the x - coordinates of the list ; Sort the y - coordinates of the list ; dx -- > maximum uncovered tiles in x coordinates ; dy -- > maximum uncovered tiles in y coordinates ; Calculate the maximum uncovered distances for both x and y coordinates ; Largest unguarded area is max ( dx ) - 1 * max ( dy ) - 1 ; Driver Code ; Length and width of the grid ; No of guard towers ; Array to store the x and y coordinates ; Function call",
        "Category": "Array"
    },
    {
        "ID": "4315-4315",
        "Code": "MOD = 1000000007 NEW_LINE def solve ( values , salary ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values = sorted ( values ) NEW_LINE salary = sorted ( salary ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( ( len ( values ) and values [ - 1 ] >= salary [ - 1 ] ) ) : NEW_LINE INDENT amt += 1 NEW_LINE del values [ - 1 ] NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE amt -= 1 NEW_LINE ret %= MOD NEW_LINE del salary [ - 1 ] NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT values = [ 1 , 2 ] NEW_LINE salary = [ 2 ] NEW_LINE print ( solve ( values , salary ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count ways to distribute exactly one coin to each worker | Python3 program for the above approach ; Function to find number of way to distribute coins giving exactly one coin to each person ; Sort the given arrays ; Start from bigger salary ; Increment the amount ; Reduce amount of valid coins by one each time ; Return the result ; Driver code ; Given two arrays ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4323-4323",
        "Code": "def XorSum ( A , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT ans = ans ^ ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 6 , 0 , 0 , 3 , 3 ] NEW_LINE B = [ 0 , 5 , 6 , 5 , 0 , 3 ] NEW_LINE N = len ( A ) NEW_LINE print ( XorSum ( A , B , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "XOR of all possible pairwise sum from two given Arrays | Function to calculate the sum of XOR of the sum of every pair ; Stores the XOR of sums of every pair ; Iterate to generate all possible pairs ; Update XOR ; Return the answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4324-4324",
        "Code": "from bisect import bisect , bisect_left , bisect_right NEW_LINE def XorSum ( A , B , N ) : NEW_LINE INDENT maxBit = 29 NEW_LINE ans = 0 NEW_LINE for k in range ( maxBit ) : NEW_LINE INDENT C = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] = B [ i ] % ( 1 << ( k + 1 ) ) NEW_LINE DEDENT C = sorted ( C ) NEW_LINE count = 0 NEW_LINE l , r = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = A [ i ] % ( 1 << ( k + 1 ) ) NEW_LINE l = bisect_left ( C , ( 1 << k ) - x ) NEW_LINE r = bisect_left ( C , ( 1 << k ) * 2 - x ) NEW_LINE count += ( r - l ) NEW_LINE l = bisect_left ( C , ( 1 << k ) * 3 - x ) NEW_LINE r = bisect_left ( C , ( 1 << k ) * 4 - x ) NEW_LINE count += ( r - l ) NEW_LINE DEDENT if ( count & 1 ) : NEW_LINE INDENT ans += ( 1 << k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 4 , 6 , 0 , 0 , 3 , 3 ] NEW_LINE B = [ 0 , 5 , 6 , 5 , 0 , 3 ] NEW_LINE N = len ( A ) NEW_LINE print ( XorSum ( A , B , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "XOR of all possible pairwise sum from two given Arrays | Python3 program to implement the above approach ; Function to calculate the XOR of the sum of every pair ; Stores the maximum bit ; Look for all the k - th bit ; Stores the modulo of elements B [ ] with ( 2 ^ ( k + 1 ) ) ; Calculate modulo of array B [ ] with ( 2 ^ ( k + 1 ) ) ; Sort the array C [ ] ; Stores the total number whose k - th bit is set ; Calculate and store the modulo of array A [ ] with ( 2 ^ ( k + 1 ) ) ; Lower bound to count the number of elements having k - th bit in the range ( 2 ^ k - x , 2 * 2 ^ ( k ) - x ) ; Add total number i . e ( r - l ) whose k - th bit is one ; Lower bound to count the number of elements having k - th bit in range ( 3 * 2 ^ k - x , 4 * 2 ^ ( k ) - x ) ; If count is even , Xor of k - th bit becomes zero , no need to add to the answer . If count is odd , only then , add to the final answer ; Return answer ; Driver code ; Function call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "4332-4332",
        "Code": "def minCost ( arr , n ) : NEW_LINE INDENT sortedarr = [ ] NEW_LINE total_cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sortedarr . append ( [ arr [ i ] , i ] ) NEW_LINE DEDENT sortedarr . sort ( ) NEW_LINE overall_minimum = sortedarr [ 0 ] [ 0 ] NEW_LINE vis = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] and sortedarr [ i ] [ 1 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT v = [ ] NEW_LINE j = i NEW_LINE size = 0 NEW_LINE while vis [ j ] == False : NEW_LINE INDENT vis [ j ] = True NEW_LINE v . append ( sortedarr [ j ] [ 0 ] ) NEW_LINE j = sortedarr [ j ] [ 1 ] NEW_LINE size += 1 NEW_LINE DEDENT if size != 0 : NEW_LINE INDENT local_minimum = v [ 0 ] NEW_LINE result1 = 0 NEW_LINE result2 = 0 NEW_LINE for k in range ( 1 , size ) : NEW_LINE INDENT result1 += local_minimum * v [ k ] NEW_LINE DEDENT for k in range ( size ) : NEW_LINE INDENT result2 += overall_minimum * v [ k ] NEW_LINE DEDENT result2 += ( overall_minimum * local_minimum ) NEW_LINE total_cost += min ( result1 , result2 ) NEW_LINE DEDENT DEDENT return total_cost NEW_LINE DEDENT A = [ 1 , 8 , 9 , 7 , 6 ] NEW_LINE ans = minCost ( A , len ( A ) ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum cost to sort an Array such that swapping X and Y costs XY | Function returns the minimum cost to sort the given array ; Create array of pairs in which 1 st element is the array element and 2 nd element is index of first ; Initialize the total cost ; Sort the array with respect to array value ; Initialize the overall minimum which is the 1 st element ; To keep track of visited elements create a visited array & initialize all elements as not visited ; Iterate over every element of the array ; If the element is visited or in the sorted position , and check for next element ; Create a vector which stores all elements of a cycle ; It covers all the elements of a cycle ; If cycle is found then the swapping is required ; Initialize local minimum with 1 st element of the vector as it contains the smallest element in the beginning ; Stores the cost with using only local minimum value . ; Stores the cost of using both local minimum and overall minimum ; Update the result2 ; Store the minimum of the two result to total cost ; Return the minimum cost ; Given array arr [ ] ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4340-4340",
        "Code": "mod = 1e9 + 7 NEW_LINE def findMinValue ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE pro = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro [ i ] = ( ( i + 1 ) * ( n - i ) ) NEW_LINE pro [ i ] *= ( a [ i ] ) NEW_LINE DEDENT b . sort ( reverse = True ) NEW_LINE pro . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( pro [ i ] % mod * b [ i ] ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE b = [ 2 , 3 , 2 ] NEW_LINE print ( int ( findMinValue ( a , b ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize the Sum of all the subarrays made up of the products of same | Python3 Program to implement the above approach ; Function to rearrange the second array such that the sum of its product of same indexed elements from both the arrays is minimized ; Stores ( i - 1 ) * ( n - i ) * a [ i ] for every i - th element ; Updating the value of pro according to the function ; Sort the array in reverse order ; Sort the products ; Updating the ans ; Return the ans ; Driver code ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4342-4342",
        "Code": "def compare ( p1 , p2 ) : NEW_LINE INDENT return p1 [ 0 ] > p2 [ 0 ] NEW_LINE DEDENT def maximiseScore ( A , B , K , N ) : NEW_LINE INDENT pairs = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pairs . append ( [ A [ i ] , B [ i ] ] ) NEW_LINE DEDENT pairs . sort ( key = lambda x : x [ 0 ] , reverse = True ) NEW_LINE Sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( pairs [ i ] [ 1 ] == 0 ) : NEW_LINE INDENT Sum += pairs [ i ] [ 0 ] NEW_LINE DEDENT elif ( pairs [ i ] [ 1 ] == 1 ) : NEW_LINE INDENT if ( K > 0 ) : NEW_LINE INDENT Sum += pairs [ i ] [ 0 ] NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum -= pairs [ i ] [ 0 ] NEW_LINE DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT A = [ 5 , 4 , 6 , 2 , 8 ] NEW_LINE B = [ 1 , 0 , 1 , 1 , 0 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( maximiseScore ( A , B , K , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize the Sum of the given array using given operations | Comparator to sort the array in ascending order ; Function to maximise the sum of the given array ; Stores { A [ i ] , B [ i ] } pairs ; Sort in descending order of the values in the array A [ ] ; Stores the maximum sum ; If B [ i ] is equal to 0 ; Simply add A [ i ] to the sum ; Add the highest K numbers ; Subtract from the sum ; Return the sum ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4350-4350",
        "Code": "def removeElements ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] * pow ( 2 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ 3 , 1 , 2 , 3 ] NEW_LINE print ( removeElements ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost to empty Array where cost of removing an element is 2 ^ ( removed_count ) * arr [ i ] | Function to find the minimum cost of removing elements from the array ; Sorting in Increasing order ; Loop to find the minimum cost of removing elements ; Driver Code ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4365-4365",
        "Code": "MAX = int ( 1e5 + 5 ) NEW_LINE def find_missing ( interval ) : NEW_LINE INDENT vis = [ 0 ] * ( MAX ) NEW_LINE for i in range ( len ( interval ) ) : NEW_LINE INDENT start = interval [ i ] [ 0 ] NEW_LINE end = interval [ i ] [ 1 ] NEW_LINE vis [ start ] += 1 NEW_LINE vis [ end + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT vis [ i ] += vis [ i - 1 ] NEW_LINE if ( vis [ i ] == 0 ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT interval = [ [ 0 , 14 ] , [ 86 , 108 ] , [ 22 , 30 ] , [ 5 , 17 ] ] NEW_LINE find_missing ( interval ) NEW_LINE",
        "Type": "py",
        "NL": "Find least non | Python3 program to find the least non - overlapping number from a given set intervals ; Function to find the smallest non - overlapping number ; Create a visited array ; Find the first missing value ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4366-4366",
        "Code": "def find_missing ( interval ) : NEW_LINE INDENT interval . sort ( ) NEW_LINE mx = 0 NEW_LINE for i in range ( len ( interval ) ) : NEW_LINE INDENT if ( interval [ i ] [ 0 ] > mx ) : NEW_LINE INDENT print ( mx ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , interval [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT DEDENT print ( mx ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT interval = [ [ 0 , 14 ] , [ 86 , 108 ] , [ 22 , 30 ] , [ 5 , 17 ] ] NEW_LINE find_missing ( interval ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find least non | function to find the smallest non - overlapping number ; Sort the intervals based on their starting value ; Check if any missing value exist ; Finally print the missing value ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "438-438",
        "Code": "class DisjointUnionSets : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . rank = [ 0 ] * n NEW_LINE self . parent = [ 0 ] * n NEW_LINE self . n = n NEW_LINE self . makeSet ( ) NEW_LINE DEDENT def makeSet ( self ) : NEW_LINE INDENT for i in range ( self . n ) : NEW_LINE INDENT self . parent [ i ] = i NEW_LINE DEDENT DEDENT def find ( self , x ) : NEW_LINE INDENT if ( self . parent [ x ] != x ) : NEW_LINE INDENT return self . find ( self . parent [ x ] ) NEW_LINE DEDENT return x NEW_LINE DEDENT def Union ( self , x , y ) : NEW_LINE INDENT xRoot = self . find ( x ) NEW_LINE yRoot = self . find ( y ) NEW_LINE if xRoot == yRoot : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ xRoot ] < self . rank [ yRoot ] : NEW_LINE INDENT parent [ xRoot ] = yRoot NEW_LINE DEDENT elif self . rank [ yRoot ] < self . rank [ xRoot ] : NEW_LINE INDENT self . parent [ yRoot ] = xRoot NEW_LINE DEDENT else : NEW_LINE INDENT self . parent [ yRoot ] = xRoot NEW_LINE self . rank [ xRoot ] = self . rank [ xRoot ] + 1 NEW_LINE DEDENT DEDENT DEDENT def countIslands ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( a [ 0 ] ) NEW_LINE dus = DisjointUnionSets ( n * m ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( 0 , m ) : NEW_LINE INDENT if a [ j ] [ k ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if j + 1 < n and a [ j + 1 ] [ k ] == 1 : NEW_LINE INDENT dus . Union ( j * ( m ) + k , ( j + 1 ) * ( m ) + k ) NEW_LINE DEDENT if j - 1 >= 0 and a [ j - 1 ] [ k ] == 1 : NEW_LINE INDENT dus . Union ( j * ( m ) + k , ( j - 1 ) * ( m ) + k ) NEW_LINE DEDENT if k + 1 < m and a [ j ] [ k + 1 ] == 1 : NEW_LINE INDENT dus . Union ( j * ( m ) + k , ( j ) * ( m ) + k + 1 ) NEW_LINE DEDENT if k - 1 >= 0 and a [ j ] [ k - 1 ] == 1 : NEW_LINE INDENT dus . Union ( j * ( m ) + k , ( j ) * ( m ) + k - 1 ) NEW_LINE DEDENT if ( j + 1 < n and k + 1 < m and a [ j + 1 ] [ k + 1 ] == 1 ) : NEW_LINE INDENT dus . Union ( j * ( m ) + k , ( j + 1 ) * ( m ) + k + 1 ) NEW_LINE DEDENT if ( j + 1 < n and k - 1 >= 0 and a [ j + 1 ] [ k - 1 ] == 1 ) : NEW_LINE INDENT dus . Union ( j * m + k , ( j + 1 ) * ( m ) + k - 1 ) NEW_LINE DEDENT if ( j - 1 >= 0 and k + 1 < m and a [ j - 1 ] [ k + 1 ] == 1 ) : NEW_LINE INDENT dus . Union ( j * m + k , ( j - 1 ) * m + k + 1 ) NEW_LINE DEDENT if ( j - 1 >= 0 and k - 1 >= 0 and a [ j - 1 ] [ k - 1 ] == 1 ) : NEW_LINE INDENT dus . Union ( j * m + k , ( j - 1 ) * m + k - 1 ) NEW_LINE DEDENT DEDENT DEDENT c = [ 0 ] * ( n * m ) NEW_LINE numberOfIslands = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if a [ j ] [ k ] == 1 : NEW_LINE INDENT x = dus . find ( j * m + k ) NEW_LINE if c [ x ] == 0 : NEW_LINE INDENT numberOfIslands += 1 NEW_LINE c [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return numberOfIslands NEW_LINE DEDENT a = [ [ 1 , 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 0 , 0 ] , [ 1 , 0 , 1 , 0 , 1 ] ] NEW_LINE print ( \" Number ▁ of ▁ Islands ▁ is : \" , countIslands ( a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number of Islands | Set 2 ( Using Disjoint Set ) | Class to represent Disjoint Set Data structure ; Initially , all elements are in their own set . ; Finds the representative of the set that x is an element of ; if x is not the parent of itself , then x is not the representative of its set . so we recursively call Find on its parent and move i 's node directly under the  representative of this set ; Unites the set that includes x and the set that includes y ; Find the representatives ( or the root nodes ) for x an y ; Elements are in the same set , no need to unite anything . ; If x ' s ▁ rank ▁ is ▁ less ▁ than ▁ y ' s rank Then move x under y so that depth of tree remains less ; Else if y ' s ▁ rank ▁ is ▁ less ▁ than ▁ x ' s rank Then move y under x so that depth of tree remains less ; Else if their ranks are the same ; Then move y under x ( doesn 't matter which one goes where) ; And increment the result tree 's  rank by 1 ; Returns number of islands in a [ ] [ ] ; The following loop checks for its neighbours and unites the indexes if both are 1. ; If cell is 0 , nothing to do ; Check all 8 neighbours and do a Union with neighbour 's set if neighbour is  also 1 ; Array to note down frequency of each set ; If frequency of set is 0 , increment numberOfIslands ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "4381-4381",
        "Code": "from typing import Any , List NEW_LINE def countReductions ( v : List [ Any ] , K : int ) -> int : NEW_LINE INDENT sum = 0 NEW_LINE for i in v : NEW_LINE INDENT sum += i [ 0 ] NEW_LINE DEDENT if ( sum <= K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT v . sort ( key = lambda a : a [ 0 ] - a [ 1 ] ) NEW_LINE i = 0 NEW_LINE while ( sum > K and i < len ( v ) ) : NEW_LINE INDENT sum -= ( v [ i ] [ 0 ] - v [ i ] [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT if ( sum <= K ) : NEW_LINE INDENT return i NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE K = 25 NEW_LINE v = [ [ 0 , 0 ] for _ in range ( N ) ] NEW_LINE v [ 0 ] = [ 10 , 5 ] NEW_LINE v [ 1 ] = [ 20 , 9 ] NEW_LINE v [ 2 ] = [ 12 , 10 ] NEW_LINE v [ 3 ] = [ 4 , 2 ] NEW_LINE print ( countReductions ( v , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of minimum reductions required to get the required sum K | Python3 program to find the count of minimum reductions required to get the required sum K ; Function to return the count of minimum reductions ; If the sum is already less than K ; Sort in non - increasing order of difference ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4382-4382",
        "Code": "class node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def setData ( head ) : NEW_LINE INDENT tmp = head NEW_LINE while ( tmp != None ) : NEW_LINE INDENT print ( tmp . data , end = \" ▁ - > ▁ \" ) NEW_LINE tmp = tmp . next NEW_LINE DEDENT DEDENT def getData ( head , num ) : NEW_LINE INDENT temp = node ( - 1 ) NEW_LINE tail = head NEW_LINE temp . data = num NEW_LINE temp . next = None NEW_LINE if ( head == None ) : NEW_LINE INDENT head = temp NEW_LINE tail = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( tail != None ) : NEW_LINE INDENT if ( tail . next == None ) : NEW_LINE INDENT tail . next = temp NEW_LINE tail = tail . next NEW_LINE DEDENT tail = tail . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT def mergelists ( head1 , head2 ) : NEW_LINE INDENT tail = head1 NEW_LINE while ( tail != None ) : NEW_LINE INDENT if ( tail . next == None and head2 != None ) : NEW_LINE INDENT tail . next = head2 NEW_LINE break NEW_LINE DEDENT tail = tail . next NEW_LINE DEDENT return head1 NEW_LINE DEDENT def sortlist ( head1 ) : NEW_LINE INDENT curr = head1 NEW_LINE temp = head1 NEW_LINE while ( curr . next != None ) : NEW_LINE INDENT temp = curr . next NEW_LINE while ( temp != None ) : NEW_LINE INDENT if ( temp . data < curr . data ) : NEW_LINE INDENT t = temp . data NEW_LINE temp . data = curr . data NEW_LINE curr . data = t NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT curr = curr . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head1 = node ( - 1 ) NEW_LINE head2 = node ( - 1 ) NEW_LINE head1 = None NEW_LINE head2 = None NEW_LINE head1 = getData ( head1 , 4 ) NEW_LINE head1 = getData ( head1 , 7 ) NEW_LINE head1 = getData ( head1 , 5 ) NEW_LINE head2 = getData ( head2 , 2 ) NEW_LINE head2 = getData ( head2 , 1 ) NEW_LINE head2 = getData ( head2 , 8 ) NEW_LINE head2 = getData ( head2 , 1 ) NEW_LINE head1 = mergelists ( head1 , head2 ) NEW_LINE sortlist ( head1 ) NEW_LINE setData ( head1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Merge two unsorted linked lists to get a sorted list | Create structure for a node ; Function to print the linked list ; Store the head of the linked list into a temporary node * and iterate ; Function takes the head of the LinkedList and the data as argument and if no LinkedList exists , it creates one with the head pointing to first node . If it exists already , it appends given node at end of the last node ; Create a new node ; Insert data into the temporary node and point it 's next to NULL ; Check if head is null , create a linked list with temp as head and tail of the list ; Else insert the temporary node after the tail of the existing node and make the temporary node as the tail of the linked list ; Return the list ; Function to concatenate the two lists ; Iterate through the head1 to find the last node join the next of last node of head1 to the 1 st node of head2 ; return the concatenated lists as a single list - head1 ; Sort the linked list using bubble sort ; Compares two adjacent elements and swaps if the first element is greater than the other one . ; Driver Code ; Given Linked List 1 ; Given Linked List 2 ; Merge the two lists in a single list ; Sort the unsorted merged list ; Print the final sorted merged list",
        "Category": "Linked List"
    },
    {
        "ID": "4388-4388",
        "Code": "from queue import PriorityQueue NEW_LINE def final_element ( arr , n ) : NEW_LINE INDENT heap = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT heap . put ( - 1 * arr [ i ] ) NEW_LINE DEDENT while ( heap . qsize ( ) > 1 ) : NEW_LINE INDENT X = - 1 * heap . get ( ) NEW_LINE Y = - 1 * heap . get ( ) NEW_LINE if ( X != Y ) : NEW_LINE INDENT diff = abs ( X - Y ) NEW_LINE heap . put ( - 1 * diff ) NEW_LINE DEDENT DEDENT if ( heap . qsize ( ) == 1 ) : NEW_LINE INDENT print ( - 1 * heap . get ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE final_element ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Last element remaining by deleting two largest elements and replacing by their absolute difference if they are unequal | Python3 program for the above approach ; Function to print the remaining element ; Priority queue can be used to construct max - heap ; Insert all element of arr [ ] into priority queue . Default priority queue in Python is min - heap so use - 1 * arr [ i ] ; Perform operation until heap size becomes 0 or 1 ; Remove largest element ; Remove 2 nd largest element ; If extracted elements are not equal ; Find X - Y and push it to heap ; If heap size is 1 , then print the remaining element ; Else print \" - 1\" ; Driver Code ; Given array arr [ ] ; Size of array arr [ ] ; Function call",
        "Category": "Heap"
    },
    {
        "ID": "4414-4414",
        "Code": "def sortDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE out = [ ] NEW_LINE while n : NEW_LINE INDENT out . append ( arr . pop ( n // 2 ) ) NEW_LINE n = n - 1 NEW_LINE DEDENT print ( * out ) NEW_LINE return out NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 3 , 0 ] NEW_LINE n = 5 NEW_LINE sortDiff ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort elements of an array in increasing order of absolute difference of adjacent elements | Function to sort the elements of the array by difference ; Sorting the array ; Array to store the elements of the array ; Iterating over the length of the array to include each middle element of array ; Appending the middle element of the array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4418-4418",
        "Code": "sticks = [ 6 , 7 , 4 , 6 , 5 , 4 , 6 , 5 , 2 , 4 , 4 , 3 , 6 , 6 , 6 , 5 , 7 , 6 , 5 , 3 , 5 , 4 , 6 , 4 , 3 , 4 ] NEW_LINE number = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE def countSticks ( st ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ch = st [ i ] NEW_LINE if ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT cnt += sticks [ ord ( ch ) - ord ( ' A ' ) ] NEW_LINE DEDENT else : NEW_LINE INDENT cnt += number [ ord ( ch ) - ord ( '0' ) ] NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def sortArr ( arr , n ) : NEW_LINE INDENT vp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT vp . append ( [ countSticks ( arr [ i ] ) , arr [ i ] ] ) NEW_LINE DEDENT vp . sort ( ) NEW_LINE for i in range ( len ( vp ) ) : NEW_LINE INDENT print ( vp [ i ] [ 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" GEEKS \" , \" FOR \" , \" GEEKSFORGEEKS \" ] NEW_LINE n = len ( arr ) NEW_LINE sortArr ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort the strings based on the numbers of matchsticks required to represent them | Stick [ ] stores the count of sticks required to represent the alphabets ; Number [ ] stores the count of sticks required to represent the numerals ; Function that return the count of sticks required to represent the given string str ; Loop to iterate over every character of the string ; Add the count of sticks required to represent the current character ; Function to sort the array according to the number of sticks required to represent it ; Vector to store the number of sticks required with respective strings ; Inserting number of sticks with respective strings ; Sort the vector ; Print the sorted vector ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4419-4419",
        "Code": "from functools import cmp_to_key NEW_LINE def myCompare ( date1 , date2 ) : NEW_LINE INDENT day1 = date1 [ 0 : 2 ] NEW_LINE month1 = date1 [ 3 : 3 + 2 ] NEW_LINE year1 = date1 [ 6 : 6 + 4 ] NEW_LINE day2 = date2 [ 0 : 2 ] NEW_LINE month2 = date2 [ 3 : 3 + 2 ] NEW_LINE year2 = date2 [ 6 : 6 + 4 ] NEW_LINE if ( year1 < year2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( year1 > year2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( month1 < month2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( month1 > month2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( day1 < day2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( day1 > day2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def printDatesAscending ( arr ) : NEW_LINE INDENT arr = sorted ( arr , key = cmp_to_key ( lambda a , b : myCompare ( a , b ) ) ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT arr = [ ] NEW_LINE arr . append ( \"25-08-1996\" ) NEW_LINE arr . append ( \"03-08-1970\" ) NEW_LINE arr . append ( \"09-04-1994\" ) NEW_LINE arr . append ( \"29-08-1996\" ) NEW_LINE arr . append ( \"14-02-1972\" ) NEW_LINE printDatesAscending ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Sort an Array of dates in ascending order using Custom Comparator | Python3 implementation to sort the array of dates in the form of \" DD - MM - YYYY \" using custom comparator ; Comparator to sort the array of dates ; Condition to check the year ; Condition to check the month ; Condition to check the day ; Function that prints the dates in ascensding order ; Sort the dates using library sort function with custom Comparator ; Loop to print the dates ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4446-4446",
        "Code": "def isVowel ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) ; NEW_LINE return ( ch == ' A ' or ch == ' E ' or ch == ' I ' or ch == ' O ' or ch == ' U ' ) ; NEW_LINE DEDENT def countVowels ( string ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def sortArr ( arr , n ) : NEW_LINE INDENT vp = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT vp . append ( ( countVowels ( arr [ i ] ) , arr [ i ] ) ) ; NEW_LINE DEDENT vp . sort ( ) NEW_LINE for i in range ( len ( vp ) ) : NEW_LINE INDENT print ( vp [ i ] [ 1 ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" lmno \" , \" pqrst \" , \" aeiou \" , \" xyz \" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sortArr ( arr , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort an Array of Strings according to the number of Vowels in them | Function to check the Vowel ; Returns count of vowels in str ; Check for vowel ; Function to sort the array according to the number of the vowels ; Vector to store the number of vowels with respective elements ; Inserting number of vowels with respective strings in the vector pair ; Sort the vector , this will sort the pair according to the number of vowels ; Print the sorted vector content ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4449-4449",
        "Code": "def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkIsGP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE r = arr [ 1 ] / arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] / arr [ i - 1 ] != r ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkIsHP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT rec = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rec . append ( ( 1 / arr [ i ] ) ) NEW_LINE DEDENT if ( checkIsAP ( rec , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT arr = [ 1.0 / 5.0 , 1.0 / 10.0 , 1.0 / 15.0 , 1.0 / 20.0 ] NEW_LINE n = len ( arr ) NEW_LINE flag = 0 NEW_LINE if ( checkIsAP ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ An ▁ AP ▁ can ▁ be ▁ formed \" , end =   ' ' ) NEW_LINE flag = 1 NEW_LINE DEDENT if ( checkIsGP ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ A ▁ GP ▁ can ▁ be ▁ formed \" , end =   ' ' ) NEW_LINE flag = 1 NEW_LINE DEDENT if ( checkIsHP ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes , ▁ A ▁ HP ▁ can ▁ be ▁ formed \" , end =   ' ' ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( flag == 0 ) : NEW_LINE INDENT print ( \" No \" , end =   ' ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if elements of array can be arranged in AP , GP or HP | Returns true if arr [ 0. . n - 1 ] can form AP ; Base Case ; Sort array ; After sorting , difference between consecutive elements must be same . ; Traverse the given array and check if the difference between ith element and ( i - 1 ) th element is same or not ; Returns true if arr [ 0. . n - 1 ] can form GP ; Base Case ; Sort array ; After sorting , common ratio between consecutive elements must be same . ; Traverse the given array and check if the common ratio between ith element and ( i - 1 ) th element is same or not ; Returns true if arr [ 0. . n - 1 ] can form HP ; Base Case ; Find reciprocal of arr [ ] ; After finding reciprocal , check if the reciprocal is in A . P . To check for A . P . ; Driver Code ; Function to check AP ; Function to check GP ; Function to check HP",
        "Category": "Array"
    },
    {
        "ID": "445-445",
        "Code": "def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( sum ( graph [ i ] ) ) NEW_LINE DEDENT startpoint , numofodd = 0 , 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( numofadj [ i ] % 2 == 1 ) : NEW_LINE INDENT numofodd += 1 NEW_LINE startpoint = i NEW_LINE DEDENT DEDENT if ( numofodd > 2 ) : NEW_LINE INDENT print ( \" No ▁ Solution \" ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE path = [ ] NEW_LINE cur = startpoint NEW_LINE while ( len ( stack ) > 0 or sum ( graph [ cur ] ) != 0 ) : NEW_LINE INDENT if ( sum ( graph [ cur ] ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack [ - 1 ] NEW_LINE del stack [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( graph [ cur ] [ i ] == 1 ) : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , end = \" ▁ - > ▁ \" ) NEW_LINE DEDENT print ( cur ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT graph1 = [ [ 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 , 0 ] ] NEW_LINE n = len ( graph1 ) NEW_LINE findpath ( graph1 , n ) NEW_LINE graph2 = [ [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 0 , 0 ] ] NEW_LINE n = len ( graph2 ) NEW_LINE findpath ( graph2 , n ) NEW_LINE graph3 = [ [ 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 1 , 0 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] ] NEW_LINE n = len ( graph3 ) NEW_LINE findpath ( graph3 , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Eulerian Path in undirected graph | Function to find out the path It takes the adjacency matrix representation of the graph as input ; Find out number of edges each vertex has ; Find out how many vertex has odd number edges ; If number of vertex with odd number of edges is greater than two return \" No ▁ Solution \" . ; If there is a path find the path Initialize empty stack and path take the starting current as discussed ; Loop will run until there is element in the stack or current edge has some neighbour . ; If current node has not any neighbour add it to path and pop stack set new current to the popped element ; If the current vertex has at least one neighbour add the current vertex to stack , remove the edge between them and set the current to its neighbour . ; Print the path ; Driver Code ; Test case 1 ; Test case 2 ; Test case 3",
        "Category": "Graph Theory"
    },
    {
        "ID": "4453-4453",
        "Code": "def sortMat ( data , row , col ) : NEW_LINE INDENT size = row * col NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( 0 , size - 1 ) : NEW_LINE INDENT if ( data [ j // col ] [ j % col ] > data [ ( j + 1 ) // col ] [ ( j + 1 ) % col ] ) : NEW_LINE INDENT temp = data [ j // col ] [ j % col ] NEW_LINE data [ j // col ] [ j % col ] = data [ ( j + 1 ) // col ] [ ( j + 1 ) % col ] NEW_LINE data [ ( j + 1 ) // col ] [ ( j + 1 ) % col ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def printMat ( mat , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE row = len ( mat ) NEW_LINE col = len ( mat [ 0 ] ) NEW_LINE sortMat ( mat , row , col ) NEW_LINE printMat ( mat , row , col ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort the given Matrix | Memory Efficient Approach | Function to sort the matrix ; Number of elements in matrix ; Loop to sort the matrix using Bubble Sort ; Condition to check if the Adjacent elements ; Swap if previous value is greater ; Loop to print the matrix ; Driver Code ; Function call to sort ; Function call to print matrix",
        "Category": "Matrix"
    },
    {
        "ID": "4461-4461",
        "Code": "def overlap ( v ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE data = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT data . append ( [ v [ i ] [ 0 ] , ' x ' ] ) NEW_LINE data . append ( [ v [ i ] [ 1 ] , ' y ' ] ) NEW_LINE DEDENT data = sorted ( data ) NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT if ( data [ i ] [ 1 ] == ' x ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( data [ i ] [ 1 ] == ' y ' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT v = [ [ 1 , 2 ] , [ 2 , 4 ] , [ 3 , 6 ] ] NEW_LINE overlap ( v ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum number of overlapping Intervals | Function that prmaximum overlap among ranges ; variable to store the maximum count ; storing the x and y coordinates in data vector ; pushing the x coordinate ; pushing the y coordinate ; sorting of ranges ; Traverse the data vector to count number of overlaps ; if x occur it means a new range is added so we increase count ; if y occur it means a range is ended so we decrease count ; updating the value of ans after every traversal ; printing the maximum value ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "447-447",
        "Code": "from collections import deque NEW_LINE def shortestChainLen ( start , target , D ) : NEW_LINE INDENT if start == target : NEW_LINE return 0 NEW_LINE if target not in D : NEW_LINE INDENT return 0 NEW_LINE DEDENT level , wordlength = 0 , len ( start ) NEW_LINE Q = deque ( ) NEW_LINE Q . append ( start ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT level += 1 NEW_LINE sizeofQ = len ( Q ) NEW_LINE for i in range ( sizeofQ ) : NEW_LINE INDENT word = [ j for j in Q . popleft ( ) ] NEW_LINE for pos in range ( wordlength ) : NEW_LINE INDENT orig_char = word [ pos ] NEW_LINE for c in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT word [ pos ] = chr ( c ) NEW_LINE if ( \" \" . join ( word ) == target ) : NEW_LINE INDENT return level + 1 NEW_LINE DEDENT if ( \" \" . join ( word ) not in D ) : NEW_LINE INDENT continue NEW_LINE DEDENT del D [ \" \" . join ( word ) ] NEW_LINE Q . append ( \" \" . join ( word ) ) NEW_LINE DEDENT word [ pos ] = orig_char NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT D = { } NEW_LINE D [ \" poon \" ] = 1 NEW_LINE D [ \" plee \" ] = 1 NEW_LINE D [ \" same \" ] = 1 NEW_LINE D [ \" poie \" ] = 1 NEW_LINE D [ \" plie \" ] = 1 NEW_LINE D [ \" poin \" ] = 1 NEW_LINE D [ \" plea \" ] = 1 NEW_LINE start = \" toon \" NEW_LINE target = \" plea \" NEW_LINE print ( \" Length ▁ of ▁ shortest ▁ chain ▁ is : ▁ \" , shortestChainLen ( start , target , D ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Word Ladder ( Length of shortest chain to reach a target word ) | Python3 program to find length of the shortest chain transformation from source to target ; Returns length of shortest chain to reach ' target ' from ' start ' using minimum number of adjacent moves . D is dictionary ; If the target is not present in the dictionary ; To store the current chain length and the length of the words ; Push the starting word into the queue ; While the queue is non - empty ; Increment the chain length ; Current size of the queue ; Since the queue is being updated while it is being traversed so only the elements which were already present in the queue before the start of this loop will be traversed for now ; Remove the first word from the queue ; For every character of the word ; Retain the original character at the current position ; Replace the current character with every possible lowercase alphabet ; If the new word is equal to the target word ; Remove the word from the set if it is found in it ; And push the newly generated word which will be a part of the chain ; Restore the original character at the current position ; Driver code ; Make dictionary",
        "Category": "Breadth First Search (BFS) is the core algorithmic technique used in this solution. However, since BFS is not explicitly listed in the provided category list and the implementation uses a **Queue** (from collections import deque) for level-order"
    },
    {
        "ID": "4476-4476",
        "Code": "def sortArrays ( arr , length ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < length - 1 ) : NEW_LINE INDENT d1 = arr [ j ] NEW_LINE d2 = arr [ j + 1 ] NEW_LINE if ( d1 > d2 ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j + 1 ] NEW_LINE arr [ j + 1 ] = temp NEW_LINE j = - 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT geeks = \" GEEKSFORGEEKS \" NEW_LINE n = len ( geeks ) NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = geeks [ i ] NEW_LINE DEDENT print ( \" Original ▁ array : ▁ [ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) if ( i + 1 != n ) : print ( \" , ▁ \" , end = \" \" ) print ( \" ] \" ) NEW_LINE DEDENT ansarr = sortArrays ( arr , n ) NEW_LINE print ( \" Sorted ▁ array : ▁ [ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ansarr [ i ] , end = \" \" ) if ( i + 1 != n ) : print ( \" , ▁ \" , end = \" \" ) print ( \" ] \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to sort an array in a single loop ? | Function for Sorting the array using a single loop ; Sorting using a single loop ; Type Conversion of char to int . ; Comparing the ascii code . ; Swapping of the characters ; Declaring a String ; declaring character array ; copying the contents of the string to char array ; Printing the original Array . ; Sorting the array using a single loop ; Printing the sorted array .",
        "Category": "Array"
    },
    {
        "ID": "4484-4484",
        "Code": "def partOdd ( s ) : NEW_LINE INDENT odd = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT odd . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return odd NEW_LINE DEDENT def partEven ( s ) : NEW_LINE INDENT even = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return even NEW_LINE DEDENT def canBeMadeEqual ( s1 , s2 ) : NEW_LINE INDENT even_s1 = partEven ( s1 ) NEW_LINE even_s2 = partEven ( s2 ) NEW_LINE odd_s1 = partOdd ( s1 ) NEW_LINE odd_s2 = partOdd ( s2 ) NEW_LINE even_s1 . sort ( ) NEW_LINE even_s2 . sort ( ) NEW_LINE odd_s1 . sort ( ) NEW_LINE odd_s2 . sort ( ) NEW_LINE if even_s1 == even_s2 and odd_s1 == odd_s2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s1 = \" cdab \" NEW_LINE s2 = \" abcd \" NEW_LINE if canBeMadeEqual ( s1 , s2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether the string S1 can be made equal to S2 with the given operation | Function to return the string formed by the odd indexed characters of s ; Function to return the string formed by the even indexed characters of s ; Function that returns true if s1 can be made equal to s2 with the given operation ; Get the string formed by the even indexed characters of s1 ; Get the string formed by the even indexed characters of s2 ; Get the string formed by the odd indexed characters of s1 ; Get the string formed by the odd indexed characters of s2 ; Sorting all the lists ; If the strings can be made equal ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "4487-4487",
        "Code": "MAX = 100001 NEW_LINE def isPossible ( rangee , N ) : NEW_LINE INDENT test = [ [ 0 for x in range ( 3 ) ] for x in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT test [ i ] [ 0 ] = rangee [ i ] [ 0 ] NEW_LINE test [ i ] [ 1 ] = rangee [ i ] [ 1 ] NEW_LINE test [ i ] [ 2 ] = rangee [ i ] [ 2 ] NEW_LINE DEDENT test . sort ( key = lambda x : x [ 2 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE current_velocity = test [ i ] [ 2 ] NEW_LINE j = i NEW_LINE while ( j < N and test [ j ] [ 2 ] == current_velocity ) : NEW_LINE INDENT for k in range ( test [ j ] [ 0 ] , test [ j ] [ 1 ] + 1 ) : NEW_LINE INDENT count [ k ] += 1 NEW_LINE if ( count [ k ] >= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT rangee = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 1 ] , [ 3 , 10 , 1 ] , [ 4 , 4 , 1 ] , [ 5 , 7 , 10 ] ] NEW_LINE n = len ( rangee ) NEW_LINE if ( isPossible ( rangee , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if there exists a direction for ranges such that no two range intersect | Python implementation of the approach ; Function that returns true if the assignment of directions is possible ; Structure to hold details of each interval ; Sort the intervals based on velocity ; Test the condition for all intervals with same velocity ; If for any velocity , 3 or more intervals share a common poreturn false ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "45-45",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printSpecificLevelOrder ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT print root . data , NEW_LINE if root . left is not None : NEW_LINE INDENT print root . left . data , NEW_LINE print root . right . data , NEW_LINE DEDENT if root . left . left is None : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root . left ) NEW_LINE q . append ( root . right ) NEW_LINE first = None NEW_LINE second = None NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT first = q . pop ( 0 ) NEW_LINE second = q . pop ( 0 ) NEW_LINE print first . left . data , NEW_LINE print second . right . data , NEW_LINE print first . right . data , NEW_LINE print second . left . data , NEW_LINE if first . left . left is not None : NEW_LINE INDENT q . append ( first . left ) NEW_LINE q . append ( second . right ) NEW_LINE q . append ( first . right ) NEW_LINE q . append ( second . left ) NEW_LINE DEDENT DEDENT DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . left . left . left = Node ( 8 ) NEW_LINE root . left . left . right = Node ( 9 ) NEW_LINE root . left . right . left = Node ( 10 ) NEW_LINE root . left . right . right = Node ( 11 ) NEW_LINE root . right . left . left = Node ( 12 ) NEW_LINE root . right . left . right = Node ( 13 ) NEW_LINE root . right . right . left = Node ( 14 ) NEW_LINE root . right . right . right = Node ( 15 ) NEW_LINE root . left . left . left . left = Node ( 16 ) NEW_LINE root . left . left . left . right = Node ( 17 ) NEW_LINE root . left . left . right . left = Node ( 18 ) NEW_LINE root . left . left . right . right = Node ( 19 ) NEW_LINE root . left . right . left . left = Node ( 20 ) NEW_LINE root . left . right . left . right = Node ( 21 ) NEW_LINE root . left . right . right . left = Node ( 22 ) NEW_LINE root . left . right . right . right = Node ( 23 ) NEW_LINE root . right . left . left . left = Node ( 24 ) NEW_LINE root . right . left . left . right = Node ( 25 ) NEW_LINE root . right . left . right . left = Node ( 26 ) NEW_LINE root . right . left . right . right = Node ( 27 ) NEW_LINE root . right . right . left . left = Node ( 28 ) NEW_LINE root . right . right . left . right = Node ( 29 ) NEW_LINE root . right . right . right . left = Node ( 30 ) NEW_LINE root . right . right . right . right = Node ( 31 ) NEW_LINE print \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" NEW_LINE printSpecificLevelOrder ( root ) ; NEW_LINE",
        "Type": "py",
        "NL": "Perfect Binary Tree Specific Level Order Traversal | A binary tree ndoe ; Given a perfect binary tree print its node in specific order ; Let us print root and next level first ; Since it is perfect Binary tree , one of the node is needed to be checked ; Do anythong more if there are nodes at next level in given perfect Binary Tree ; Create a queue and enqueue left and right children of root ; We process two nodes at a time , so we need two variables to stroe two front items of queue ; Traversal loop ; Pop two items from queue ; Print children of first and second in reverse order ; If first and second have grandchildren , enqueue them in reverse order ; Driver program to test above function Perfect Binary Tree of Height 4",
        "Category": "Binary Tree"
    },
    {
        "ID": "4500-4500",
        "Code": "x = - 1 ; NEW_LINE heap = [ 0 ] * 1000 ; NEW_LINE def heapForm ( k ) : NEW_LINE INDENT global x ; NEW_LINE x += 1 ; NEW_LINE heap [ x ] = k ; NEW_LINE child = x ; NEW_LINE index = x // 2 ; NEW_LINE while ( index >= 0 ) : NEW_LINE INDENT if ( heap [ index ] > heap [ child ] ) : NEW_LINE INDENT tmp = heap [ index ] ; NEW_LINE heap [ index ] = heap [ child ] ; NEW_LINE heap [ child ] = tmp ; NEW_LINE child = index ; NEW_LINE index = index // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT def heapSort ( ) : NEW_LINE INDENT global x ; NEW_LINE while ( x >= 0 ) : NEW_LINE INDENT k = heap [ 0 ] ; NEW_LINE print ( k , end = \" ▁ \" ) ; NEW_LINE heap [ 0 ] = heap [ x ] ; NEW_LINE x = x - 1 ; NEW_LINE tmp = - 1 ; NEW_LINE index = 0 ; NEW_LINE length = x ; NEW_LINE left1 = 1 ; NEW_LINE right1 = left1 + 1 ; NEW_LINE while ( left1 <= length ) : NEW_LINE INDENT if ( heap [ index ] <= heap [ left1 ] and heap [ index ] <= heap [ right1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( heap [ left1 ] < heap [ right1 ] ) : NEW_LINE INDENT tmp = heap [ index ] ; NEW_LINE heap [ index ] = heap [ left1 ] ; NEW_LINE heap [ left1 ] = tmp ; NEW_LINE index = left1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tmp = heap [ index ] ; NEW_LINE heap [ index ] = heap [ right1 ] ; NEW_LINE heap [ right1 ] = tmp ; NEW_LINE index = right1 ; NEW_LINE DEDENT DEDENT left1 = 2 * left1 ; NEW_LINE right1 = left1 + 1 ; NEW_LINE DEDENT DEDENT DEDENT def sort ( k , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT heapForm ( k [ i ] ) ; NEW_LINE DEDENT heapSort ( ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" banana \" , \" orange \" , \" apple \" , \" pineapple \" , \" berries \" , \" lichi \" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sort ( arr , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographical ordering using Heap Sort | Used for index in heap ; Predefining the heap array ; Defining formation of the heap ; Iterative heapiFy ; Just swapping if the element is smaller than already stored element ; Swapping the current index with its child ; Moving upward in the heap ; Defining heap sort ; Taking output of the minimum element ; Set first element as a last one ; Decrement of the size of the string ; Initializing the left and right index ; Process of heap sort If root element is minimum than its both of the child then break ; Otherwise checking that the child which one is smaller , swap them with parent element ; Swapping ; Changing the left index and right index ; Utility function ; To heapiFy ; Calling heap sort function ; Driver Code",
        "Category": "Heap"
    },
    {
        "ID": "4504-4504",
        "Code": "N = 20 NEW_LINE fact = [ 0 ] * N ; NEW_LINE def pre ( ) : NEW_LINE INDENT fact [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] ; NEW_LINE DEDENT DEDENT def CountPermutation ( a , n ) : NEW_LINE INDENT ways = 1 ; NEW_LINE a . sort ( ) ; NEW_LINE size = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] ) : NEW_LINE INDENT size += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ways *= fact [ size ] ; NEW_LINE size = 1 ; NEW_LINE DEDENT DEDENT ways *= fact [ size ] ; NEW_LINE return ways ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 4 , 4 , 2 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE pre ( ) ; NEW_LINE print ( CountPermutation ( a , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count permutation such that sequence is non decreasing | Python3 implementation of the approach ; To store the factorials ; Function to update fact [ ] array such that fact [ i ] = i ! ; 0 ! = 1 ; i ! = i * ( i - 1 ) ! ; Function to return the count of possible permutations ; To store the result ; Sort the array ; Initial size of the block ; Increase the size of block ; Update the result for the previous block ; Reset the size to 1 ; Update the result for the last block ; Driver code ; Pre - calculating factorials",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "4505-4505",
        "Code": "N = 2005 NEW_LINE ans = dict ( ) NEW_LINE def dfs ( n , left , ct ) : NEW_LINE INDENT if ( ct >= 15 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( left == 0 ) : NEW_LINE INDENT ans [ n ] = 1 NEW_LINE DEDENT for i in range ( min ( left , 9 ) + 1 ) : NEW_LINE INDENT dfs ( n * 10 + i , left - i , ct + 1 ) NEW_LINE DEDENT DEDENT def getKthNum ( m , k ) : NEW_LINE INDENT dfs ( 0 , m , 0 ) NEW_LINE c = 0 NEW_LINE for it in sorted ( ans . keys ( ) ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c == k ) : NEW_LINE INDENT return it NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT m = 5 NEW_LINE k = 3 NEW_LINE print ( getKthNum ( m , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the kth smallest number with sum of digits as m | Python3 implementation of the approach ; Recursively moving to add all the numbers upto a limit with sum of digits as m ; Max nber of digits allowed in a nber for this implementation ; Function to return the kth number with sum of digits as m ; The kth smallest number is found ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "4506-4506",
        "Code": "mod = 1000000007 NEW_LINE def power ( x : int , y : int , p : int ) -> int : NEW_LINE INDENT res = 1 NEW_LINE x %= p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y // 2 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT size = [ 0 ] * 300005 NEW_LINE freq = [ 0 ] * 300004 NEW_LINE edges = [ ] NEW_LINE def initialize ( arr : list , N : int ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE size [ i ] = 1 NEW_LINE DEDENT DEDENT def root ( arr : list , i : int ) -> int : NEW_LINE INDENT while arr [ i ] != i : NEW_LINE INDENT i = arr [ i ] NEW_LINE DEDENT return i NEW_LINE DEDENT def weighted_union ( arr : list , size : list , A : int , B : int ) : NEW_LINE INDENT root_A = root ( arr , A ) NEW_LINE root_B = root ( arr , B ) NEW_LINE if size [ root_A ] < size [ root_B ] : NEW_LINE INDENT arr [ root_A ] = arr [ root_B ] NEW_LINE size [ root_B ] += size [ root_A ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ root_B ] = arr [ root_A ] NEW_LINE size [ root_A ] += size [ root_B ] NEW_LINE DEDENT DEDENT def AddEdge ( a : int , b : int , w : int ) : NEW_LINE INDENT edges . append ( ( w , ( a , b ) ) ) NEW_LINE DEDENT def makeTree ( ) : NEW_LINE INDENT AddEdge ( 1 , 2 , 1 ) NEW_LINE AddEdge ( 1 , 3 , 3 ) NEW_LINE AddEdge ( 3 , 4 , 2 ) NEW_LINE DEDENT def minProduct ( ) -> int : NEW_LINE INDENT result = 1 NEW_LINE edges . sort ( key = lambda a : a [ 0 ] ) NEW_LINE for i in range ( len ( edges ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_weight = edges [ i ] [ 0 ] NEW_LINE node1 = edges [ i ] [ 1 ] [ 0 ] NEW_LINE node2 = edges [ i ] [ 1 ] [ 1 ] NEW_LINE root1 = root ( freq , node1 ) NEW_LINE set1_size = size [ root1 ] NEW_LINE root2 = root ( freq , node2 ) NEW_LINE set2_size = size [ root2 ] NEW_LINE prod = set1_size * set2_size NEW_LINE product = power ( curr_weight , prod , mod ) NEW_LINE result = ( ( result % mod ) * ( product % mod ) ) % mod NEW_LINE weighted_union ( freq , size , node1 , node2 ) NEW_LINE DEDENT return result % mod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE initialize ( freq , n ) NEW_LINE makeTree ( ) NEW_LINE print ( minProduct ( ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Product of minimum edge weight between all pairs of a Tree | Python3 implementation of the approach ; Function to return ( x ^ y ) mod p ; Declaring size array globally ; Initializing DSU data structure ; Function to find the root of ith node in the disjoint set ; Weighted union using Path Compression ; size of set A is small than size of set B ; size of set B is small than size of set A ; Function to add an edge in the tree ; Build the tree ; Function to return the required product ; Sorting the edges with respect to its weight ; Start iterating in decreasing order of weight ; Determine Current edge values ; Calculate root of each node and size of each set ; Using the formula ; Calculating final result ; Weighted union using Path Compression ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "4521-4521",
        "Code": "def findSubarray ( a , k , n ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( i , i + k ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT vec . append ( temp ) NEW_LINE DEDENT vec = sorted ( vec ) NEW_LINE return vec [ len ( vec ) - 1 ] NEW_LINE DEDENT a = [ 1 , 4 , 3 , 2 , 5 ] NEW_LINE k = 4 NEW_LINE n = len ( a ) NEW_LINE ans = findSubarray ( a , k , n ) NEW_LINE for it in ans : NEW_LINE INDENT print ( it , end = \" ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Greatest contiguous sub | Function that returns the sub - array ; Data - structure to store all the sub - arrays of size K ; Iterate to find all the sub - arrays ; Store the sub - array elements in the array ; Push the vector in the container ; Sort the vector of elements ; The last sub - array in the sorted order will be the answer ; Driver code ; Get the sub - array",
        "Category": "Sliding Window"
    },
    {
        "ID": "4531-4531",
        "Code": "def CountCircles ( c , r , n ) : NEW_LINE INDENT diameter = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT obj = [ ] NEW_LINE obj . append ( c [ i ] - r [ i ] ) NEW_LINE obj . append ( c [ i ] + r [ i ] ) NEW_LINE diameter . append ( obj ) NEW_LINE DEDENT diameter . sort ( ) NEW_LINE count = 0 NEW_LINE cur = diameter [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( diameter [ i ] [ 0 ] > cur ) : NEW_LINE INDENT cur = diameter [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT c = [ 1 , 2 , 3 , 4 ] NEW_LINE r = [ 1 , 1 , 1 , 1 ] NEW_LINE n = len ( c ) NEW_LINE CountCircles ( c , r , n ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum Circles needed to be removed so that all remaining circles are non intersecting | Function to return the count of non intersecting circles ; Structure with start and end of diameter of circles ; Sorting with smallest finish time first ; count stores number of circles to be removed ; cur stores ending of first circle ; Non intersecting circles ; Intersecting circles ; Centers of circles ; Radius of circles ; Number of circles",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4534-4534",
        "Code": "def partition ( arr , low , high , mod ) : NEW_LINE INDENT pivot = ord ( arr [ high ] ) ; NEW_LINE i = ( low - 1 ) ; NEW_LINE piv = pivot % mod ; NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT a = ord ( arr [ j ] ) % mod ; NEW_LINE if ( a <= piv ) : NEW_LINE INDENT i += 1 ; NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) ; NEW_LINE DEDENT def quickSort ( arr , low , high , mod ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high , mod ) ; NEW_LINE quickSort ( arr , low , pi - 1 , mod ) ; NEW_LINE quickSort ( arr , pi + 1 , high , mod ) ; NEW_LINE return arr NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ ' g ' , ' e ' , ' e ' , ' k ' , ' s ' ] ; NEW_LINE n = len ( arr ) ; NEW_LINE mod = 8 ; NEW_LINE arr = quickSort ( arr , 0 , n - 1 , mod ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort the character array based on ASCII % N | This function takes last element as pivot , places the pivot element at its correct position in sorted array , and places all smaller ( smaller than pivot ) to left of pivot and all greater elements to right of pivot ; pivot ; Index of smaller element ; If current element is smaller than or equal to pivot Instead of values , ASCII % m values are compared ; Increment index of smaller element ; swap ; The main function that implements QuickSort arr [ ] -- > Array to be sorted , low -- > Starting index , high -- > Ending index ; pi is partitioning index , arr [ p ] is now at right place ; Separately sort elements before partition and after partition ; Function to print the given array ; Driver code ; Sort the given array ; Print the sorted array",
        "Category": "Array"
    },
    {
        "ID": "4539-4539",
        "Code": "class node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . data , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def merge ( root1 , root2 ) : NEW_LINE INDENT if ( not root1 and not root2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( not root1 ) : NEW_LINE INDENT inorder ( root2 ) NEW_LINE return NEW_LINE DEDENT if ( not root2 ) : NEW_LINE INDENT inorder ( root1 ) NEW_LINE return NEW_LINE DEDENT temp1 = root1 NEW_LINE prev1 = None NEW_LINE while ( temp1 . left ) : NEW_LINE INDENT prev1 = temp1 NEW_LINE temp1 = temp1 . left NEW_LINE DEDENT temp2 = root2 NEW_LINE prev2 = None NEW_LINE while ( temp2 . left ) : NEW_LINE INDENT prev2 = temp2 NEW_LINE temp2 = temp2 . left NEW_LINE DEDENT if ( temp1 . data <= temp2 . data ) : NEW_LINE INDENT print ( temp1 . data , end = \" ▁ \" ) NEW_LINE if ( prev1 == None ) : NEW_LINE INDENT merge ( root1 . right , root2 ) NEW_LINE DEDENT else : NEW_LINE INDENT prev1 . left = temp1 . right NEW_LINE merge ( root1 , root2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( temp2 . data , end = \" ▁ \" ) NEW_LINE if ( prev2 == None ) : NEW_LINE INDENT merge ( root1 , root2 . right ) NEW_LINE DEDENT else : NEW_LINE INDENT prev2 . left = temp2 . right NEW_LINE merge ( root1 , root2 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = None NEW_LINE root2 = None NEW_LINE root1 = node ( 3 ) NEW_LINE root1 . left = node ( 1 ) NEW_LINE root1 . right = node ( 5 ) NEW_LINE root2 = node ( 4 ) NEW_LINE root2 . left = node ( 2 ) NEW_LINE root2 . right = node ( 6 ) NEW_LINE merge ( root1 , root2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Merge two BSTs with constant extra space | Node of the binary tree ; A utility function to print Inorder traversal of a Binary Tree ; The function to print data of two BSTs in sorted order ; Base cases ; If the first tree is exhausted simply print the inorder traversal of the second tree ; If second tree is exhausted simply print the inoreder traversal of the first tree ; A temporary pointer currently pointing to root of first tree ; previous pointer to store the parent of temporary pointer ; Traverse through the first tree until you reach the leftmost element , which is the first element of the tree in the inorder traversal . This is the least element of the tree ; Another temporary pointer currently pointing to root of second tree ; Previous pointer to store the parent of second temporary pointer ; Traverse through the second tree until you reach the leftmost element , which is the first element of the tree in inorder traversal . This is the least element of the tree . ; Compare the least current least elements of both the tree ; If first tree 's element is  smaller print it ; If the node has no parent , that means this node is the root ; Simply make the right child of the root as new root ; If node has a parent ; As this node is the leftmost node , it is certain that it will not have a let child so we simply assign this node ' s ▁ right ▁ pointer , ▁ which ▁ can ▁ be ▁ ▁ either ▁ null ▁ or ▁ not , ▁ to ▁ its ▁ parent ' s left pointer . This statement is just doing the task of deleting the node ; recursively call the merge function with updated tree ; If the node has no parent , that means this node is the root ; Simply make the right child of root as new root ; If node has a parent ; Recursively call the merge function with updated tree ; Driver Code ; Print sorted nodes of both trees",
        "Category": "Binary Tree"
    },
    {
        "ID": "4563-4563",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def AddNode ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT root = Node ( data ) NEW_LINE return root NEW_LINE DEDENT if ( root . data < data ) : NEW_LINE INDENT root . right = AddNode ( root . right , data ) NEW_LINE DEDENT elif ( root . data > data ) : NEW_LINE INDENT root . left = AddNode ( root . left , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def TargetPair ( node , tar ) : NEW_LINE INDENT LeftList = [ ] NEW_LINE RightList = [ ] NEW_LINE curr_left = node NEW_LINE curr_right = node NEW_LINE while ( curr_left != None or curr_right != None or len ( LeftList ) > 0 and len ( RightList ) > 0 ) : NEW_LINE INDENT while ( curr_left != None ) : NEW_LINE INDENT LeftList . append ( curr_left ) NEW_LINE curr_left = curr_left . left NEW_LINE DEDENT while ( curr_right != None ) : NEW_LINE INDENT RightList . append ( curr_right ) NEW_LINE curr_right = curr_right . right NEW_LINE DEDENT LeftNode = LeftList [ - 1 ] NEW_LINE RightNode = RightList [ - 1 ] NEW_LINE leftVal = LeftNode . data NEW_LINE rightVal = RightNode . data NEW_LINE if ( leftVal >= rightVal ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( leftVal + rightVal < tar ) : NEW_LINE INDENT del LeftList [ - 1 ] NEW_LINE curr_left = LeftNode . right NEW_LINE DEDENT elif ( leftVal + rightVal > tar ) : NEW_LINE INDENT del RightList [ - 1 ] NEW_LINE curr_right = RightNode . left NEW_LINE DEDENT else : NEW_LINE INDENT print ( LeftNode . data , RightNode . data ) NEW_LINE del RightList [ - 1 ] NEW_LINE del LeftList [ - 1 ] NEW_LINE curr_left = LeftNode . right NEW_LINE curr_right = RightNode . left NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = AddNode ( root , 2 ) NEW_LINE root = AddNode ( root , 6 ) NEW_LINE root = AddNode ( root , 5 ) NEW_LINE root = AddNode ( root , 3 ) NEW_LINE root = AddNode ( root , 4 ) NEW_LINE root = AddNode ( root , 1 ) NEW_LINE root = AddNode ( root , 7 ) NEW_LINE sum = 8 NEW_LINE TargetPair ( root , sum ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find all the pairs with given sum in a BST | Set 2 | A binary tree node ; Function to append a node to the BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; Function to find the target pairs ; LeftList which stores the left side values ; RightList which stores the right side values ; curr_left pointer is used for left side execution and curr_right pointer is used for right side execution ; Storing the left side values into LeftList till leaf node not found ; Storing the right side values into RightList till leaf node not found ; Last node of LeftList ; Last node of RightList ; To prevent repetition like 2 , 6 and 6 , 2 ; Delete the last value of LeftList and make the execution to the right side ; Delete the last value of RightList and make the execution to the left side ; ( left value + right value ) = target then print the left value and right value Delete the last value of left and right list and make the left execution to right side and right side execution to left side ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "4574-4574",
        "Code": "def selectionSort ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp ) : NEW_LINE INDENT minn = temp NEW_LINE r = temp . next NEW_LINE while ( r ) : NEW_LINE INDENT if ( minn . data > r . data ) : NEW_LINE INDENT minn = r NEW_LINE DEDENT r = r . next NEW_LINE DEDENT x = temp . data NEW_LINE temp . data = minn . data NEW_LINE minn . data = x NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Iterative selection sort for linked list |  ; Traverse the List ; Traverse the unsorted sublist ; Swap Data",
        "Category": "Linked List"
    },
    {
        "ID": "4575-4575",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . data = val NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def selectionSort ( head ) : NEW_LINE INDENT a = b = head NEW_LINE while b . next : NEW_LINE INDENT c = d = b . next NEW_LINE while d : NEW_LINE INDENT if b . data > d . data : NEW_LINE INDENT if b . next == d : NEW_LINE INDENT if b == head : NEW_LINE INDENT b . next = d . next NEW_LINE d . next = b NEW_LINE b , d = d , b NEW_LINE c = d NEW_LINE head = b NEW_LINE d = d . next NEW_LINE DEDENT else : NEW_LINE INDENT b . next = d . next NEW_LINE d . next = b NEW_LINE a . next = d NEW_LINE b , d = d , b NEW_LINE c = d NEW_LINE d = d . next NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b == head : NEW_LINE INDENT r = b . next NEW_LINE b . next = d . next NEW_LINE d . next = r NEW_LINE c . next = b NEW_LINE b , d = d , b NEW_LINE c = d NEW_LINE d = d . next NEW_LINE head = b NEW_LINE DEDENT else : NEW_LINE INDENT r = b . next NEW_LINE b . next = d . next NEW_LINE d . next = r NEW_LINE c . next = b NEW_LINE a . next = d NEW_LINE b , d = d , b NEW_LINE c = d NEW_LINE d = d . next NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT c = d NEW_LINE d = d . next NEW_LINE DEDENT DEDENT a = b NEW_LINE b = b . next NEW_LINE DEDENT return head NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while head : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = Node ( 5 ) NEW_LINE head . next = Node ( 4 ) NEW_LINE head . next . next = Node ( 3 ) NEW_LINE head = selectionSort ( head ) NEW_LINE printList ( head ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Iterative selection sort for linked list | Linked List Node ; Function to sort a linked list using selection sort algorithm by swapping the next pointers ; While b is not the last node ; While d is pointing to a valid node ; If d appears immediately after b ; Case 1 : b is the head of the linked list ; Move d before b ; Swap b and d pointers ; Update the head ; Skip to the next element as it is already in order ; Case 2 : b is not the head of the linked list ; Move d before b ; Swap b and d pointers ; Skip to the next element as it is already in order ; If b and d have some non - zero number of nodes in between them ; Case 3 : b is the head of the linked list ; Swap b . next and d . next ; Swap b and d pointers ; Skip to the next element as it is already in order ; Update the head ; Case 4 : b is not the head of the linked list ; Swap b . next and d . next ; Swap b and d pointers ; Skip to the next element as it is already in order ; Update c and skip to the next element as it is already in order ; Function to print the list ; Driver Code",
        "Category": "Linked List"
    },
    {
        "ID": "4582-4582",
        "Code": "def maxDisjointIntervals ( list_ ) : NEW_LINE INDENT list_ . sort ( key = lambda x : x [ 1 ] ) NEW_LINE print ( \" [ \" , list_ [ 0 ] [ 0 ] , \" , ▁ \" , list_ [ 0 ] [ 1 ] , \" ] \" ) NEW_LINE r1 = list_ [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , len ( list_ ) ) : NEW_LINE INDENT l1 = list_ [ i ] [ 0 ] NEW_LINE r2 = list_ [ i ] [ 1 ] NEW_LINE if l1 > r1 : NEW_LINE INDENT print ( \" [ \" , l1 , \" , ▁ \" , r2 , \" ] \" ) NEW_LINE r1 = r2 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE intervals = [ [ 1 , 4 ] , [ 2 , 3 ] , [ 4 , 6 ] , [ 8 , 9 ] ] NEW_LINE maxDisjointIntervals ( intervals ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximal Disjoint Intervals | Function to find maximal disjoint set ; sort the list of intervals ; First interval will always be included in set ; End point of first interval ; Check if given interval overlap with previously included interval , if not then include this interval and update the end point of last added interval ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4587-4587",
        "Code": "def findSquare ( n ) : NEW_LINE INDENT points = [ [ 1 , 2 ] , [ - 3 , 4 ] , [ 1 , 78 ] , [ - 3 , - 7 ] ] NEW_LINE a = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE a [ i ] = max ( abs ( x ) , abs ( y ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE index = n // 2 - 1 NEW_LINE print ( \" Minimum ▁ M ▁ required ▁ is : \" , a [ index ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE findSquare ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum length of square to contain at least half of the given Coordinates | Function to Calculate the Minimum value of M ; To store the minimum M for each point in array ; Sort the array ; Index at which atleast required point are inside square of length 2 * M ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4600-4600",
        "Code": "n = 4 ; NEW_LINE def merge ( l , r , output ) : NEW_LINE INDENT l_in = l * n ; NEW_LINE r_in = ( ( l + r ) // 2 + 1 ) * n ; NEW_LINE l_c = ( ( l + r ) // 2 - l + 1 ) * n ; NEW_LINE r_c = ( r - ( l + r ) // 2 ) * n ; NEW_LINE l_arr = [ 0 ] * l_c ; r_arr = [ 0 ] * r_c ; NEW_LINE for i in range ( l_c ) : NEW_LINE INDENT l_arr [ i ] = output [ l_in + i ] ; NEW_LINE DEDENT for i in range ( r_c ) : NEW_LINE INDENT r_arr [ i ] = output [ r_in + i ] ; NEW_LINE DEDENT l_curr = 0 ; r_curr = 0 ; NEW_LINE in1 = l_in ; NEW_LINE while ( l_curr + r_curr < l_c + r_c ) : NEW_LINE INDENT if ( r_curr == r_c or ( l_curr != l_c and l_arr [ l_curr ] < r_arr [ r_curr ] ) ) : NEW_LINE INDENT output [ in1 ] = l_arr [ l_curr ] ; NEW_LINE l_curr += 1 ; in1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT output [ in1 ] = r_arr [ r_curr ] ; NEW_LINE r_curr += 1 ; in1 += 1 ; NEW_LINE DEDENT DEDENT DEDENT def divide ( l , r , output , arr ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT output [ l * n + i ] = arr [ l ] [ i ] ; NEW_LINE DEDENT return ; NEW_LINE DEDENT divide ( l , ( l + r ) // 2 , output , arr ) ; NEW_LINE divide ( ( l + r ) // 2 + 1 , r , output , arr ) ; NEW_LINE merge ( l , r , output ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 5 , 7 , 15 , 18 ] , [ 1 , 8 , 9 , 17 ] , [ 1 , 4 , 7 , 7 ] ] ; NEW_LINE k = len ( arr ) ; NEW_LINE output = [ 0 ] * ( n * k ) ; NEW_LINE divide ( 0 , k - 1 , output , arr ) ; NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT print ( output [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Merge K sorted arrays | Set 3 ( Using Divide and Conquer Approach ) | Python3 program to merge K sorted arrays ; Function to perform merge operation ; to store the starting point of left and right array ; to store the size of left and right array ; array to temporarily store left and right array ; storing data in left array ; storing data in right array ; to store the current index of temporary left and right array ; to store the current index for output array ; two pointer merge for two sorted arrays ; Code to drive merge - sort and create recursion tree ; base step to initialize the output array before performing merge operation ; to sort left half ; to sort right half ; merge the left and right half ; Driver code ; input 2D - array ; Number of arrays ; Output array ; Print merged array",
        "Category": "Divide and Conquer"
    },
    {
        "ID": "4608-4608",
        "Code": "def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True and i < len ( v1 ) ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE index += 1 NEW_LINE i += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT elif j < len ( v2 ) : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 , 21 , 23 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE AlternateRearrange ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Rearrange Odd and Even values in Alternate Fashion in Ascending Order | Python3 implementation of the above approach ; Sort the array ; v1 = list ( ) to insert even values v2 = list ( ) to insert odd values ; Set flag to true if first element is even ; Start rearranging array ; If first element is even ; Else , first element is Odd ; Print the rearranged array ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4614-4614",
        "Code": "def Minimum_Cells ( v ) : NEW_LINE INDENT col = [ 0 ] * 3 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT column_number = v [ i ] [ 1 ] NEW_LINE col [ i ] = column_number NEW_LINE DEDENT col . sort ( ) NEW_LINE v . sort ( ) NEW_LINE MidRow = v [ 1 ] [ 0 ] NEW_LINE s = set ( ) NEW_LINE Maxcol = col [ 2 ] NEW_LINE MinCol = col [ 0 ] NEW_LINE for i in range ( MinCol , int ( Maxcol ) + 1 ) : NEW_LINE INDENT s . add ( ( MidRow , i ) ) NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT if ( v [ i ] [ 0 ] == MidRow ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT for j in range ( min ( v [ i ] [ 0 ] , MidRow ) , max ( v [ i ] [ 0 ] , MidRow ) + 1 ) : NEW_LINE INDENT s . add ( ( j , v [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ ( 0 , 0 ) , ( 1 , 1 ) , ( 2 , 2 ) ] NEW_LINE print ( Minimum_Cells ( v ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum Numbers of cells that are connected with the smallest path between 3 given cells | Function to return the minimum cells that are connected via the minimum length path ; Array to store column number of the given cells ; Sort cells in ascending order of row number ; Middle row number ; Set pair to store required cells ; Range of column number ; Store all cells of middle row within column number range ; Final step to store all the column number of 1 st and 3 rd cell upto MidRow ; Driver Code ; vector pair to store X , Y , Z",
        "Category": "Array"
    },
    {
        "ID": "4629-4629",
        "Code": "def merge ( arr , start , mid , end ) : NEW_LINE INDENT start2 = mid + 1 NEW_LINE if ( arr [ mid ] <= arr [ start2 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT while ( start <= mid and start2 <= end ) : NEW_LINE INDENT if ( arr [ start ] <= arr [ start2 ] ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT value = arr [ start2 ] NEW_LINE index = start2 NEW_LINE while ( index != start ) : NEW_LINE INDENT arr [ index ] = arr [ index - 1 ] NEW_LINE index -= 1 NEW_LINE DEDENT arr [ start ] = value NEW_LINE start += 1 NEW_LINE mid += 1 NEW_LINE start2 += 1 NEW_LINE DEDENT DEDENT DEDENT def mergeSort ( arr , l , r ) : NEW_LINE INDENT if ( l < r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE mergeSort ( arr , l , m ) NEW_LINE mergeSort ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT def printArray ( A , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE arr_size = len ( arr ) NEW_LINE mergeSort ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "In | Merges two subarrays of arr . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] Inplace Implementation ; If the direct merge is already sorted ; Two pointers to maintain start of both arrays to merge ; If element 1 is in right place ; Shift all the elements between element 1 element 2 , right by 1. ; Update all the pointers ; * l is for left index and r is right index of the sub - array of arr to be sorted ; Same as ( l + r ) / 2 , but avoids overflow for large l and r ; Sort first and second halves ; Function to pran array ; Driver program to test above functions",
        "Category": "Merge Sort"
    },
    {
        "ID": "4630-4630",
        "Code": "import math NEW_LINE def nextGap ( gap ) : NEW_LINE INDENT if gap <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( math . ceil ( gap / 2 ) ) NEW_LINE DEDENT def swap ( nums , i , j ) : NEW_LINE INDENT temp = nums [ i ] NEW_LINE nums [ i ] = nums [ j ] NEW_LINE nums [ j ] = temp NEW_LINE DEDENT def inPlaceMerge ( nums , start , end ) : NEW_LINE INDENT gap = end - start + 1 NEW_LINE gap = nextGap ( gap ) NEW_LINE while gap > 0 : NEW_LINE INDENT i = start NEW_LINE while ( i + gap ) <= end : NEW_LINE INDENT j = i + gap NEW_LINE if nums [ i ] > nums [ j ] : NEW_LINE INDENT swap ( nums , i , j ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT gap = nextGap ( gap ) NEW_LINE DEDENT DEDENT def mergeSort ( nums , s , e ) : NEW_LINE INDENT if s == e : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( s + e ) // 2 NEW_LINE mergeSort ( nums , s , mid ) NEW_LINE mergeSort ( nums , mid + 1 , e ) NEW_LINE inPlaceMerge ( nums , s , e ) NEW_LINE DEDENT def printArray ( A , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE arr_size = len ( arr ) NEW_LINE mergeSort ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "In | Python3 program for the above approach ; Calculating next gap ; Function for swapping ; Merging the subarrays using shell sorting Time Complexity : O ( nlog n ) Space Complexity : O ( 1 ) ; merge sort makes log n recursive calls and each time calls merge ( ) which takes nlog n steps Time Complexity : O ( n * log n + 2 ( ( n / 2 ) * log ( n / 2 ) ) + 4 ( ( n / 4 ) * log ( n / 4 ) ) + ... . . + 1 ) Time Complexity : O ( logn * ( n * log n ) ) i . e . O ( n * ( logn ) ^ 2 ) Space Complexity : O ( 1 ) ; Calculating mid to slice the array in two halves ; Recursive calls to sort left and right subarrays ; UTILITY FUNCTIONS Function to pran array ; Driver Code",
        "Category": "Merge Sort"
    },
    {
        "ID": "4633-4633",
        "Code": "def minCost ( A , n ) : NEW_LINE INDENT cost = 0 NEW_LINE A . sort ( ) ; NEW_LINE K = A [ int ( n / 2 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cost = cost + abs ( A [ i ] - K ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT tempCost = 0 NEW_LINE K = A [ int ( n / 2 ) - 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempCost = tempCost + abs ( A [ i ] - K ) NEW_LINE DEDENT cost = min ( cost , tempCost ) NEW_LINE DEDENT return cost NEW_LINE DEDENT A = [ 1 , 6 , 7 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( minCost ( A , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum Increment / decrement to make array elements equal | Function to return minimum operations need to be make each element of array equal ; Initialize cost to 0 ; Sort the array ; Middle element ; Find Cost ; If n , is even . Take minimum of the Cost obtained by considering both middle elements ; FInd cost again ; Take minimum of two cost ; Return total cost ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4635-4635",
        "Code": "def items ( n , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE z = a [ n - 1 ] NEW_LINE x = 1 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s <= z ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT / * Driver code * / NEW_LINE n = 5 NEW_LINE a = [ 5 , 3 , 1 , 5 , 6 ] NEW_LINE print ( items ( n , a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Get maximum items when other items of total cost of an item are free | Function to count the total number of items ; Sort the prices ; Choose the last element ; Initial count of item ; Sum to keep track of the total price of free items ; If total is less than or equal to z then we will add 1 to the answer ;",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4647-4647",
        "Code": "def kThLexString ( st , k , n ) : NEW_LINE INDENT z = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pp = \" \" NEW_LINE for j in range ( i , i + k ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT pp += s [ j ] NEW_LINE z . add ( pp ) NEW_LINE DEDENT DEDENT fin = list ( z ) NEW_LINE fin . sort ( ) NEW_LINE print ( fin [ k - 1 ] ) NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE k = 5 NEW_LINE n = len ( s ) NEW_LINE kThLexString ( s , k , n ) NEW_LINE",
        "Type": "py",
        "NL": "K | Python3 implementation of the above approach ; Set to store the unique substring ; String to create each substring ; adding to set ; converting set into a list ; sorting the strings int the list into lexicographical order ; printing kth substring ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "4649-4649",
        "Code": "def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] NEW_LINE r = 2 NEW_LINE n = len ( house ) NEW_LINE print ( number_of_tower ( house , r , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of towers required such that every house is in the range of at least one tower | Function to count the number of tower ; first we sort the house numbers ; for count number of towers ; for iterate all houses ; count number of towers ; find find the middle location ; traverse till middle location ; this is point to middle house where we insert the tower ; now find the last location ; traverse till last house of the range ; return the number of tower ; Driver code ; given elements ; print number of towers",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4655-4655",
        "Code": "from math import sqrt NEW_LINE prime = [ 0 ] * 100005 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == 0 : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = \" ▁ \" ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 17 , 1 ] NEW_LINE sortedArray ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sort only non | Python3 program to sort only non primes ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to print the array such that only non primes are sorted ; list v will store all non prime numbers ; If not prime , insert into list ; sorting list of non primes ; print the required array ; Driver code",
        "Category": "SieveOfEratosthenes (used for prime number generation), Array (used for storing prime flags and input array), Sorting (to sort non-prime numbers) → **Array** is the most dominant and representative category here."
    },
    {
        "ID": "4662-4662",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT start = None NEW_LINE def isPairWiseSorted ( head ) : NEW_LINE INDENT flag = True NEW_LINE temp = head NEW_LINE while ( temp != None and temp . next != None ) : NEW_LINE INDENT if ( temp . data > temp . next . data ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT temp = temp . next . next NEW_LINE DEDENT return flag NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT global start NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE start = head_ref NEW_LINE DEDENT start = None NEW_LINE push ( start , 5 ) NEW_LINE push ( start , 1 ) NEW_LINE push ( start , 9 ) NEW_LINE push ( start , 9 ) NEW_LINE push ( start , 15 ) NEW_LINE push ( start , 10 ) NEW_LINE if ( isPairWiseSorted ( start ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a Linked List is Pairwise Sorted | Linked List node ; Function to check if linked list is pairwise sorted ; Traverse further only if there are at - least two nodes left ; Function to add a node at the beginning of Linked List ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver Code ; The constructed linked list is : 10.15 . 9.9 .1 .5",
        "Category": "Linked List"
    },
    {
        "ID": "4679-4679",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def insertAtTheBegin ( start_ref , data ) : NEW_LINE INDENT ptr1 = Node ( data ) NEW_LINE ptr1 . data = data ; NEW_LINE ptr1 . next = start_ref ; NEW_LINE if ( start_ref != None ) : NEW_LINE ( start_ref ) . prev = ptr1 ; NEW_LINE start_ref = ptr1 ; NEW_LINE return start_ref NEW_LINE DEDENT def printList ( start ) : NEW_LINE INDENT temp = start ; NEW_LINE print ( ) NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE temp = temp . next ; NEW_LINE DEDENT DEDENT def bubbleSort ( start ) : NEW_LINE INDENT swapped = 0 NEW_LINE lptr = None ; NEW_LINE if ( start == None ) : NEW_LINE INDENT return ; NEW_LINE DEDENT while True : NEW_LINE INDENT swapped = 0 ; NEW_LINE ptr1 = start ; NEW_LINE while ( ptr1 . next != lptr ) : NEW_LINE INDENT if ( ptr1 . data > ptr1 . next . data ) : NEW_LINE INDENT ptr1 . data , ptr1 . next . data = ptr1 . next . data , ptr1 . data NEW_LINE swapped = 1 ; NEW_LINE DEDENT ptr1 = ptr1 . next ; NEW_LINE DEDENT lptr = ptr1 ; NEW_LINE if swapped == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 56 , 2 , 11 , 1 , 90 ] NEW_LINE start = None ; NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT start = insertAtTheBegin ( start , arr [ i ] ) ; NEW_LINE DEDENT print ( \" Linked ▁ list ▁ before ▁ sorting ▁ \" , end = ' ' ) ; NEW_LINE printList ( start ) ; NEW_LINE bubbleSort ( start ) ; NEW_LINE print ( \" Linked list after sorting   \" , end = ' ' ) ; NEW_LINE printList ( start ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Bubble Sort On Doubly Linked List | structure of a node ; Function to insert a node at the beginning of a linked list ; Function to print nodes in a given linked list ; Bubble sort the given linked list ; Checking for empty list ; Driver code ; start with empty linked list ; Create linked list from the array arr [ ] . Created linked list will be 1.11 . 2.56 . 12 ; print list before sorting ; sort the linked list ; print list after sorting",
        "Category": "Linked List"
    },
    {
        "ID": "4680-4680",
        "Code": "def substringSort ( arr , n , maxLen ) : NEW_LINE INDENT count = [ 0 ] * ( maxLen ) NEW_LINE sortedArr = [ \" \" ] * ( maxLen ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE Len = len ( s ) NEW_LINE if ( count [ Len - 1 ] == 0 ) : NEW_LINE INDENT sortedArr [ Len - 1 ] = s NEW_LINE count [ Len - 1 ] = 1 NEW_LINE DEDENT elif ( sortedArr [ Len - 1 ] == s ) : NEW_LINE INDENT count [ Len - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Cannot ▁ be ▁ sorted \" ) NEW_LINE return NEW_LINE DEDENT DEDENT index = 0 NEW_LINE while ( count [ index ] == 0 ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT prev = index NEW_LINE prevString = sortedArr [ prev ] NEW_LINE index += 1 NEW_LINE while index < maxLen : NEW_LINE INDENT if ( count [ index ] != 0 ) : NEW_LINE INDENT current = sortedArr [ index ] NEW_LINE if ( prevString in current ) : NEW_LINE INDENT prev = index NEW_LINE prevString = current NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Cannot ▁ be ▁ sorted \" ) NEW_LINE return NEW_LINE DEDENT DEDENT index += 1 NEW_LINE DEDENT for i in range ( maxLen ) : NEW_LINE INDENT s = sortedArr [ i ] NEW_LINE for j in range ( count [ i ] ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT maxLen = 100 NEW_LINE arr1 = [ \" d \" , \" zddsaaz \" , \" ds \" , \" ddsaa \" , \" dds \" , \" dds \" ] NEW_LINE substringSort ( arr1 , len ( arr1 ) , maxLen ) NEW_LINE arr2 = [ \" for \" , \" rof \" ] NEW_LINE substringSort ( arr2 , len ( arr2 ) , maxLen ) NEW_LINE",
        "Type": "py",
        "NL": "Substring Sort | Alternative code to sort substrings ; sort the input array ; repeated length should be the same string ; two different strings with the same length input array cannot be sorted ; validate that each string is a substring of the following one ; get first element ; The array is valid and sorted print the strings in order ; Test 1 ; Test 2",
        "Category": "Substring"
    },
    {
        "ID": "4692-4692",
        "Code": "def printSorted ( s , l ) : NEW_LINE INDENT stack = [ ] NEW_LINE tempstack = [ ] NEW_LINE stack . append ( s [ 0 ] ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT a = ord ( s [ i ] ) NEW_LINE b = ord ( stack [ - 1 ] ) NEW_LINE if ( ( a - b ) >= 1 or ( a == b ) ) : NEW_LINE INDENT stack . append ( s [ i ] ) NEW_LINE DEDENT elif ( ( b - a ) >= 1 ) : NEW_LINE INDENT while ( ( b - a ) >= 1 ) : NEW_LINE INDENT tempstack . append ( stack . pop ( ) ) NEW_LINE if ( len ( stack ) > 0 ) : NEW_LINE INDENT b = ord ( stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT stack . append ( s [ i ] ) NEW_LINE while ( len ( tempstack ) > 0 ) : NEW_LINE INDENT stack . append ( tempstack . pop ( ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( stack ) ) NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE l = len ( s ) NEW_LINE printSorted ( s , l ) NEW_LINE",
        "Type": "py",
        "NL": "Sort string of characters using Stack | function to print the characters in sorted order ; primary stack ; secondary stack ; append first character ; iterate for all character in string ; i - th character ASCII ; stack 's top element ASCII ; if greater or equal to top element then push to stack ; if smaller , then push all element to the temporary stack ; push all greater elements ; push operation ; push till the stack is not - empty ; push the i - th character ; push the tempstack back to stack ; print the stack in reverse order ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "4699-4699",
        "Code": "def maximum_toys ( cost , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE cost . sort ( reverse = False ) NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT if ( sum + cost [ i ] <= K ) : NEW_LINE INDENT sum = sum + cost [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 50 NEW_LINE cost = [ 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 ] NEW_LINE N = len ( cost ) NEW_LINE print ( maximum_toys ( cost , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximise the number of toys that can be purchased with amount K | This functions returns the required number of toys ; sort the cost array ; Check if we can buy ith toy or not ; Increment the count variable ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "47-47",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def specific_level_order_traversal ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE sz = len ( q ) NEW_LINE i = 0 NEW_LINE while ( i < sz ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE i = 0 NEW_LINE j = len ( v ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( v [ i ] , \" ▁ \" , v [ j ] , end = \" ▁ \" ) NEW_LINE j = j - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is \" ) NEW_LINE specific_level_order_traversal ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Perfect Binary Tree Specific Level Order Traversal | Set 2 | Linked List node ; Given a perfect binary tree , print its nodes in specific level order ; for level order traversal ; Stack to print reverse ; vector to store the level ; considering size of the level ; push data of the node of a particular level to vector ; push vector containing a level in Stack ; print the Stack ; Finally pop all Nodes from Stack and prints them . ; finally print root ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "4703-4703",
        "Code": "def areBookingsPossible ( A , B , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if i + K < len ( A ) and A [ i + K ] < B [ i ] : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arrival = [ 1 , 2 , 3 ] NEW_LINE departure = [ 2 , 3 , 4 ] NEW_LINE K = 1 NEW_LINE print areBookingsPossible ( arrival , departure , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if k bookings possible with given arrival and departure times | Python Code Implementation of the above approach ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "4711-4711",
        "Code": "def PandigitalProduct_1_9 ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( ( n % i == 0 ) and bool ( isPandigital ( str ( n ) + str ( i ) + str ( n // i ) ) ) ) : NEW_LINE INDENT return bool ( True ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return bool ( False ) NEW_LINE DEDENT def isPandigital ( Str ) : NEW_LINE INDENT if ( len ( Str ) != 9 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT ch = \" \" . join ( sorted ( Str ) ) NEW_LINE if ( ch == \"123456789\" ) : NEW_LINE INDENT return bool ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT DEDENT n = 6952 NEW_LINE if ( bool ( PandigitalProduct_1_9 ( n ) ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Pandigital Product | Calculate the multiplicand , multiplier , and product eligible for pandigital ; To check the string formed from multiplicand multiplier and product is pandigital ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "4712-4712",
        "Code": "def evenOddInsertionSort ( arr , n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT j = i - 2 NEW_LINE temp = arr [ i ] NEW_LINE if ( ( i + 1 ) & 1 == 1 ) : NEW_LINE INDENT while ( temp >= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp <= arr [ j ] and j >= 0 ) : NEW_LINE INDENT arr [ j + 2 ] = arr [ j ] NEW_LINE j -= 2 NEW_LINE DEDENT arr [ j + 2 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE evenOddInsertionSort ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Insertion sort to sort even and odd positioned elements in different orders | Function to calculate the given problem . ; checking for odd positioned . ; Inserting even positioned elements in ascending order . ; sorting the even positioned . ; Inserting odd positioned elements in descending order . ; A utility function to print an array of size n ; Driver program",
        "Category": "Insertion Sort"
    },
    {
        "ID": "4719-4719",
        "Code": "def function ( st ) : NEW_LINE INDENT st = list ( st ) NEW_LINE l = len ( st ) NEW_LINE st [ : l // 2 ] = sorted ( st [ : l // 2 ] ) NEW_LINE st [ l // 2 : ] = sorted ( st [ l // 2 : ] ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( st [ i ] != st [ l // 2 + i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT st = \" abcasdsabcae \" NEW_LINE if function ( st ) : print ( \" Yes , ▁ both ▁ halves ▁ differ ▁ \" , \" by ▁ at ▁ least ▁ one ▁ character \" ) NEW_LINE else : print ( \" No , ▁ both ▁ halves ▁ do ▁ not ▁ differ ▁ at ▁ all \" ) NEW_LINE",
        "Type": "py",
        "NL": "Check if both halves of the string have at least one different character | Function which break string into two halves Sorts the two halves separately Compares the two halves return true if any index has non - zero value ; Declaration and initialization of counter array ; Driver function",
        "Category": "Substring"
    },
    {
        "ID": "4723-4723",
        "Code": "import math NEW_LINE def sort012 ( arr , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count0 = count0 + 1 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , count0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for i in range ( count0 , ( count0 + count1 ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT for i in range ( ( count0 + count1 ) , n ) : NEW_LINE INDENT arr [ i ] = 2 NEW_LINE DEDENT return NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE sort012 ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Sort an array of 0 s , 1 s and 2 s ( Simple Counting ) | Python C ++ program to sort an array of 0 s 1 s and 2 s . ; Variables to maintain the count of 0 ' s , ▁ ▁ 1' s and 2 's in the array ; Putting the 0 's in the array in starting. ; Putting the 1 ' s ▁ in ▁ the ▁ array ▁ after ▁ the ▁ 0' s . ; Putting the 2 ' s ▁ in ▁ the ▁ array ▁ after ▁ the ▁ 1' s ; Prints the array ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4728-4728",
        "Code": "MAX = 26 NEW_LINE def alternateSort ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lCount = [ 0 for i in range ( MAX ) ] NEW_LINE uCount = [ 0 for i in range ( MAX ) ] NEW_LINE s = list ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT uCount [ ord ( s [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lCount [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( k < n ) : NEW_LINE INDENT while ( i < MAX and uCount [ i ] == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i < MAX ) : NEW_LINE INDENT s [ k ] = chr ( ord ( ' A ' ) + i ) NEW_LINE k += 1 NEW_LINE uCount [ i ] -= 1 NEW_LINE DEDENT while ( j < MAX and lCount [ j ] == 0 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j < MAX ) : NEW_LINE INDENT s [ k ] = chr ( ord ( ' a ' ) + j ) NEW_LINE k += 1 NEW_LINE lCount [ j ] -= 1 NEW_LINE DEDENT DEDENT print ( \" \" . join ( s ) ) NEW_LINE DEDENT str = \" bAwutndekWEdkd \" NEW_LINE alternateSort ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Alternate Lower Upper String Sort | Python3 program for unusul string sorting ; Function for alternate sorting of string ; Count occurrences of individual lower case and upper case characters ; Traverse through count arrays and one by one pick characters . Below loop takes O ( n ) time considering the MAX is constant . ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4736-4736",
        "Code": "def unsort ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + 1 == r ) : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE DEDENT def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" NO ▁ SOLUTION \" ) NEW_LINE return NEW_LINE DEDENT a = [ 0 for i in range ( n + 2 ) ] NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT k -= 1 NEW_LINE unsort ( 0 , n , a , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 17 NEW_LINE arrayWithKCalls ( n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find array with k number of merge sort calls | Python program to find an array that can be sorted with k merge sort calls . ; We make two recursive calls , so reduce k by 2. ; Create an array with values in [ 1 , n ] ; calling unsort function ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "4746-4746",
        "Code": "def dualPivotQuickSort ( arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT lp , rp = partition ( arr , low , high ) NEW_LINE dualPivotQuickSort ( arr , low , lp - 1 ) NEW_LINE dualPivotQuickSort ( arr , lp + 1 , rp - 1 ) NEW_LINE dualPivotQuickSort ( arr , rp + 1 , high ) NEW_LINE DEDENT DEDENT def partition ( arr , low , high ) : NEW_LINE INDENT if arr [ low ] > arr [ high ] : NEW_LINE INDENT arr [ low ] , arr [ high ] = arr [ high ] , arr [ low ] NEW_LINE DEDENT j = k = low + 1 NEW_LINE g , p , q = high - 1 , arr [ low ] , arr [ high ] NEW_LINE while k <= g : NEW_LINE INDENT if arr [ k ] < p : NEW_LINE INDENT arr [ k ] , arr [ j ] = arr [ j ] , arr [ k ] NEW_LINE j += 1 NEW_LINE DEDENT elif arr [ k ] >= q : NEW_LINE INDENT while arr [ g ] > q and k < g : NEW_LINE INDENT g -= 1 NEW_LINE DEDENT arr [ k ] , arr [ g ] = arr [ g ] , arr [ k ] NEW_LINE g -= 1 NEW_LINE if arr [ k ] < p : NEW_LINE INDENT arr [ k ] , arr [ j ] = arr [ j ] , arr [ k ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT k += 1 NEW_LINE DEDENT j -= 1 NEW_LINE g += 1 NEW_LINE arr [ low ] , arr [ j ] = arr [ j ] , arr [ low ] NEW_LINE arr [ high ] , arr [ g ] = arr [ g ] , arr [ high ] NEW_LINE return j , g NEW_LINE DEDENT arr = [ 24 , 8 , 42 , 75 , 29 , 77 , 38 , 57 ] NEW_LINE dualPivotQuickSort ( arr , 0 , 7 ) NEW_LINE print ( ' Sorted ▁ array : ▁ ' , end = ' ' ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "Type": "py",
        "NL": "Dual pivot Quicksort | Python3 program to implement dual pivot QuickSort ; lp means left pivot and rp means right pivot ; p is the left pivot , and q is the right pivot . ; If elements are less than the left pivot ; If elements are greater than or equal to the right pivot ; Bring pivots to their appropriate positions . ; Returning the indices of the pivots ; Driver code",
        "Category": "Sorting Algorithm (Note: While \"Sorting Algorithm\" isn't in your provided list, the closest and most representative category from your list would be: **Array**, as it operates on arrays and involves array manipulation and sorting logic.)"
    },
    {
        "ID": "4747-4747",
        "Code": "def minMaxSelectionSort ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE max = arr [ i ] NEW_LINE min_i = i NEW_LINE max_i = i NEW_LINE for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ k ] > max ) : NEW_LINE INDENT max = arr [ k ] NEW_LINE max_i = k NEW_LINE DEDENT elif ( arr [ k ] < min ) : NEW_LINE INDENT min = arr [ k ] NEW_LINE min_i = k NEW_LINE DEDENT DEDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ min_i ] NEW_LINE arr [ min_i ] = temp NEW_LINE if ( arr [ min_i ] == max ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ min_i ] NEW_LINE arr [ min_i ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ max_i ] NEW_LINE arr [ max_i ] = temp NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT print ( \" Sorted ▁ array : \" , end = \" ▁ \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 23 , 78 , 45 , 8 , 32 , 56 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE minMaxSelectionSort ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "A sorting algorithm that slightly improves on selection sort | Python3 program to implement min max selection sort . ; shifting the min . ; Shifting the max . The equal condition happens if we shifted the max to arr [ min_i ] in the previous swap . ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4753-4753",
        "Code": "def check ( v , l ) : NEW_LINE INDENT n = len ( v ) NEW_LINE for i in v : NEW_LINE INDENT i = ' ' . join ( sorted ( i ) ) NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT v = [ \" ebcda \" , \" ihgfj \" , \" klmno \" , \" pqrst \" , \" yvwxu \" ] NEW_LINE if check ( v , l ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a grid can become row | v [ ] is vector of strings . len is length of strings in every row . ; Driver code ; l = 5 Length of strings",
        "Category": "Matrix"
    },
    {
        "ID": "4765-4765",
        "Code": "def longestCommonPrefix ( a ) : NEW_LINE INDENT size = len ( a ) NEW_LINE if ( size == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT if ( size == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT a . sort ( ) NEW_LINE end = min ( len ( a [ 0 ] ) , len ( a [ size - 1 ] ) ) NEW_LINE i = 0 NEW_LINE while ( i < end and a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT pre = a [ 0 ] [ 0 : i ] NEW_LINE return pre NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE print ( \" The ▁ longest ▁ Common ▁ Prefix ▁ is ▁ : \" , longestCommonPrefix ( input ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Common Prefix using Sorting | Python 3 program to find longest common prefix of given array of words . ; if size is 0 , return empty string ; sort the array of strings ; find the minimum length from first and last string ; find the common prefix between the first and last string ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "4767-4767",
        "Code": "from math import ceil NEW_LINE def find ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE b = int ( ceil ( n / k ) ) NEW_LINE print ( \" minimum ▁ \" , sum ( arr [ : b ] ) ) NEW_LINE print ( \" maximum ▁ \" , sum ( arr [ - b : ] ) ) NEW_LINE DEDENT arr = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE find ( arr , n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find the minimum and maximum amount to buy all N candies | Python implementation to find the minimum and maximum amount ; function to find the maximum and the minimum cost required ; Sort the array ; print the minimum cost ; print the maximum cost ; Driver Code ; Function call",
        "Category": "Array"
    },
    {
        "ID": "4769-4769",
        "Code": "def mergeArrays ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr3 = [ None ] * ( n1 + n2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while i < n1 and j < n2 : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT arr3 [ k ] = arr1 [ i ] NEW_LINE k = k + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr3 [ k ] = arr2 [ j ] NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while i < n1 : NEW_LINE INDENT arr3 [ k ] = arr1 [ i ] ; NEW_LINE k = k + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT while j < n2 : NEW_LINE INDENT arr3 [ k ] = arr2 [ j ] ; NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT print ( \" Array ▁ after ▁ merging \" ) NEW_LINE for i in range ( n1 + n2 ) : NEW_LINE INDENT print ( str ( arr3 [ i ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr1 = [ 1 , 3 , 5 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE arr2 = [ 2 , 4 , 6 , 8 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE mergeArrays ( arr1 , arr2 , n1 , n2 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Merge two sorted arrays | Merge arr1 [ 0. . n1 - 1 ] and arr2 [ 0. . n2 - 1 ] into arr3 [ 0. . n1 + n2 - 1 ] ; Traverse both array ; Check if current element of first array is smaller than current element of second array . If yes , store first array element and increment first array index . Otherwise do same with second array ; Store remaining elements of first array ; Store remaining elements of second array ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "4773-4773",
        "Code": "MIN_MERGE = 32 NEW_LINE def calcMinRun ( n ) : NEW_LINE INDENT r = 0 NEW_LINE while n >= MIN_MERGE : NEW_LINE INDENT r |= n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return n + r NEW_LINE DEDENT def insertionSort ( arr , left , right ) : NEW_LINE INDENT for i in range ( left + 1 , right + 1 ) : NEW_LINE INDENT j = i NEW_LINE while j > left and arr [ j ] < arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT len1 , len2 = m - l + 1 , r - m NEW_LINE left , right = [ ] , [ ] NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT left . append ( arr [ l + i ] ) NEW_LINE DEDENT for i in range ( 0 , len2 ) : NEW_LINE INDENT right . append ( arr [ m + 1 + i ] ) NEW_LINE DEDENT i , j , k = 0 , 0 , l NEW_LINE while i < len1 and j < len2 : NEW_LINE INDENT if left [ i ] <= right [ j ] : NEW_LINE INDENT arr [ k ] = left [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] = right [ j ] NEW_LINE j += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT while i < len1 : NEW_LINE INDENT arr [ k ] = left [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while j < len2 : NEW_LINE INDENT arr [ k ] = right [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT def timSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE minRun = calcMinRun ( n ) NEW_LINE for start in range ( 0 , n , minRun ) : NEW_LINE INDENT end = min ( start + minRun - 1 , n - 1 ) NEW_LINE insertionSort ( arr , start , end ) NEW_LINE DEDENT size = minRun NEW_LINE while size < n : NEW_LINE INDENT for left in range ( 0 , n , 2 * size ) : NEW_LINE INDENT mid = min ( n - 1 , left + size - 1 ) NEW_LINE right = min ( ( left + 2 * size - 1 ) , ( n - 1 ) ) NEW_LINE if mid < right : NEW_LINE INDENT merge ( arr , left , mid , right ) NEW_LINE DEDENT DEDENT size = 2 * size NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 2 , 7 , 15 , - 14 , 0 , 15 , 0 , 7 , - 7 , - 4 , - 13 , 5 , 8 , - 14 , 12 ] NEW_LINE print ( \" Given ▁ Array ▁ is \" ) NEW_LINE print ( arr ) NEW_LINE timSort ( arr ) NEW_LINE print ( \" After ▁ Sorting ▁ Array ▁ is \" ) NEW_LINE print ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "TimSort | Python3 program to perform basic timSort ; Becomes 1 if any 1 bits are shifted off ; This function sorts array from left index to to right index which is of size atmost RUN ; Merge function merges the sorted runs ; original array is broken in two parts left and right array ; after comparing , we merge those two array in larger sub array ; Copy remaining elements of left , if any ; Copy remaining element of right , if any ; Iterative Timsort function to sort the array [ 0. . . n - 1 ] ( similar to merge sort ) ; Sort individual subarrays of size RUN ; Start merging from size RUN ( or 32 ) . It will merge to form size 64 , then 128 , 256 and so on ... . ; Pick starting point of left sub array . We are going to merge arr [ left . . left + size - 1 ] and arr [ left + size , left + 2 * size - 1 ] After every merge , we increase left by 2 * size ; Find ending point of left sub array mid + 1 is starting point of right sub array ; Merge sub array arr [ left ... . . mid ] & arr [ mid + 1. ... right ] ; Driver program to test above function ; Function Call",
        "Category": "Sorting Algorithm (TimSort)"
    },
    {
        "ID": "4777-4777",
        "Code": "def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT boxes = [ 10 , 20 , 30 , 50 , 60 , 70 ] NEW_LINE n = len ( boxes ) NEW_LINE print ( maxLevel ( boxes , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find maximum height pyramid from the given array of objects | Returns maximum number of pyramidcal levels n boxes of given widths . ; Sort objects in increasing order of widths ; Total width of previous level and total number of objects in previous level ; Number of object in current level . ; Width of current level . ; Picking the object . So increase current width and number of object . ; If current width and number of object are greater than previous . ; Update previous width , number of object on previous level . ; Reset width of current level , number of object on current level . ; Increment number of level . ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "480-480",
        "Code": "V = 4 NEW_LINE def multiply ( A , B , C ) : NEW_LINE INDENT global V NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE for k in range ( V ) : NEW_LINE INDENT C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getTrace ( graph ) : NEW_LINE INDENT global V NEW_LINE trace = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT trace += graph [ i ] [ i ] NEW_LINE DEDENT return trace NEW_LINE DEDENT def triangleInGraph ( graph ) : NEW_LINE INDENT global V NEW_LINE aux2 = [ [ None ] * V for i in range ( V ) ] NEW_LINE aux3 = [ [ None ] * V for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT multiply ( graph , graph , aux2 ) NEW_LINE multiply ( graph , aux2 , aux3 ) NEW_LINE trace = getTrace ( aux3 ) NEW_LINE return trace // 6 NEW_LINE DEDENT graph = [ [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] ] NEW_LINE print ( \" Total ▁ number ▁ of ▁ Triangle ▁ in ▁ Graph ▁ : \" , triangleInGraph ( graph ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of Triangles in an Undirected Graph | Number of vertices in the graph ; Utility function for matrix multiplication ; Utility function to calculate trace of a matrix ( sum ofdiagnonal elements ) ; Utility function for calculating number of triangles in graph ; To Store graph ^ 2 ; To Store graph ^ 3 ; Initialising aux matrices with 0 ; aux2 is graph ^ 2 now printMatrix ( aux2 ) ; after this multiplication aux3 is graph ^ 3 printMatrix ( aux3 ) ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "4812-4812",
        "Code": "def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE DEDENT i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE INDENT while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = int ( ( right + left ) / 2 ) NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def countSwaps ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE return _mergeSort ( arr , temp , 0 , n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 20 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Number ▁ of ▁ swaps ▁ is \" , countSwaps ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of swaps to sort when only adjacent swapping allowed | This function merges two sorted arrays and returns inversion count in the arrays . ; i is index for left subarray ; j is index for right subarray ; k is index for resultant merged subarray ; this is tricky -- see above explanation / diagram for merge ( ) ; Copy the remaining elements of left subarray ( if there are any ) to temp ; Copy the remaining elements of right subarray ( if there are any ) to temp ; Copy back the merged elements to original array ; An auxiliary recursive function that sorts the input array and returns the number of inversions in the array . ; Divide the array into two parts and call _mergeSortAndCountInv ( ) for each of the parts ; Inversion count will be sum of inversions in left - part , right - part and number of inversions in merging ; Merge the two parts ; This function sorts the input array and returns the number of inversions in the array ; Driver progra to test above functions",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "4824-4824",
        "Code": "def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while index < n : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT if arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index = index - 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT arr = [ 34 , 2 , 10 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE arr = gnomeSort ( arr , n ) NEW_LINE print \" Sorted ▁ sequence ▁ after ▁ applying ▁ Gnome ▁ Sort ▁ : \" , NEW_LINE for i in arr : NEW_LINE INDENT print i , NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Gnome Sort | A function to sort the given list using Gnome sort ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4825-4825",
        "Code": "def cocktailSort ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE swapped = True NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( swapped == True ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( swapped == False ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT a = [ 5 , 1 , 4 , 2 , 8 , 0 , 2 ] NEW_LINE cocktailSort ( a ) NEW_LINE print ( \" Sorted ▁ array ▁ is : \" ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT print ( \" % ▁ d \" % a [ i ] ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Cocktail Sort | Sorts arrar a [ 0. . n - 1 ] using Cocktail sort ; reset the swapped flag on entering the loop , because it might be true from a previous iteration . ; loop from left to right same as the bubble sort ; if nothing moved , then array is sorted . ; otherwise , reset the swapped flag so that it can be used in the next stage ; move the end point back by one , because item at the end is in its rightful spot ; from right to left , doing the same comparison as in the previous stage ; increase the starting point , because the last stage would have moved the next smallest number to its rightful spot . ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "484-484",
        "Code": "V = 4 NEW_LINE def colorGraph ( G , color , pos , c ) : NEW_LINE INDENT if color [ pos ] != - 1 and color [ pos ] != c : NEW_LINE INDENT return False NEW_LINE DEDENT color [ pos ] = c NEW_LINE ans = True NEW_LINE for i in range ( 0 , V ) : NEW_LINE INDENT if G [ pos ] [ i ] : NEW_LINE INDENT if color [ i ] == - 1 : NEW_LINE INDENT ans &= colorGraph ( G , color , i , 1 - c ) NEW_LINE DEDENT if color [ i ] != - 1 and color [ i ] != 1 - c : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if not ans : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isBipartite ( G ) : NEW_LINE INDENT color = [ - 1 ] * V NEW_LINE pos = 0 NEW_LINE return colorGraph ( G , color , pos , 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT G = [ [ 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 0 ] ] NEW_LINE if isBipartite ( G ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a given graph is Bipartite or not | Python3 program to find out whether a given graph is Bipartite or not using recursion . ; color this pos as c and all its neighbours and 1 - c ; start is vertex 0 ; two colors 1 and 0 ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "4840-4840",
        "Code": "def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) ; NEW_LINE exit . sort ( ) ; NEW_LINE guests_in = 1 ; NEW_LINE max_guests = 1 ; NEW_LINE time = arrl [ 0 ] ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 ; NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in ; NEW_LINE time = arrl [ i ] ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 ; NEW_LINE j = j + 1 ; NEW_LINE DEDENT DEDENT print ( \" Maximum ▁ Number ▁ of ▁ Guests ▁ = \" , max_guests , \" at ▁ time \" , time ) NEW_LINE DEDENT arrl = [ 1 , 2 , 10 , 5 , 5 ] ; NEW_LINE exit = [ 4 , 5 , 12 , 9 , 12 ] ; NEW_LINE n = len ( arrl ) ; NEW_LINE findMaxGuests ( arrl , exit , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find the point where maximum intervals overlap | Program to find maximum guest at any time in a party ; Sort arrival and exit arrays ; guests_in indicates number of guests at a time ; Similar to merge in merge sort to process all events in sorted order ; If next event in sorted order is arrival , increment count of guests ; Update max_guests if needed ; increment index of arrival array ; If event is exit , decrement count ; of guests . ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4871-4871",
        "Code": "def maxShiftArrayValue ( arr , cap , N ) : NEW_LINE INDENT sumVals = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumVals += arr [ i ] NEW_LINE DEDENT maxCapacity = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxCapacity = max ( cap [ i ] , maxCapacity ) NEW_LINE DEDENT return min ( maxCapacity , sumVals ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 ] NEW_LINE cap = [ 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maxShiftArrayValue ( arr , cap , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum possible value of array elements that can be made based on given capacity conditions | Function to find the maximum element after shifting operations in arr [ ] ; Stores the sum of array element ; Stores the maximum element in cap [ ] ; Iterate to find maximum element ; Return the resultant maximum value ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4873-4873",
        "Code": "def minimumSizeArray ( S , P ) : NEW_LINE INDENT if ( S == P ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 2 , S + 1 ) : NEW_LINE INDENT d = i NEW_LINE if ( ( S / d ) >= pow ( P , 1.0 / d ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 NEW_LINE P = 6 NEW_LINE print ( minimumSizeArray ( S , P ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum size of Array possible with given sum and product values | Function to find the minimum size of array with sum S and product P ; Base Case ; Iterate through all values of S and check the mentioned condition ; Otherwise , print \" - 1\" ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4888-4888",
        "Code": "def findPermutation ( K , arr ) : NEW_LINE INDENT missing = [ ] NEW_LINE visited = [ 0 ] * ( K + 1 ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT visited [ arr [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT missing . append ( i ) NEW_LINE DEDENT DEDENT INT_MAX = 2147483647 NEW_LINE arr . append ( INT_MAX ) NEW_LINE missing . append ( INT_MAX ) NEW_LINE p1 = 0 NEW_LINE p2 = 0 NEW_LINE ans = [ ] NEW_LINE while ( len ( ans ) < K ) : NEW_LINE INDENT if ( arr [ p1 ] < missing [ p2 ] ) : NEW_LINE INDENT ans . append ( arr [ p1 ] ) NEW_LINE p1 = p1 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( missing [ p2 ] ) NEW_LINE p2 = p2 + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , K ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 7 NEW_LINE arr = [ 6 , 4 , 2 , 1 ] NEW_LINE findPermutation ( K , arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest permutation number up to K having given array as a subsequence | Function to find the lexicographically smallest permutation such that the given array is a subsequence of it ; Stores the missing elements in arr in the range [ 1 , K ] ; Stores if the ith element is present in arr or not ; Loop to mark all integers present in the array as visited ; Loop to insert all the integers not visited into missing ; Append INT_MAX at end in order to prevent going out of bounds ; Pointer to the current element ; Pointer to the missing element ; Stores the required permutation ; Loop to construct the permutation using greedy approach ; If missing element is smaller that the current element insert missing element ; Insert current element ; Print the required Permutation ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4890-4890",
        "Code": "from math import ceil , floor NEW_LINE import sys NEW_LINE def findRange ( arr , N , K ) : NEW_LINE INDENT L = - sys . maxsize - 1 NEW_LINE R = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) NEW_LINE r = ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) - 1 ) NEW_LINE L = max ( L , l ) NEW_LINE R = min ( R , r ) NEW_LINE DEDENT print ( L , R ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 9 , 11 ] NEW_LINE K = 10 NEW_LINE N = len ( arr ) NEW_LINE findRange ( arr , N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find range of values for S in given Array with values satisfying [ arr [ i ] = floor ( ( i * S ) / K ) ] | Python 3 program for the above approach ; Function to find the range of values for S in a given array that satisfies the given condition ; Stores the left range value ; Stores the right range value ; Find the current left range value for S ; Find the current right range value for S ; Updating L value ; Updating R value ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4892-4892",
        "Code": "def findAnagram ( s ) : NEW_LINE INDENT check = s NEW_LINE st = list ( s ) NEW_LINE i = 0 NEW_LINE j = len ( st ) - 1 NEW_LINE while ( i < len ( st ) and j >= 0 ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] and check [ i ] != st [ j ] and check [ j ] != st [ i ] ) : NEW_LINE INDENT st [ i ] , st [ j ] = st [ j ] , st [ i ] NEW_LINE i += 1 NEW_LINE j = len ( st ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT if ( len ( st ) % 2 != 0 ) : NEW_LINE INDENT mid = len ( st ) / 2 NEW_LINE if ( check [ mid ] == st [ mid ] ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( check [ i ] != st [ mid ] and st [ i ] != st [ mid ] ) : NEW_LINE INDENT st [ i ] , st [ mid ] = st [ mid ] , st [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT ok = True NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( check [ i ] == st [ i ] ) : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( ok ) : NEW_LINE INDENT print ( \" \" . join ( st ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" geek \" NEW_LINE findAnagram ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find an anagram of given String having different characters at corresponding indices | Function to find anagram of string such that characters at the same indices are different ; Copying our original string for comparison ; Declaring the two pointers ; Checking the given condition ; When string length is odd ; The mid element ; If the characters are the same , then perform the swap operation as illustrated ; Check if the corresponding indices has the same character or not ; If string follows required condition ; Driver Code",
        "Category": "Two Pointers"
    },
    {
        "ID": "4896-4896",
        "Code": "from math import sqrt NEW_LINE def findRemainingIndex ( N ) : NEW_LINE INDENT ans = N NEW_LINE while ( N > 1 ) : NEW_LINE INDENT discard = int ( sqrt ( N ) ) NEW_LINE if ( discard * discard == N ) : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT N -= discard NEW_LINE DEDENT return ans NEW_LINE DEDENT def findRemainingElement ( arr , N ) : NEW_LINE INDENT remainingIndex = findRemainingIndex ( N ) NEW_LINE print ( arr [ remainingIndex - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 4 , 2 , 4 , - 3 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE findRemainingElement ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Last element remaining after repeated removal of Array elements at perfect square indices | Python 3 program for the above approach ; Function to find last remaining index after repeated removal of perfect square indices ; Initialize the ans variable as N ; Iterate a while loop and discard the possible values ; Total discarded values ; Check if this forms a perfect square ; Decrease answer by 1 ; Subtract the value from the current value of N ; Return the value remained ; Function to find last remaining element after repeated removal of array element at perfect square indices ; Find the remaining index ; Print the element at that index as the result ; Driver Code ; Given input",
        "Category": "Math"
    },
    {
        "ID": "4902-4902",
        "Code": "def check ( x , N ) : NEW_LINE INDENT while True : NEW_LINE INDENT N -= x NEW_LINE if len ( str ( x ) ) == 1 : NEW_LINE INDENT break NEW_LINE DEDENT x = sum ( list ( map ( int , str ( x ) ) ) ) NEW_LINE DEDENT if len ( str ( x ) ) == 1 and N == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def countNoOfsuchX ( N ) : NEW_LINE INDENT k = len ( str ( N ) ) NEW_LINE count = 0 NEW_LINE for x in range ( N - k * ( k + 1 ) * 5 , N + 1 ) : NEW_LINE INDENT if check ( x , N ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 9939 NEW_LINE print ( countNoOfsuchX ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of values chosen for X such that N is reduced to 0 after given operations | Function to check if the value of X reduces N to 0 or not ; Update the value of N as N - x ; Check if x is a single digit integer ; Function to find the number of values X such that N can be reduced to 0 after performing the given operations ; Number of digits in N ; Stores the count of value of X ; Iterate over all possible value of X ; Check if x follow the conditions ; Return the total count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4904-4904",
        "Code": "def minimumMoves ( A , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE sum_A = 0 NEW_LINE sum_B = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum_A += A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum_B += B [ i ] NEW_LINE DEDENT if ( sum_A != sum_B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT if ( A [ i ] > B [ i ] ) : NEW_LINE INDENT temp = A [ i ] - B [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and temp > 0 ) : NEW_LINE INDENT if ( B [ j ] > A [ j ] ) : NEW_LINE INDENT cnt = min ( temp , ( B [ j ] - A [ j ] ) ) NEW_LINE A [ j ] += cnt NEW_LINE temp -= cnt NEW_LINE ans += ( cnt * abs ( j - i ) ) NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( temp > 0 ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < N and temp > 0 ) : NEW_LINE INDENT if ( B [ j ] > A [ j ] ) : NEW_LINE INDENT cnt = min ( temp , ( B [ j ] - A [ j ] ) ) NEW_LINE A [ j ] += cnt NEW_LINE temp -= cnt NEW_LINE ans += ( cnt * abs ( j - i ) ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 5 , 7 ] NEW_LINE B = [ 13 , 0 , 0 ] NEW_LINE N = len ( A ) NEW_LINE print ( minimumMoves ( A , B , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize increment | Function to calculate the minimum number of operations to convert array A to array B by incrementing and decrementing adjacent elements ; Stores the final count ; Stores the sum of array A and B respectivelly ; Check of the sums are unequall ; Pointer to iterate through array ; Case 1 where A [ i ] > B [ i ] ; Stores the extra values for the current index ; Iterate the array from [ i - 1 , 0 ] ; Stores the count of values being transfered from A [ i ] to A [ j ] ; Add operation count ; Iterate the array in right direction id A [ i ] - B [ i ] > 0 ; Iterate the array from [ i + 1 , n - 1 ] ; Stores the count of values being transfered from A [ i ] to A [ j ] ; Add operation count ; Return Answer ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4905-4905",
        "Code": "def possibleReachingSequence ( X , D , T ) : NEW_LINE INDENT if X < T : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT if T * D < X : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT if ( X - T ) % ( D - 1 ) == 0 : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT X = 10 NEW_LINE D = 3 NEW_LINE T = 6 NEW_LINE print ( possibleReachingSequence ( X , D , T ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if X can be reduced to 0 in exactly T moves by substracting D or 1 from it | Function to check the above problem condition ; Check the base case . ; check if X - T is a divisor of D - 1 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "4910-4910",
        "Code": "def minApples ( ) : NEW_LINE INDENT if M <= S * K : NEW_LINE INDENT return M NEW_LINE DEDENT elif M <= S * K + E + W : NEW_LINE INDENT return S * K + ( M - S * K ) * K NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = 10 NEW_LINE K = 15 NEW_LINE N = 0 NEW_LINE S = 1 NEW_LINE W = 0 NEW_LINE E = 0 NEW_LINE ans = minApples ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of Apples to be collected from trees to guarantee M red apples | Function to minimum no . of apples ; If we get all required apple from South ; If we required trees at East and West ; If we doesn 't have enough  red apples ; Driver Code ; No . of red apple for gift ; No . of red apple in each tree ; No . of tree in North ; No . of tree in South ; No . of tree in West ; No . of tree in East ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "4914-4914",
        "Code": "def minProductUtil ( R1 , B1 , R2 , B2 , M ) : NEW_LINE INDENT x = min ( R1 - B1 , M ) NEW_LINE M -= x NEW_LINE R1 -= x NEW_LINE if M > 0 : NEW_LINE INDENT y = min ( R2 - B2 , M ) NEW_LINE M -= y NEW_LINE R2 -= y NEW_LINE DEDENT return R1 * R2 NEW_LINE DEDENT def minProduct ( R1 , B1 , R2 , B2 , M ) : NEW_LINE INDENT res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) NEW_LINE res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) NEW_LINE return min ( res1 , res2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R1 = 21 ; B1 = 10 ; R2 = 13 ; B2 = 11 ; M = 3 NEW_LINE print ( minProduct ( R1 , B1 , R2 , B2 , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize product of two scores possible by at most M reductions | Utility function to find the minimum product of R1 and R2 possible ; Reaching to its limit ; If M is remaining ; Function to find the minimum product of R1 and R2 ; Case 1 - R1 reduces first ; case 2 - R2 reduces first ; Driver Code ; Given Input ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4921-4921",
        "Code": "def largestMerge ( word1 , word2 ) : NEW_LINE INDENT merge = \" \" NEW_LINE while len ( word1 ) != 0 or len ( word2 ) != 0 : NEW_LINE INDENT if word1 >= word2 : NEW_LINE INDENT merge = merge + word1 [ 0 ] NEW_LINE word1 = word1 [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT merge = merge + word2 [ 0 ] NEW_LINE word2 = word2 [ 1 : ] NEW_LINE DEDENT DEDENT return merge NEW_LINE DEDENT S1 = \" xyzxyz \" NEW_LINE S2 = \" xywzxyx \" NEW_LINE print ( largestMerge ( S1 , S2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Lexicographically largest string possible by repeatedly appending first character of two given strings | Function to make the lexicographically largest string by merging two strings ; Stores the resultant string ; If the string word1 is lexographically greater than or equal to word2 ; Update the string merge ; Erase the first index of the string word1 ; Otherwise ; Update the string merge ; Erase the first index of the string word2 ; Return the final string ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "4928-4928",
        "Code": "def maxGcd ( a , b ) : NEW_LINE INDENT print ( abs ( a - b ) ) NEW_LINE DEDENT a = 2231 NEW_LINE b = 343 NEW_LINE maxGcd ( a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum GCD of two numbers possible by adding same value to them | Function to calculate maximum gcd of two numbers possible by adding same value to both a and b ; Given Input",
        "Category": "Math"
    },
    {
        "ID": "493-493",
        "Code": "def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( power ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Hypercube Graph | function to find power of 2 ; Dricer code",
        "Category": "Math"
    },
    {
        "ID": "4934-4934",
        "Code": "def MinCost ( days , cost , N ) : NEW_LINE INDENT size = days [ N - 1 ] + 1 NEW_LINE dp = [ 0 for i in range ( size ) ] NEW_LINE dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) NEW_LINE ptr = N - 2 NEW_LINE for i in range ( size - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( ptr >= 0 and days [ ptr ] == i ) : NEW_LINE INDENT val1 = dp [ i + 1 ] + cost [ 0 ] NEW_LINE val2 = cost [ 1 ] + ( 0 if ( i + 7 >= size ) else dp [ i + 7 ] ) NEW_LINE val3 = cost [ 2 ] + ( 0 if ( i + 30 >= size ) else dp [ i + 30 ] ) NEW_LINE dp [ i ] = min ( val1 , min ( val2 , val3 ) ) NEW_LINE ptr -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE DEDENT DEDENT return dp [ 1 ] NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 7 , 8 , 10 , 17 ] NEW_LINE cost = [ 3 , 8 , 20 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MinCost ( arr , cost , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum cost to complete given tasks if cost of 1 , 7 and 30 days are given | Function to find the minimum cost to hire the workers for the given days in the array days [ ] ; Initialize the array dp ; Minimum Cost for Nth day ; Poleter of the array arr [ ] ; Traverse from right to left ; If worker is hired for 1 day ; If worker is hired for 7 days ; If worker is hired for 30 days ; Update the value of dp [ i ] as minimum of 3 options ; If the day is not at the array arr [ ] ; Return the answer ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "4937-4937",
        "Code": "def minimumSteps ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE a = abs ( a - b ) NEW_LINE cnt = ( a // 5 ) + ( a % 5 ) // 2 + ( a % 5 ) % 2 NEW_LINE return cnt NEW_LINE DEDENT A = 3 NEW_LINE B = 9 NEW_LINE print ( minimumSteps ( A , B ) ) NEW_LINE",
        "Type": "py",
        "NL": "Convert A into B by incrementing or decrementing 1 , 2 , or 5 any number of times | Function to find minimum number of moves required to convert A into B ; Stores the minimum number of moves required ; Stores the absolute difference ; FInd the number of moves ; Return cnt ; Input ; Function call",
        "Category": "Math"
    },
    {
        "ID": "4945-4945",
        "Code": "import math NEW_LINE def countOpenDoors ( N ) : NEW_LINE INDENT doorsOpen = int ( math . sqrt ( N ) ) NEW_LINE return doorsOpen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 100 NEW_LINE print ( countOpenDoors ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of open doors | TCS Coding Question | Python3 code for the above approach ; Function that counts the number of doors opens after the Nth turn ; Find the number of open doors ; Return the resultant count of open doors ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4957-4957",
        "Code": "def possibleNumbers ( N , M , A , B ) : NEW_LINE INDENT if ( A > B ) : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT number = N + M * A NEW_LINE print ( number , end = \" ▁ \" ) NEW_LINE if ( A != B ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT number = number - A + B NEW_LINE print ( number , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE M = 3 NEW_LINE A = 4 NEW_LINE B = 6 NEW_LINE possibleNumbers ( N , M , A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all numbers that can be obtained by adding A or B to N exactly M times | Function to find all possible numbers that can be obtained by adding A or B to N exactly M times ; For maintaining increasing order ; Smallest number that can be obtained ; If A and B are equal , then only one number can be obtained , i . e . N + M * A ; For finding others numbers , subtract A from number once and add B to number once ; Driver Code ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "4958-4958",
        "Code": "def possibleNumbers ( N , M , A , B ) : NEW_LINE INDENT if ( A > B ) : NEW_LINE INDENT temp = A NEW_LINE A = B NEW_LINE B = temp NEW_LINE DEDENT number = N + M * A NEW_LINE print ( number , end = \" ▁ \" ) NEW_LINE if ( A != B ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT number = number - A + B NEW_LINE print ( number , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE M = 3 NEW_LINE A = 4 NEW_LINE B = 6 NEW_LINE possibleNumbers ( N , M , A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all numbers that can be obtained by adding A or B to N exactly M times | Function to find all possible numbers that can be obtained by adding A or B to N exactly M times ; For maintaining increasing order ; Smallest number that can be achieved ; If A and B are equal , the only number that can be onbtained is N + M * A ; For finding other numbers , subtract A from number 1 time and add B to number 1 time ; Driver Code ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "4960-4960",
        "Code": "Pi = 3.141592 NEW_LINE def MaxBuildingsCovered ( arr , N , L ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE start = 0 NEW_LINE curr_count = 0 NEW_LINE max_count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum = curr_sum + ( arr [ i ] * Pi ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT curr_sum += 1 NEW_LINE DEDENT if ( curr_sum <= L ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT elif ( curr_sum > L ) : NEW_LINE INDENT curr_sum = curr_sum - ( arr [ start ] * Pi ) NEW_LINE curr_sum -= 1 NEW_LINE start += 1 NEW_LINE curr_count -= 1 NEW_LINE DEDENT max_count = max ( curr_count , max_count ) NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 6 , 2 ] NEW_LINE L = 24 NEW_LINE N = len ( arr ) NEW_LINE print ( MaxBuildingsCovered ( arr , N , L ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize number of circular buildings that can be covered by L length wire | Python3 program for the above approach ; Function to find the maximum number of buildings covered ; Store the current sum ; Traverse the array ; Add the length of wire required for current building to cur_sum ; Add extra unit distance 1 ; If curr_sum <= length of wire increment count by 1 ; If curr_sum > length of wire increment start by 1 and decrement count by 1 and update the new curr_sum ; Update the max_count ; Return the max_count ; Driver Code ; Given Input ; Size of the array ; Function Call",
        "Category": "Sliding Window"
    },
    {
        "ID": "4963-4963",
        "Code": "def countUnsetBits ( N ) : NEW_LINE INDENT c = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT N = N >> 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def countBitwiseZero ( N ) : NEW_LINE INDENT unsetBits = countUnsetBits ( N ) NEW_LINE print ( ( 1 << unsetBits ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE countBitwiseZero ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers less than N whose Bitwise AND with N is zero | Function to count number of unset bits in the integer N ; Stores the number of unset bits in N ; Check if N is even ; Increment the value of c ; Right shift N by 1 ; Return the value of count of unset bits ; Function to count numbers whose Bitwise AND with N equal to 0 ; Stores the number of unset bits in N ; Prthe value of 2 to the power of unsetBits ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "4981-4981",
        "Code": "def getDate ( d , m ) : NEW_LINE INDENT days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE month = [ ' January ' , ' February ' , ' March ' , ' April ' , ' May ' , ' June ' , ' July ' , ' August ' , ' September ' , ' October ' , ' November ' , ' December ' ] NEW_LINE cnt = 183 NEW_LINE cur_month = month . index ( m ) NEW_LINE cur_date = d NEW_LINE while ( 1 ) : NEW_LINE INDENT while ( cnt > 0 and cur_date <= days [ cur_month ] ) : NEW_LINE INDENT cnt -= 1 NEW_LINE cur_date += 1 NEW_LINE DEDENT if ( cnt == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_month = ( cur_month + 1 ) % 12 NEW_LINE cur_date = 1 NEW_LINE DEDENT print ( cur_date , month [ cur_month ] ) NEW_LINE DEDENT D = 15 NEW_LINE M = \" January \" NEW_LINE getDate ( D , M ) NEW_LINE",
        "Type": "py",
        "NL": "Find the date after next half year from a given date | Function to find the date after the next half - year ; Stores the number of days in the months of a leap year ; List of months ; Days in half of a year ; Index of current month ; Starting day ; Decrement the value of cnt by 1 ; Increment cur_date ; If cnt is equal to 0 , then break out of the loop ; Update cur_month ; Update cur_date ; Print the resultant date ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "4987-4987",
        "Code": "def findSequence ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE sumPos = 0 NEW_LINE sumNeg = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT arr [ i ] = - ( i + 1 ) NEW_LINE sumNeg += arr [ i ] NEW_LINE DEDENT for i in range ( n - k , n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE sumPos += arr [ i ] NEW_LINE DEDENT if ( abs ( sumNeg ) >= sumPos ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 10 NEW_LINE K = 6 NEW_LINE findSequence ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Generate an array with K positive numbers such that arr [ i ] is either | Python program for the above approach Function to generate the resultant sequence of first N natural numbers ; Initialize an array of size N ; Stores the sum of positive and negative elements ; Mark the first N - K elements as negative ; Update the value of arr [ i ] ; Update the value of sumNeg ; Mark the remaining K elements as positive ; Update the value of arr [ i ] ; Update the value of sumPos ; If the sum of the sequence is negative , then pr - 1 ; Pr the required sequence ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "4992-4992",
        "Code": "import math NEW_LINE def minimumValue ( N , K ) : NEW_LINE INDENT return math . ceil ( K / N ) NEW_LINE DEDENT N = 4 NEW_LINE K = 50 NEW_LINE print ( minimumValue ( N , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Generate an N | Python3 program for the above approach ; Function to minimize the maximum element present in an N - length array having sum of elements divisible by K ; Return the ceil value of ( K / N ) ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "4998-4998",
        "Code": "def MaxCollection ( S , P , Q ) : NEW_LINE INDENT maxstr = [ i for i in ( \" ab \" if P >= Q else \" ba \" ) ] NEW_LINE minstr = [ i for i in ( \" ba \" if P >= Q else \" ab \" ) ] NEW_LINE maxp = max ( P , Q ) NEW_LINE minp = min ( P , Q ) NEW_LINE cost = 0 NEW_LINE stack1 = [ ] NEW_LINE s = [ i for i in S ] NEW_LINE for ch in s : NEW_LINE INDENT if ( len ( stack1 ) > 0 and ( stack1 [ - 1 ] == maxstr [ 0 ] and ch == maxstr [ 1 ] ) ) : NEW_LINE INDENT del stack1 [ - 1 ] NEW_LINE cost += maxp NEW_LINE DEDENT else : NEW_LINE INDENT stack1 . append ( ch ) NEW_LINE DEDENT DEDENT sb = \" \" NEW_LINE while ( len ( stack1 ) > 0 ) : NEW_LINE INDENT sb += stack1 [ - 1 ] NEW_LINE del stack1 [ - 1 ] NEW_LINE DEDENT sb = sb [ : : - 1 ] NEW_LINE remstr = sb NEW_LINE for ch in remstr : NEW_LINE INDENT if ( len ( stack1 ) > 0 and ( stack1 [ - 1 ] == minstr [ 0 ] and ch == minstr [ 1 ] ) ) : NEW_LINE INDENT del stack1 [ - 1 ] NEW_LINE cost += minp NEW_LINE DEDENT else : NEW_LINE INDENT stack1 . append ( ch ) NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" cbbaabbaab \" NEW_LINE P = 6 ; NEW_LINE Q = 4 ; NEW_LINE print ( MaxCollection ( S , P , Q ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize cost of removing all occurrences of substrings \" ab \" and \" ba \" | Function to find the maximum cost of removing substrings \" ab \" and \" ba \" from S ; MaxStr is the substring char array with larger cost ; MinStr is the substring char array with smaller cost ; ; Denotes larger point ; Denotes smaller point ; Stores cost scored ; Stack to keep track of characters ; Traverse the string ; If the substring is maxstr ; Pop from the stack ; Add maxp to cost ; Push the character to the stack ; Remaining string after removing maxstr ; Find remaining string ; Reversing the string retrieved from the stack ; Removing all occurences of minstr ; If the substring is minstr ; Pop from the stack ; Add minp to the cost ; Otherwise ; Return the maximum cost ; Driver Code ; Input String ; Costs",
        "Category": "Stack"
    },
    {
        "ID": "5-5",
        "Code": "tree = [ None ] * 10 NEW_LINE def root ( key ) : NEW_LINE INDENT if tree [ 0 ] != None : NEW_LINE INDENT print ( \" Tree ▁ already ▁ had ▁ root \" ) NEW_LINE DEDENT else : NEW_LINE INDENT tree [ 0 ] = key NEW_LINE DEDENT DEDENT def set_left ( key , parent ) : NEW_LINE INDENT if tree [ parent ] == None : NEW_LINE INDENT print ( \" Can ' t ▁ set ▁ child ▁ at \" , ( parent * 2 ) + 1 , \" , ▁ no ▁ parent ▁ found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT tree [ ( parent * 2 ) + 1 ] = key NEW_LINE DEDENT DEDENT def set_right ( key , parent ) : NEW_LINE INDENT if tree [ parent ] == None : NEW_LINE INDENT print ( \" Can ' t ▁ set ▁ child ▁ at \" , ( parent * 2 ) + 2 , \" , ▁ no ▁ parent ▁ found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT tree [ ( parent * 2 ) + 2 ] = key NEW_LINE DEDENT DEDENT def print_tree ( ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT if tree [ i ] != None : NEW_LINE INDENT print ( tree [ i ] , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT root ( ' A ' ) NEW_LINE set_right ( ' C ' , 0 ) NEW_LINE set_left ( ' D ' , 1 ) NEW_LINE set_right ( ' E ' , 1 ) NEW_LINE set_right ( ' F ' , 2 ) NEW_LINE print_tree ( ) NEW_LINE",
        "Type": "py",
        "NL": "Binary Tree ( Array implementation ) | Python3 implementation of tree using array numbering starting from 0 to n - 1. ; create root ; create left son of root ; create right son of root ; Print tree ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "5002-5002",
        "Code": "def findEquation ( A , B , C , K ) : NEW_LINE INDENT print ( A , K * B , K * K * C ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , B , C , K = 1 , 2 , 1 , 2 NEW_LINE findEquation ( A , B , C , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Quadratic equation whose roots are K times the roots of given equation | Function to find the quadratic equation whose roots are K times the roots of the given equation ; Prquadratic equation ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5003-5003",
        "Code": "def findMaxValueOfEquation ( arr , K ) : NEW_LINE INDENT pq = [ ] NEW_LINE res = - 10 ** 8 NEW_LINE for point in arr : NEW_LINE INDENT while ( len ( pq ) > 0 and point [ 0 ] - pq [ - 1 ] [ 1 ] > K ) : NEW_LINE INDENT del pq [ - 1 ] NEW_LINE DEDENT if ( len ( pq ) > 0 ) : NEW_LINE INDENT res = max ( res , pq [ - 1 ] [ 0 ] + point [ 0 ] + point [ 1 ] ) NEW_LINE DEDENT pq . append ( [ point [ 1 ] - point [ 0 ] , point [ 0 ] ] ) NEW_LINE pq = sorted ( pq ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 3 ] , [ 2 , 0 ] , [ 5 , 10 ] , [ 6 , - 10 ] ] NEW_LINE K = 1 NEW_LINE findMaxValueOfEquation ( arr , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum the value of a given expression for any pair of coordinates on a 2D plane | Function to find the maximum value of the given expression possible for any pair of co - ordinates ; Stores the differences between pairs ; Stores the maximum value ; Traverse the array arr [ ] [ ] ; While pq is not empty and difference between point [ 0 ] and pq . top ( ) [ 1 ] > K ; Removes the top element ; If pq is not empty ; Update the value res ; Push pair { point [ 1 ] - point [ 0 ] , point [ 0 ] } in pq ; Prthe result ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "5004-5004",
        "Code": "def checkString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( 2 * k + 1 > n ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT a = s [ 0 : k ] NEW_LINE b = s [ n - k : n ] NEW_LINE b = b [ : : - 1 ] NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" qwqwq \" NEW_LINE K = 1 NEW_LINE checkString ( S , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if 2 * K + 1 non | Function to check if the S can be obtained by ( K + 1 ) non - empty substrings whose concatenation and concatenation of the reverse of these K strings ; Stores the size of the string ; If n is less than 2 * k + 1 ; Stores the first K characters ; Stores the last K characters ; Reverse the string ; If both the strings are equal ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5005-5005",
        "Code": "def calc ( a , b ) : NEW_LINE INDENT return a * b + ( b - a ) NEW_LINE DEDENT def findMaximum ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE ans = - 10 ** 9 NEW_LINE ans = max ( ans , calc ( arr [ 0 ] , arr [ 1 ] ) ) NEW_LINE ans = max ( ans , calc ( arr [ N - 2 ] , arr [ N - 1 ] ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , - 47 , 12 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMaximum ( arr , N ) ) NEW_LINE arr = [ 0 , - 47 , 12 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMaximum ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum value of ( arr [ i ] * arr [ j ] ) + ( arr [ j ] | Function to find the value of the expression a * b + ( b - a ) ; Function to find the maximum value of the expression a * b + ( b - a ) possible for any pair ( a , b ) ; Sort the vector in ascending order ; Stores the maximum value ; Update ans by choosing the pair of the minimum and 2 nd minimum ; Update ans by choosing the pair of maximum and 2 nd maximum ; Return the value of ans ; Driver Code ; Given inputs",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5008-5008",
        "Code": "def minimumFlips ( A , B , C ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x , y , z = 0 , 0 , 0 NEW_LINE if ( A & ( 1 << i ) ) : NEW_LINE INDENT x = 1 NEW_LINE DEDENT if ( B & ( 1 << i ) ) : NEW_LINE INDENT y = 1 NEW_LINE DEDENT if ( C & ( 1 << i ) ) : NEW_LINE INDENT z = 1 NEW_LINE DEDENT if ( z == 0 ) : NEW_LINE INDENT if ( x ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( y ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( z == 1 ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , B , C = 2 , 6 , 5 NEW_LINE print ( minimumFlips ( A , B , C ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of bits required to be flipped such that Bitwise OR of A and B is equal to C | Function to count the number of bit flips required on A and B such that Bitwise OR of A and B is C ; Stores the count of flipped bit ; Iterate over the range [ 0 , 32 ] ; Check if i - th bit of A is set ; Check if i - th bit of B is set or not ; Check if i - th bit of C is set or not ; If i - th bit of C is unset ; Check if i - th bit of A is set or not ; Check if i - th bit of B is set or not ; Check if i - th bit of C is set or not ; Check if i - th bit of both A and B is set ; Return the count of bits flipped ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5010-5010",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def countDistinctNumbers ( A , B , C ) : NEW_LINE INDENT g = gcd ( A , B ) NEW_LINE count = C // g NEW_LINE print ( count ) NEW_LINE DEDENT A = 2 NEW_LINE B = 3 NEW_LINE C = 5 NEW_LINE countDistinctNumbers ( A , B , C ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers up to C that can be reduced to 0 by adding or subtracting A or B | Function to calculate GCD of the two numbers a and b ; Base Case ; Recursively find the GCD ; Function to count the numbers up to C that can be reduced to 0 by adding or subtracting A or B ; Stores GCD of A and B ; Stores the count of multiples of g in the range ( 0 , C ] ; Print the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5011-5011",
        "Code": "def printLastElement ( arr , N ) : NEW_LINE INDENT leftTurn = True NEW_LINE remainElements = N NEW_LINE step = 1 NEW_LINE head = 1 NEW_LINE while ( remainElements > 1 ) : NEW_LINE INDENT if ( leftTurn ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT else : NEW_LINE INDENT if ( remainElements % 2 == 1 ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT DEDENT remainElements = remainElements // 2 NEW_LINE step = step * 2 NEW_LINE leftTurn = not leftTurn NEW_LINE DEDENT print ( arr [ head - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE printLastElement ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the last element after repeatedly removing every second element from either end alternately | Function to find the last element remaining in the array after performing the given operations ; Checks if traversal is from left to right or vice versa ; Store the elements currently present in the array ; Store the distance between 2 consecutive array elements ; Store the first element of the remaining array ; Iterate while elements are greater than 1 ; If left to right turn ; Update head ; Otherwise , check if the remaining elements are odd ; If true , update head ; Eleminate half of the array elements ; Double the steps after each turn ; Alter the turn ; Print the remaining element ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5013-5013",
        "Code": "prefixCount = [ [ 0 for x in range ( 32 ) ] for y in range ( 10000 ) ] NEW_LINE def findPrefixCount ( arr , size ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT prefixCount [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) NEW_LINE for j in range ( 1 , size ) : NEW_LINE INDENT prefixCount [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) NEW_LINE prefixCount [ i ] [ j ] += prefixCount [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def arrayBitwiseAND ( size ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT temp = prefixCount [ i ] [ size - 1 ] NEW_LINE if ( temp == size ) : NEW_LINE INDENT result = ( result | ( 1 << i ) ) NEW_LINE DEDENT DEDENT print ( result , end = \" ▁ \" ) NEW_LINE DEDENT def applyQuery ( currentVal , newVal , size ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT bit1 = ( ( currentVal >> i ) & 1 ) NEW_LINE bit2 = ( ( newVal >> i ) & 1 ) NEW_LINE if ( bit2 > 0 and bit1 == 0 ) : NEW_LINE INDENT prefixCount [ i ] [ size - 1 ] += 1 NEW_LINE DEDENT elif ( bit1 > 0 and bit2 == 0 ) : NEW_LINE INDENT prefixCount [ i ] [ size - 1 ] -= 1 NEW_LINE DEDENT DEDENT DEDENT def findbitwiseAND ( queries , arr , N , M ) : NEW_LINE INDENT findPrefixCount ( arr , N ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT id = queries [ i ] [ 0 ] NEW_LINE newVal = queries [ i ] [ 1 ] NEW_LINE currentVal = arr [ id ] NEW_LINE arr [ id ] = newVal NEW_LINE applyQuery ( currentVal , newVal , N ) NEW_LINE arrayBitwiseAND ( N ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE queries = [ [ 0 , 2 ] , [ 3 , 3 ] , [ 4 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( queries ) NEW_LINE findbitwiseAND ( queries , arr , N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to calculate Bitwise AND of an array with updates | Store the number of set bits at each position ; Function to precompute the prefix count array ; Iterate over the range [ 0 , 31 ] ; Set the bit at position i if arr [ 0 ] is set at position i ; Traverse the array and take prefix sum ; Update prefixCount [ i ] [ j ] ; Function to find the Bitwise AND of all array elements ; Stores the required result ; Iterate over the range [ 0 , 31 ] ; Stores the number of set bits at position i ; If temp is N , then set ith position in the result ; Print the result ; Function to update the prefix count array in each query ; Iterate through all the bits of the current number ; Store the bit at position i in the current value and the new value ; If bit2 is set and bit1 is unset , then increase the set bits at position i by 1 ; If bit1 is set and bit2 is unset , then decrease the set bits at position i by 1 ; Function to find the bitwise AND of the array after each query ; Fill the prefix count array ; Traverse the queries ; Store the index and the new value ; Store the current element at the index ; Update the array element ; Apply the changes to the prefix count array ; Print the bitwise AND of the modified array ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5015-5015",
        "Code": "def max_min ( N , C , K ) : NEW_LINE INDENT maximum = 0 NEW_LINE minimum = 0 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT maximum = minimum = C NEW_LINE DEDENT elif ( K >= C ) : NEW_LINE INDENT maximum = C NEW_LINE minimum = 0 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = K NEW_LINE minimum = 0 NEW_LINE remain_candy = C - K NEW_LINE maximum += remain_candy // N NEW_LINE minimum = remain_candy // N NEW_LINE DEDENT if ( remain_candy % N == N - 1 ) : NEW_LINE INDENT minimum += 1 NEW_LINE DEDENT print ( \" Maximum ▁ = ▁ { } \" . format ( maximum ) ) NEW_LINE print ( \" Minimum ▁ = ▁ { } \" . format ( minimum ) ) NEW_LINE DEDENT N = 4 NEW_LINE C = 12 NEW_LINE K = 3 NEW_LINE max_min ( N , C , K ) NEW_LINE",
        "Type": "py",
        "NL": "Distributed C candies among N boys such that difference between maximum and minimum candies received is K | Function to calculate the maximum and minimum number of candies a boy can possess ; All candies will be given to one boy ; All the candies will be given to 1 boy ; Give K candies to 1 st boy initially ; Count remaining candies ; If the last candy of remaining candies is given to the last boy , i . e Nth boy ; Increase minimum count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5031-5031",
        "Code": "def findLongestArray ( K ) : NEW_LINE INDENT primefactors = [ ] NEW_LINE K_temp = K NEW_LINE i = 2 NEW_LINE while i * i <= K : NEW_LINE INDENT count = 0 NEW_LINE while ( K_temp % i == 0 ) : NEW_LINE INDENT K_temp //= i NEW_LINE count += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT primefactors . append ( [ count , i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( K_temp != 1 ) : NEW_LINE INDENT primefactors . append ( [ 1 , K_temp ] ) NEW_LINE DEDENT primefactors . sort ( ) NEW_LINE answer = [ primefactors [ 0 ] [ 0 ] , primefactors [ 0 ] [ 1 ] ] NEW_LINE answer [ - 1 ] *= K NEW_LINE for i in range ( primefactors [ 0 ] [ 0 ] ) : NEW_LINE INDENT answer [ - 1 ] //= primefactors [ 0 ] [ 1 ] NEW_LINE DEDENT print ( \" { \" , end = \" \" ) NEW_LINE for i in range ( len ( answer ) ) : NEW_LINE INDENT if ( i == len ( answer ) - 1 ) : NEW_LINE INDENT print ( answer [ i ] , end = \" } \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( answer [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 4 NEW_LINE findLongestArray ( K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate longest possible array with product K such that each array element is divisible by its previous adjacent element | Function to construct longest array with product K such that each element is divisible by its previous element ; Stores the prime factors of K ; Stores the power to which primefactor i is raised ; Sort prime factors in descending order ; Stores the final array ; Multiply the last element by K ; Print the constructed array ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5036-5036",
        "Code": "def findScoreSum ( n ) : NEW_LINE INDENT total = 0 NEW_LINE prev_monday , curr_day = 0 , 0 NEW_LINE for day in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( day % 7 == 1 ) : NEW_LINE INDENT prev_monday += 1 NEW_LINE curr_day = prev_monday NEW_LINE DEDENT total += curr_day NEW_LINE curr_day += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE findScoreSum ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Calculate sum of scores after N days based on given conditions | Function to c sum of calculate sum of scores after n days ; Store the required sum ; Store the score on previous monday and current day respectively ; Iterate over the range [ 1 , n ] ; If the current day is monday ; Increment score of prev_monday by 1 ; Update score of current day ; Add score of current day and increment score for next day ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5037-5037",
        "Code": "def findScoreSum ( n ) : NEW_LINE INDENT F = n // 7 NEW_LINE D = n % 7 NEW_LINE fullWeekScore = ( 49 + 7 * F ) * F // 2 NEW_LINE lastNonFullWeekScore = ( 2 * F + D + 1 ) * D // 2 NEW_LINE print ( fullWeekScore + lastNonFullWeekScore ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE findScoreSum ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Calculate sum of scores after N days based on given conditions | Function to calculate sum of scores after n days ; Store the number of full weeks ; Stores the remaining days in the last week ; Store the sum of scores in the first F full weeks ; Store the sum of scores in the last week ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5040-5040",
        "Code": "def maximumNum ( X , Y , N ) : NEW_LINE INDENT num = 0 NEW_LINE if ( N - N % X + Y <= N ) : NEW_LINE INDENT num = N - N % X + Y NEW_LINE DEDENT else : NEW_LINE INDENT num = N - N % X - ( X - Y ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 10 NEW_LINE Y = 5 NEW_LINE N = 15 NEW_LINE print ( maximumNum ( X , Y , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest number up to N whose modulus with X is equal to Y modulo X | Function to print the largest number upto N whose modulus with X is same as Y % X ; Stores the required number ; Update num as the result ; Return the resultant number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5043-5043",
        "Code": "def getArea ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) NEW_LINE DEDENT def isInside ( triangle , point ) : NEW_LINE INDENT A , B , C = triangle NEW_LINE x , y = point NEW_LINE ABC = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) NEW_LINE BPC = getArea ( x , y , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) NEW_LINE APC = getArea ( A [ 0 ] , A [ 1 ] , x , y , C [ 0 ] , C [ 1 ] ) NEW_LINE APB = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , x , y ) NEW_LINE return ABC == ( APC + APB + BPC ) NEW_LINE DEDENT def countPoints ( rectangle , triangle , points ) : NEW_LINE INDENT triangle1 = rectangle [ 1 : ] NEW_LINE triangle2 = rectangle [ : 3 ] NEW_LINE triangle3 = rectangle [ : 2 ] NEW_LINE triangle3 . append ( rectangle [ 3 ] ) NEW_LINE triangle4 = rectangle [ - 2 : ] NEW_LINE triangle4 . append ( rectangle [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for point in points : NEW_LINE INDENT condOne = isInside ( triangle1 , point ) NEW_LINE condTwo = isInside ( triangle2 , point ) NEW_LINE condThree = isInside ( triangle3 , point ) NEW_LINE condFour = isInside ( triangle4 , point ) NEW_LINE condFive = isInside ( triangle , point ) NEW_LINE if ( condOne or condTwo or condThree   \\ or condFour ) and condFive : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT rectangle = [ [ 6 , 5 ] , [ 2 , 2 ] , [ 2 , 1 ] , [ 5 , 5 ] ] NEW_LINE points = [ [ 1 , 1 ] , [ 6 , 1 ] , [ 6 , 6 ] , [ 1 , 6 ] ] NEW_LINE triangle = [ [ 4 , 4 ] , [ 0 , 4 ] , [ 0 , - 2 ] ] NEW_LINE countPoints ( points , triangle , rectangle ) NEW_LINE",
        "Type": "py",
        "NL": "Number of points lying inside a rectangle as well as a triangle | Function to calculate area of a triangle ; Return the resultant area ; Function to check if a point lies inside a triangle or not ; Calculate area of triangle ABC ; Calculate area of triangle formed by connecting B , C , point ; Calculate area of triangle formed by connecting A , C , point ; Calculate area of triangle formed by connecting A , B , point ; Check if the sum of the areas of above three triangles the same as ABC ; Function to count the number of points lying inside a triangle & rectangle ; Stores the coordinates of the vertices of the triangles ; Stores the number of points lying inside the triangle and rectangle ; Traverse the array of points ; Stores whether the current point lies inside triangle1 or not ; Stores whether the current point lies inside triangle2 or not ; Stores whether the current point lies inside triangle3 or not ; Stores whether the current point lies inside triangle4 or not ; Stores whether the current point lies inside given triangle or not ; If current point lies inside given triangle as well as inside any of the four obtained triangles ; Print the count of points ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5049-5049",
        "Code": "def findString ( S , N ) : NEW_LINE INDENT strLen = 4 * N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ strLen - 1 ] = '1' NEW_LINE strLen -= 2 NEW_LINE DEDENT for i in range ( 4 * N ) : NEW_LINE INDENT print ( S [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT N = 2 NEW_LINE S = [ 0 ] * ( 4 * N ) NEW_LINE for i in range ( 4 * N ) : NEW_LINE INDENT S [ i ] = '0' NEW_LINE DEDENT findString ( S , N ) NEW_LINE",
        "Type": "py",
        "NL": "Modify a Binary String by flipping characters such that any pair of indices consisting of 1 s are neither co | Function to modify a string such that there doesn 't exist any pair of indices consisting of 1s, whose GCD is 1 and are divisible by each other ; Flips characters at indices 4 N , 4 N - 2 , 4 N - 4 . ... upto N terms ; Print the string ; Driver code ; Initialize the string S ; function call",
        "Category": "Substring"
    },
    {
        "ID": "506-506",
        "Code": "class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . adj [ u ] . append ( v ) NEW_LINE self . adj [ v ] . append ( u ) NEW_LINE DEDENT def countEdges ( self ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( self . V ) : NEW_LINE INDENT Sum += len ( self . adj [ i ] ) NEW_LINE DEDENT return Sum // 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V = 9 NEW_LINE g = Graph ( V ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 7 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 1 , 7 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 2 , 8 ) NEW_LINE g . addEdge ( 2 , 5 ) NEW_LINE g . addEdge ( 3 , 4 ) NEW_LINE g . addEdge ( 3 , 5 ) NEW_LINE g . addEdge ( 4 , 5 ) NEW_LINE g . addEdge ( 5 , 6 ) NEW_LINE g . addEdge ( 6 , 7 ) NEW_LINE g . addEdge ( 6 , 8 ) NEW_LINE g . addEdge ( 7 , 8 ) NEW_LINE print ( g . countEdges ( ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count number of edges in an undirected graph | Adjacency list representation of graph ; add edge to graph ; Returns count of edge in undirected graph ; traverse all vertex ; add all edge that are linked to the current vertex ; The count of edge is always even because in undirected graph every edge is connected twice between two vertices ; Driver Code ; making above uhown graph",
        "Category": "Graph Theory"
    },
    {
        "ID": "5063-5063",
        "Code": "def LCMPairs ( arr , N ) : NEW_LINE INDENT total_pairs = ( N * ( N - 1 ) ) / 2 NEW_LINE odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT odd = ( odd * ( odd - 1 ) ) // 2 NEW_LINE print ( \" Even ▁ = \" , int ( total_pairs - odd ) , \" , \" , \" ▁ Odd ▁ = \" , odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 5 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE LCMPairs ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of pairs having even and odd LCM from an array | Function to find count of distinct pairs having even LCM and odd LCM ; Store the total number of pairs ; Stores the count of odd numbers in the array ; Traverse the array arr [ ] ; Update the count of pairs with odd LCM ; Print the count of required pairs ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5066-5066",
        "Code": "def countEvenOdd ( L , R ) : NEW_LINE INDENT range = R - L + 1 ; NEW_LINE even = ( range // 4 ) * 2 ; NEW_LINE if ( ( L & 1 ) != 0 and ( range % 4 == 3 ) ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT elif ( ( L & 1 ) == 0 and ( range % 4 != 0 ) ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT print ( \" Even ▁ = ▁ \" , even , \" , ▁ Odd ▁ = ▁ \" , ( range - even ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 2 ; R = 7 ; NEW_LINE countEvenOdd ( L , R ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count even and odd Bitwise XORs of consecutive numbers in a range [ L , R ] starting from L | Prcount of even and odd numbers of XOR value from L to R ; Store the number of elements between L and R ; Count of even XOR values ; If L is odd and range % 4 = 3 ; Increment even by 1 ; If L is even and range % 4 != 0 ; Increment even by 1 ; Prthe answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5068-5068",
        "Code": "def countSwaps ( S , T ) : NEW_LINE INDENT value = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT value [ i ] = i + 1 NEW_LINE DEDENT N = len ( S ) NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE flag = False NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += value [ ord ( S [ i ] ) - ord ( ' a ' ) ] NEW_LINE sum2 += value [ ord ( T [ i ] ) - ord ( ' a ' ) ] NEW_LINE if ( value [ ord ( S [ i ] ) - ord ( ' a ' ) ] % 2 == 0 and value [ ord ( T [ i ] ) - ord ( ' a ' ) ] % 2 == 1 or value [ ord ( S [ i ] ) - ord ( ' a ' ) ] % 2 == 1 and value [ ord ( T [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if ( sum1 % 2 == 1 and sum2 % 2 == 1 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT elif ( sum1 % 2 == 0 and sum2 % 2 == 0 ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" acd \" NEW_LINE T = \" dbf \" NEW_LINE countSwaps ( S , T ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize swaps of same | Function to count the number of swaps required to make the sum of ASCII values of the characters of both strings odd ; Initialize alphabets with value ; Initialize values for each alphabet ; Size of the string ; Sum of S ; Sum of T ; Stores whether there is any index i such that S [ i ] and T [ i ] have different parities ; Traverse the strings ; Update sum1 and sum2 ; If ord ( S [ i ] ) anord ( ' a ) rd ( T [ i ] ) ▁ haord ( ' a ) different parities ; If sum1 and sum2 are both odd ; If sum1 and sum2 are both even ; If exists pr1 ; Otherwise ; If sum1 and sum2 are of different parities ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5070-5070",
        "Code": "def countPairs ( L , R ) : NEW_LINE INDENT firstNum = 2 * L NEW_LINE lastNum = 2 * R NEW_LINE Cntpairs = lastNum - firstNum + 1 NEW_LINE print ( Cntpairs ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 3 NEW_LINE countPairs ( L , R ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs having distinct sum from a given range | Function to count pairs made up of elements from the range [ L , R ] having distinct sum ; Stores the least sum which can be formed by the pairs ; Stores the highest sum which can be formed by the pairs ; Stores the count of pairs having distinct sum ; Print the count of pairs ; Driver Code ; Function call to count the number of pairs having distinct sum in the range [ L , R ]",
        "Category": "Math"
    },
    {
        "ID": "5088-5088",
        "Code": "from math import ceil , floor NEW_LINE def MinimumMoves ( A , B , N ) : NEW_LINE INDENT totalOperations = 0 NEW_LINE carry = 0 NEW_LINE K = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT nearestMultiple = ceil ( ( A [ i ] + carry ) / B [ i ] ) * B [ i ] NEW_LINE K = nearestMultiple - ( A [ i ] + carry ) NEW_LINE totalOperations += K NEW_LINE carry += K NEW_LINE DEDENT return totalOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 3 , 4 , 5 , 2 , 5 , 5 , 9 ] NEW_LINE B = [ 1 , 1 , 9 , 6 , 3 , 8 , 7 ] NEW_LINE N = len ( A ) NEW_LINE print ( MinimumMoves ( A , B , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum prefix increments required to make all elements of an array multiples of another array | Python3 program for the above approach ; Function to find minimum count of operations required to make A [ i ] multiple of B [ i ] by incrementing prefix subarray ; Stores minimum count of operations required to make A [ i ] multiple of B [ i ] by incrementing prefix subarray ; Stores the carry ; Stores minimum difference of correspoinding element in prefix subarray ; Traverse the array ; Stores the closest greater or equal number to A [ i ] which is a multiple of B [ i ] ; Stores minimum difference ; Update totalOperations ; Update carry ; Driver Code ; Input arrays A [ ] and B [ ] ; Length of arrays",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "509-509",
        "Code": "maxn = 25 NEW_LINE gr = [ [ None ] * maxn for i in range ( maxn ) ] NEW_LINE def isCover ( V , k , E ) : NEW_LINE INDENT Set = ( 1 << k ) - 1 NEW_LINE limit = ( 1 << V ) NEW_LINE vis = [ [ None ] * maxn for i in range ( maxn ) ] NEW_LINE while ( Set < limit ) : NEW_LINE INDENT vis = [ [ 0 ] * maxn for i in range ( maxn ) ] NEW_LINE cnt = 0 NEW_LINE j = 1 NEW_LINE v = 1 NEW_LINE while ( j < limit ) : NEW_LINE INDENT if ( Set & j ) : NEW_LINE INDENT for k in range ( 1 , V + 1 ) : NEW_LINE INDENT if ( gr [ v ] [ k ] and not vis [ v ] [ k ] ) : NEW_LINE INDENT vis [ v ] [ k ] = 1 NEW_LINE vis [ k ] [ v ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT j = j << 1 NEW_LINE v += 1 NEW_LINE DEDENT if ( cnt == E ) : NEW_LINE INDENT return True NEW_LINE DEDENT c = Set & - Set NEW_LINE r = Set + c NEW_LINE Set = ( ( ( r ^ Set ) >> 2 ) // c ) | r NEW_LINE DEDENT return False NEW_LINE DEDENT def findMinCover ( n , m ) : NEW_LINE INDENT left = 1 NEW_LINE right = n NEW_LINE while ( right > left ) : NEW_LINE INDENT mid = ( left + right ) >> 1 NEW_LINE if ( isCover ( n , mid , m ) == False ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT return left NEW_LINE DEDENT def insertEdge ( u , v ) : NEW_LINE INDENT gr [ u ] [ v ] = 1 NEW_LINE gr [ v ] [ u ] = 1 NEW_LINE DEDENT V = 6 NEW_LINE E = 6 NEW_LINE insertEdge ( 1 , 2 ) NEW_LINE insertEdge ( 2 , 3 ) NEW_LINE insertEdge ( 1 , 3 ) NEW_LINE insertEdge ( 1 , 4 ) NEW_LINE insertEdge ( 1 , 5 ) NEW_LINE insertEdge ( 1 , 6 ) NEW_LINE print ( \" Minimum ▁ size ▁ of ▁ a ▁ vertex ▁ cover ▁ = ▁ \" , findMinCover ( V , E ) ) NEW_LINE gr = [ [ 0 ] * maxn for i in range ( maxn ) ] NEW_LINE V = 6 NEW_LINE E = 7 NEW_LINE insertEdge ( 1 , 2 ) NEW_LINE insertEdge ( 1 , 3 ) NEW_LINE insertEdge ( 2 , 3 ) NEW_LINE insertEdge ( 2 , 4 ) NEW_LINE insertEdge ( 3 , 5 ) NEW_LINE insertEdge ( 4 , 5 ) NEW_LINE insertEdge ( 4 , 6 ) NEW_LINE print ( \" Minimum ▁ size ▁ of ▁ a ▁ vertex ▁ cover ▁ = ▁ \" , findMinCover ( V , E ) ) NEW_LINE",
        "Type": "py",
        "NL": "Finding minimum vertex cover size of a graph using binary search | A Python3 program to find size of minimum vertex cover using Binary Search ; Global array to store the graph Note : since the array is global , all the elements are 0 initially ; Returns true if there is a possible subSet of size ' k ' that can be a vertex cover ; Set has first ' k ' bits high initially ; to mark the edges covered in each subSet of size ' k ' ; ReSet visited array for every subSet of vertices ; Set counter for number of edges covered from this subSet of vertices to zero ; selected vertex cover is the indices where ' Set ' has its bit high ; Mark all edges emerging out of this vertex visited ; If the current subSet covers all the edges ; Generate previous combination with k bits high Set & - Set = ( 1 << last bit high in Set ) ; Returns answer to graph stored in gr [ ] [ ] ; Binary search the answer ; at the end of while loop both left and right will be equal , / as when they are not , the while loop won 't exit the   minimum size vertex cover = left = right  ; Inserts an edge in the graph ; Undirected graph ; 6 / 1 -- -- - 5 vertex cover = { 1 , 2 } / | \\ 3 | \\  \\ | \\ 2 4 ; Let us create another graph ; 2 -- -- 4 -- -- 6 / | | 1 | | vertex cover = { 2 , 3 , 4 } \\ | | 3 -- -- 5",
        "Category": "Graph Theory"
    },
    {
        "ID": "5096-5096",
        "Code": "def FindwinnerOfGame ( S ) : NEW_LINE INDENT cntZero = 0 NEW_LINE cntConOne = 0 NEW_LINE nimSum = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT cntConOne += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nimSum ^= cntConOne NEW_LINE cntConOne = 0 NEW_LINE cntZero += 1 NEW_LINE DEDENT DEDENT nimSum ^= cntConOne NEW_LINE if ( cntZero % 2 == 0 ) : NEW_LINE INDENT print ( \" Tie \" ) NEW_LINE DEDENT elif ( nimSum ) : NEW_LINE INDENT print ( \" player ▁ 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" player ▁ 2\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"0110011\" NEW_LINE FindwinnerOfGame ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the player with least 0 s after emptying a Binary String by removing non | Function to find the player who wins the game ; Stores total count of 0 s in the string ; Stores count of consecutive 1 s ; Stores Nim - Sum on count of consecutive 1 s ; Stores length of the string ; Traverse the string ; If the current character is 1 ; Update cntConOne ; Update nimSum ; Update cntConOne ; Update cntZero ; Update nimSum ; If countZero is an even number ; nimSum is not 0 ; If nimSum is zero ; Driver Code",
        "Category": "Game Theory"
    },
    {
        "ID": "5097-5097",
        "Code": "def check ( current_row , current_col , destination_row , destination_col ) : NEW_LINE INDENT if ( current_row == destination_row ) : NEW_LINE INDENT return ( \" POSSIBLE \" ) NEW_LINE DEDENT elif ( current_col == destination_col ) : NEW_LINE INDENT return ( \" POSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( \" NOT ▁ POSSIBLE \" ) NEW_LINE DEDENT DEDENT current_row = 8 NEW_LINE current_col = 8 NEW_LINE destination_row = 8 NEW_LINE destination_col = 4 NEW_LINE output = check ( current_row , current_col , destination_row , destination_col ) NEW_LINE print ( output ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a Rook can reach the given destination in a single move | Function to check if it is possible to reach destination in a single move by a rook ; Given arrays",
        "Category": "Array"
    },
    {
        "ID": "5100-5100",
        "Code": "def Winner ( N ) : NEW_LINE INDENT player = True NEW_LINE while N > 1 : NEW_LINE INDENT X , Y = divmod ( N , ( 9 if player else 2 ) ) NEW_LINE N = X + 1 if Y else X NEW_LINE player = not player NEW_LINE DEDENT if player : NEW_LINE return ' B ' NEW_LINE else : NEW_LINE return ' A ' NEW_LINE DEDENT N = 10 NEW_LINE print ( Winner ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the player to reach at least N by multiplying with any value from given range | Function to find the winner ; Backtrack from N to 1 ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "5104-5104",
        "Code": "def farthestCellDistance ( N , M , R , C ) : NEW_LINE INDENT d1 = N + M - R - C ; NEW_LINE d2 = R + C - 2 ; NEW_LINE d3 = N - R + C - 1 ; NEW_LINE d4 = M - C + R - 1 ; NEW_LINE maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; NEW_LINE print ( maxDistance ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE M = 12 ; NEW_LINE R = 1 ; NEW_LINE C = 6 ; NEW_LINE farthestCellDistance ( N , M , R , C ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Farthest cell from a given cell in a Matrix | Function to find the farthest cell distance from the given cell ; From cell ( N , M ) ; From Cell ( 1 , 1 ) ; From cell ( N , 1 ) ; From cell ( 1 , M ) ; Finding out maximum ; Prthe answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "511-511",
        "Code": "def addEdge ( adj , u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE DEDENT def findSum ( adj , V ) : NEW_LINE INDENT sum = 0 NEW_LINE for u in range ( V ) : NEW_LINE INDENT sum += len ( adj [ u ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V = 4 NEW_LINE adj = [ [ ] for i in range ( V ) ] NEW_LINE addEdge ( adj , 0 , 2 ) NEW_LINE addEdge ( adj , 0 , 3 ) NEW_LINE addEdge ( adj , 1 , 3 ) NEW_LINE addEdge ( adj , 2 , 3 ) NEW_LINE print ( \" Sum ▁ of ▁ dependencies ▁ is \" , findSum ( adj , V ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of dependencies in a graph | To add an edge ; Find the sum of all dependencies ; Just find the size at each vector 's index ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "5110-5110",
        "Code": "from math import log NEW_LINE def constructArray ( arr , N ) : NEW_LINE INDENT brr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT K = int ( log ( arr [ i ] ) / log ( 2 ) ) NEW_LINE R = pow ( 2 , K ) NEW_LINE brr [ i ] = R NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( brr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 5 , 7 , 3 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE constructArray ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate an N | Python3 program for the above approach ; Function to construct an array with given conditions ; Traverse the array arr [ ] ; Stores closest power of 2 less than or equal to arr [ i ] ; Stores R into brr [ i ] ; Prarray elements ; Driver Code ; Given array ; Size of the array ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5114-5114",
        "Code": "def minOpsToEmptyString ( S , N ) : NEW_LINE INDENT one = 0 NEW_LINE zero = 0 NEW_LINE x0 = 0 NEW_LINE x1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT x0 += 1 NEW_LINE x1 = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x1 += 1 NEW_LINE x0 = 0 NEW_LINE DEDENT zero = max ( x0 , zero ) NEW_LINE one = max ( x1 , one ) NEW_LINE DEDENT print ( max ( one , zero ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0100100111\" NEW_LINE N = len ( S ) NEW_LINE minOpsToEmptyString ( S , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize removal of alternating subsequences to empty given Binary String | Function to find the minimum number of operations required to empty the string ; Initialize variables ; Traverse the string ; If current character is 0 ; Update maximum consecutive 0 s and 1 s ; Print the minimum operation ; Driver code + ; input string ; length of string ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5121-5121",
        "Code": "import math NEW_LINE def CheckAllEqual ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minCntOperations ( arr , N ) : NEW_LINE INDENT Max = max ( arr ) NEW_LINE isPower2 = not ( Max and ( Max & ( Max - 1 ) ) ) NEW_LINE if ( isPower2 and CheckAllEqual ( arr , N ) ) : NEW_LINE INDENT return log2 ( Max ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( math . log2 ( Max ) ) + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minCntOperations ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize count of given operations required to be performed to make all array elements equal to 1 | Python 3 program to implement the above approach ; Function to check if all array elements are equal or not ; Traverse the array ; If all array elements are not equal ; Function to find minimum count of operation to make all the array elements equal to 1 ; Stores largest element of the array ; Check if a number is a power of 2 or not ; If Max is a power of 2 and all array elements are equal ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5122-5122",
        "Code": "def greatestReducedNumber ( num , s ) : NEW_LINE INDENT vis_s = [ False ] * 10 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE vis_s [ ( ord ) ( s [ i ] ) - 48 ] = True NEW_LINE n = len ( num ) NEW_LINE In = - 1 NEW_LINE for i in range ( n ) : NEW_LINE if ( vis_s [ ord ( num [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT In = i NEW_LINE break NEW_LINE DEDENT if ( In == - 1 ) : NEW_LINE return num NEW_LINE for dig in range ( ord ( num [ In ] ) , ord ( '0' ) - 1 , - 1 ) : NEW_LINE if ( vis_s [ dig - ord ( '0' ) ] == False ) : NEW_LINE INDENT num = num [ 0 : In ] + chr ( dig ) + num [ In + 1 : n - In - 1 ] NEW_LINE break NEW_LINE DEDENT LargestDig = '0' NEW_LINE for dig in range ( ord ( '9' ) , ord ( '0' ) - 1 , - 1 ) : NEW_LINE if ( vis_s [ dig - ord ( '0' ) ] == False ) : NEW_LINE INDENT LargestDig = dig NEW_LINE break NEW_LINE DEDENT for i in range ( In + 1 , n ) : NEW_LINE num = num [ 0 : i ] + chr ( LargestDig ) NEW_LINE Count = 0 NEW_LINE for i in range ( n ) : NEW_LINE if ( num [ i ] == '0' ) : NEW_LINE INDENT Count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT num = num [ Count : n ] NEW_LINE if ( int ( len ( num ) ) == 0 ) : NEW_LINE return \"0\" NEW_LINE return num NEW_LINE DEDENT N = \"12345\" NEW_LINE S = \"23\" NEW_LINE print ( greatestReducedNumber ( N , S ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest number not exceeding N that does not contain any of the digits of S | Function to obtain the largest number not exceeding num which does not contain any digits present in S ; Stores digits of S ; Traverse the string S ; Set occurrence as true ; Traverse the string n ; All digits of num are not present in string s ; Largest Digit not present in the string s ; Set all digits from positions in + 1 to n - 1 as LargestDig ; Counting leading zeroes ; Removing leading zeroes ; If the string becomes null ; Return the largest number ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "5126-5126",
        "Code": "if ( X == 0 ) : NEW_LINE INDENT if ( N % M == 0 ) : NEW_LINE INDENT global res NEW_LINE res = N NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT res = - 1 NEW_LINE def isDiv ( N , X , M ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT if ( isDiv ( N * 10 + i , X - 1 , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , M , X = 4 , 50 , 2 NEW_LINE if ( isDiv ( N , X , M ) ) : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Append X digits to the end of N to make it divisible by M | Base case ; If N is divisible by M ; global variable to store result ; Iterate over the range [ 0 , 9 ] ; if N is Divisible by M upon appending X digits ; Driver Code ; Stores the number by appending X digits on the right side of N",
        "Category": "Backtracking"
    },
    {
        "ID": "5140-5140",
        "Code": "def maxksum ( L , R , K ) : NEW_LINE INDENT N = ( R // 10 - L // 10 ) + 1 ; NEW_LINE if ( K > N ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT R = R // 10 ; NEW_LINE X = R - K ; NEW_LINE sum = 10 * ( ( R * ( R + 1 ) ) // 2 - ( X * ( X + 1 ) ) // 2 ) ; NEW_LINE print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 16 ; R = 60 ; K = 4 ; NEW_LINE maxksum ( L , R , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum possible sum of K even multiples of 5 in a given range | Function to find the maximum sum of K even multiples of 5 in the range [ L , R ] ; Store the total number of even multiples of 5 in the range [ L , R ] ; Check if K > N ; If true , print - 1 and return ; Otherwise , divide R by 10 ; Store the sum using the formula ; Print the sum ; Driver Code ; Given L , R and K ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5146-5146",
        "Code": "def path_to_root ( node ) : NEW_LINE INDENT while ( node >= 1 ) : NEW_LINE INDENT print ( node , end = \" ▁ \" ) NEW_LINE node //= 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 NEW_LINE path_to_root ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print path from a node to root of given Complete Binary Tree | Function to print the path from node to root ; Iterate until root is reached ; Print the value of the current node ; Move to parent of the current node ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "5148-5148",
        "Code": "def findSmallestNumberPossible ( N , K ) : NEW_LINE INDENT if ( N > 45 * K ) : NEW_LINE INDENT print ( \" - 1\" , endl = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT res = \" \" ; NEW_LINE count = 0 ; NEW_LINE i = 9 ; NEW_LINE while i >= 1 : NEW_LINE INDENT if ( count == K ) : NEW_LINE INDENT i -= 1 ; NEW_LINE count = 0 ; NEW_LINE DEDENT if ( N > i ) : NEW_LINE INDENT N -= i ; NEW_LINE res += chr ( 48 + i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res += chr ( N + 48 ) ; NEW_LINE N = 0 ; NEW_LINE break ; NEW_LINE DEDENT count += 1 ; NEW_LINE DEDENT res = res [ : : - 1 ] NEW_LINE print ( res , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 ; K = 3 ; NEW_LINE findSmallestNumberPossible ( N , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest number whose sum of digits is N and every digit occurring at most K times | Function to find the smallest number whose sum of digits is N and each digit occurring at most K times ; Maximum sum possible using each digit at most K times ; Append smallest number into the resultant string ; Iterate over the range [ 9 , 1 ] ; If the count of the digit is K , then update count and check for the next digit ; If N is greater than current digit ; Subtract i from N ; Insert i as a digit ; Insert remaining N as a digit ; Increment count ; Reverse the string ; Print the answer ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5150-5150",
        "Code": "def result ( n ) : NEW_LINE INDENT if ( n > 45 ) : NEW_LINE INDENT print ( - 1 , end = \" \" ) NEW_LINE return NEW_LINE DEDENT res = \" \" NEW_LINE digit = 9 NEW_LINE while ( n > digit ) : NEW_LINE INDENT res = str ( digit ) + res NEW_LINE n -= digit NEW_LINE digit -= 1 NEW_LINE DEDENT if ( n > 0 ) : NEW_LINE INDENT res = str ( n ) + res NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 19 NEW_LINE result ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest positive number made up of non | Function to find smallest positive number made up of non - repeating digits whose sum of its digits is equal to n ; No such number exists ; Stores the required answer ; Store the digit at unit 's place ; Iterate until n > digit ; Push digit at the start of res ; Decrement n by digit ; Decrement digit by 1 ; Push the remaining number as the starting digit ; Print the required number ; Driver Code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5152-5152",
        "Code": "import math NEW_LINE def countEvenPairs ( N , M ) : NEW_LINE INDENT count = 0 ; NEW_LINE nEven = int ( math . floor ( N / 2 ) ) ; NEW_LINE nOdd = int ( math . ceil ( N / 2 ) ) ; NEW_LINE mEven = int ( math . floor ( M / 2 ) ) ; NEW_LINE mOdd = int ( math . ceil ( M / 2 ) ) ; NEW_LINE count = nEven * mEven + nOdd * mOdd ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE M = 6 ; NEW_LINE print ( countEvenPairs ( N , M ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pair of integers having even sum | Python3 program for the above approach ; Function to count even pairs ; Stores count of pairs having even sum ; Stores count of even numbers up to N ; Stores count of odd numbers up to N ; Stores count of even numbers up to M ; Stores count of odd numbers up to M ; Return the count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5154-5154",
        "Code": "def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT lenn = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < M ) : NEW_LINE INDENT if ( pat [ i ] == pat [ lenn ] ) : NEW_LINE INDENT lenn += 1 NEW_LINE lps [ i ] = lenn NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( lenn != 0 ) : NEW_LINE INDENT lenn = lps [ lenn - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def KMPSearch ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE lps = [ 0 for i in range ( M ) ] NEW_LINE computeLPSArray ( pat , M , lps ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT if ( pat [ j ] == txt [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT return 1 NEW_LINE j = lps [ j - 1 ] NEW_LINE DEDENT elif ( i < N and pat [ j ] != txt [ i ] ) : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT j = lps [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def maxRepeating ( seq , word ) : NEW_LINE INDENT resCount = 0 NEW_LINE curWord = word NEW_LINE numWords = len ( seq ) // len ( word ) NEW_LINE for i in range ( numWords ) : NEW_LINE INDENT if ( KMPSearch ( curWord , seq ) ) : NEW_LINE INDENT curWord += word NEW_LINE resCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( resCount ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 , S2 = \" ababc \" , \" ab \" NEW_LINE maxRepeating ( S1 , S2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of times a given string needs to be concatenated to form a substring of another string | Function to find lps [ ] for given pattern pat [ 0. . M - 1 ] ; Length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; Iterate string to calculate lps [ i ] ; If the current character of the pattern matches ; Otherwise ; Otherwise ; Function to implement KMP algorithm ; Stores the longest prefix and suffix values for pattern ; Preprocess the pattern and find the lps [ ] array ; Index for txt [ ] ; Index for pat [ ] ; If pattern is found return 1 ; Mismatch after j matches ; Don 't match lps[0, lps[j - 1]]  characters they will  match anyway ; Return 0 if the pattern is not found ; Function to find the maximum value K for which S2 concatenated K times is a subof S1 ; Store the required maximum number ; Create a temporary to store word ; Store the maximum number of times S2 can occur in S1 ; Traverse in range [ 0 , numWords - 1 ] ; If curWord is found in sequence ; Concatenate word to curWord ; Increment resCount by 1 ; Otherwise break the loop ; Print the answer ; Driver Code ; Function Call",
        "Category": "KMP Algorithm is a string matching algorithm that uses an LPS (Longest Prefix Suffix) array to efficiently search for a pattern in a text. Although the LPS array computation and the search process involve arrays, the dominant and most specific algorithm"
    },
    {
        "ID": "5156-5156",
        "Code": "def lastRemovedCharacter ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( str [ n - 2 ] == '0' ) : NEW_LINE INDENT return ( ord ( '1' ) - ord ( str [ n - 1 ] ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT return ord ( str [ n - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"10010\" NEW_LINE print ( chr ( lastRemovedCharacter ( str ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Last remaining character after repeated removal of the first character and flipping of characters of a Binary String | Function to find the last removed character from the string ; Stores length of the string ; Base Case : ; If the second last character is '0 ; If the second last character is '1 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5157-5157",
        "Code": "def findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) : NEW_LINE INDENT a , b , c = 0 , 0 , 0 ; NEW_LINE aSUMb = 0 ; NEW_LINE aSUMc = 0 ; NEW_LINE bSUMc = 0 ; NEW_LINE aSUMb = aXORb + aANDb * 2 ; NEW_LINE aSUMc = aXORc + aANDc * 2 ; NEW_LINE bSUMc = bXORc + bANDc * 2 ; NEW_LINE a = ( aSUMb - bSUMc + aSUMc ) // 2 ; NEW_LINE b = aSUMb - a ; NEW_LINE c = aSUMc - a ; NEW_LINE print ( \" a ▁ = ▁ \" , a , end = \" \" ) ; NEW_LINE print ( \" , ▁ b ▁ = ▁ \" , b , end = \" \" ) ; NEW_LINE print ( \" , ▁ c ▁ = ▁ \" , c , end = \" \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT aXORb = 30 ; aANDb = 0 ; aXORc = 20 ; aANDc = 10 ; bXORc = 10 ; bANDc = 20 ; NEW_LINE findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the triplet from given Bitwise XOR and Bitwise AND values of all its pairs | Function to find the triplet with given Bitwise XOR and Bitwise AND values of all possible pairs of the triplet ; Stores values of a triplet ; Stores a + b ; Stores a + c ; Stores b + c ; Calculate aSUMb ; Calculate aSUMc ; Calculate bSUMc ; Calculate a ; Calculate b ; Calculate c ; Pra ; Prb ; Prc ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "516-516",
        "Code": "def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE self . head = new_node NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Linked List | Set 2 ( Inserting a node ) | This function is in LinkedList class Function to insert a new node at the beginning ; 1 & 2 : Allocate the Node & Put in the data ; 3. Make next of new Node as head ; 4. Move the head to point to new Node",
        "Category": "Linked List"
    },
    {
        "ID": "5161-5161",
        "Code": "def array_divisbleby_k ( N , K ) : NEW_LINE INDENT flag = False NEW_LINE d1 , d2 = 0 , 0 NEW_LINE for i in range ( 2 , int ( K ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( K % i == 0 ) : NEW_LINE INDENT flag = True NEW_LINE d1 = i NEW_LINE d2 = K // i NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT print ( d2 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d1 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE K = 21 NEW_LINE array_divisbleby_k ( N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate an array with product of all subarrays of length exceeding one divisible by K | Function to check if the required array can be generated or not ; To check if divisor exists ; To store divisiors of K ; Check if K is prime or not ; If array can be generated ; Print d1 and d2 alternatively ; No such array can be generated ; Driver Code ; Given N and K ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5168-5168",
        "Code": "def subString ( s , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT find = s [ i : i + len ] NEW_LINE v . append ( find ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def IsPresent ( str , target ) : NEW_LINE INDENT if ( target in str ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def countSubstrings ( S , T ) : NEW_LINE INDENT v = subString ( S , len ( S ) ) NEW_LINE ans = 0 NEW_LINE for it in v : NEW_LINE INDENT if ( IsPresent ( it , T ) != - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" dabc \" NEW_LINE T = \" ab \" NEW_LINE countSubstrings ( S , T ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of substrings of a string containing another given string as a substring | Function to store all substrings of S ; Stores the substrings of S ; Pick start point in outer loop and lengths of different strings for a given starting point ; Return the array containing substrings of S ; Function to check if a is present in another string ; Check if target is in the str or not ; Function to count the subof S containing T in it as substring ; Store all substrings of S in the array v [ ] ; Store required count of substrings ; Iterate through all the substrings of S ; If T is present in the current substring , then increment the ans ; Print the answer ; Driver code ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "5178-5178",
        "Code": "def findMinOperationsReqEmpStr ( str ) : NEW_LINE INDENT cntOne = 0 NEW_LINE cntZero = 0 NEW_LINE for element in str : NEW_LINE INDENT if element == '0' : NEW_LINE INDENT if cntOne > 0 : NEW_LINE INDENT cntOne = cntOne - 1 NEW_LINE DEDENT cntZero = cntZero + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cntZero > 0 : NEW_LINE INDENT cntZero = cntZero - 1 NEW_LINE DEDENT cntOne = cntOne + 1 NEW_LINE DEDENT DEDENT return cntOne + cntZero NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"0100100111\" NEW_LINE print ( findMinOperationsReqEmpStr ( str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum removal of subsequences of distinct consecutive characters required to empty a given string | Function to count minimum operations required to make the string an empty string ; Stores count of 1 s by removing consecutive distinct subsequence ; Stores count of 0 s by removing consecutive distinct subsequence ; Traverse the string ; If current character is 0 ; Update cntOne ; Update cntZero ; If current character is 1 ; Update cntZero ; Update cntOne ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5180-5180",
        "Code": "def minimumCost ( a , b ) : NEW_LINE INDENT fre1 = [ 0 ] * ( 256 ) NEW_LINE fre2 = [ 0 ] * ( 256 ) NEW_LINE for c in a : NEW_LINE INDENT fre1 [ ord ( c ) ] += 1 NEW_LINE DEDENT for c in b : NEW_LINE INDENT fre2 [ ord ( c ) ] += 1 NEW_LINE DEDENT mincost = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT mincost += abs ( fre1 [ i ] - fre2 [ i ] ) NEW_LINE DEDENT print ( mincost ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \"1AB + - \" NEW_LINE B = \" cc \" NEW_LINE minimumCost ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost to convert one given string to another using swap , insert or delete operations | Function to find the minimum cost to convert a to b ; Stores the frequency of string a and b respectively ; Store the frequencies of characters in a ; Store the frequencies of characters in b ; Minimum cost to convert A to B ; Find the minimum cost ; Print the minimum cost ; Driver Code ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "5191-5191",
        "Code": "def minimumCntOfFlipsRequired ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE zeros = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT zeros += 1 ; NEW_LINE DEDENT DEDENT if ( zeros == 0 or zeros == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minFlips = 10000001 ; NEW_LINE currOnes = 0 ; NEW_LINE flips = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT currOnes += 1 ; NEW_LINE DEDENT flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) ; NEW_LINE minFlips = min ( minFlips , flips ) ; NEW_LINE DEDENT return minFlips ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"100101\" ; NEW_LINE print ( minimumCntOfFlipsRequired ( str ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum flips to make all 1 s in right and 0 s in left | Function to find the minimum count of flips required to make all 1 s on the right and all 0 s on the left of the given string ; Stores length of str ; Store count of 0 s in the string ; Traverse the string ; If current character is 0 ; Update zeros ; If count of 0 s in the string is 0 or n ; Store minimum count of flips required to make all 0 s on the left and all 1 s on the right ; Stores count of 1 s on the left of each index ; Stores count of flips required to make all 0 s on the left and all 1 s on the right ; Traverse the string ; If current character is 1 ; Update currOnes ; Update flips ; Update the minimum count of flips ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5200-5200",
        "Code": "def separate ( arr , n , parity ) : NEW_LINE INDENT count = 1 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( ( arr [ i ] + parity ) & 1 ) and ( ( arr [ i - 1 ] + parity ) & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 1 ) : NEW_LINE INDENT res += count - 1 NEW_LINE DEDENT count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def requiredOps ( arr , N ) : NEW_LINE INDENT res1 = separate ( arr , N , 0 ) NEW_LINE res2 = separate ( arr , N , 1 ) NEW_LINE print ( max ( res1 , res2 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 13 , 2 , 6 , 8 , 3 , 5 , 7 , 10 , 14 , 15 ] NEW_LINE N = len ( arr ) NEW_LINE requiredOps ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum subarray reversals required such that sum of all pairs of adjacent elements is odd | Function to count reversals to separate elements with same parity ; Traverse the given array ; Count size of subarray having integers with same parity only ; Otherwise ; Reversals required is equal to one less than subarray size ; Return the total reversals ; Function to print the array elements ; Function to count the minimum reversals required to make make sum of all adjacent elements odd ; Stores operations required for separating adjacent odd elements ; Stores operations required for separating adjacent even elements ; Maximum of two is the return ; Driver Code ; Given array arr [ ] ; Size of array ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5203-5203",
        "Code": "import sys NEW_LINE def substringCount ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE DEDENT INDENT maxfreq = - sys . maxsize - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( maxfreq < freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT maxfreq = freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( maxfreq == freq [ i ] ) : NEW_LINE INDENT max_char = chr ( i + ord ( ' a ' ) ) NEW_LINE break NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if ( max_char == ch ) : NEW_LINE INDENT ans += ( len ( s ) - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abcab \" NEW_LINE print ( substringCount ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of substrings having the most frequent character in the string as first character | Python3 program for the above approach ; Function to find all substrings whose first character occurs maximum number of times ; Stores frequency of characters ; Stores character that appears maximum number of times max_char = ; Stores max frequency of character ; Updates frequency of characters ; Update maxfreq ; Character that occures maximum number of times ; Update the maximum frequency character ; Stores all count of substrings ; Traverse over string ; Get the current character ; Update count of substrings ; Return the count of all valid substrings ; Driver Code ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "5206-5206",
        "Code": "def removeDuplicateLetters ( s ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE vis = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in s : NEW_LINE INDENT cnt [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( not vis [ ord ( s [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT while ( len ( res ) > 0 and res [ - 1 ] > s [ i ] and cnt [ ord ( res [ - 1 ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT vis [ ord ( res [ - 1 ] ) - ord ( ' a ' ) ] = 0 NEW_LINE del res [ - 1 ] NEW_LINE DEDENT res += s [ i ] NEW_LINE vis [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT DEDENT return \" \" . join ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" acbc \" NEW_LINE print ( removeDuplicateLetters ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest string formed by removing duplicates | Function that finds lexicographically smallest after removing the duplicates from the given string ; Stores the frequency of characters ; Mark visited characters ; Stores count of each character ; Stores the resultant string ; Decrease the count of current character ; If character is not already in answer ; Last character > S [ i ] and its count > 0 ; Mark letter unvisited ; Add s [ i ] in res and mark it visited ; Return the resultant string ; Driver Code ; Given S ; Function Call",
        "Category": "Stack"
    },
    {
        "ID": "5209-5209",
        "Code": "def minChange ( s , n ) : NEW_LINE INDENT L = [ 0 ] * 26 ; NEW_LINE R = [ 0 ] * 26 ; NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE INDENT ch = s [ i ] ; NEW_LINE L [ ord ( ch ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n // 2 , n ) : NEW_LINE INDENT ch = s [ i ] ; NEW_LINE R [ ord ( ch ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT count = n ; NEW_LINE for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) ) : NEW_LINE INDENT count = min ( count , n - L [ ch - ord ( ' a ' ) ] - R [ ch - ord ( ' a ' ) ] ) ; NEW_LINE DEDENT change = n / 2 ; NEW_LINE for d in range ( 0 , 25 ) : NEW_LINE INDENT change -= L [ d ] ; NEW_LINE change += R [ d ] ; NEW_LINE count = min ( count , change ) ; NEW_LINE DEDENT change = n / 2 ; NEW_LINE for d in range ( 0 , 25 ) : NEW_LINE INDENT change -= R [ d ] ; NEW_LINE change += L [ d ] ; NEW_LINE count = min ( change , count ) ; NEW_LINE DEDENT return int ( count ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aababc \" ; NEW_LINE N = len ( S ) ; NEW_LINE print ( minChange ( S , N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count minimum character replacements required such that given string satisfies the given conditions | Function that finds the minimum count of steps required to make the string special ; Stores the frequency of the left & right half of string ; Find frequency of left half ; Find frequency of left half ; Make all characters equal to character c ; Case 1 : For s [ i ] < s [ j ] ; Subtract all the characters on left side that are <= d ; Adding all characters on the right side that same as d ; Find minimum value of count ; Similarly for Case 2 : s [ i ] > s [ j ] ; Return the minimum changes ; Driver Code ; Given string S ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "5220-5220",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countInverse ( arr , N , M ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT gcdOfMandelement = gcd ( M , arr [ i ] ) NEW_LINE if ( gcdOfMandelement == 1 ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( XOR ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE M = 4 NEW_LINE N = len ( arr ) NEW_LINE countInverse ( arr , N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "XOR of array elements whose modular inverse with a given number exists | Function to return the gcd of a & b ; Base Case ; Recursively calculate GCD ; Function to print the Bitwise XOR of elements of arr [ ] if gcd ( arr [ i ] , M ) is 1 ; Initialize xor ; Traversing the array ; GCD of M and arr [ i ] ; If GCD is 1 , update xor ; Print xor ; Drive Code ; Given array arr [ ] ; Given number M ; Size of the array ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5221-5221",
        "Code": "def Moves_Calculator ( x , y , row , col ) : NEW_LINE INDENT total_moves = 0 NEW_LINE if ( row - x ) > 0 and ( col - y ) > 0 : NEW_LINE INDENT total_moves += min ( ( row - x ) , ( col - y ) ) NEW_LINE DEDENT if ( y - 1 ) > 0 and ( x - 1 ) > 0 : NEW_LINE INDENT total_moves += min ( ( y - 1 ) , ( x - 1 ) ) NEW_LINE DEDENT if ( x - 1 ) > 0 and ( col - y ) > 0 : NEW_LINE INDENT total_moves += min ( ( x - 1 ) , ( col - y ) ) NEW_LINE DEDENT if ( row - x ) > 0 and ( y - 1 ) > 0 : NEW_LINE INDENT total_moves += min ( ( row - x ) , ( y - 1 ) ) NEW_LINE DEDENT total_moves += ( row - 1 ) + ( col - 1 ) NEW_LINE king_moves = 0 NEW_LINE if x + 1 <= m : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x + 1 <= m and y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x + 1 <= m and y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 and y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 and y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT return total_moves - king_moves NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , m = 8 , 8 NEW_LINE x , y = 1 , 1 NEW_LINE print ( Moves_Calculator ( x , y , m , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count positions in a chessboard that can be visited by the Queen which are not visited by the King | Function to print the number of cells only visited by the queen ; Find all the moves ; Find all moves for x + 1 , y + 1 ; Find all moves for x - 1 , y - 1 ; Find all moves for x - 1 , y + 1 ; Find all moves for x + 1 , y - 1 ; Find all squares visited by King x + 1 , in same row ; x - 1 , in same row ; y + 1 , in same column ; y - 1 , in same column ; Return answer ; Driver Code ; Dimension of Board ; Position of Cell ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5238-5238",
        "Code": "def minProd ( X , Y , N ) : NEW_LINE INDENT if ( X <= Y ) : NEW_LINE INDENT if ( N < X ) : NEW_LINE INDENT return ( X - N ) * Y NEW_LINE DEDENT else : NEW_LINE INDENT return max ( Y - ( N - X + 1 ) , 1 ) NEW_LINE DEDENT DEDENT if ( Y >= N ) : NEW_LINE INDENT return ( Y - N ) * X NEW_LINE DEDENT return max ( X - ( N - Y + 1 ) , 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 47 NEW_LINE Y = 42 NEW_LINE N = 167 NEW_LINE print ( minProd ( X , Y , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize positive product of two given numbers by at most N decrements | Function to minimize the product of two numbers ; Reducing X , N times , minimizes the product ; Reduce X to 1 and reduce remaining N from Y ; Reducing Y , N times , minimizes the product ; Reduce Y to 1 and reduce remaining N from X ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5241-5241",
        "Code": "import math NEW_LINE MAXN = 1000000 NEW_LINE is_prime = [ 0 ] * MAXN NEW_LINE count_of_primes = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 3 , MAXN , 2 ) : NEW_LINE INDENT is_prime [ i ] = 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( MAXN ) ) , 2 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT is_prime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT is_prime [ 2 ] = 1 NEW_LINE for i in range ( 1 , MAXN ) : NEW_LINE INDENT count_of_primes [ i ] = ( count_of_primes [ i - 1 ] + is_prime [ i ] ) NEW_LINE DEDENT DEDENT def power ( x , y , p ) : NEW_LINE INDENT result = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if y & 1 == 1 : NEW_LINE INDENT result = ( result * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE y >>= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def numberOfWays ( N ) : NEW_LINE INDENT count = count_of_primes [ N ] - 1 NEW_LINE mod = 1000000007 NEW_LINE answer = power ( 2 , count , mod ) NEW_LINE if N == 1 : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE N = 7 NEW_LINE numberOfWays ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count ways to split N ! into two distinct co | Python3 program for the above approach ; Maximum value of N ; Stores at each indices if given number is prime or not ; Stores count_of_primes ; Function to generate primes using Sieve of Eratsothenes ; Assume all odds are primes ; If a prime is encountered ; Mark all its multiples as non - prime ; Count primes <= MAXN ; Function to calculate ( x ^ y ) % p in O ( log y ) ; Utility function to count the number of ways N ! can be split into co - prime factors ; Driver Code ; Calling sieve function ; Given N ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5247-5247",
        "Code": "X = 1000000 NEW_LINE def getPrimeNum ( ) : NEW_LINE INDENT isPrime = [ True ] * ( X ) NEW_LINE isPrime [ 0 ] = False NEW_LINE isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= X : NEW_LINE INDENT if ( isPrime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * i , X , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return isPrime NEW_LINE DEDENT def cntPairs ( arr , N ) : NEW_LINE INDENT isPrime = getPrimeNum ( ) NEW_LINE cntOne = 0 NEW_LINE cntPrime = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT elif ( isPrime [ i ] ) : NEW_LINE INDENT cntPrime += 1 NEW_LINE DEDENT DEDENT cntNonComp = 0 NEW_LINE cntNonComp = ( cntPrime * cntOne + cntOne * ( cntOne - 1 ) // 2 ) NEW_LINE res = 0 NEW_LINE res = ( N * ( N - 1 ) // 2 - cntNonComp ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 2 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE print ( cntPairs ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs in an array whose product is composite number | Python3 program to implement the above approach ; Function to get all the prime numbers in the range [ 1 , X ] ; Stores the boolean value to check if a number is prime or not ; Mark all non prime numbers as false ; If i is prime number ; Mark j as a composite number ; Function to get the count of pairs whose product is a composite number ; Stores the boolean value to check if a number is prime or not ; Stores the count of 1 s ; Stores the count of prime numbers ; Traverse the given array . ; Stores count of pairs whose product is not a composite number ; Stores the count of pairs whose product is composite number ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5252-5252",
        "Code": "def longestPalinSub ( st ) : NEW_LINE INDENT N = len ( st ) NEW_LINE hash1 = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash1 [ ord ( st [ i ] ) ] += 1 NEW_LINE DEDENT res1 = \" \" NEW_LINE res2 = \" \" NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT for j in range ( hash1 [ i ] // 2 ) : NEW_LINE INDENT res1 += chr ( i ) NEW_LINE DEDENT for j in range ( ( hash1 [ i ] + 1 ) // 2 , hash1 [ i ] ) : NEW_LINE INDENT res2 += chr ( i ) NEW_LINE DEDENT DEDENT p = list ( res2 ) NEW_LINE p . reverse ( ) NEW_LINE res2 = ' ' . join ( p ) NEW_LINE res3 = \" \" NEW_LINE f = False NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( hash1 [ i ] % 2 ) : NEW_LINE INDENT if ( not f ) : NEW_LINE INDENT res1 += chr ( i ) NEW_LINE f = True NEW_LINE DEDENT else : NEW_LINE INDENT res3 += chr ( i ) NEW_LINE DEDENT DEDENT DEDENT return ( res1 + res2 + res3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" geeksforgeeks \" NEW_LINE print ( longestPalinSub ( st ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange string to obtain Longest Palindromic Substring | Function to rearrange the string to get the longest palindromic substring ; Stores the length of str ; Store the count of occurrence of each character ; Traverse the string , str ; Count occurrence of each character ; Store the left half of the longest palindromic substring ; Store the right half of the longest palindromic substring ; Traverse the array , hash [ ] ; Append half of the characters to res1 ; Append half of the characters to res2 ; reverse string res2 to make res1 + res2 palindrome ; Store the remaining characters ; Check If any odd character appended to the middle of the resultant string or not ; Append all the character which occurs odd number of times ; If count of occurrence of characters is odd ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5256-5256",
        "Code": "import math NEW_LINE def power ( X , n ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n & 1 != 0 ) : NEW_LINE INDENT res = res * X NEW_LINE DEDENT X = X * X NEW_LINE n = n >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def closestgtNum ( N ) : NEW_LINE INDENT n = int ( math . log10 ( N ) + 1 ) NEW_LINE P = power ( 10 , n - 1 ) NEW_LINE Y = N % P NEW_LINE res = N + ( P - Y ) NEW_LINE return res NEW_LINE DEDENT N = 120 NEW_LINE print ( closestgtNum ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the greater number closest to N having at most one non | Python3 program to implement the above approach ; Function to calculate X ^ n in log ( n ) ; Stores the value of X ^ n ; If N is odd ; Function to find the closest number > N having at most 1 non - zero digit ; Stores the count of digits in N ; Stores the power of 10 ^ ( n - 1 ) ; Stores the last ( n - 1 ) digits ; Store the answer ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5261-5261",
        "Code": "def makeArraySumEqual ( a , N ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( ( i + 1 ) % 2 == 0 ) : NEW_LINE INDENT even_sum += a [ i ] NEW_LINE DEDENT elif ( ( i + 1 ) % 2 > 0 ) : NEW_LINE INDENT odd_sum += a [ i ] NEW_LINE DEDENT DEDENT if ( odd_sum == even_sum ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( count_0 >= N / 2 ) : NEW_LINE INDENT for i in range ( count_0 ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT is_Odd = count_1 % 2 NEW_LINE count_1 -= is_Odd NEW_LINE for i in range ( count_1 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE makeArraySumEqual ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Modify given array to make sum of odd and even indexed elements same | Function to modify array to make sum of odd and even indexed elements equal ; Stores the count of 0 s , 1 s ; Stores sum of odd and even indexed elements respectively ; Count 0 s ; Count 1 s ; Calculate odd_sum and even_sum ; If both are equal ; Print the original array ; Otherwise ; Print all the 0 s ; For checking even or odd ; Update total count of 1 s ; Print all 1 s ; Given array arr [ ] ; Function call",
        "Category": "Array"
    },
    {
        "ID": "5267-5267",
        "Code": "N , M = 6 , 6 NEW_LINE def swap ( mat , startx_X , starty_X , startx_Y , starty_Y ) : NEW_LINE INDENT row , col = 0 , 0 NEW_LINE i = startx_X NEW_LINE while ( bool ( True ) ) : NEW_LINE INDENT col = 0 NEW_LINE j = startx_X NEW_LINE while ( bool ( True ) ) : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ startx_Y + row ] [ starty_Y + col ] NEW_LINE mat [ startx_Y + row ] [ starty_Y + col ] = temp NEW_LINE col += 1 NEW_LINE if col >= M // 2 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT row += 1 NEW_LINE if row >= N // 2 : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def swapQuadOfMatrix ( mat , X , Y ) : NEW_LINE INDENT if ( X == 1 and Y == 2 ) : NEW_LINE INDENT swap ( mat , 0 , 0 , 0 , M // 2 ) NEW_LINE DEDENT elif ( X == 1 and Y == 3 ) : NEW_LINE INDENT swap ( mat , 0 , 0 , N // 2 , 0 ) NEW_LINE DEDENT elif ( X == 1 and Y == 4 ) : NEW_LINE INDENT swap ( mat , 0 , 0 , N // 2 , M // 2 ) NEW_LINE DEDENT elif ( X == 2 and Y == 3 ) : NEW_LINE INDENT swap ( mat , 0 , M // 2 , N // 2 , 0 ) NEW_LINE DEDENT elif ( X == 2 and Y == 4 ) : NEW_LINE INDENT swap ( mat , 0 , M // 2 , N // 2 , M // 2 ) NEW_LINE DEDENT elif ( X == 3 and Y == 4 ) : NEW_LINE INDENT swap ( mat , N // 2 , 0 , N // 2 , M // 2 ) NEW_LINE DEDENT printMat ( mat ) NEW_LINE DEDENT def printMat ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 , 17 , 18 ] , [ 19 , 20 , 21 , 22 , 23 , 24 ] , [ 25 , 26 , 27 , 28 , 29 , 30 ] , [ 31 , 32 , 33 , 34 , 35 , 36 ] ] NEW_LINE X , Y = 1 , 4 NEW_LINE swapQuadOfMatrix ( mat , X , Y ) NEW_LINE",
        "Type": "py",
        "NL": "Swap the elements between any two given quadrants of a Matrix | Python3 program for the above approach ; Function to iterate over the X quadrant and swap its element with Y quadrant ; Iterate over X quadrant ; Swap operations ; Function to swap the elements of the two given quadrants ; For Swapping 1 st and 2 nd Quadrant ; For Swapping 1 st and 3 rd Quadrant ; For Swapping 1 st and 4 th Quadrant ; For Swapping 2 nd and 3 rd Quadrant ; For Swapping 2 nd and 4 th Quadrant ; For Swapping 3 rd and 4 th Quadrant ; Print the resultant matrix ; Function to print the matrix ; Iterate over the rows ; Iterate over the cols ; Given matrix ; Given quadrants ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "5269-5269",
        "Code": "import math NEW_LINE def check_digits ( N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT n = N % 10 NEW_LINE if ( ( n != 0 ) and ( n != 1 ) and ( n != 4 ) and ( n != 9 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT N = N // 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def is_perfect ( N ) : NEW_LINE INDENT n = math . sqrt ( N ) NEW_LINE if ( math . floor ( n ) != math . ceil ( n ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def isFullSquare ( N ) : NEW_LINE INDENT if ( is_perfect ( N ) and check_digits ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT N = 144 NEW_LINE isFullSquare ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a number is a perfect square having all its digits as a perfect square | Python3 program for the above approach ; Function to check if digits of N is a perfect square or not ; Iterate over the digits ; Extract the digit ; Check if digit is a perfect square or not ; Divide N by 10 ; Return true ; Function to check if N is a perfect square or not ; If floor and ceil of n is not same ; Function to check if N satisfies the required conditions or not ; If both the conditions are satisfied ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5273-5273",
        "Code": "def power ( x , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , n // 2 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT DEDENT def count_Total_Numbers ( n , x ) : NEW_LINE INDENT total , multiples = 0 , 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( i % x == 0 ) : NEW_LINE INDENT multiples += 1 NEW_LINE DEDENT DEDENT if ( n == 1 ) : NEW_LINE INDENT return multiples NEW_LINE DEDENT total = ( ( multiples - 1 ) * power ( multiples , n - 1 ) ) NEW_LINE return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 1 NEW_LINE X = 3 NEW_LINE print ( count_Total_Numbers ( N , X ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count all N digit numbers whose digits are multiple of X | Function to calculate x ^ n using binary - exponentiation ; Stores the resultant power ; Stores the value of x ^ ( n / 2 ) ; Function to count aN - digit numbers whose digits are multiples of x ; Count adigits which are multiples of x ; Check if current number is a multiple of X ; Increase count of multiples ; Check if it 's a 1 digit number ; Count the total numbers ; Return the total numbers ; Driver Code ; Given N and X ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5275-5275",
        "Code": "def number_of_strings ( N , M ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT if ( N >= 2 ) : NEW_LINE INDENT N -= 2 NEW_LINE M -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if M >= 2 : NEW_LINE INDENT M -= 2 NEW_LINE N -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 19 NEW_LINE number_of_strings ( N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize count of strings of length 3 that can be formed from N 1 s and M 0 s | Function that counts the number of strings of length three that can be made with given m 0 s and n 1 s ; Iterate until N & M are positive ; Case 1 : ; Case 2 : ; Print the count of strings ; Driver code ; Given count of 1 s and 0 s ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5276-5276",
        "Code": "def number_of_strings ( N , M ) : NEW_LINE INDENT print ( min ( N , min ( M , ( N + M ) // 3 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 19 NEW_LINE number_of_strings ( N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize count of strings of length 3 that can be formed from N 1 s and M 0 s | Function that counts the number of strings of length 3 that can be made with given m 0 s and n 1 s ; Print the count of strings ; Driver Code ; Given count of 1 s and 0 s ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5278-5278",
        "Code": "maxm = 10001 ; NEW_LINE prime = [ True ] * ( maxm + 1 ) ; NEW_LINE prime_number = [ 0 ] * ( maxm + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , ( int ( maxm ** 1 / 2 ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , maxm , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE DEDENT def num_prime ( ) : NEW_LINE INDENT prime_number [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , maxm + 1 ) : NEW_LINE INDENT tmp = - 1 ; NEW_LINE if ( prime [ i ] == True ) : NEW_LINE INDENT tmp = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tmp = 0 ; NEW_LINE DEDENT prime_number [ i ] = prime_number [ i - 1 ] + tmp ; NEW_LINE DEDENT DEDENT def min_steps ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE num_prime ( ) ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT print ( \"0\" ) ; NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT print ( \"1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( prime_number [ n ] - 1 + ( n - 2 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 3 , 2 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE min_steps ( arr , N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum replacement of pairs by their LCM required to reduce given array to its LCM | Python3 program for the above approach ; Boolean array to set or unset prime non - prime indices ; Stores the prefix sum of the count of prime numbers ; Function to check if a number is prime or not from 0 to N ; If p is a prime ; Set its multiples as non - prime ; Function to store the count of prime numbers ; Function to count the operations to reduce the array to one element by replacing each pair with its LCM ; Generating Prime Number ; Corner Case ; Driver code ; Given array arr ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5281-5281",
        "Code": "def isReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while ( x2 > x1 and y2 > y1 ) : NEW_LINE INDENT if ( x2 > y2 ) : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if ( x2 == x1 ) : NEW_LINE INDENT return ( y2 - y1 ) >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif ( y2 == y1 ) : NEW_LINE INDENT return ( x2 - x1 ) >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT source_x = 2 NEW_LINE source_y = 10 NEW_LINE dest_x = 26 NEW_LINE dest_y = 12 NEW_LINE if ( isReachable ( source_x , source_y , dest_x , dest_y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a destination is reachable from source with two movements allowed | Set 2 | Check if ( x2 , y2 ) can be reached from ( x1 , y1 ) ; Reduce x2 by y2 until it is less than or equal to x1 ; Reduce y2 by x2 until it is less than or equal to y1 ; If x2 is reduced to x1 ; Check if y2 can be reduced to y1 or not ; If y2 is reduced to y1 ; Check if x2 can be reduced to x1 or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5287-5287",
        "Code": "from math import gcd NEW_LINE def minSubarrays ( arr , n ) : NEW_LINE INDENT right = n - 1 NEW_LINE left = 0 NEW_LINE subarrays = 0 NEW_LINE while ( right >= 0 ) : NEW_LINE INDENT for left in range ( right + 1 ) : NEW_LINE INDENT if ( gcd ( arr [ left ] , arr [ right ] ) > 1 ) : NEW_LINE INDENT subarrays += 1 NEW_LINE right = left - 1 NEW_LINE break NEW_LINE DEDENT if ( left == right and __gcd ( arr [ left ] , arr [ right ] ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return subarrays NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE arr = [ 2 , 3 , 4 , 4 , 4 , 3 ] NEW_LINE print ( minSubarrays ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split array into minimum number of subarrays having GCD of its first and last element exceeding 1 | Python3 program for the above approach ; Function to find the minimum number of subarrays ; Right pointer ; Left pointer ; Count of subarrays ; Find GCD ( left , right ) ; Found a valid large subarray between arr [ left , right ] ; Searched the arr [ 0. . right ] and found no subarray having size > 1 and having gcd ( left , right ) > 1 ; Driver Code ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5295-5295",
        "Code": "def updateQuery ( from_x , from_y , to_x , to_y , k , aux ) : NEW_LINE INDENT aux [ from_x ] [ from_y ] += k NEW_LINE if ( to_x + 1 < 3 ) : NEW_LINE INDENT aux [ to_x + 1 ] [ from_y ] -= k NEW_LINE DEDENT if ( to_x + 1 < 3 and to_y + 1 < 4 ) : NEW_LINE INDENT aux [ to_x + 1 ] [ to_y + 1 ] += k NEW_LINE DEDENT if ( to_y + 1 < 4 ) : NEW_LINE INDENT aux [ from_x ] [ to_y + 1 ] -= k NEW_LINE DEDENT return aux NEW_LINE DEDENT def updatematrix ( mat , aux ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT aux [ i ] [ j ] += aux [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 1 , 3 ) : NEW_LINE INDENT aux [ j ] [ i ] += aux [ j - 1 ] [ i ] NEW_LINE DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT mat [ i ] [ j ] += aux [ i ] [ j ] NEW_LINE DEDENT DEDENT return mat NEW_LINE DEDENT def printmatrix ( mat ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def matrixQuery ( mat , Q , q ) : NEW_LINE INDENT aux = [ [ 0 for i in range ( 4 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT updateQuery ( q [ i ] [ 0 ] , q [ i ] [ 1 ] , q [ i ] [ 2 ] , q [ i ] [ 3 ] , q [ i ] [ 4 ] , aux ) NEW_LINE DEDENT updatematrix ( mat , aux ) NEW_LINE printmatrix ( mat ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 0 , 1 , 2 ] , [ 0 , 2 , 4 , 1 ] , [ 1 , 2 , 1 , 0 ] ] NEW_LINE Q = 1 NEW_LINE q = [ [ 0 , 0 , 1 , 1 , 2 ] ] NEW_LINE matrixQuery ( mat , Q , q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Final Matrix after incrementing submatrices by K in range given by Q queries | Function to update the given query ; Update top cell ; Update bottom left cell ; Update bottom right cell ; Update top right cell ; Function that updates the matrix mat [ ] [ ] by adding elements of aux [ ] [ ] ; Compute the prefix sum of all columns ; Compute the prefix sum of all rows ; Get the final matrix by adding mat and aux matrix at each cell ; Function that prints matrix mat [ ] ; Traverse each row ; Traverse each columns ; Function that performs each query in the given matrix and print the updated matrix after each operation performed ; Initialize all elements to 0 ; Update auxiliary matrix by traversing each query ; Update Query ; Compute the final answer ; Print the updated matrix ; Driver Code ; Given 4 atrix ; Given Queries ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "5301-5301",
        "Code": "def countNestedPolygons ( sides ) : NEW_LINE INDENT count = 0 NEW_LINE while ( sides > 5 ) : NEW_LINE INDENT sides //= 2 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 12 NEW_LINE print ( countNestedPolygons ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of nested polygons that can be drawn by joining vertices internally | Function that counts the nested polygons inside another polygons ; Stores the count ; Child polygons can only exists if parent polygon has sides > 5 ; Get next nested polygon ; Return the count ; Given side of polygon ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5302-5302",
        "Code": "def smallestCommon ( a , b , c , d ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > c ) : NEW_LINE INDENT swap ( a , c ) ; NEW_LINE swap ( b , d ) ; NEW_LINE DEDENT first_term_diff = ( c - a ) ; NEW_LINE possible_y = 0 ; NEW_LINE for possible_y in range ( b ) : NEW_LINE INDENT if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( possible_y != b ) : NEW_LINE INDENT return c + possible_y * d ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def swap ( x , y ) : NEW_LINE INDENT temp = x ; NEW_LINE x = y ; NEW_LINE y = temp ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 ; B = 20 ; C = 19 ; D = 9 ; NEW_LINE print ( smallestCommon ( A , B , C , D ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Least common element in given two Arithmetic sequences | Function to find the smallest element common in both the subsequences ; If a is equal to c ; If a exceeds c ; Check for the satisfying equation ; Least value of possible_y satisfying the given equation will yield True in the below if and break the loop ; If the value of possible_y satisfying the given equation lies in range [ 0 , b ] ; If no value of possible_y satisfies the given equation ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5314-5314",
        "Code": "def mindigits ( n ) : NEW_LINE INDENT if ( n % 9 == 0 ) : NEW_LINE INDENT print ( n // 9 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n // 9 ) + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 24 ; NEW_LINE n2 = 18 ; NEW_LINE mindigits ( n1 ) ; NEW_LINE mindigits ( n2 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum count of digits required to obtain given Sum | Function to print the minimum count of digits ; IF N is divisible by 9 ; Count of 9 's is the answer ; If remainder is non - zero ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5318-5318",
        "Code": "import math NEW_LINE def printSubset ( N , K ) : NEW_LINE INDENT answer = \" \" NEW_LINE while ( N > 0 ) : NEW_LINE INDENT p = int ( math . log ( N , 2 ) ) NEW_LINE answer = str ( K ** p ) + \" ▁ \" + answer NEW_LINE N = N % ( 2 ** p ) NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT N = 5 NEW_LINE K = 4 NEW_LINE printSubset ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Nth Subset of the Sequence consisting of powers of K in increasing order of their Sum | Python3 program for the above approach ; Function to print the required N - th subset ; Nearest power of 2 <= N ; Now insert k ^ p in the answer ; Update N ; Print the subset ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5319-5319",
        "Code": "import math NEW_LINE def printsubset ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE x = 0 NEW_LINE vec = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = n & 1 NEW_LINE if ( x ) : NEW_LINE INDENT vec . append ( pow ( k , count ) ) NEW_LINE DEDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT for item in vec : NEW_LINE INDENT print ( item , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE k = 4 NEW_LINE printsubset ( n , k ) NEW_LINE",
        "Type": "py",
        "NL": "Nth Subset of the Sequence consisting of powers of K in increasing order of their Sum | Python3 program to print subset at the nth position ordered by the sum of the elements ; Function to print the elements of the subset at pos n ; Initialize count = 0 and x = 0 ; Create a vector for storing the elements of subsets ; Doing until all the set bits of n are used ; This part is executed only when the last bit is set ; Right shift the bit by one position ; Increasing the count each time by one ; Printing the values os elements ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5326-5326",
        "Code": "def countOperations ( n , k ) : NEW_LINE INDENT div = 2 * k + 1 NEW_LINE if ( n // 2 <= k ) : NEW_LINE INDENT print ( 1 ) NEW_LINE if ( n > k ) : NEW_LINE INDENT print ( k + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n % div == 0 ) : NEW_LINE INDENT oprn = n // div NEW_LINE print ( oprn ) NEW_LINE pos = k + 1 NEW_LINE print ( pos , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , oprn + 1 ) : NEW_LINE INDENT print ( pos , end = \" ▁ \" ) NEW_LINE pos += div NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT oprn = n // div + 1 NEW_LINE print ( oprn ) NEW_LINE pos = n % div NEW_LINE if ( n % div > k ) : NEW_LINE INDENT pos -= k NEW_LINE DEDENT for i in range ( 1 , oprn + 1 ) : NEW_LINE INDENT print ( pos , end = \" ▁ \" ) NEW_LINE pos += div NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" edfreqwsazxet \" NEW_LINE ch = ' $ ' NEW_LINE n = len ( str ) NEW_LINE k = 4 NEW_LINE countOperations ( n , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum operations required to convert all characters of a String to a given Character | Function to find the minimum number of operations required ; Maximum number of characters that can be changed in one operation ; If length of the less than maximum number of characters that can be changed in an operation ; Set the last index as the index for the operation ; Otherwise ; If size of the is equal to the maximum number of characters in an operation ; Find the number of operations required ; Find the starting position ; Print i - th index ; Shift to next index ; Otherwise ; Find the number of operations required ; If n % div exceeds k ; Print i - th index ; Shift to next index ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5331-5331",
        "Code": "import math NEW_LINE def maxORminusXOR ( N ) : NEW_LINE INDENT MSB = int ( math . log2 ( N ) ) ; NEW_LINE M = 0 NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT M += ( 1 << i ) NEW_LINE DEDENT return M NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( maxORminusXOR ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest number M having bit count of N such that difference between their OR and XOR value is maximized | Python3 program for the above approach ; Function to find the largest number M having the same length in binary form as N such that the difference between N | M and N ^ M is maximum ; Find the most significant bit of N ; Initialize M ; Set all the bits of M ; Return the answer ; Driver code ; Given Number N ; Function call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5341-5341",
        "Code": "from collections import deque NEW_LINE def largestString ( n , k , sc ) : NEW_LINE INDENT s = [ i for i in sc ] NEW_LINE deq = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( deq ) > 0 and deq [ - 1 ] < s [ i ] and k > 0 ) : NEW_LINE INDENT deq . popleft ( ) NEW_LINE k -= 1 NEW_LINE DEDENT deq . append ( s [ i ] ) NEW_LINE DEDENT st = \" \" NEW_LINE for c in deq : NEW_LINE INDENT st = st + c NEW_LINE DEDENT return st NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE k = 2 NEW_LINE sc = \" ritz \" NEW_LINE result = largestString ( n , k , sc ) NEW_LINE print ( result ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest string obtained in Dictionary order after deleting K characters | Python3 program for the above approach ; Function to find the largest string after deleting k characters ; Deque dq used to find the largest string in dictionary after deleting k characters ; Iterate till the length of the string ; Condition for popping characters from deque ; To store the resultant string ; To form resultant string ; Return the resultant string ; Driver Code ; Given String ; Function call ; Print the answer",
        "Category": "Sliding Window"
    },
    {
        "ID": "5344-5344",
        "Code": "def countSetBit ( n ) : NEW_LINE INDENT i = 0 ; NEW_LINE ans = 0 ; NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = True ; NEW_LINE change = 1 << i ; NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT ans += 0 if k == True else 1 ; NEW_LINE if ( change == 1 ) : NEW_LINE INDENT k = False if k == True else True ; NEW_LINE change = 1 << i ; NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def countSetBits ( L , R ) : NEW_LINE INDENT return abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 3 ; NEW_LINE R = 5 ; NEW_LINE print ( \" Total ▁ set ▁ bit ▁ count ▁ is ▁ \" , countSetBits ( L , R ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count total set bits in all numbers from range L to R | Function that counts the set bits from 0 to N ; To store sum of set bits from 0 - N ; Until n >= to 2 ^ i ; This k will get flipped after 2 ^ i iterations ; Change is iterator from 2 ^ i to 1 ; This will loop from 0 to n for every bit position ; When change = 1 flip the bit ; Again set change to 2 ^ i ; Increment the position ; Function that counts the set bit in the range ( L , R ) ; Return the count ; Driver Code ; Given L and R ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5348-5348",
        "Code": "def countElement ( A , N , B , M , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT currentElement = B [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT diff = abs ( currentElement - A [ j ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 100 , 65 , 35 , 85 , 55 ] NEW_LINE B = [ 30 , 60 , 75 , 95 ] NEW_LINE N = len ( A ) NEW_LINE M = len ( B ) NEW_LINE K = 5 NEW_LINE countElement ( A , N , B , M , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Make max elements in B [ ] equal to that of A [ ] by adding / subtracting integers in range [ 0 , K ] | Function that count the number of integers from array B such that subtracting element in the range [ 0 , K ] given any element in A ; To store the count of element ; Traverse the array B ; Traverse the array A ; Find the difference ; If difference is atmost K then increment the cnt ; Print the count ; Driver Code ; Given array A and B ; Given K ; Function call",
        "Category": "Array"
    },
    {
        "ID": "5350-5350",
        "Code": "def gcd ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) < len ( str2 ) ) : NEW_LINE INDENT return gcd ( str2 , str1 ) NEW_LINE DEDENT elif ( not str1 . startswith ( str2 ) ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT elif ( len ( str2 ) == 0 ) : NEW_LINE INDENT return str1 NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( str1 [ len ( str2 ) : ] , str2 ) NEW_LINE DEDENT DEDENT def findGCD ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ \" GFGGFG \" , \" GFGGFG \" , \" GFGGFGGFGGFG \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGCD ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find Greatest Common Divisor ( GCD ) of N strings | Function that finds gcd of 2 strings ; If str1 length is less than that of str2 then recur with gcd ( str2 , str1 ) ; If str1 is not the concatenation of str2 ; GCD string is found ; Cut off the common prefix part of str1 & then recur ; Function to find GCD of array of strings ; Return the GCD of strings ; Given array of strings ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "5356-5356",
        "Code": "def unixTimeToHumanReadable ( seconds ) : NEW_LINE INDENT ans = \" \" NEW_LINE daysOfMonth = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ( currYear , daysTillNow , extraTime , extraDays , index , date , month , hours , minutes , secondss , flag ) = ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) NEW_LINE daysTillNow = seconds // ( 24 * 60 * 60 ) NEW_LINE extraTime = seconds % ( 24 * 60 * 60 ) NEW_LINE currYear = 1970 NEW_LINE while ( daysTillNow >= 365 ) : NEW_LINE INDENT if ( currYear % 400 == 0 or ( currYear % 4 == 0 and currYear % 100 != 0 ) ) : NEW_LINE INDENT daysTillNow -= 366 NEW_LINE DEDENT else : NEW_LINE INDENT daysTillNow -= 365 NEW_LINE DEDENT currYear += 1 NEW_LINE DEDENT extraDays = daysTillNow + 1 NEW_LINE if ( currYear % 400 == 0 or ( currYear % 4 == 0 and currYear % 100 != 0 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT month = 0 NEW_LINE index = 0 NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( index == 1 ) : NEW_LINE INDENT if ( extraDays - 29 < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT month += 1 NEW_LINE extraDays -= 29 NEW_LINE DEDENT else : NEW_LINE INDENT if ( extraDays - daysOfMonth [ index ] < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT month += 1 NEW_LINE extraDays -= daysOfMonth [ index ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( extraDays - daysOfMonth [ index ] < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT month += 1 NEW_LINE extraDays -= daysOfMonth [ index ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT if ( extraDays > 0 ) : NEW_LINE INDENT month += 1 NEW_LINE date = extraDays NEW_LINE DEDENT else : NEW_LINE INDENT if ( month == 2 and flag == 1 ) : NEW_LINE INDENT date = 29 NEW_LINE DEDENT else : NEW_LINE INDENT date = daysOfMonth [ month - 1 ] NEW_LINE DEDENT DEDENT hours = extraTime // 3600 NEW_LINE minutes = ( extraTime % 3600 ) // 60 NEW_LINE secondss = ( extraTime % 3600 ) % 60 NEW_LINE ans += str ( date ) NEW_LINE ans += \" / \" NEW_LINE ans += str ( month ) NEW_LINE ans += \" / \" NEW_LINE ans += str ( currYear ) NEW_LINE ans += \" ▁ \" NEW_LINE ans += str ( hours ) NEW_LINE ans += \" : \" NEW_LINE ans += str ( minutes ) NEW_LINE ans += \" : \" NEW_LINE ans += str ( secondss ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = 1595497956 NEW_LINE ans = unixTimeToHumanReadable ( T ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert Unix timestamp to DD / MM / YYYY HH : MM : SS format | Function to convert unix time to Human readable format ; Save the time in Human readable format ; Number of days in month in normal year ; Calculate total days unix time T ; Calculating current year ; Updating extradays because it will give days till previous day and we have include current day ; Calculating MONTH and DATE ; Current Month ; Calculating HH : MM : YYYY ; Return the time ; Driver code ; Given unix time ; Function call to convert unix time to human read able ; Print time in format DD : MM : YYYY : HH : MM : SS",
        "Category": "Math"
    },
    {
        "ID": "5357-5357",
        "Code": "def AreaofRectangle ( L , W ) : NEW_LINE INDENT area = ( W + L ) * ( W + L ) / 2 NEW_LINE return area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 18 NEW_LINE W = 12 NEW_LINE print ( AreaofRectangle ( L , W ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum area of a Rectangle that can be circumscribed about a given Rectangle of size LxW | Function to find area of rectangle inscribed another rectangle of length L and width W ; Area of rectangle ; Return the area ; Driver Code ; Given Dimensions ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5359-5359",
        "Code": "def downToZero ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE print ( downToZero ( n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of operations required to reduce N to 0 | Function to find the minimum steps required to reduce n ; Base case ; Return answer based on parity of n ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5367-5367",
        "Code": "def FindMatrix ( n , m , x , y ) : NEW_LINE INDENT if ( n * m == 1 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT print ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT return NEW_LINE DEDENT a = min ( x , y ) NEW_LINE b = min ( 2 * x , y ) - a NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b , end = \" ▁ \" ) NEW_LINE DEDENT flag = not flag NEW_LINE DEDENT if ( ( ( n % 2 != 0 and m % 2 == 0 ) or ( n % 2 == 0 and m % 2 == 0 ) ) ) : NEW_LINE INDENT flag = not flag NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 3 NEW_LINE M = 3 NEW_LINE X = 5 NEW_LINE Y = 3 NEW_LINE FindMatrix ( N , M , X , Y ) NEW_LINE",
        "Type": "py",
        "NL": "Construct a Matrix with no element exceeding X and sum of two adjacent elements not exceeding Y | Function to print the required matrix ; For 1 * 1 matrix ; Greater number ; Smaller number ; Sets / Resets for alternate filling of the matrix ; Print the matrix ; If end of row is reached ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "537-537",
        "Code": "def count ( self , temp , key ) : NEW_LINE INDENT if temp is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if temp . data == key : NEW_LINE INDENT return 1 + count ( temp . next , key ) NEW_LINE DEDENT return count ( temp . next , key ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Write a function that counts the number of times a given int occurs in a Linked List | Counts the no . of occurrences of a node ( search_for ) in a linked list ( head )",
        "Category": "Linked List"
    },
    {
        "ID": "5371-5371",
        "Code": "def minimumrequired ( A , N ) : NEW_LINE INDENT K = N NEW_LINE while ( K > 0 ) : NEW_LINE INDENT if ( K % 2 ) == 1 : NEW_LINE INDENT ans = K NEW_LINE break NEW_LINE DEDENT ispalindrome = 1 NEW_LINE for i in range ( 0 , K // 2 ) : NEW_LINE INDENT if ( A [ i ] != A [ K - 1 - i ] ) : NEW_LINE INDENT ispalindrome = 0 NEW_LINE DEDENT DEDENT if ( ispalindrome == 1 ) : NEW_LINE INDENT ans = K // 2 NEW_LINE K = K // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = K NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 1 , 2 , 2 , 1 , 1 , 2 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( minimumrequired ( A , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum count of elements required to obtain the given Array by repeated mirror operations | Function to find minimum number of elements required to form A [ ] by performing mirroring operation ; Initialize K ; Odd length array cannot be formed by mirror operation ; Check if prefix of length K is palindrome ; Check if not a palindrome ; If found to be palindrome ; Otherwise ; Return the final answer ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "5374-5374",
        "Code": "def sumOfFactors ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT first = i NEW_LINE last = ( N // i ) * i NEW_LINE factors = ( last - first ) // i + 1 NEW_LINE totalContribution = ( ( ( factors * ( factors + 1 ) ) // 2 ) * i ) NEW_LINE ans += totalContribution NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 3 NEW_LINE print ( sumOfFactors ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of product of all integers upto N with their count of divisors | Function to find the sum of the product of all the integers and their positive divisors up to N ; Iterate for every number between 1 and N ; Find the first multiple of i between 1 and N ; Find the last multiple of i between 1 and N ; Find the total count of multiple of in [ 1 , N ] ; Compute the contribution of i using the formula ; Add the contribution of i to the answer ; Return the result ; Given N ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5377-5377",
        "Code": "def computePair ( K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( K * K / ( K - 1 ) , end = \" ▁ \" ) NEW_LINE print ( K / ( K - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 6 NEW_LINE computePair ( K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Pair of integers with difference K having an element as the K | Function to find the required pair ; No pair possible ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5381-5381",
        "Code": "cont = [ [ 0 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def num_of_containers ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE cont [ 1 ] [ 1 ] = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( cont [ i ] [ j ] >= 1 ) : NEW_LINE INDENT count += 1 NEW_LINE cont [ i + 1 ] [ j ] += ( cont [ i ] [ j ] - 1 ) / 2 NEW_LINE cont [ i + 1 ] [ j + 1 ] += ( cont [ i ] [ j ] - 1 ) / 2 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT n = 3 NEW_LINE x = 5 NEW_LINE num_of_containers ( n , x ) NEW_LINE",
        "Type": "py",
        "NL": "Number of containers that can be filled in the given time | Matrix of containers ; Function to find the number of containers that will be filled in X seconds ; Container on top level ; If container gets filled ; Dividing the liquid equally in two halves ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "5382-5382",
        "Code": "def countStrings ( A , B , K ) : NEW_LINE INDENT X = ( A + B ) // ( K + 1 ) NEW_LINE return ( min ( A , min ( B , X ) ) * ( K + 1 ) ) NEW_LINE DEDENT N , M , K = 101 , 231 , 15 NEW_LINE print ( countStrings ( N , M , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of Binary Strings possible as per given conditions | Function to generate maximum possible strings that can be generated ; Maximum possible strings ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5384-5384",
        "Code": "def ConstructBinaryString ( N , M , K ) : NEW_LINE INDENT if ( M < ( N - 1 ) or M > K * ( N + 1 ) ) : NEW_LINE INDENT return ' - 1' NEW_LINE DEDENT ans = \" \" NEW_LINE l = min ( K , M // ( N - 1 ) ) NEW_LINE temp = N NEW_LINE while ( temp ) : NEW_LINE INDENT temp -= 1 NEW_LINE ans += '0' NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT ans += '1' NEW_LINE DEDENT DEDENT M -= ( N - 1 ) * l NEW_LINE if ( M == 0 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT l = min ( M , K ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ans += '1' NEW_LINE DEDENT M -= l NEW_LINE while ( M > 0 ) : NEW_LINE INDENT ans = '1' + ans NEW_LINE M -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE M = 9 NEW_LINE K = 2 NEW_LINE print ( ConstructBinaryString ( N , M , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate a Binary String without any consecutive 0 ' s ▁ and ▁ at ▁ most ▁ K ▁ consecutive ▁ 1' s | Function to construct the binary string ; Conditions when string construction is not possible ; Stores maximum 1 's that  can be placed in between ; Place 0 's ; Place 1 's in between ; Count remaining M 's ; Place 1 's at the end ; Place 1 's at the beginning ; Return the final string ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "5385-5385",
        "Code": "def UniqueMatrix ( N ) : NEW_LINE INDENT element_value = 1 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT for f in range ( element_value , element_value + N , 1 ) : NEW_LINE INDENT print ( f , end = ' ▁ ' ) NEW_LINE DEDENT element_value += N NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( element_value + N - 1 , element_value - 1 , - 1 ) : NEW_LINE INDENT print ( k , end = ' ▁ ' ) NEW_LINE DEDENT element_value += N NEW_LINE DEDENT print ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE UniqueMatrix ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Construct a Matrix N x N with first N ^ 2 natural numbers for an input N | Function to print the desired matrix ; Iterate ove all [ 0 , N ] ; If is even ; If row number is even print the row in forward order ; if row number is odd print the row in reversed order ; Given Matrix Size ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "539-539",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE self . flag = 0 NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) ; NEW_LINE new_node . data = new_data ; NEW_LINE new_node . flag = 0 ; NEW_LINE new_node . next = ( head_ref ) ; NEW_LINE ( head_ref ) = new_node ; NEW_LINE return head_ref NEW_LINE DEDENT def detectLoop ( h ) : NEW_LINE INDENT while ( h != None ) : NEW_LINE INDENT if ( h . flag == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT h . flag = 1 ; NEW_LINE h = h . next ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None ; NEW_LINE head = push ( head , 20 ) ; NEW_LINE head = push ( head , 4 ) ; NEW_LINE head = push ( head , 15 ) ; NEW_LINE head = push ( head , 10 ) NEW_LINE head . next . next . next . next = head ; NEW_LINE if ( detectLoop ( head ) ) : NEW_LINE INDENT print ( \" Loop ▁ found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Loop \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Detect loop in a linked list | Link list node ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Returns true if there is a loop in linked list else returns false . ; If this node is already traverse it means there is a cycle ( Because you we encountering the node for the second time ) . ; If we are seeing the node for the first time , mark its flag as 1 ; Driver program to test above function ; Start with the empty list ; Create a loop for testing",
        "Category": "Linked List"
    },
    {
        "ID": "5394-5394",
        "Code": "def possible ( N , a , b , n ) : NEW_LINE INDENT sum_of_angle = 180 * ( N - 2 ) NEW_LINE Total_angle = ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 NEW_LINE if ( sum_of_angle != Total_angle ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def nth_angle ( N , a , b , n ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = a + ( n - 1 ) * b NEW_LINE return nth NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE a = 30 NEW_LINE b = 30 NEW_LINE n = 3 NEW_LINE if ( possible ( N , a , b , n ) ) : NEW_LINE INDENT print ( nth_angle ( N , a , b , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Nth angle of a Polygon whose initial angle and per angle increment is given | Function to check if the angle is possible or not ; Angular sum of a N - sided polygon ; Angular sum of N - sided given polygon ; Check if both sum are equal ; Function to find the nth angle ; Calculate nth angle ; Return the nth angle ; Driver Code ; Checks the possibility of the polygon exist or not ; Print nth angle of the polygon",
        "Category": "Math"
    },
    {
        "ID": "5395-5395",
        "Code": "import sys NEW_LINE def findTriplet ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE st = [ ] NEW_LINE h3 = - sys . maxsize - 1 NEW_LINE h1 = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT h1 = arr [ i ] NEW_LINE while ( len ( st ) > 0 and st [ - 1 ] < arr [ i ] ) : NEW_LINE INDENT h3 = st [ - 1 ] NEW_LINE del st [ - 1 ] NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE if ( h1 < h3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 7 , 5 , 6 ] NEW_LINE if ( findTriplet ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether there exists a triplet ( i , j , k ) such that arr [ i ] < arr [ k ] < arr [ j ] for i < j < k | Python3 program for the above approach ; Function to check if there exist triplet in the array such that i < j < k and arr [ i ] < arr [ k ] < arr [ j ] ; Initialize the heights of h1 and h3 to INT_MAX and INT_MIN respectively ; Store the current element as h1 ; If the element at top of stack is less than the current element then pop the stack top and keep updating the value of h3 ; Push the current element on the stack ; If current element is less than h3 , then we found such triplet and return true ; No triplet found , hence return false ; Driver Code ; Given array ; Function Call",
        "Category": "Stack"
    },
    {
        "ID": "5399-5399",
        "Code": "def distinctNumbers ( arr , m , n ) : NEW_LINE INDENT count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] = count . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT fre_arr = [ 0 ] * ( n + 1 ) NEW_LINE for it in count : NEW_LINE INDENT fre_arr [ count [ it ] ] += 1 NEW_LINE DEDENT ans = len ( count ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = fre_arr [ i ] NEW_LINE if ( temp == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT t = min ( temp , m // i ) NEW_LINE ans -= t NEW_LINE m -= i * t NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 1 , 5 , 3 , 5 , 1 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 2 NEW_LINE print ( distinctNumbers ( arr , m , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of distinct elements after removing M items | Set 2 | Function to return minimum distinct character after M removals ; Count the occurences of number and store in count ; Count the occurences of the frequencies ; Take answer as total unique numbers and remove the frequency and subtract the answer ; Remove the minimum number of times ; Return the answer ; Driver Code ; Initialize array ; Size of array ; Function call",
        "Category": "Hash Table"
    },
    {
        "ID": "5406-5406",
        "Code": "def min_cost ( n , x , p , q ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT print ( ( n - 1 ) * p ) NEW_LINE return 0 NEW_LINE DEDENT ans = ( n - 1 ) * p NEW_LINE pre = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT tmp = n // x NEW_LINE if ( tmp < 0 ) : NEW_LINE break NEW_LINE pre += ( n - tmp * x ) * p NEW_LINE n //= x NEW_LINE pre += q NEW_LINE ans = min ( ans , pre + ( n - 1 ) * p ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; x = 2 ; NEW_LINE p = 2 ; q = 3 ; NEW_LINE print ( min_cost ( n , x , p , q ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost to reduce the integer N to 1 as per given conditions | Function to find the minimum cost to reduce the integer N to 1 by the given operations ; Check if x is 1 ; Print the answer ; Prestore the answer ; Iterate till n exists ; Divide N by x ; Reduce n by x ; Add the cost ; Update the answer ; Return the answer ; Driver Code ; Initialize the variables ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "541-541",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . key , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def detectLoop ( head ) : NEW_LINE INDENT temp = \" \" NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( head . next == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( head . next == temp ) : NEW_LINE INDENT return True NEW_LINE DEDENT nex = head . next NEW_LINE head . next = temp NEW_LINE head = nex NEW_LINE DEDENT return False NEW_LINE DEDENT head = newNode ( 1 ) NEW_LINE head . next = newNode ( 2 ) NEW_LINE head . next . next = newNode ( 3 ) NEW_LINE head . next . next . next = newNode ( 4 ) NEW_LINE head . next . next . next . next = newNode ( 5 ) NEW_LINE head . next . next . next . next . next = head . next . next NEW_LINE found = detectLoop ( head ) NEW_LINE if ( found ) : NEW_LINE INDENT print ( \" Loop ▁ Found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Loop \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Detect loop in a linked list | Python3 program to return first node of loop A binary tree node has data , pointer to left child and a pointer to right child Helper function that allocates a new node with the given data and None left and right pointers ; A utility function to pra linked list ; Function to detect first node of loop in a linked list that may contain loop ; Create a temporary node ; This condition is for the case when there is no loop ; Check if next is already pointing to temp ; Store the pointer to the next node in order to get to it in the next step ; Make next poto temp ; Get to the next node in the list ; Driver Code ; Create a loop for testing ( 5 is pointing to 3 )",
        "Category": "Linked List"
    },
    {
        "ID": "5415-5415",
        "Code": "def countMissingNum ( a , N ) : NEW_LINE INDENT count = a [ N - 1 ] - a [ 0 ] + 1 - N NEW_LINE print ( count ) NEW_LINE DEDENT arr = [ 5 , 10 , 20 , 40 ] NEW_LINE N = len ( arr ) NEW_LINE countMissingNum ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Count of Missing Numbers in a sorted array | Function that find the count of missing numbers in array a [ ] ; Calculate the count of missing numbers in the array ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5421-5421",
        "Code": "def good_pair ( st , N ) : NEW_LINE INDENT countStr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT res = st [ i ] + st [ j ] NEW_LINE vowel = [ 0 ] * 5 NEW_LINE for k in range ( len ( res ) ) : NEW_LINE INDENT if ( res [ k ] == ' a ' ) : NEW_LINE INDENT vowel [ 0 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == ' e ' ) : NEW_LINE INDENT vowel [ 1 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == ' i ' ) : NEW_LINE INDENT vowel [ 2 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == ' o ' ) : NEW_LINE INDENT vowel [ 3 ] = 1 NEW_LINE DEDENT elif ( res [ k ] == ' u ' ) : NEW_LINE INDENT vowel [ 4 ] = 1 NEW_LINE DEDENT DEDENT temp = 0 NEW_LINE for ind in range ( 5 ) : NEW_LINE INDENT if ( vowel [ ind ] == 1 ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT DEDENT if ( temp == 5 ) : NEW_LINE INDENT countStr += 1 NEW_LINE DEDENT DEDENT DEDENT return countStr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" aaweiolkju \" , \" oxdfgujkmi \" ] NEW_LINE N = len ( arr ) NEW_LINE print ( good_pair ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pair of strings whose concatenation has every vowel | Function to return the count of all concatenated string with each vowel at least once ; Concatenating all possible pairs of string ; Creating an array which checks , the presence of each vowel ; Checking for each vowel by traversing the concatenated string ; Checking if all the elements are set in vowel [ ] ; Check if all vowels are present or not ; Return the final count ; Driver Code ; Given array of strings ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "5426-5426",
        "Code": "def find_max ( n , k ) : NEW_LINE INDENT X = [ 0 ] * 32 NEW_LINE cnt = 0 NEW_LINE i = 31 NEW_LINE while ( i >= 0 and cnt != k ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT X [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT s = \" \" NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if X [ i ] == 0 : NEW_LINE INDENT s += '0' NEW_LINE DEDENT else : NEW_LINE INDENT s += '1' NEW_LINE DEDENT DEDENT return int ( s , 2 ) NEW_LINE DEDENT n , k = 10 , 2 NEW_LINE print ( find_max ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum integer with at most K bits set such that their bitwise AND with N is maximum | Function to find the integer with maximum bitwise with N ; Store answer in the bitset Initialized with 0 ; To maintain the count of set bits that should exceed k ; Start traversing from the Most significant if that bit is set in n then we will set in our answer i . e in X ; Checking if the ith bit is set in n or not ; Converting into integer ; Driver code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5428-5428",
        "Code": "def convert ( s ) : NEW_LINE INDENT num = 0 NEW_LINE n = len ( s ) NEW_LINE for i in s : NEW_LINE INDENT num = num * 10 + ( ord ( i ) - 48 ) NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"123\" NEW_LINE convert ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert string to integer without using any in | Function to convert string to integer without using functions ; Initialize a variable ; Iterate till length of the string ; Subtract 48 from the current digit ; Print the answer ; Driver code ; Given string of number ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5432-5432",
        "Code": "def maxProfit ( value , N , K ) : NEW_LINE INDENT value . sort ( ) NEW_LINE maxval = value [ N - 1 ] NEW_LINE maxProfit = 0 NEW_LINE while True : NEW_LINE INDENT curr_val = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_val += value [ i ] NEW_LINE if ( curr_val <= K ) : NEW_LINE INDENT maxProfit = max ( curr_val + maxval * ( i + 1 ) , maxProfit ) NEW_LINE DEDENT DEDENT if not next_permutation ( value ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return maxProfit NEW_LINE DEDENT def next_permutation ( p ) : NEW_LINE INDENT for a in range ( len ( p ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if p [ a ] < p [ a + 1 ] : NEW_LINE INDENT b = len ( p ) - 1 NEW_LINE while True : NEW_LINE INDENT if p [ b ] > p [ a ] : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE a += 1 NEW_LINE b = len ( p ) - 1 NEW_LINE while a < b : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE a += 1 NEW_LINE b -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT b -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT N , K = 4 , 6 NEW_LINE values = [ 5 , 2 , 7 , 3 ] NEW_LINE print ( maxProfit ( values , N , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum profit such that total stolen value is less than K to get bonus | Function to find the maximum profit from the given values ; Iterating over every possible permutation ; Driver Code ; Function Call",
        "Category": "Backtracking"
    },
    {
        "ID": "5433-5433",
        "Code": "def findways ( s , x ) : NEW_LINE INDENT if ( x > len ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = len ( s ) NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT se = set ( ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT se . add ( freq [ i ] ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( x // 2 ) : NEW_LINE INDENT count = 0 NEW_LINE for u in se : NEW_LINE INDENT if ( u >= 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans *= count NEW_LINE DEDENT p = list ( se ) NEW_LINE val = p [ - 1 ] NEW_LINE p . pop ( - 1 ) NEW_LINE se = set ( p ) NEW_LINE if ( val > 2 ) : NEW_LINE INDENT se . add ( val - 2 ) NEW_LINE DEDENT DEDENT if ( x % 2 != 0 ) : NEW_LINE INDENT count = 0 NEW_LINE for u in se : NEW_LINE INDENT if ( u > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = ans * count NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aaa \" NEW_LINE x = 2 NEW_LINE print ( findways ( s , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of unique palindromic strings of length X from given string | Function to count different palindromic string of length X from the given string S ; Base case ; Create the frequency array Intitalise frequency array with 0 ; Count the frequency in the string ; Store frequency of the char ; Check the frequency which is greater than zero ; No . of different char we can put at the position of the i and x - i ; Iterator pointing to the last element of the set ; Decrease the value of the char we put on the position i and n - i ; Different no of char we can put at the position x / 2 ; Return total no of different string ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "5434-5434",
        "Code": "def FindIfPossible ( n , a , b ) : NEW_LINE INDENT if ( b % a ) != 0 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % b ) != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( n / b ) NEW_LINE DEDENT DEDENT c = b / a NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE while ( n % b == 0 ) : NEW_LINE INDENT n /= b NEW_LINE x += 1 NEW_LINE DEDENT while ( n % c == 0 ) : NEW_LINE INDENT n /= c NEW_LINE y += 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT total_steps = x + 2 * y NEW_LINE return total_steps NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT n = 48 NEW_LINE a = 3 NEW_LINE b = 12 NEW_LINE print ( FindIfPossible ( n , a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Min operations to reduce N to 1 by multiplying by A or dividing by B | Function to check if it is possible to convert a number N to 1 by a minimum use of the two operations ; For the Case b % a != 0 ; Check if n equal to 1 ; Check if n is not divisible by b ; Initialize a variable c ; Loop until n is divisible by b ; Count number of divisions ; Loop until n is divisible by c ; Count number of operations ; Check if n is reduced to 1 ; Count steps ; Return the total number of steps ; Given n , a and b ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "5435-5435",
        "Code": "import math NEW_LINE def MinValue ( n ) : NEW_LINE INDENT while ( int ( math . sqrt ( n ) ) == math . sqrt ( n ) and n > 1 ) : NEW_LINE INDENT n = math . sqrt ( n ) NEW_LINE DEDENT for i in range ( int ( math . sqrt ( n ) ) , 1 , - 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n /= i NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT n = 20 NEW_LINE MinValue ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Min operations to reduce N by multiplying by any number or taking square root | Python3 program for the above approach ; Function to reduce N to its minimum possible value by the given operations ; Keep replacing n until is an integer ; Keep replacing n until n is divisible by i * i ; Print the answer ; Given N ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5442-5442",
        "Code": "def findArray ( _sum , xorr ) : NEW_LINE INDENT if ( xorr > _sum or _sum % 2 != xorr % 2 ) : NEW_LINE INDENT print ( \" No ▁ Array ▁ Possible \" ) NEW_LINE return NEW_LINE DEDENT if ( _sum == xorr ) : NEW_LINE INDENT if ( _sum == 0 ) : NEW_LINE INDENT print ( \" Array ▁ is ▁ empty \" , \" ▁ with ▁ size ▁ 0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Array ▁ size ▁ is \" , 1 ) NEW_LINE print ( \" Array ▁ is \" , _sum ) NEW_LINE DEDENT return NEW_LINE DEDENT mid = ( _sum - xorr ) // 2 NEW_LINE if ( xorr & mid == 1 ) : NEW_LINE INDENT print ( \" Array ▁ size ▁ is \" , 3 ) NEW_LINE print ( \" Array ▁ is \" , xorr , mid , mid ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Array ▁ size ▁ is \" , 2 ) NEW_LINE print ( \" Array ▁ is \" , ( xorr + mid ) , mid ) NEW_LINE DEDENT DEDENT _sum = 4 NEW_LINE xorr = 2 NEW_LINE findArray ( _sum , xorr ) NEW_LINE",
        "Type": "py",
        "NL": "Construct the smallest possible Array with given Sum and XOR | Function to find array ; Array not possible ; Array possible with exactly 1 or no element ; Checking array with two elements possible or not . ; Given sum and value of Bitwise XOR ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "5443-5443",
        "Code": "def Kperiodicinteger ( X , N , K ) : NEW_LINE INDENT X = list ( X ) NEW_LINE temp = X . copy ( ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT j = i NEW_LINE while ( j < N ) : NEW_LINE INDENT X [ j ] = X [ i ] NEW_LINE j += K NEW_LINE DEDENT DEDENT if ( X >= temp ) : NEW_LINE INDENT return X NEW_LINE DEDENT POS = 0 NEW_LINE for i in range ( K - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( X [ i ] != '9' ) : NEW_LINE INDENT X [ i ] = str ( int ( X [ i ] ) + 1 ) NEW_LINE POS = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( POS + 1 , K ) : NEW_LINE INDENT X [ i ] = '0' NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT j = i NEW_LINE while ( j < N ) : NEW_LINE INDENT X [ j ] = X [ i ] NEW_LINE j += K NEW_LINE DEDENT DEDENT return X NEW_LINE DEDENT N = 4 NEW_LINE K = 2 NEW_LINE X = \"1215\" NEW_LINE print ( * Kperiodicinteger ( X , N , K ) , sep = ' ' ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number greater than X which is K | Function to find the smallest K periodic integer greater than X ; Stores the number in a temporary string ; Set X [ i ] = X [ i - k ] for i > k ; Start from the current index ; Loop upto N change X [ j ] to X [ i ] ; Return X if current Value is greater than original value ; Find the first digit not equal to 9 ; Increment X [ i ] ; Set POS to current index ; Change X [ i ] to 0 for all indices from POS + 1 to K ; Set X [ i ] = X [ i - k ] for i > k ; Loop upto N change X [ j ] to X [ i ] ; Return the final string ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5450-5450",
        "Code": "import sys NEW_LINE from collections import defaultdict NEW_LINE def moduloEquality ( A , B , n , m ) : NEW_LINE INDENT mapA = defaultdict ( int ) NEW_LINE mapB = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mapA [ A [ i ] ] += 1 NEW_LINE mapB [ B [ i ] ] += 1 NEW_LINE DEDENT possibleValues = set ( ) NEW_LINE FirstElement = B [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur = A [ i ] NEW_LINE if cur > FirstElement : NEW_LINE INDENT possibleValues . add ( m - cur + FirstElement ) NEW_LINE DEDENT else : NEW_LINE INDENT possibleValues . add ( FirstElement - cur ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for it in possibleValues : NEW_LINE INDENT possible = True NEW_LINE for it2 in mapA : NEW_LINE INDENT if ( mapA [ it2 ] != mapB [ ( it2 + it ) % m ] ) : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( possible ) : NEW_LINE INDENT ans = min ( ans , it ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE m = 3 NEW_LINE A = [ 0 , 0 , 2 , 1 ] NEW_LINE B = [ 2 , 0 , 1 , 1 ] NEW_LINE print ( moduloEquality ( A , B , n , m ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest number to be added in first Array modulo M to make frequencies of both Arrays equal | Python3 program for the above approach ; Utility function to find the answer ; Stores the frequencies of array elements ; Stores the possible values of X ; Generate possible positive values of X ; Initialize answer to MAX value ; Flag to check if the current element of the set can be considered ; If the frequency of an element in A [ ] is not equal to that in B [ ] after the operation ; Current set element cannot be considered ; Update minimum value of X ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "5454-5454",
        "Code": "def isPalindrome ( l , r , s ) : NEW_LINE INDENT while ( l <= r ) : NEW_LINE INDENT if ( s [ l ] != s [ r ] ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return bool ( True ) NEW_LINE DEDENT def numWays ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isPalindrome ( 0 , i , s ) and isPalindrome ( i + 1 , n - 1 , s ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT S = \" aaaaa \" NEW_LINE print ( numWays ( S ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of ways to split given string into two non | Function to check whether the substring from l to r is palindrome or not ; If characters at l and r differ ; Not a palindrome ; If the string is a palindrome ; Function to count and return the number of possible splits ; Stores the count of splits ; Check if the two substrings after the split are palindromic or not ; If both are palindromes ; Print the final count ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5456-5456",
        "Code": "def maxProfit ( prices , n ) : NEW_LINE INDENT profit = 0 NEW_LINE currentDay = n - 1 NEW_LINE while ( currentDay > 0 ) : NEW_LINE INDENT day = currentDay - 1 NEW_LINE while ( day >= 0 and ( prices [ currentDay ] > prices [ day ] ) ) : NEW_LINE INDENT profit += ( prices [ currentDay ] - prices [ day ] ) NEW_LINE day -= 1 NEW_LINE DEDENT currentDay = day ; NEW_LINE DEDENT return profit ; NEW_LINE DEDENT prices = [ 2 , 3 , 5 ] NEW_LINE N = len ( prices ) NEW_LINE print ( maxProfit ( prices , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize Profit by trading stocks based on given rate per day | Function to find the maximum profit ; Start from the last day ; Traverse and keep adding the profit until a day with price of stock higher than currentDay is obtained ; Set this day as currentDay with maximum cost of stock currently ; Return the profit ; Given array of prices ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5458-5458",
        "Code": "def findDirection ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT if ( m % 2 == 0 ) : NEW_LINE INDENT print ( \" Up \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Down \" ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Left \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Right \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 3 ; m = 3 ; NEW_LINE findDirection ( n , m ) ; NEW_LINE",
        "Type": "py",
        "NL": "Final direction after visiting every cell of Matrix starting from ( 0 , 0 ) | Function to find the direction when stopped moving ; Given size of NxM grid ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "5461-5461",
        "Code": "def removeLeadingZeros ( Str ) : NEW_LINE INDENT i = 0 NEW_LINE n = len ( Str ) NEW_LINE while ( Str [ i ] == '0' and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT Str = Str [ i : ] NEW_LINE return Str NEW_LINE DEDENT def findPairs ( Sum , K ) : NEW_LINE INDENT A = \" \" NEW_LINE B = \" \" NEW_LINE N = str ( Sum ) NEW_LINE n = len ( N ) NEW_LINE for i in range ( n ) : NEW_LINE D = int ( N [ i ] ) - int ( '0' ) NEW_LINE if ( D == K ) : NEW_LINE INDENT D1 = D // 2 ; NEW_LINE D2 = ( D // 2 ) + ( D % 2 ) NEW_LINE A = A + ( str ) ( D1 + int ( '0' ) ) NEW_LINE B = B + ( str ) ( D2 + int ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT A = A + ( str ) ( D + int ( '0' ) ) NEW_LINE B = B + '0' NEW_LINE DEDENT A = removeLeadingZeros ( A ) NEW_LINE B = removeLeadingZeros ( B ) NEW_LINE print ( A + \" , ▁ \" + B ) NEW_LINE DEDENT N = 33673 NEW_LINE K = 3 NEW_LINE findPairs ( N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Find two numbers with sum N such that neither of them contains digit K | Python3 implementation of the above approach ; Count leading zeros ; It removes i characters starting from index 0 ; Check each digit of the N ; If digit is K break it ; For odd numbers ; Add D1 to A and D2 to B ; If the digit is not K , no need to break String D in A and 0 in B ; Remove leading zeros ; Print the answer ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5471-5471",
        "Code": "def solve ( n , m , x , y , d ) : NEW_LINE INDENT top = min ( d , x - 1 ) NEW_LINE down = min ( d , n - x ) NEW_LINE left = min ( d , y - 1 ) NEW_LINE right = min ( d , m - y ) NEW_LINE quad1 = top * left NEW_LINE quad2 = left * down NEW_LINE quad3 = down * right NEW_LINE quad4 = right * top NEW_LINE totalsq = ( quad1 + quad2 + quad3 + quad4 ) NEW_LINE singleBlocks = ( top + down + left + right + 1 ) NEW_LINE return totalsq + singleBlocks NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 10 NEW_LINE x = 7 NEW_LINE y = 8 NEW_LINE d = 4 NEW_LINE d -= 1 NEW_LINE print ( solve ( n , m , x , y , d ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Total number of cells covered in a matrix after D days | Function to return the total infected cells after d days ; Top extension ; Bottom extension ; Left extension ; Right extension ; Calculating the cells in each quadrilateral ; Sum all of them to get total cells in each quadrilateral ; Add the singleblocks along the lines of top , down , left , right ; Return the ans ; Driver Code ; Dimensions of cell ; Starting Coordinates ; Number of Days ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "5473-5473",
        "Code": "def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N % 4 == 0 ) : NEW_LINE INDENT return \"01\" ; NEW_LINE DEDENT elif ( N % 4 == 1 ) : NEW_LINE INDENT return \"07\" ; NEW_LINE DEDENT elif ( N % 4 == 2 ) : NEW_LINE INDENT return \"49\" ; NEW_LINE DEDENT return \"43\" ; NEW_LINE DEDENT N = 12 ; NEW_LINE print ( get_last_two_digit ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Last two digits of powers of 7 | Function to find the last two digits of 7 ^ N ; Case 4 ; Case 3 ; Case 2 ; Case 1 ; Given number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "5474-5474",
        "Code": "M = 3 NEW_LINE N = 3 NEW_LINE def minchanges ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = N + M - 2 NEW_LINE while ( left < right ) : NEW_LINE INDENT mp = { } NEW_LINE totalsize = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( i + j == left ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = NEW_LINE mp . get ( mat [ i ] [ j ] , 0 ) + 1 NEW_LINE totalsize += 1 NEW_LINE DEDENT elif ( i + j == right ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = NEW_LINE mp . get ( mat [ i ] [ j ] , 0 ) + 1 NEW_LINE totalsize += 1 NEW_LINE DEDENT DEDENT DEDENT changes = 0 NEW_LINE for itr in mp : NEW_LINE INDENT changes = max ( changes , mp [ itr ] ) NEW_LINE DEDENT count += totalsize - changes NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 4 , 1 ] , [ 2 , 5 , 3 ] , [ 1 , 3 , 1 ] ] NEW_LINE print ( minchanges ( mat ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum steps to convert all paths in matrix from top left to bottom right as palindromic paths | Python3 implementation to find the minimum number of changes required such that every path from top left to the bottom right are palindromic paths ; Function to find the minimum number of the changes required for the every path to be palindromic ; count variable for maintaining total changes . ; left and right variables for keeping distance values from cell ( 0 , 0 ) and ( N - 1 , M - 1 ) respectively . ; Iterating over the matrix ; Finding minimum number of changes required . ; Minimum no . of changes will be the the minimum no . of different values and we will assume to make them equals to value with maximum frequency element ; Moving ahead with greater distance ; Driver Code ; Function Call",
        "Category": "Matrix"
    },
    {
        "ID": "5481-5481",
        "Code": "def print_path ( N , jump , coin ) : NEW_LINE INDENT if ( jump > coin or jump * ( N - 1 ) < coin ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = 1 ; NEW_LINE while ( jump > 0 ) : NEW_LINE INDENT tmp = min ( N - 1 , coin - ( jump - 1 ) ) ; NEW_LINE if ( pos + tmp <= N ) : NEW_LINE INDENT pos += tmp ; NEW_LINE DEDENT else : NEW_LINE INDENT pos -= tmp ; NEW_LINE DEDENT print ( pos , end = \" ▁ \" ) NEW_LINE coin -= tmp ; NEW_LINE jump -= 1 ; NEW_LINE DEDENT DEDENT DEDENT N = 5 NEW_LINE K = 4 NEW_LINE M = 12 NEW_LINE print_path ( N , K , M ) ; NEW_LINE",
        "Type": "py",
        "NL": "Path traversed using exactly M coins in K jumps | Function that pr the path using exactly K jumps and M coins ; If no path exists ; It decides which box to be jump ; It decides whether to jump on left side or to jump on right side ; Print the path ; Driver code ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5492-5492",
        "Code": "def makeZero ( x , y , a , b ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT tot_cost = ( y - x ) * a NEW_LINE cost1 = 2 * x * a NEW_LINE cost2 = x * b NEW_LINE tot_cost += min ( cost1 , cost2 ) NEW_LINE print ( tot_cost ) NEW_LINE DEDENT / * Driver code * / NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X , Y = 1 , 3 NEW_LINE cost1 , cost2 = 391 , 555 NEW_LINE makeZero ( X , Y , cost1 , cost2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize cost to convert given two integers to zero using given operations | Function to find out the minimum cost to make two number X and Y equal to zero ; If x is greater than y then swap ; Cost of making y equal to x ; Cost if we choose 1 st operation ; Cost if we choose 2 nd operation ; Total cost ;",
        "Category": "Math"
    },
    {
        "ID": "5493-5493",
        "Code": "def count_triangles ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( a , b + 1 ) : NEW_LINE INDENT num_greater_than_d = ( max ( d , c + x ) - max ( d , b + x - 1 ) ) NEW_LINE ans = ( ans + num_greater_than_d * ( d - c + 1 ) ) NEW_LINE r = min ( max ( c , c + x ) , d ) - c ; NEW_LINE l = min ( max ( c , b + x - 1 ) , d ) - c ; NEW_LINE x1 = int ( ( r * ( r + 1 ) ) / 2 ) NEW_LINE x2 = int ( ( l * ( l + 1 ) ) / 2 ) NEW_LINE ans = ans + ( x1 - x2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE print ( count_triangles ( a , b , c , d ) , end =   ' ' ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of triangles possible for the given sides range | Function to count the number of possible triangles for the given sides ranges ; Iterate for every possible of x ; Range of y is [ b , c ] From this range First we will find the number of x + y greater than d ; For x + y greater than d we can choose all z from [ c , d ] Total permutation will be ; Now we will find the number of x + y in between the [ c , d ] ; [ l , r ] will be the range from total [ c , d ] x + y belongs For any r such that r = x + y We can choose z , in the range [ c , d ] only less than r , Thus total permutation be ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5496-5496",
        "Code": "def minFlip ( s , n , k , a , p ) : NEW_LINE INDENT allowed = [ 0 ] * 26 NEW_LINE for i in range ( p ) : NEW_LINE INDENT allowed [ ord ( a [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT freq = [ [ 0 for x in range ( 26 ) ] for y in range ( k ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT freq [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT freq [ i % k ] [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE totalpositions = n // k NEW_LINE for i in range ( k ) : NEW_LINE INDENT maxfrequency = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] [ j ] > maxfrequency and allowed [ j ] == True ) : NEW_LINE INDENT maxfrequency = freq [ i ] [ j ] NEW_LINE DEDENT DEDENT ans += ( totalpositions - maxfrequency ) NEW_LINE if ( i % k < n % k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" nihsiakyt \" NEW_LINE n = len ( S ) NEW_LINE K = 3 NEW_LINE A = [ ' n ' , ' i ' , ' p ' , ' s ' , ' q ' ] NEW_LINE p = len ( A ) NEW_LINE minFlip ( S , n , K , A , p ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of swaps required to make the string K periodic | Python3 code to find the minimum number of swaps required to make the string K periodic ; Mark all allowed characters as true ; Initialize the freq array to 0 ; Increase the frequency of each character ; Total number of periods of size K in the string ; Check if the current character is present in allowed and whether the current frequency is greater than all previous frequencies for this position ; Update the answer by subtracting the maxfrequency from total positions if there exist extra character at the end of the string apart from the n / k characters then add 1. ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5500-5500",
        "Code": "def printKParts ( N , K ) : NEW_LINE INDENT if ( N % K == 0 ) : NEW_LINE INDENT for i in range ( 1 , K ) : NEW_LINE INDENT print ( \"1 , ▁ \" ) ; NEW_LINE DEDENT print ( N - ( K - 1 ) , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( K == 2 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT for i in range ( 1 , K - 1 ) : NEW_LINE INDENT print ( 1 , end = \" , ▁ \" ) ; NEW_LINE DEDENT print ( 2 , \" , ▁ \" , ( N - K ) , end = \" \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 18 ; NEW_LINE K = 5 ; NEW_LINE printKParts ( N , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split a number as sum of K numbers which are not divisible by K | Function to split into K parts and print them ; Print 1 K - 1 times ; Print N - K + 1 ; Print 1 K - 2 times ; Print 2 and N - K ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5508-5508",
        "Code": "def MinDiff ( n ) : NEW_LINE INDENT val = 2 ** n NEW_LINE sep = n // 2 NEW_LINE grp1 = 0 NEW_LINE grp2 = 0 NEW_LINE grp1 = grp1 + val NEW_LINE for i in range ( 1 , sep ) : NEW_LINE INDENT grp1 = grp1 + 2 ** i NEW_LINE DEDENT for i in range ( sep , n ) : NEW_LINE INDENT grp2 = grp2 + 2 ** i NEW_LINE DEDENT print ( abs ( grp1 - grp2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE MinDiff ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split N powers of 2 into two subsets such that their difference of sum is minimum | Python3 program to find the minimum difference possible by splitting all powers of 2 up to N into two sets of equal size ; Store the largest ; Form two separate groups ; Initialize the sum for two groups as 0 ; Insert 2 ^ n in the first group ; Calculate the sum of least n / 2 - 1 elements added to the first set ; sum of remaining n / 2 - 1 elements ; Min Difference between the two groups ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5517-5517",
        "Code": "from math import gcd NEW_LINE def checkDivisible ( x , k ) : NEW_LINE INDENT g = gcd ( x , k ) NEW_LINE k //= g NEW_LINE if ( x % k == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 6 NEW_LINE k = 9 NEW_LINE checkDivisible ( x , k ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the square of a number is divisible by K or not | Python3 implementation to check if the square of X is divisible by K ; Function to return if square of X is divisible by K ; Finding gcd of x and k ; Dividing k by their gcd ; Check for divisibility of X by reduced K ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5531-5531",
        "Code": "def findString ( N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + i % K ) , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; NEW_LINE K = 3 ; NEW_LINE findString ( N , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the String having each substring with exactly K distinct characters | Function to find the required output string ; Each element at index i is modulus of K ; Driver code ; initialise integers N and K",
        "Category": "Substring"
    },
    {
        "ID": "5533-5533",
        "Code": "def digit_prod ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x ) : NEW_LINE INDENT prod = prod * ( x % 10 ) NEW_LINE x = x // 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def find_count ( n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = digit_prod ( i ) NEW_LINE if x in mpp : NEW_LINE INDENT mpp [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ x ] = 1 NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE maxm = 0 NEW_LINE for value in mpp . values ( ) : NEW_LINE INDENT if ( value > maxm ) : NEW_LINE INDENT maxm = value NEW_LINE ans = 1 NEW_LINE DEDENT elif ( value == maxm ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 13 NEW_LINE print ( find_count ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of largest sized groups while grouping according to product of digits | Function to find out product of digit ; calculate product ; return the product of digits ; Function to find the count ; hash map for counting frequency ; counting freq of each element ; find the maximum ; count the number of groups having size of equal to largest group . ; initialise N",
        "Category": "Hash Table"
    },
    {
        "ID": "5553-5553",
        "Code": "def findSmallNum ( N , K ) : NEW_LINE INDENT rem = N % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N - rem NEW_LINE DEDENT DEDENT def findLargeNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N + K - rem NEW_LINE DEDENT DEDENT def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE first = findSmallNum ( A , M ) NEW_LINE last = findLargeNum ( B , M ) NEW_LINE if ( first < A ) : NEW_LINE INDENT first += M NEW_LINE DEDENT if ( last > B ) : NEW_LINE INDENT first -= M NEW_LINE DEDENT n = ( B // M ) - ( A - 1 ) // M NEW_LINE return n * ( first + last ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 6 NEW_LINE B = 15 NEW_LINE M = 3 NEW_LINE print ( sumDivisibles ( A , B , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all numbers in the given range which are divisible by M | Function to find the largest number smaller than or equal to N that is divisible by K ; Finding the remainder when N is divided by K ; If the remainder is 0 , then the number itself is divisible by K ; Else , then the difference between N and remainder is the largest number which is divisible by K ; Function to find the smallest number greater than or equal to N that is divisible by K ; Finding the remainder when N is divided by K ; If the remainder is 0 , then the number itself is divisible by K ; Else , then the difference between N and remainder is the largest number which is divisible by K ; Function to find the sum of numbers divisible by M in the given range ; Variable to store the sum ; To bring the smallest and largest numbers in the range [ A , B ] ; To count the number of terms in the AP ; Sum of n terms of an AP ; Driver code ; A and B define the range , M is the dividend ; Printing the result",
        "Category": "Math"
    },
    {
        "ID": "5554-5554",
        "Code": "import heapq NEW_LINE def check ( A , B , N ) : NEW_LINE INDENT pq1 = [ ] NEW_LINE pq2 = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( pq1 , - A [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( pq2 , - B [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if - pq1 [ 0 ] > - pq2 [ 0 ] : NEW_LINE INDENT c += 1 NEW_LINE heapq . heappop ( pq1 ) NEW_LINE heapq . heappop ( pq2 ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( pq2 ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT heapq . heappop ( pq2 ) NEW_LINE DEDENT DEDENT return ( c ) NEW_LINE DEDENT A = [ 10 , 3 , 7 , 5 , 8 ] NEW_LINE B = [ 8 , 6 , 2 , 5 , 9 ] NEW_LINE N = len ( A ) NEW_LINE print ( check ( A , B , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of pairs from arrays A and B such that element in A is greater than element in B at that index | Python3 program to find the maximum count of values that follow the given condition ; Function to find the maximum count of values that follow the given condition ; Initializing the max - heap for the array A [ ] ; Adding the values of A [ ] into max heap ; Adding the values of B [ ] into max heap ; Counter variable ; Loop to iterate through the heap ; Comparing the values at the top . If the value of heap A [ ] is greater , then counter is incremented ; Driver code",
        "Category": "Heap"
    },
    {
        "ID": "5569-5569",
        "Code": "def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf for i in range ( sizeOfB ) ] for i in range ( 26 ) ] NEW_LINE for i in range ( sizeOfB ) : NEW_LINE INDENT next [ ord ( B [ i ] ) - ord ( ' a ' ) ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while ( i < sizeOfA ) : NEW_LINE INDENT if ( pos == 0 and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] == inf ) : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif ( pos < sizeOfB and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] < inf ) : NEW_LINE INDENT nextIndex = next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" aacbe \" NEW_LINE B = \" aceab \" NEW_LINE print ( findMinimumSubsequences ( A , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of subsequences required to convert one string to another using Greedy Algorithm | Function to find the minimum number of subsequences required to convert one to another S2 == A and S1 == B ; At least 1 subsequence is required Even in best case , when A is same as B ; size of B ; size of A ; Create an 2D array next [ ] [ ] of size 26 * sizeOfB to store the next occurrence of a character ( ' a ' to ' z ' ) as an index [ 0 , sizeOfA - 1 ] ; Loop to Store the values of index ; If the value of next [ i ] [ j ] is infinite then update it with next [ i ] [ j + 1 ] ; Greedy algorithm to obtain the maximum possible subsequence of B to cover the remaining of A using next subsequence ; Loop to iterate over the A ; Condition to check if the character is not present in the B ; Condition to check if there is an element in B matching with character A [ i ] on or next to B [ pos ] given by next [ A [ i ] - ' a ' ] [ pos ] ; Condition to check if reached at the end of B or no such element exists on or next to A [ pos ] , thus increment number by one and reinitialise pos to zero ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5571-5571",
        "Code": "import numpy as np NEW_LINE def vertical_Fill ( records , tape , m , n ) : NEW_LINE INDENT v = np . zeros ( ( m , n ) ) ; NEW_LINE sum = 0 ; NEW_LINE Retrieval_Time = 0 ; NEW_LINE Mrt = None ; NEW_LINE z = 0 ; j = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( i ) : NEW_LINE INDENT sum += v [ j ] [ k ] ; NEW_LINE DEDENT if ( sum + records [ z ] <= tape [ j ] ) : NEW_LINE INDENT v [ j ] [ i ] = records [ z ] ; NEW_LINE z += 1 ; NEW_LINE DEDENT DEDENT if ( v [ 2 ] [ i ] == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT Retrieval_Time = 0 ; NEW_LINE print ( \" tape \" , i + 1 , \" : ▁ [ \" , end = \" \" ) ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ j ] != 0 ) : NEW_LINE INDENT print ( v [ i ] [ j ] , end = \" ▁ \" ) ; else : break ; print ( \" ] \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT k = 0 ; NEW_LINE while v [ i ] [ k ] != 0 : NEW_LINE INDENT Retrieval_Time += v [ i ] [ k ] * ( j - k ) ; NEW_LINE k += 1 ; NEW_LINE DEDENT Mrt = Retrieval_Time / j ; NEW_LINE print ( \" MRT ▁ : \" , Mrt ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT records = [ 15 , 2 , 8 , 23 , 45 , 50 , 60 , 120 ] ; NEW_LINE tape = [ 25 , 80 , 160 ] ; NEW_LINE n = len ( records ) ; NEW_LINE m = len ( tape ) ; NEW_LINE records . sort ( ) ; NEW_LINE vertical_Fill ( records , tape , m , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Vertical and Horizontal retrieval ( MRT ) on Tapes | Python3 program to print Vertical filling ; 2D matrix for vertical insertion on tapes ; It is used for checking whether tape is full or not ; It is used for calculating total retrieval time ; It is used for calculating mean retrieval time ; It is used for calculating mean retrieval time ; vertical insertion on tape ; initialize variables to 0 for each iteration ; Used for getting ' sum ' sizes of records in tape to determine whether tape is full or not ; if tape is not full ; check for ability of tapes to hold value ; initialize variables to 0 for each iteration ; display elements of tape ; calculating total retrieval time ; MRT formula ; calculating mean retrieval time using formula ; v . size ( ) is function of vector is used to get size of vector ; Driver Code ; store the size of records [ ] ; store the size of tape [ ] ; sorting of an array is required to attain greedy approach of algorithm",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5574-5574",
        "Code": "MAX_SIZE = 10 ; NEW_LINE def convolution ( x , h , n , m ) : NEW_LINE INDENT row_vec = [ 0 ] * MAX_SIZE ; NEW_LINE col_vec = [ 0 ] * MAX_SIZE ; NEW_LINE out = [ 0 ] * MAX_SIZE ; NEW_LINE circular_shift_mat = [ [ 0 for i in range ( MAX_SIZE ) ] for j in range ( MAX_SIZE ) ] ; NEW_LINE if ( n > m ) : NEW_LINE INDENT maxSize = n ; NEW_LINE DEDENT else : NEW_LINE INDENT maxSize = m ; NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT row_vec [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT row_vec [ i ] = x [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( maxSize ) : NEW_LINE INDENT if ( i >= m ) : NEW_LINE INDENT col_vec [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT col_vec [ i ] = h [ i ] ; NEW_LINE DEDENT DEDENT k = 0 ; NEW_LINE d = 0 ; NEW_LINE for i in range ( maxSize ) : NEW_LINE INDENT curIndex = k - d ; NEW_LINE for j in range ( maxSize ) : NEW_LINE INDENT circular_shift_mat [ j ] [ i ] = row_vec [ curIndex % maxSize ] ; NEW_LINE curIndex += 1 ; NEW_LINE DEDENT k = maxSize ; NEW_LINE d += 1 ; NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT for j in range ( maxSize ) : NEW_LINE INDENT out [ i ] += circular_shift_mat [ i ] [ j ] * col_vec [ j ] ; NEW_LINE DEDENT print ( out [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = [ 5 , 7 , 3 , 2 ] ; NEW_LINE n = len ( x ) ; NEW_LINE h = [ 1 , 5 ] ; NEW_LINE m = len ( h ) ; NEW_LINE convolution ( x , h , n , m ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Circular Convolution using Matrix Method | Python program to compute circular convolution of two arrays ; Function to find circular convolution ; Finding the maximum size between the two input sequence sizes ; Copying elements of x to row_vec and padding zeros if size of x < maxSize ; Copying elements of h to col_vec and padding zeros if size of h is less than maxSize ; Generating 2D matrix of circularly shifted elements ; Computing result by matrix multiplication and printing results ; Driver program",
        "Category": "Matrix"
    },
    {
        "ID": "5581-5581",
        "Code": "def max_palindrome ( s , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s [ i ] ) % 2 != 0 ) : NEW_LINE INDENT flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT z = 0 ; o = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( s [ i ] ) ) : NEW_LINE INDENT if ( s [ i ] [ j ] == '0' ) : NEW_LINE INDENT z += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 ; NEW_LINE DEDENT DEDENT DEDENT if ( o % 2 == 0 and z % 2 == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT return n - 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE s = [ \"1110\" , \"100110\" , \"010101\" ] ; NEW_LINE print ( max_palindrome ( s , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize the number of palindromic Strings | Python3 program for the above approach ; To check if there is any string of odd length ; If there is at least 1 string of odd length . ; If all the strings are of even length . ; Count of 0 's in all  the strings ; Count of 1 's in  all the strings ; If z is even and o is even then ans will be N . ; Otherwise ans will be N - 1. ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "5601-5601",
        "Code": "def valueofX ( ar , n ) : NEW_LINE INDENT summ = sum ( ar ) NEW_LINE if ( summ % n == 0 ) : NEW_LINE INDENT return summ // n NEW_LINE DEDENT else : NEW_LINE INDENT A = summ // n NEW_LINE B = summ // n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the minimum value of X for an expression | Function to calculate value of X ; Check for both possibilities ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5602-5602",
        "Code": "def minLength ( n ) : NEW_LINE INDENT ans = n // 26 NEW_LINE if ( n % 26 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def minString ( n ) : NEW_LINE INDENT ans = n // 26 NEW_LINE res = \" \" NEW_LINE while ( ans ) : NEW_LINE INDENT res = res + \" z \" NEW_LINE ans -= 1 NEW_LINE DEDENT if ( n % 26 != 0 ) : NEW_LINE INDENT res = res + chr ( ( n % 26 ) + 96 ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 50 ; NEW_LINE print ( minLength ( n ) ) NEW_LINE print ( minString ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum length String with Sum of the alphabetical values of the characters equal to N | Function to find the minimum length ; Function to find the minimum length String ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5605-5605",
        "Code": "def minCapacity ( enter , exit , n ) : NEW_LINE INDENT minCap = 0 ; NEW_LINE currCap = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT currCap = currCap + enter [ i ] - exit [ i ] ; NEW_LINE minCap = max ( minCap , currCap ) ; NEW_LINE DEDENT return minCap ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT enter = [ 3 , 5 , 2 , 0 ] ; NEW_LINE exit = [ 0 , 2 , 4 , 4 ] ; NEW_LINE n = len ( enter ) ; NEW_LINE print ( minCapacity ( enter , exit , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the minimum capacity of the train required to hold the passengers | Function to return the minimum capacity required ; To store the minimum capacity ; To store the current capacity of the train ; For every station ; Add the number of people entering the train and subtract the number of people exiting the train to get the current capacity of the train ; Update the minimum capacity ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5608-5608",
        "Code": "def lexo_small ( n , k ) : NEW_LINE INDENT arr = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr += ' a ' ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT k -= i ; NEW_LINE if ( k >= 0 ) : NEW_LINE INDENT if ( k >= 26 ) : NEW_LINE INDENT arr = arr [ : i ] + ' z ' + arr [ i + 1 : ] ; NEW_LINE k -= 26 ; NEW_LINE DEDENT else : NEW_LINE INDENT c = ( k + 97 - 1 ) ; NEW_LINE arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] ; NEW_LINE k -= ord ( arr [ i ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT k += i ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; k = 42 ; NEW_LINE arr = lexo_small ( n , k ) ; NEW_LINE print ( arr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest string of length N and sum K | Function to return the lexicographically smallest string of length n that satisfies the given condition ; Iteration from the last position in the array ; If k is a positive integer ; ' z ' needs to be inserted ; Add the required character ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5611-5611",
        "Code": "def minBinary ( n ) : NEW_LINE INDENT digit = [ 0 for i in range ( 3 ) ] NEW_LINE len = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit [ len ] = n % 10 NEW_LINE len += 1 NEW_LINE n //= 10 NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ) : NEW_LINE INDENT ans = max ( ans , digit [ i ] ) NEW_LINE DEDENT print ( \" Minimum ▁ Number ▁ of ▁ binary ▁ strings ▁ needed : \" , ans ) NEW_LINE for i in range ( 1 , ans + 1 , 1 ) : NEW_LINE INDENT num = 0 NEW_LINE for j in range ( 0 , len , 1 ) : NEW_LINE INDENT if ( digit [ j ] > 0 ) : NEW_LINE INDENT num = num * 10 + 1 NEW_LINE digit [ j ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT num *= 10 NEW_LINE DEDENT DEDENT print ( num , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 564 NEW_LINE minBinary ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of Binary strings to represent a Number | Function to find the minimum number of binary strings to represent a number ; Storing digits in correct order ; Find the maximum digit in the array ; Traverse for all the binary strings ; If digit at jth position is greater than 0 then substitute 1 ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5615-5615",
        "Code": "def StrictlyPositiveXor ( A , N ) : NEW_LINE INDENT allxor = 0 ; NEW_LINE checkallzero = True ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT allxor ^= A [ i ] ; NEW_LINE if ( A [ i ] > 0 ) : NEW_LINE INDENT checkallzero = False ; NEW_LINE DEDENT DEDENT if ( allxor != 0 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT if ( checkallzero ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT l = N ; r = - 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT l = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return max ( N - l , r - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 0 , 0 , 1 ] ; NEW_LINE N = len ( A ) ; NEW_LINE print ( StrictlyPositiveXor ( A , N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Subarray having strictly positive XOR | Function to return the length of the longest sub - array having positive XOR ; To store the XOR of all the elements ; To check if all the elements of the array are 0 s ; Take XOR of all the elements ; If any positive value is found the make the checkallzero false ; If complete array is the answer ; If all elements are equal to zero ; Initialize l and r ; First positive value of the array ; Last positive value of the array ; Maximum length among these two subarrays ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "5617-5617",
        "Code": "def find_set ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE DEDENT sum1 = ( n * ( n - 1 ) ) / 2 ; NEW_LINE sum2 = n ; NEW_LINE print ( sum1 , \" ▁ \" , sum2 ) ; NEW_LINE DEDENT n = 8 ; NEW_LINE find_set ( n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Partition first N natural number into two sets such that their sum is not coprime | Function to find the required sets ; Impossible case ; Sum of first n - 1 natural numbers ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5618-5618",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def FindMinOperation ( a , n , k ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE Q . append ( a [ i ] ) NEW_LINE Q . sort ( ) NEW_LINE ans = 0 NEW_LINE while ( True ) : NEW_LINE if ( Q [ 0 ] >= k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( len ( Q ) < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = Q [ 0 ] NEW_LINE Q . pop ( 0 ) NEW_LINE y = Q [ 0 ] NEW_LINE Q . pop ( 0 ) NEW_LINE z = ( x * y ) // gcd ( x , y ) NEW_LINE Q . append ( z ) NEW_LINE Q . sort ( ) NEW_LINE ans += 1 NEW_LINE return ans NEW_LINE DEDENT a = [ 3 , 5 , 7 , 6 , 8 ] NEW_LINE k = 8 NEW_LINE n = len ( a ) NEW_LINE print ( FindMinOperation ( a , n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum operations required to make every element greater than or equal to K | Function to calculate gcd of two numbers ; function to get minimum operation needed ; The priority queue holds a minimum element in the top position ; push value one by one from the given array ; store count of minimum operation needed ; All elements are now >= k ; It is impossible to make as there are no sufficient elements available ; Take two smallest elements and replace them by their LCM first smallest element ; Second smallest element ; Increment the count ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5619-5619",
        "Code": "def findWeights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = pow ( 3 , power + 1 ) - 1 NEW_LINE sum //= 2 NEW_LINE power += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = \" ▁ \" ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT X = 2 NEW_LINE findWeights ( X ) NEW_LINE",
        "Type": "py",
        "NL": "Find optimal weights which can be used to weigh all the weights in the range [ 1 , X ] | Function to find the optimal weights ; Number of weights required ; Finding the value of required powers of 3 ; Optimal Weights are powers of 3 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5620-5620",
        "Code": "def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) ; NEW_LINE factor = 1 ; NEW_LINE size = N ; NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = size ; NEW_LINE count_Arr [ 1 ] += factor * N ; NEW_LINE count_Arr [ end + 1 ] -= factor * N ; NEW_LINE factor += 1 ; NEW_LINE size //= 2 ; NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] ; NEW_LINE DEDENT element = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ; NEW_LINE DEDENT element . sort ( ) ; NEW_LINE start = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 ; NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] ; NEW_LINE DEDENT start += element [ i ] [ 1 ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 13 ; NEW_LINE print ( solve ( arr , N , K ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Kth smallest element in the sorted generated array | Function to return the Kth element in B [ ] ; Initialize the count Array ; Reduce N repeatedly to half its value ; Add count to start ; Subtract same count after end index ; Store each element of Array [ ] with their count ; Sort the elements wrt value ; If Kth element is in range of element [ i ] return element [ i ] ; If K is out of bound ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5624-5624",
        "Code": "def matrix_exist ( row , column , r , c ) : NEW_LINE INDENT row_sum = 0 NEW_LINE column_sum = 0 NEW_LINE row_max = - 1 NEW_LINE column_max = - 1 NEW_LINE row_non_zero = 0 NEW_LINE column_non_zero = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT row_sum += row [ i ] NEW_LINE row_max = max ( row_max , row [ i ] ) NEW_LINE if ( row [ i ] ) : NEW_LINE INDENT row_non_zero = row_non_zero + 1 NEW_LINE DEDENT DEDENT for i in range ( c ) : NEW_LINE INDENT column_sum = column_sum + column [ i ] NEW_LINE column_max = max ( column_max , column [ i ] ) NEW_LINE if ( column [ i ] ) : NEW_LINE INDENT column_non_zero = column_non_zero + 1 NEW_LINE DEDENT DEDENT if ( ( row_sum != column_sum ) or ( row_max > column_non_zero ) or ( column_max > row_non_zero ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT row = [ 2 , 2 , 2 , 2 , 2 ] NEW_LINE column = [ 5 , 5 , 0 , 0 ] NEW_LINE r = len ( row ) NEW_LINE c = len ( column ) NEW_LINE if matrix_exist ( row , column , r , c ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find if a binary matrix exists with given row and column sums | Function to check if matrix exists ; Store sum of rowsums , max of row sum number of non zero row sums ; Store sum of column sums , max of column sum number of non zero column sums ; Check condition 1 , 2 , 3 ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "5638-5638",
        "Code": "MAX = 25 ; NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] ; f = 0 ; NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 ; NEW_LINE e = e // 2 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem ; NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) ; NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) ; NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp ; NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans ; NEW_LINE sum = sum + arr [ d ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimizing array sum by applying XOR operation on all elements of the array | Python3 implementation of the approach ; Function to return the minimized sum ; To store the frequency of bit in every element ; Finding element X ; Taking XOR of elements and finding sum ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5639-5639",
        "Code": "def maxCoins ( X , Y ) : NEW_LINE INDENT if ( X < Y ) : NEW_LINE INDENT X , Y = Y , X ; NEW_LINE DEDENT coins = X ; NEW_LINE X -= 1 ; NEW_LINE coins += max ( X , Y ) ; NEW_LINE return coins ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 7 ; Y = 5 ; NEW_LINE print ( maxCoins ( X , Y ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum money that can be withdrawn in two steps | Function to return the maximum coins we can get ; Update elements such that X > Y ; Take from the maximum ; Refill ; Again , take the maximum ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5644-5644",
        "Code": "def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT s = \" abaebio \" NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count the pairs of vowels in the given string | Function that return true if character ch is a vowel ; Function to return the count of adjacent vowel pairs in the given string ; If current character and the character after it are both vowels ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "5649-5649",
        "Code": "def getSum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT isOdd = True NEW_LINE DEDENT else : NEW_LINE INDENT isOdd = False NEW_LINE DEDENT sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isOdd ) : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT isOdd = not isOdd NEW_LINE n //= 10 NEW_LINE DEDENT print ( \" Sum ▁ odd ▁ = ▁ \" , sumOdd ) NEW_LINE print ( \" Sum ▁ even ▁ = ▁ \" , sumEven ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 457892 NEW_LINE getSum ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the sum of digits of a number at even and odd places | Function to find the sum of the odd and even positioned digits in a number ; If n is odd then the last digit will be odd positioned ; To store the respective sums ; While there are digits left process ; If current digit is odd positioned ; Even positioned digit ; Invert state ; Remove last digit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5654-5654",
        "Code": "def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdeededff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the longest substring with no consecutive same letters | Function to return the length of the required sub - string ; Get the length of the string ; Iterate in the string ; Check for not consecutive ; If cnt greater than maxi ; Re - initialize ; Check after iteration is complete ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "5656-5656",
        "Code": "def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE k = 2 NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle ( arr1 , m , arr2 , n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of elements in an array whose difference with the mean of another array is less than k | Function for finding sum of elements whose diff with mean is not more than k ; Find the mean of second array ; Find sum of elements from array1 whose difference with mean is not more than k ; Return result ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "5658-5658",
        "Code": "def Minsteps ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > n ) : NEW_LINE INDENT if ( m & 1 ) : NEW_LINE INDENT m += 1 NEW_LINE ans += 1 NEW_LINE DEDENT m //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans + n - m NEW_LINE DEDENT n = 4 NEW_LINE m = 6 NEW_LINE print ( Minsteps ( n , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the minimum number of steps to reach M from N | Function to find a minimum number of steps to reach M from N ; Continue till m is greater than n ; If m is odd ; add one ; divide m by 2 ; Return the required answer ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5663-5663",
        "Code": "def Maxsum ( c1 , c2 , c3 , c4 ) : NEW_LINE INDENT sum = 0 NEW_LINE two34 = min ( c2 , min ( c3 , c4 ) ) NEW_LINE sum = two34 * 234 NEW_LINE c2 -= two34 NEW_LINE sum += min ( c2 , c1 ) * 12 NEW_LINE return sum NEW_LINE DEDENT c1 = 5 ; c2 = 2 ; c3 = 3 ; c4 = 4 NEW_LINE print ( Maxsum ( c1 , c2 , c3 , c4 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Given count of digits 1 , 2 , 3 , 4 , find the maximum sum possible | Function to find the maximum possible sum ; To store required sum ; Number of 234 's can be formed ; Sum obtained with 234 s ; Remaining 2 's ; Sum obtained with 12 s ; Return the required sum ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5668-5668",
        "Code": "def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return true NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ len ( s2 ) - 1 ] + s2 NEW_LINE s2 = s2 [ 0 : len ( s2 ) - 1 ] NEW_LINE if ( s != s2 and isPalindrome ( s2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if ( len ( s ) <= 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT max = cnt [ 0 ] NEW_LINE for i in range ( len ( cnt ) ) : NEW_LINE INDENT if cnt [ i ] > max : NEW_LINE INDENT max = cnt [ i ] NEW_LINE DEDENT DEDENT if ( max >= len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ans ( s ) == True : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" nolon \" NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cuts required to convert a palindromic string to a different palindromic string | Function to check if string is palindrome or not ; Function to check if it is possible to get result by making just one cut ; Appending last element in front ; Removing last element ; Checking whether string s2 is palindrome and different from s . ; If length is <= 3 then it is impossible ; Array to store frequency of characters ; Store count of characters in a array ; Condition for edge cases ; Return 1 if it is possible to get palindromic string in just one cut . Else we can always reached in two cuttings . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5669-5669",
        "Code": "def solveEven ( s ) : NEW_LINE INDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT ls = s [ 0 : len ( s ) // 2 ] NEW_LINE rs = s [ len ( s ) // 2 : len ( s ) ] NEW_LINE if ls != rs : NEW_LINE INDENT return 1 NEW_LINE DEDENT return solveEven ( ls ) NEW_LINE DEDENT def solveOdd ( s ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if max ( cnt ) >= len ( s ) - 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if len ( s ) % 2 == 0 : NEW_LINE INDENT return solveEven ( s ) NEW_LINE DEDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT return solveOdd ( s ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" nolon \" NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cuts required to convert a palindromic string to a different palindromic string | Recursive function to find minimum number of cuts if length of string is even ; If length is odd then return 2 ; To check if half of palindromic string is itself a palindrome ; If not then return 1 ; Else call function with half palindromic string ; Function to find minimum number of cuts If length of string is odd ; If length is <= 3 then it is impossible ; Array to store frequency of characters ; Store count of characters in a array ; Condition for edge cases ; If length is even ; If length is odd ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5674-5674",
        "Code": "def findArray ( N , P ) : NEW_LINE INDENT ans = ( P * ( P + 1 ) ) // 2 + ( N - P ) ; NEW_LINE arr = [ 0 ] * ( N + 1 ) ; NEW_LINE for i in range ( 1 , P + 1 ) : NEW_LINE INDENT arr [ i ] = i ; NEW_LINE DEDENT for i in range ( P + 1 , N + 1 ) : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE DEDENT print ( \" The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ \" , ans ) ; NEW_LINE print ( \" The ▁ Array ▁ Elements ▁ are : ▁ \" ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT N = 5 ; NEW_LINE P = 3 ; NEW_LINE findArray ( N , P ) ; NEW_LINE",
        "Type": "py",
        "NL": "Generate array with minimum sum which can be deleted in P steps | Function to find the required array ; calculating minimum possible sum ; Array ; place first P natural elements ; Fill rest of the elements with 1 ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "5684-5684",
        "Code": "def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 27 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aaacaabbaa \" NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum count of sub | Function to return the count of the required sub - strings ; Iterate over all characters ; Count with current character ; If the substring has a length k then increment count with current character ; Update max count ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5686-5686",
        "Code": "import math NEW_LINE def canBePicked ( digits , num ) : NEW_LINE INDENT copyDigits = [ ] ; NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT copyDigits . append ( digits [ i ] ) ; NEW_LINE DEDENT while ( num > 0 ) : NEW_LINE INDENT digit = num % 10 ; NEW_LINE if ( copyDigits [ digit ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT copyDigits [ digit ] -= 1 ; NEW_LINE DEDENT num = math . floor ( num / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def countAlphabets ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE digits = [ 0 ] * 10 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE digits [ digit ] += 1 ; NEW_LINE n = math . floor ( n / 10 ) ; NEW_LINE DEDENT for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if ( canBePicked ( digits , i ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT for i in range ( ord ( ' A ' ) , ord ( ' Z ' ) + 1 ) : NEW_LINE INDENT if ( canBePicked ( digits , i ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT n = 1623455078 ; NEW_LINE print ( countAlphabets ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count of alphabets whose ASCII values can be formed with the digits of N | Python3 implementation of the approach ; Function that returns true if num can be formed with the digits in digits [ ] array ; Copy of the digits array ; Get last digit ; If digit array doesn 't contain  current digit ; One occurrence is used ; Remove the last digit ; Function to return the count of required alphabets ; To store the occurrences of digits ( 0 - 9 ) ; Get last digit ; Update the occurrence of the digit ; Remove the last digit ; If any lowercase character can be picked from the current digits ; If any uppercase character can be picked from the current digits ; Return the required count of alphabets ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "5688-5688",
        "Code": "def max ( a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def smallestSide ( a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE side1 = a [ 0 ] + a [ 3 ] NEW_LINE side2 = a [ 1 ] + a [ 2 ] NEW_LINE side3 = a [ 0 ] + a [ 1 ] NEW_LINE side4 = a [ 2 ] + a [ 3 ] NEW_LINE side11 = max ( side1 , side2 ) NEW_LINE side12 = max ( side3 , side4 ) NEW_LINE sideOfSquare = max ( side11 , side12 ) NEW_LINE return sideOfSquare NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT side = [ 0 for i in range ( 4 ) ] NEW_LINE print ( \" Test ▁ Case ▁ 1\" ) NEW_LINE side [ 0 ] = 2 NEW_LINE side [ 1 ] = 2 NEW_LINE side [ 2 ] = 2 NEW_LINE side [ 3 ] = 2 NEW_LINE print ( smallestSide ( side ) ) NEW_LINE print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE print ( \" Test ▁ Case ▁ 2\" ) NEW_LINE side [ 0 ] = 100000000000000 NEW_LINE side [ 1 ] = 123450000000000 NEW_LINE side [ 2 ] = 987650000000000 NEW_LINE side [ 3 ] = 987654321000000 NEW_LINE print ( smallestSide ( side ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the Side of the smallest Square that can contain given 4 Big Squares | Function to find the maximum of two values ; Function to find the smallest side of the suitable suitcase ; sort array to find the smallest and largest side of suitcases ; side of the suitcase will be smallest if they arranged in 2 x 2 way so find all possible sides of that arrangement ; since suitcase should be square so find maximum of all four side ; now find greatest side and that will be the smallest square ; return the result ; Driver Code ; Get the side of the 4 small squares ; Find the smallest side ; Get the side of the 4 small squares ; Find the smallest side",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5689-5689",
        "Code": "import math as mt NEW_LINE def find_rectangle ( area ) : NEW_LINE INDENT l , b = 0 , 0 NEW_LINE M = mt . ceil ( mt . sqrt ( area ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( M , 0 , - 1 ) : NEW_LINE INDENT if ( area % i == 0 ) : NEW_LINE INDENT l = ( area // i ) NEW_LINE b = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" l ▁ = \" , l , \" , ▁ b ▁ = \" , b ) NEW_LINE DEDENT area = 99 NEW_LINE find_rectangle ( area ) NEW_LINE",
        "Type": "py",
        "NL": "Rectangle with minimum possible difference between the length and the width | Python3 implementation of the approach ; Function to print the length ( l ) and breadth ( b ) of the rectangle having area = N and | l - b | as minimum as possible ; i is a factor ; l >= sqrt ( area ) >= i ; so here l is + ve always ; Here l and b are length and breadth of the rectangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5694-5694",
        "Code": "def greatestKBits ( X , K ) : NEW_LINE INDENT set_bit_count = bin ( X ) . count ( '1' ) NEW_LINE if ( set_bit_count <= K ) : NEW_LINE INDENT return X NEW_LINE DEDENT diff = set_bit_count - K NEW_LINE for i in range ( 0 , diff , 1 ) : NEW_LINE INDENT X &= ( X - 1 ) NEW_LINE DEDENT return X NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 21 NEW_LINE K = 2 NEW_LINE print ( greatestKBits ( X , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest number less than X having at most K set bits | Function to return the greatest number <= X having at most K set bits . ; Remove rightmost set bits one by one until we count becomes k ; Return the required number ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5696-5696",
        "Code": "def numberOfLines ( S , widths ) : NEW_LINE INDENT if ( S == \" \" ) : NEW_LINE INDENT return 0 , 0 NEW_LINE DEDENT lines , width = 1 , 0 NEW_LINE for c in S : NEW_LINE INDENT w = widths [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE width += w NEW_LINE if width > 10 : NEW_LINE INDENT lines += 1 NEW_LINE width = w NEW_LINE DEDENT DEDENT return lines , width NEW_LINE DEDENT S = \" bbbcccdddaa \" NEW_LINE Widths = [ 4 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE print ( numberOfLines ( S , Widths ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of lines required to write the given String | Function to return the number of lines required ; If string is empty ; Initialize lines and width ; Iterate through S ; Return lines and width used ; Driver Code ; Function call to print required answer",
        "Category": "Array"
    },
    {
        "ID": "5703-5703",
        "Code": "def check_distribution ( n , k , age , candy ) : NEW_LINE INDENT mxage = max ( age ) + 1 NEW_LINE mxcandy = max ( candy ) + 1 NEW_LINE fr1 = [ 0 ] * mxage NEW_LINE fr2 = [ 0 ] * mxcandy NEW_LINE for j in range ( n ) : NEW_LINE INDENT fr1 [ age [ j ] ] += 1 NEW_LINE DEDENT for j in range ( k ) : NEW_LINE INDENT fr2 [ candy [ j ] ] += 1 NEW_LINE DEDENT k = 0 NEW_LINE Tf = True NEW_LINE for j in range ( mxage ) : NEW_LINE INDENT if ( fr1 [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = False NEW_LINE while ( k < mxcandy ) : NEW_LINE INDENT if ( fr1 [ j ] <= fr2 [ k ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT k = k + 1 NEW_LINE if ( flag == False ) : NEW_LINE INDENT Tf = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( Tf ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT age = [ 5 , 15 , 10 ] NEW_LINE candy = [ 2 , 2 , 2 , 3 , 3 , 4 ] NEW_LINE n = len ( age ) NEW_LINE k = len ( candy ) NEW_LINE check_distribution ( n , k , age , candy ) NEW_LINE",
        "Type": "py",
        "NL": "Distribution of candies according to ages of students | Function to check The validity of distribution ; Stroring the max age of all students + 1 ; Stroring the max candy + 1 ; creating the frequency array of the age of students ; Creating the frequency array of the packets of candies ; pointer to tell whether we have reached the end of candy frequency array ; Flag to tell if distribution is possible or not ; Flag to tell if we can choose some candy packets for the students with age j ; If the quantity of packets is greater than or equal to the number of students of age j , then we can choose these packets for the students ; Start searching from k + 1 in next operation ; If we cannot choose any packets then the answer is NO ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5705-5705",
        "Code": "def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while power <= n : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT n = 11 ; k = 2 NEW_LINE print ( find_sum ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of first N natural numbers which are not powers of K | Function to return the sum of first n natural numbers which are not positive powers of k ; sum of first n natural numbers ; subtract all positive powers of k which are less than n ; next power of k ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5707-5707",
        "Code": "from math import gcd as __gcd NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( __gcd ( gcd , sum - gcd ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( \" a ▁ = \" , min ( gcd , sum - gcd ) , \" , ▁ b ▁ = \" , sum - min ( gcd , sum - gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find two numbers whose sum and GCD are given | Python 3 program to find two numbers whose sum and GCD is given ; Function to find two numbers whose sum and gcd is given ; sum != gcd checks that both the numbers are positive or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5708-5708",
        "Code": "def maxLitres ( budget , plastic , glass , refund ) : NEW_LINE INDENT if glass - refund < plastic : NEW_LINE INDENT ans = max ( ( budget - refund ) // ( glass - refund ) , 0 ) NEW_LINE budget -= ans * ( glass - refund ) NEW_LINE ans += budget // plastic NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( budget // plastic ) NEW_LINE DEDENT DEDENT budget , plastic , glass , refund = 10 , 11 , 9 , 8 NEW_LINE maxLitres ( budget , plastic , glass , refund ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum litres of water that can be bought with N Rupees | Python3 implementation of the above approach ; if buying glass bottles is profitable ; Glass bottles that can be bought ; Change budget according the bought bottles ; Plastic bottles that can be bought ; if only plastic bottles need to be bought ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5714-5714",
        "Code": "def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = P - a [ i ] * 0.006 NEW_LINE if abs ( t - A ) < tmp : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT N , P , A = 2 , 12 , 5 NEW_LINE a = [ 1000 , 2000 ] NEW_LINE print ( leastValue ( P , A , N , a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find number from given list for which value of the function is closest to A | Function to find number from given list for which value of the function is closest to A ; Stores the final index ; Declaring a variable to store the minimum absolute difference ; Finding F ( n ) ; Updating the index of the answer if new absolute difference is less than tmp ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5715-5715",
        "Code": "MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of operations required to delete all elements of the array | Python 3 implementation of the above approach ; function to find minimum operations ; sort array ; prepare hash of array ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "5725-5725",
        "Code": "def isSellingPossible ( n , a ) : NEW_LINE INDENT c25 = 0 ; NEW_LINE c50 = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] == 25 ) : NEW_LINE INDENT c25 += 1 ; NEW_LINE DEDENT elif ( a [ i ] == 50 ) : NEW_LINE INDENT c50 += 1 ; NEW_LINE if ( c25 == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT c25 -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( c50 > 0 and c25 > 0 ) : NEW_LINE INDENT c50 -= 1 ; NEW_LINE c25 -= 1 ; NEW_LINE DEDENT elif ( c25 >= 3 ) : NEW_LINE INDENT c25 -= 3 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT a = [ 25 , 25 , 50 , 100 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isSellingPossible ( n , a ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to serve customer queue with different notes | Function that returns true is selling of the tickets is possible ; Nothing to return to the customer ; Check if 25 can be returned to customer . ; Try returning one 50 and one 25 ; Try returning three 25 ; If the loop did not break , all the tickets were sold ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5727-5727",
        "Code": "' NEW_LINE def cal_minimum_time ( X ) : NEW_LINE INDENT t = 0 NEW_LINE sum = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT t = t + 1 NEW_LINE sum = sum + t ; NEW_LINE DEDENT return t ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE ans = cal_minimum_time ( n ) NEW_LINE print ( \" The ▁ minimum ▁ time ▁ required ▁ is ▁ : \" , ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum time to reach a point with + t and | returns the minimum time required to reach 'X ; Stores the minimum time ; increment ' t ' by 1 ; update the sum ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5732-5732",
        "Code": "def LengthLCP ( x , y ) : NEW_LINE INDENT fr = [ 0 ] * 26 NEW_LINE for i in range ( b ) : NEW_LINE INDENT fr [ ord ( y [ i ] ) - 97 ] += 1 NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if ( fr [ ord ( x [ i ] ) - 97 ] > 0 ) : NEW_LINE INDENT c += 1 NEW_LINE fr [ ord ( x [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT x , y = \" here \" , \" there \" NEW_LINE LengthLCP ( x , y ) NEW_LINE",
        "Type": "py",
        "NL": "Find the longest common prefix between two strings after performing swaps on second string | Python program to find the longest common prefix between two strings after performing swaps on the second string ; a = len ( x ) length of x b = len ( y ) length of y ; creating frequency array of characters of y ; storing the length of longest common prefix ; checking if the frequency of the character at position i in x in b is greater than zero or not if zero we increase the prefix count by 1 ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "5735-5735",
        "Code": "s = \" ABCdcba \" NEW_LINE u = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT u [ ord ( s [ i ] ) - 65 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT DEDENT fl = True NEW_LINE po = 0 NEW_LINE ne = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( u [ i ] > 0 ) : NEW_LINE INDENT po += u [ i ] NEW_LINE DEDENT if ( u [ i ] < 0 ) : NEW_LINE INDENT ne += u [ i ] NEW_LINE DEDENT DEDENT if ( po == 0 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 1 and ne == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif ( po == 0 and ne == - 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a string can be rearranged to form special palindrome | Driver code ; creating a list which stores the frequency of each character ; Checking if a character is uppercase or not ; Increasing by 1 if uppercase ; Decreasing by 1 if lower case ; Storing the sum of positive numbers in the frequency array ; Storing the sum of negative numbers in the frequency array ; If all character balances out then its Yes ; If there is only 1 character which does not balances then also it is Yes",
        "Category": "Hash Table"
    },
    {
        "ID": "5745-5745",
        "Code": "def printCoins ( arr , n ) : NEW_LINE INDENT oddSum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT oddSum += arr [ i ] NEW_LINE DEDENT evenSum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT evenSum += arr [ i ] NEW_LINE DEDENT if oddSum > evenSum : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = 1 NEW_LINE DEDENT for i in range ( start , n , 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 8 , 15 , 3 , 7 ] NEW_LINE n = len ( arr1 ) NEW_LINE printCoins ( arr1 , n ) NEW_LINE print ( ) NEW_LINE arr2 = [ 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr2 ) NEW_LINE printCoins ( arr2 , n ) NEW_LINE print ( ) NEW_LINE arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] NEW_LINE n = len ( arr3 ) NEW_LINE printCoins ( arr3 , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Coin game of two corners ( Greedy Approach ) | Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Find sum of odd positioned coins ; Find sum of even positioned coins ; Print even or odd coins depending upon which sum is greater . ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5747-5747",
        "Code": "def countSubstrings ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE subs = 1 NEW_LINE pre = ' ' NEW_LINE for i in s : NEW_LINE INDENT if pre == i : NEW_LINE INDENT subs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT subs = 1 NEW_LINE DEDENT ans += subs NEW_LINE pre = i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT s = ' geeksforgeeks ' NEW_LINE countSubstrings ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Count substrings made up of a single distinct character | Function to count the number of substrings made up of a single distinct character ; Stores the required count ; Stores the count of substrings possible by using current character ; Stores the previous character ; Traverse the string ; If current character is same as the previous character ; Increase count of substrings possible with current character ; Reset count of substrings possible with current character ; Update count of substrings ; Update previous character ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5754-5754",
        "Code": "import bisect NEW_LINE def longestSubsequence ( a , n , q , m ) : NEW_LINE INDENT a . sort ( ) NEW_LINE Sum = 0 NEW_LINE b = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE av = Sum // ( i + 1 ) NEW_LINE b [ i ] = av + 1 NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT k = q [ i ] NEW_LINE longest = bisect . bisect_right ( b , k ) NEW_LINE print ( \" Answer ▁ to ▁ Query \" , i + 1 , \" : \" , longest ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE q = [ 4 , 2 , 1 , 5 ] NEW_LINE m = len ( q ) NEW_LINE longestSubsequence ( a , n , q , m ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest subsequence whose average is less than K | Python3 program to perform Q queries to find longest subsequence whose average is less than K ; Function to print the length for evey query ; sort array of N elements ; Array to store average from left ; Sort array of average ; number of queries ; print answer to every query using binary search ; Driver Code ; 4 queries",
        "Category": "Binary Search"
    },
    {
        "ID": "5759-5759",
        "Code": "def printKPairs ( a1 , a , size1 , size2 , k ) : NEW_LINE INDENT if ( k > ( size2 * size1 ) ) : NEW_LINE INDENT print ( \" k pairs don ' t exist \" ) NEW_LINE return NEW_LINE DEDENT _one , _two = [ 0 , 0 ] , [ 0 , 0 ] NEW_LINE cnt = 0 NEW_LINE while ( cnt < k ) : NEW_LINE INDENT if ( _one [ 0 ] == _two [ 1 ] and _two [ 0 ] == _one [ 1 ] ) : NEW_LINE INDENT if ( a1 [ _one [ 0 ] ] < a2 [ _one [ 1 ] ] ) : NEW_LINE INDENT print ( \" [ \" , a1 [ _one [ 0 ] ] , \" , ▁ \" , a2 [ _one [ 1 ] ] , \" ] ▁ \" , end = \" ▁ \" ) NEW_LINE _one [ 1 ] = ( _one [ 1 ] + 1 ) % size2 NEW_LINE INDENT _one [ 0 ] = ( _one [ 0 ] + 1 ) % size1 NEW_LINE DEDENT _two [ 1 ] = ( _two [ 1 ] + 1 ) % size2 NEW_LINE if ( _two [ 1 ] == 0 ) : NEW_LINE INDENT _two [ 0 ] = ( _two [ 0 ] + 1 ) % size2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" [ \" , a2 [ _one [ 1 ] ] , \" , ▁ \" , a1 [ _one [ 0 ] ] , \" ] ▁ \" , end = \" ▁ \" ) NEW_LINE _one [ 0 ] = ( _one [ 0 ] + 1 ) % size1 NEW_LINE INDENT _one [ 1 ] = ( _one [ 1 ] + 1 ) % size2 NEW_LINE DEDENT _two [ 0 ] = ( _two [ 0 ] + 1 ) % size2 NEW_LINE INDENT _two [ 1 ] = ( _two [ 1 ] + 1 ) % size1 NEW_LINE DEDENT DEDENT DEDENT elif ( a1 [ _one [ 0 ] ] + a2 [ _one [ 1 ] ] <= a2 [ _two [ 0 ] ] + a1 [ _two [ 1 ] ] ) : NEW_LINE INDENT if ( a1 [ _one [ 0 ] ] < a2 [ _one [ 1 ] ] ) : NEW_LINE INDENT print ( \" [ \" , a1 [ _one [ 0 ] ] , \" , ▁ \" , a2 [ _one [ 1 ] ] , \" ] ▁ \" , end = \" ▁ \" ) NEW_LINE _one [ 1 ] = ( ( _one [ 1 ] + 1 ) % size2 ) NEW_LINE INDENT _one [ 0 ] = ( _one [ 0 ] + 1 ) % size1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" [ \" , a2 [ _one [ 1 ] ] , \" , ▁ \" , a1 [ _one [ 0 ] ] , \" ] ▁ \" , end = \" ▁ \" ) NEW_LINE _one [ 0 ] = ( ( _one [ 0 ] + 1 ) % size1 ) NEW_LINE INDENT _one [ 1 ] = ( _one [ 1 ] + 1 ) % size2 NEW_LINE DEDENT DEDENT DEDENT elif ( a1 [ _one [ 0 ] ] + a2 [ _one [ 1 ] ] > a2 [ _two [ 0 ] ] + a1 [ _two [ 1 ] ] ) : NEW_LINE INDENT if ( a2 [ _two [ 0 ] ] < a1 [ _two [ 1 ] ] ) : NEW_LINE INDENT print ( \" [ \" , a2 [ _two [ 0 ] ] , \" , ▁ \" , a1 [ _two [ 1 ] ] , \" ] ▁ \" , end = \" ▁ \" ) NEW_LINE _two [ 0 ] = ( ( _two [ 0 ] + 1 ) % size2 ) NEW_LINE INDENT _two [ 1 ] = ( _two [ 1 ] + 1 ) % size1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" [ \" , a1 [ _two [ 1 ] ] , \" , ▁ \" , a2 [ _two [ 0 ] ] , \" ] ▁ \" , end = \" ▁ \" ) NEW_LINE _two [ 1 ] = ( ( _two [ 1 ] + 1 ) % size1 ) NEW_LINE INDENT _two [ 0 ] = ( _two [ 0 ] + 1 ) % size1 NEW_LINE DEDENT DEDENT DEDENT cnt += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a1 = [ 2 , 3 , 4 ] NEW_LINE a2 = [ 1 , 6 , 5 , 8 ] NEW_LINE size1 = len ( a1 ) NEW_LINE size2 = len ( a2 ) NEW_LINE k = 4 NEW_LINE printKPairs ( a1 , a2 , size1 , size2 , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find k pairs with smallest sums in two arrays | Set 2 | Function to print the K smallest pairs ; if k is greater than total pairs ; _pair _one keeps track of ' first ' in a1 and ' second ' in a2 in _two , _two [ 0 ] keeps track of element in the a2and _two [ 1 ] in a1 [ ] ; Repeat the above process till all K pairs are printed ; when both the pointers are pointing to the same elements ( po3 ) ; updates according to step 1 ; if ( _one [ 1 ] == 0 ) : see po2 ; updates opposite to step 1 ; updates according to rule 1 ; if ( _one [ 0 ] == 0 ) : see po2 ; updates opposite to rule 1 ; if ( _two [ 0 ] == 0 ) : see po2 ; else update as necessary ( po1 ) ; updating according to rule 1 ; if ( _one [ 1 ] == 0 ) : see po2 ; updating according to rule 1 ; if ( _one [ 0 ] == 0 ) : see po2 ; updating according to rule 1 ; if ( _two [ 0 ] == 0 ) : see po2 ; updating according to rule 1 ; if ( _two [ 1 ] == 0 ) : see po2 ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5760-5760",
        "Code": "def printLargest ( a , n ) : NEW_LINE INDENT max = - 1 NEW_LINE ind = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT r = num % 10 ; NEW_LINE num = num / 10 ; NEW_LINE if ( num == 0 ) : NEW_LINE INDENT if ( max < r ) : NEW_LINE INDENT max = r NEW_LINE ind = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( ind , n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) , NEW_LINE DEDENT for i in range ( 0 , ind ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 54 , 546 , 548 , 60 ] NEW_LINE n = len ( a ) NEW_LINE printLargest ( a , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number by concatenating every element in a rotation of an array | Function to print the largest number ; store the index of largest left most digit of elements ; Iterate for all numbers ; check for the last digit ; check for the largest left most digit ; print the rotation of array ; print the rotation of array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "5767-5767",
        "Code": "def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = 7 ; NEW_LINE slots = [ \"0101011\" , \"0011001\" , \"0110111\" ] ; NEW_LINE print ( findMinRooms ( slots , n , m ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Minimum rooms for m events of n batches with given schedule | Returns minimum number of rooms required to perform classes of n groups in m slots with given schedule . ; Store count of classes happening in every slot . ; initialize all values to zero ; Number of rooms required is equal to maximum classes happening in a particular slot . ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "5771-5771",
        "Code": "import math as mt NEW_LINE def preProcess ( n ) : NEW_LINE INDENT preProcessedCubes = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( 1. / 3. ) ) ) : NEW_LINE INDENT iThCube = i ** 3 NEW_LINE cubeString = str ( iThCube ) NEW_LINE preProcessedCubes . append ( cubeString ) NEW_LINE DEDENT return preProcessedCubes NEW_LINE DEDENT def findLargestCubeUtil ( num , preProcessedCubes ) : NEW_LINE INDENT preProcessedCubes = preProcessedCubes [ : : - 1 ] NEW_LINE totalCubes = len ( preProcessedCubes ) NEW_LINE for i in range ( totalCubes ) : NEW_LINE INDENT currCube = preProcessedCubes [ i ] NEW_LINE digitsInCube = len ( currCube ) NEW_LINE index = 0 NEW_LINE digitsInNumber = len ( num ) NEW_LINE for j in range ( digitsInNumber ) : NEW_LINE INDENT if ( num [ j ] == currCube [ index ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( digitsInCube == index ) : NEW_LINE INDENT return currCube NEW_LINE DEDENT DEDENT DEDENT return \" Not ▁ Possible \" NEW_LINE DEDENT def findLargestCube ( n ) : NEW_LINE INDENT preProcessedCubes = preProcess ( n ) NEW_LINE num = str ( n ) NEW_LINE ans = findLargestCubeUtil ( num , preProcessedCubes ) NEW_LINE print ( \" Largest ▁ Cube ▁ that ▁ can ▁ be ▁ formed ▁ from \" , n , \" is \" , ans ) NEW_LINE DEDENT n = 4125 NEW_LINE findLargestCube ( n ) NEW_LINE n = 876 NEW_LINE findLargestCube ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Find the Largest Cube formed by Deleting minimum Digits from a number | Python3 code to implement maximum perfect cube formed after deleting minimum digits ; Returns vector of Pre Processed perfect cubes ; convert the cube to string and push into preProcessedCubes vector ; Utility function for findLargestCube ( ) . Returns the Largest cube number that can be formed ; reverse the preProcessed cubes so that we have the largest cube in the beginning of the vector ; iterate over all cubes ; check if the current digit of the cube matches with that of the number num ; if control reaches here , the its not possible to form a perfect cube ; wrapper for findLargestCubeUtil ( ) ; pre process perfect cubes ; convert number n to String ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5778-5778",
        "Code": "import math NEW_LINE def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE print ( \" The ▁ number ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE digitsNum ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest number with sum of digits as N and divisible by 10 ^ N | Python program to find smallest number to find smallest number with N as sum of digits and divisible by 10 ^ N . ; If N = 0 the string will be 0 ; If n is not perfectly divisible by 9 output the remainder ; Print 9 N / 9 times ; Append N zero 's to the number so  as to make it divisible by 10^N ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5787-5787",
        "Code": "def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE if ( d > diff ) : NEW_LINE INDENT diff = d NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 4 ] NEW_LINE b = [ 3 , 4 , 2 , 3 , 2 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( minproduct ( a , b , n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum sum of product of two arrays | Function to find the minimum product ; Find product of current elements and update result . ; If both product and b [ i ] are negative , we must increase value of a [ i ] to minimize result . ; If both product and a [ i ] are negative , we must decrease value of a [ i ] to minimize result . ; Similar to above two cases for positive product . ; Check if current difference becomes higher than the maximum difference so far . ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "5790-5790",
        "Code": "def subsequence ( s , t , n , k ) : NEW_LINE INDENT last = 0 NEW_LINE cnt = 0 NEW_LINE new_last = 0 NEW_LINE size = 0 NEW_LINE string = ' zyxwvutsrqponmlkjihgfedcba ' NEW_LINE DEDENT ' NEW_LINE INDENT for ch in string : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( last , n ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt >= k : NEW_LINE INDENT for i in range ( last , n ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT t [ size ] = ch NEW_LINE new_last = i NEW_LINE size += 1 NEW_LINE DEDENT DEDENT last = new_last NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = [ ' b ' , ' a ' , ' n ' , ' a ' , ' n ' , ' a ' ] NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE t = [ ' ' ] * n NEW_LINE subsequence ( s , t , n - 1 , k ) NEW_LINE t = ' ' . join ( t ) NEW_LINE print ( t ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically largest subsequence such that every character occurs at least k times | Find lexicographically largest subsequence of s [ 0. . n - 1 ] such that every character appears at least k times . The result is filled in t [ ] ; Starting from largest charter ' z ' to 'a ; Counting the frequency of the character ; If frequency is greater than k ; From the last point we leave ; check if string contain ch ; If yes , append to output string ; Update the last point . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "5793-5793",
        "Code": "def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 ; NEW_LINE code_digit = unlock_code % 10 ; NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE unlock_code = int ( unlock_code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT input = 28756 ; NEW_LINE unlock_code = 98234 ; NEW_LINE print ( \" Minimum ▁ Rotation ▁ = \" , minRotation ( input , unlock_code ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Minimum rotations to unlock a circular lock | function for min rotation ; iterate till input and unlock code become 0 ; input and unlock last digit as reminder ; find min rotation ; update code and input ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5796-5796",
        "Code": "def NextFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if blockSize [ j ] >= processSize [ i ] : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( \" Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , \" ▁ \" , processSize [ i ] , end = \" ▁ \" ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Allocated \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT blockSize = [ 5 , 10 , 20 ] NEW_LINE processSize = [ 10 , 20 , 5 ] NEW_LINE m = len ( blockSize ) NEW_LINE n = len ( processSize ) NEW_LINE NextFit ( blockSize , m , processSize , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program for Next Fit algorithm in Memory Management | Function to allocate memory to blocks as per Next fit algorithm ; Initially no block is assigned to any process ; pick each process and find suitable blocks according to its size ad assign to it ; Do not start from beginning ; allocate block j to p [ i ] process ; Reduce available memory in this block . ; mod m will help in traversing the blocks from starting block after we reach the end . ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5814-5814",
        "Code": "def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += int ( a / b ) NEW_LINE rem = int ( a % b ) NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT n = 13 NEW_LINE m = 29 NEW_LINE print ( minimumSquare ( n , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Paper Cut into Minimum Number of Squares | Returns min number of squares needed ; swap if a is small size side . ; Iterate until small size side is greater then 0 ; Update result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "5830-5830",
        "Code": "def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 93 NEW_LINE print ( \" Following ▁ is ▁ minimal ▁ number \" , \" of ▁ change ▁ for \" , n , \" : ▁ \" , end = \" \" ) NEW_LINE findMin ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Greedy Algorithm to find Minimum number of Coins | Python3 program to find minimum number of denominations ; All denominations of Indian Currency ; Initialize Result ; Traverse through all denomination ; Find denominations ; Print result ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "5850-5850",
        "Code": "MOD = 1000000007 NEW_LINE from math import sqrt NEW_LINE def modPow ( x , y ) : NEW_LINE INDENT r = 1 NEW_LINE a = x NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT r = ( r * a ) % MOD NEW_LINE DEDENT a = ( a * a ) % MOD NEW_LINE y /= 2 NEW_LINE DEDENT return r NEW_LINE DEDENT def modInverse ( x ) : NEW_LINE INDENT return modPow ( x , MOD - 2 ) NEW_LINE DEDENT def modDivision ( p , q ) : NEW_LINE INDENT return ( p * modInverse ( q ) ) % MOD NEW_LINE DEDENT def C ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT p = 1 NEW_LINE q = 1 NEW_LINE for i in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT q = ( q * i ) % MOD NEW_LINE p = ( p * ( n - i + 1 ) ) % MOD NEW_LINE DEDENT return modDivision ( p , q ) NEW_LINE DEDENT def countArrays ( N , K ) : NEW_LINE INDENT res = 1 NEW_LINE for p in range ( 2 , int ( sqrt ( K ) ) , 1 ) : NEW_LINE INDENT c = 0 NEW_LINE while ( K % p == 0 ) : NEW_LINE INDENT K /= p NEW_LINE c += 1 NEW_LINE DEDENT res = ( res * C ( N - 1 + c , c ) ) % MOD NEW_LINE DEDENT if ( N > 1 ) : NEW_LINE INDENT res = ( res * N ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 5 NEW_LINE print ( countArrays ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of N | python 3 program for the above approach ; Find the value of x raised to the yth power modulo MOD ; Stores the value of x ^ y ; Iterate until y is positive ; Function to perform the Modular Multiplicative Inverse using the Fermat 's little theorem ; Modular division x / y , find modular multiplicative inverse of y and multiply by x ; Function to find Binomial Coefficient C ( n , k ) in O ( k ) time ; Base Case ; Update the value of p and q ; Function to find the count of arrays having K as the first element satisfying the given criteria ; Stores the resultant count of arrays ; Find the factorization of K ; Stores the count of the exponent of the currentprime factor ; N is one last prime factor , for c = 1 -> C ( N - 1 + 1 , 1 ) = N ; Return the totol count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "5875-5875",
        "Code": "dp = [ [ - 1 ] * 100 ] * 1000 NEW_LINE prime = [ True ] * 1005 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def countOfNumbers ( index , sum , N ) : NEW_LINE INDENT if ( index == N + 1 ) : NEW_LINE INDENT if ( prime [ sum ] == True ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT val = dp [ index ] [ sum ] NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT val = 0 NEW_LINE if ( index == 1 ) : NEW_LINE INDENT for digit in range ( ( ( 0 , 1 ) [ N == 1 ] ) + 1 , 10 , 1 ) : NEW_LINE INDENT val += countOfNumbers ( index + 1 , sum + digit , N ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for digit in range ( 0 , 10 , 1 ) : NEW_LINE INDENT val += countOfNumbers ( index + 1 , sum + digit , N ) NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT SieveOfEratosthenes ( 1000 ) NEW_LINE N = 6 NEW_LINE print ( countOfNumbers ( 1 , 0 , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count N | Stores the dp states ; Check if a number is a prime or not ; Function to generate all prime numbers that are less than or equal to n ; Base cases . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of as non - prime ; Function to find the count of N - digit numbers such that the sum of digits is a prime number ; If end of array is reached ; If the sum is equal to a prime number ; Otherwise ; If the dp - states are already computed ; If index = 1 , any digit from [ 1 - 9 ] can be placed . If N = 1 , 0 also can be placed . ; Otherwise , any digit from [ 0 - 9 ] can be placed . ; Return the answer . ; Find all primes less than or equal to 1000 , which is sufficient for N upto 100 ; Given Input ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5882-5882",
        "Code": "def dfs ( arr , left , K ) : NEW_LINE INDENT q = 0 NEW_LINE if ( left == 0 ) : NEW_LINE INDENT for i in range ( 1 , K , 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE q = max ( q , 1 + dfs ( arr , K - i , K ) ) NEW_LINE arr [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , K , 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE nleft = left - i if i <= left else K + left - i NEW_LINE q = max ( q , dfs ( arr , nleft , K ) ) NEW_LINE arr [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT return q NEW_LINE DEDENT def maxGroups ( K , arr , n ) : NEW_LINE INDENT V = [ 0 for i in range ( K ) ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT V [ arr [ x ] % K ] += 1 NEW_LINE DEDENT ans = V [ 0 ] + dfs ( V , 0 , K ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( maxGroups ( K , arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of groups that can receive fresh donuts distributed in batches of size K | Recursive function to find the maximum number of groups that will receive fresh donuts ; Store the result for the current state ; Check if the leftover donuts from the previous batch is 0 ; If true , then one by one give the fresh donuts to each group ; Decrement arr [ i ] ; Update the maximum number of groups ; Increment arr [ i ] ; Otherwise , traverse the given array , arr [ ] ; Decrement arr [ i ] ; Update the maximum number of groups ; Increment arr [ i ] ; Return the value of q ; Function to find the maximum number of groups that will receive fresh donuts ; Stores count of remainder by K ; Traverse the array arr [ ] ; Stores maximum number of groups ; Return the answer ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "5892-5892",
        "Code": "def Count ( N , L , R ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( R - L + 1 ) ] for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ( dp [ 0 ] ) ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 NEW_LINE DEDENT ans = dp [ 0 ] [ R - L ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , len ( dp [ 0 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT ans += dp [ i ] [ R - L ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE L = 6 NEW_LINE R = 9 NEW_LINE print ( Count ( N , L , R ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Total count of sorted numbers upto N digits in range [ L , R ] ( Magnificent necklace combinatorics problem ) | Function to count total number of ways ; Stores all DP - states ; Stores the result ; Traverse the range [ 0 , N ] ; Traverse the range [ 1 , R - L ] ; Update dp [ i ] [ j ] ; Assign dp [ 0 ] [ R - L ] to ans ; Traverse the range [ 1 , N ] ; Traverse the range [ 1 , R - L ] ; Update dp [ i ] [ j ] ; Increment ans by dp [ i - 1 ] [ j ] ; Return ans ; Driver Code ; Input ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5897-5897",
        "Code": "def totalSubarrays ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT ans += ( ( count * ( count + 1 ) ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countSubarrays ( arr , n , k ) : NEW_LINE INDENT count1 = totalSubarrays ( arr , n , k - 1 ) NEW_LINE count2 = totalSubarrays ( arr , n , k ) NEW_LINE ans = count2 - count1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE k = 3 NEW_LINE arr = [ 2 , 1 , 3 , 4 ] NEW_LINE print ( countSubarrays ( arr , n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of subarrays with maximum value as K | Function to count the subarrays with maximum not greater than K ; If arr [ i ] > k then arr [ i ] cannot be a part of any subarray . ; Count the number of elements where arr [ i ] is not greater than k . ; Summation of all possible subarrays in the variable ans . ; Function to count the subarrays with maximum value is equal to K ; Stores count of subarrays with max <= k - 1. ; Stores count of subarrays with max >= k + 1. ; Stores count of subarrays with max = k . ; Driver Code ; Given Input ; Function Call",
        "Category": "Sliding Window"
    },
    {
        "ID": "5900-5900",
        "Code": "from typing import Mapping NEW_LINE MAX = 30 NEW_LINE def findNumString ( X , Y , dp ) : NEW_LINE INDENT for i in range ( 0 , MAX ) : NEW_LINE INDENT for j in range ( 0 , MAX ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , X + 1 ) : NEW_LINE INDENT for j in range ( 0 , Y + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def kthString ( X , Y , K , dp ) : NEW_LINE INDENT x1 = \" \" NEW_LINE y1 = \" \" NEW_LINE for i in range ( 0 , Y ) : NEW_LINE INDENT x1 += ' b ' NEW_LINE DEDENT for i in range ( 0 , X ) : NEW_LINE INDENT y1 += ' a ' NEW_LINE DEDENT if ( X == 0 ) : NEW_LINE INDENT return x1 NEW_LINE DEDENT if ( Y == 0 ) : NEW_LINE INDENT return y1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( K <= dp [ X - 1 ] [ Y ] ) : NEW_LINE INDENT return \" a \" + kthString ( X - 1 , Y , K , dp ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT return \" b \" + kthString ( X , Y - 1 , K - dp [ X - 1 ] [ Y ] , dp ) NEW_LINE DEDENT DEDENT def kthStringUtil ( X , Y , K ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for col in range ( MAX ) ] NEW_LINE findNumString ( X , Y , dp ) NEW_LINE print ( kthString ( X , Y , K , dp ) ) NEW_LINE DEDENT X = 4 NEW_LINE Y = 3 NEW_LINE K = 4 NEW_LINE kthStringUtil ( X , Y , K ) NEW_LINE",
        "Type": "py",
        "NL": "Lexicographically Kth | Python3 program for the above approach ; Function to fill dp array ; Initialize all the entries with 0 ; Update dp [ 0 ] [ 0 ] to 1 ; Traverse the dp array ; Update the value of dp [ i ] [ j ] ; Recursive function to find the Kth lexicographical smallest string ; Handle the base cases ; If there are more than or equal to K strings which start with a , then the first character is 'a ; Otherwise the first character of the resultant string is 'b ; Function to find the Kth lexicographical smallest string ; Function call to fill the dp array ; Print the resultant ; Given Input ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5914-5914",
        "Code": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def kvowelwords ( N , K ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE MOD = 1000000007 NEW_LINE dp = [ [ 0 for i in range ( K + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE sum = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = sum * 21 NEW_LINE dp [ i ] [ 0 ] %= MOD NEW_LINE sum = dp [ i ] [ 0 ] NEW_LINE for j in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == i ) : NEW_LINE INDENT dp [ i ] [ j ] = power ( 5 , i , MOD ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] * 5 NEW_LINE DEDENT dp [ i ] [ j ] %= MOD NEW_LINE sum += dp [ i ] [ j ] NEW_LINE sum %= MOD NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( kvowelwords ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of distinct words of size N with at most K contiguous vowels | Power function to calculate long powers with mod ; Function for finding number of ways to create string with length N and atmost K contiguous vowels ; Array dp to store number of ways ; dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] . . dp [ i - 1 ] [ k ] ) * 21 ; Now setting sum to be dp [ i ] [ 0 ] ; If j > i , no ways are possible to create a string with length i and vowel j ; If j = i all the character should be vowel ; dp [ i ] [ j ] relation with dp [ i - 1 ] [ j - 1 ] ; Adding dp [ i ] [ j ] in the sum ; Driver Code ; Input ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5918-5918",
        "Code": "def maxSumWO3Consec ( A , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return A [ 0 ] + A [ 1 ] NEW_LINE DEDENT third = A [ 0 ] NEW_LINE second = third + A [ 1 ] NEW_LINE first = max ( second , A [ 1 ] + A [ 2 ] ) NEW_LINE sum = max ( max ( third , second ) , first ) NEW_LINE for i in range ( 3 , N , 1 ) : NEW_LINE INDENT sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) NEW_LINE third = second NEW_LINE second = first NEW_LINE first = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 3000 , 2000 , 1000 , 3 , 10 ] NEW_LINE N = len ( A ) NEW_LINE print ( maxSumWO3Consec ( A , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum subsequence sum such that no three are consecutive in O ( 1 ) space | Function to calculate the maximum subsequence sum such that no three elements are consecutive ; when N is 1 , answer would be the only element present ; when N is 2 , answer would be sum of elements ; variable to store sum up to i - 3 ; variable to store sum up to i - 2 ; variable to store sum up to i - 1 ; variable to store the final sum of the subsequence ; find the maximum subsequence sum up to index i ; update first , second and third ; return ans ; ; Driver code ; Input ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5923-5923",
        "Code": "def countPairs ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE ans = 0 NEW_LINE M = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] in M : NEW_LINE INDENT M [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT M [ arr [ i ] ] = [ i ] NEW_LINE DEDENT DEDENT for key , value in M . items ( ) : NEW_LINE INDENT v = value NEW_LINE sum1 = 0 NEW_LINE for j in range ( len ( v ) ) : NEW_LINE INDENT ans += ( sum1 * ( N - v [ j ] ) ) NEW_LINE sum1 += v [ j ] + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 1 ] NEW_LINE countPairs ( arr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count unordered pairs of equal elements for all subarrays | Function to count all pairs ( i , j ) such that arr [ i ] equals arr [ j ] in all possible subarrays of the array ; Stores the size of the array ; Stores the positions of all the distinct elements ; Append index corresponding to arr [ i ] in the map ; Traverse the map M ; Traverse the array ; Update the value of ans ; Update the value of the sum ; Print the value of ans ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "5933-5933",
        "Code": "def maximumStonesUtil ( arr , n , i , dp ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ i ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = - 2 ** 31 NEW_LINE ans = max ( ans , arr [ i ] - maximumStonesUtil ( arr , n , i + 1 , dp ) ) NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ i + 1 ] - maximumStonesUtil ( arr , n , i + 2 , dp ) ) NEW_LINE DEDENT if ( i + 2 < n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ i + 1 ] + arr [ i + 2 ] - maximumStonesUtil ( arr , n , i + 3 , dp ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def maximumStones ( arr , n ) : NEW_LINE INDENT dp = [ - 1 ] * n NEW_LINE res = maximumStonesUtil ( arr , n , 0 , dp ) NEW_LINE if ( res > 0 ) : NEW_LINE INDENT return \" Player1\" NEW_LINE DEDENT elif ( res < 0 ) : NEW_LINE INDENT return \" Player2\" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Tie \" NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumStones ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the winner of a game of removing at most 3 stones from a pile in each turn | Function to find the maximum score of Player 1 ; Base Case ; If the result is already computed , then return the result ; Variable to store maximum score ; Pick one stone ; Pick 2 stones ; Pick 3 stones ; Return the score of the player ; Function to find the winner of the game ; Create a 1D table , dp of size N ; Store the result ; Player 1 wins ; PLayer 2 wins ; Tie ; Given Input ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5935-5935",
        "Code": "def findNthNum ( N ) : NEW_LINE INDENT last_num = 0 NEW_LINE left = 1 NEW_LINE right = N NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = left + ( right - left ) // 2 NEW_LINE t = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( t < N ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT elif ( t == N ) : NEW_LINE INDENT a = mid NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT t = a - 1 NEW_LINE b = N - ( t * ( t + 1 ) ) // 2 - 1 NEW_LINE print ( ( 1 << a ) + ( 1 << b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 15 NEW_LINE findNthNum ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Nth natural number with exactly two bits set | Set 2 | Function to find the Nth number with exactly two bits set ; Initialize variables ; Initialize the range in which the value of ' a ' is present ; Perform Binary Search ; Find the mid value ; Update the range using the mid value t ; Find b value using a and N ; Print the value 2 ^ a + 2 ^ b ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "5940-5940",
        "Code": "def maxSum ( arr , i , n , prev , is_selected , dp ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT cur = abs ( arr [ i ] ) % 2 NEW_LINE if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT if ( i == n - 1 and is_selected == 0 ) : NEW_LINE INDENT dp [ i ] [ prev ] = arr [ i ] NEW_LINE return dp [ i ] [ prev ] NEW_LINE DEDENT if ( cur != prev ) : NEW_LINE INDENT dp [ i ] [ prev ] = arr [ i ] + maxSum ( arr , i + 1 , n , cur , 1 , dp ) NEW_LINE DEDENT dp [ i ] [ prev ] = max ( dp [ i ] [ prev ] , maxSum ( arr , i + 1 , n , prev , is_selected , dp ) ) NEW_LINE return dp [ i ] [ prev ] NEW_LINE DEDENT def maxSumUtil ( arr , n ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( 100 ) ] NEW_LINE print ( maxSum ( arr , 0 , n , 2 , 0 , dp ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 8 , - 5 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE maxSumUtil ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum Sum Subsequence made up of consecutive elements of different parity | Function to calculate the maximum sum subsequence with consecutive terms having different parity ; Base Case ; Store the parity of number at the ith position ; If the dp state has already been calculated , return it ; If the array is traversed and no element has been selected yet then select the current element ; If the parity of the current and previously selected element are different , then select the current element ; Skip the current element and move to the next element ; Return the result ; Function to calculate the maximum sum subsequence with consecutive terms having different parity ; Initialize the dp [ ] array with - 1 ; Initially the prev value is set to say 2 , as the first element can anyways be selected ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5952-5952",
        "Code": "def isUnique ( s ) : NEW_LINE INDENT return True if len ( set ( s ) ) == 1 else False NEW_LINE DEDENT def maxScore ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT mx = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT sub = s [ i : j + 1 ] NEW_LINE if isUnique ( sub ) : NEW_LINE INDENT mx = max ( mx , a [ len ( sub ) - 1 ] + maxScore ( s [ : i ] + s [ j + 1 : ] , a ) ) NEW_LINE DEDENT DEDENT DEDENT return mx NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"011\" NEW_LINE a = [ 1 , 3 , 1 ] NEW_LINE print ( maxScore ( s , a ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum score possible by removing substrings made up of single distinct character | Function to check if the string s consists of a single distinct character or not ; Function to calculate the maximum score possible by removing substrings ; If string is empty ; If length of string is 1 ; Store the maximum result ; Try to remove all substrings that satisfy the condition and check for resultant string after removal ; Store the substring { s [ i ] , . . , s [ j ] } ; Check if the substring contains only a single distinct character ; Return the maximum score ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "5958-5958",
        "Code": "def lisOtimised ( s ) : NEW_LINE INDENT dp = [ 0 ] * 30 NEW_LINE N = len ( s ) NEW_LINE lis = - 10 ** 9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE curr = 0 NEW_LINE for j in range ( val ) : NEW_LINE INDENT curr = max ( curr , dp [ j ] ) NEW_LINE DEDENT curr += 1 NEW_LINE lis = max ( lis , curr ) NEW_LINE dp [ val ] = max ( dp [ val ] , curr ) NEW_LINE DEDENT return lis NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" fdryutiaghfse \" NEW_LINE print ( lisOtimised ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of longest increasing subsequence in a string | Function to find length of longest increasing subsequence in a string ; Stores at every i - th index , the length of the longest increasing subsequence ending with character i ; Size of string ; Stores the length of LIS ; Iterate over each character of the string ; Store position of the current character ; Stores the length of LIS ending with current character ; Check for all characters less then current character ; Include current character ; Update length of longest increasing subsequence ; Updating LIS for current character ; Return the length of LIS ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5960-5960",
        "Code": "import sys NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for i in range ( 100 ) ] for i in range ( 100 ) ] NEW_LINE def minSumDifference ( arr , n , k1 , k2 , sum1 , sum2 ) : NEW_LINE INDENT global dp NEW_LINE if ( n < 0 ) : NEW_LINE INDENT if ( k1 == 0 and k2 == 0 ) : NEW_LINE INDENT return abs ( sum1 - sum2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return sys . maxsize + 1 NEW_LINE DEDENT DEDENT if ( dp [ n ] [ sum1 ] [ sum2 ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ sum1 ] [ sum2 ] NEW_LINE DEDENT op1 = sys . maxsize + 1 NEW_LINE op2 = sys . maxsize + 1 NEW_LINE op3 = sys . maxsize + 1 NEW_LINE if ( k1 > 0 ) : NEW_LINE INDENT op1 = minSumDifference ( arr , n - 1 , k1 - 1 , k2 , sum1 + arr [ n ] , sum2 ) NEW_LINE DEDENT if ( k2 > 0 ) : NEW_LINE INDENT op2 = minSumDifference ( arr , n - 1 , k1 , k2 - 1 , sum1 , sum2 + arr [ n ] ) NEW_LINE DEDENT op3 = minSumDifference ( arr , n - 1 , k1 , k2 , sum1 , sum2 ) NEW_LINE dp [ n ] [ sum1 ] [ sum2 ] = min ( op1 , min ( op2 , op3 ) ) NEW_LINE return dp [ n ] [ sum1 ] [ sum2 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 6 , 7 , 17 ] NEW_LINE K = 2 NEW_LINE N = len ( arr ) NEW_LINE print ( minSumDifference ( arr , N - 1 , K , K , 0 , 0 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize difference between sum of two K | Python3 program for the above approach ; Stores the values at recursive states ; Function to find the minimum difference between sum of two K - length subsets ; Base Case ; If k1 and k2 are 0 , then return the absolute difference between sum1 and sum2 ; Otherwise , return INT_MAX ; If the result is already computed , return the result ; Store the 3 options ; Including the element in first subset ; Including the element in second subset ; Not including the current element in both the subsets ; Store minimum of 3 values obtained ; Return the value for the current states ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5964-5964",
        "Code": "def printMinimumRemovals ( s , X ) : NEW_LINE INDENT N = len ( s ) NEW_LINE M = len ( X ) NEW_LINE dp = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( s [ 0 ] == X [ j ] ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s [ i ] == X [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 NEW_LINE if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N - 1 ] [ M - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" btagd \" NEW_LINE X = \" bad \" NEW_LINE printMinimumRemovals ( s , X ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize removals to remove another string as a subsequence of a given string | Function to print the minimum number of character removals required to remove X as a subsequence from the string str ; Length of the string str ; Length of the string X ; Stores the dp states ; Fill first row of dp [ ] [ ] ; If X [ j ] matches with str [ 0 ] ; If s [ i ] is equal to X [ j ] ; Update state after removing str [ i [ ; Update state after keeping str [ i ] ; If str [ i ] is not equal to X [ j ] ; Print the minimum number of characters removals ; Driver Code ; Input ; Function call to get minimum number of character removals",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5987-5987",
        "Code": "dp = [ [ [ - 1 for i in range ( 5005 ) ] for i in range ( 12 ) ] for i in range ( 12 ) ] NEW_LINE def findCountUtil ( N , maxDigit , position , previous , count ) : NEW_LINE INDENT global dp NEW_LINE if ( position == N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = dp [ position ] [ previous ] [ count ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( count == 0 and previous != i ) : NEW_LINE INDENT ans = ( ans + ( findCountUtil ( N , maxDigit , position + 1 , i , maxDigit [ i ] - 1 ) ) % 1000000007 ) % 1000000007 NEW_LINE DEDENT elif ( count != 0 ) : NEW_LINE INDENT ans = ( ans + ( findCountUtil ( N , maxDigit , position + 1 , i , count - 1 if ( previous == i and position != 0 ) else maxDigit [ i ] - 1 ) ) % 1000000007 ) % 1000000007 NEW_LINE DEDENT DEDENT dp [ position ] [ previous ] [ count ] = ans NEW_LINE return ans NEW_LINE DEDENT def findCount ( N , maxDigit ) : NEW_LINE INDENT ans = findCountUtil ( N , maxDigit , 0 , 0 , 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE maxDigit = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE findCount ( N , maxDigit ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count possible N | DP array for memoization ; Utility function to count N digit numbers with digit i not appearing more than max_digit [ i ] consecutively ; If number with N digits is generated ; Create a reference variable ; Check if the current state is already computed before ; Initialize ans as zero ; Check if count of previous digit has reached zero or not ; Fill current position only with digits that are unequal to previous digit ; Else set the value of count for this new digit accordingly from max_digit [ ] ; Function to count N digit numbers with digit i not appearing more than max_digit [ i ] consecutive times ; Stores the final count ; Print the total count ; Driver Code ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "5993-5993",
        "Code": "def prodOfDigit ( N ) : NEW_LINE INDENT res = 1 NEW_LINE while ( N ) : NEW_LINE INDENT res = res * ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def cntNumRange ( L , R , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( prodOfDigit ( i ) == K ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R , K = 20 , 10000 , 14 NEW_LINE print ( cntNumRange ( L , R , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers from a given range whose product of digits is K | Function to find the product of digits of a number ; Stores product of digits of N ; Update res ; Update N ; Function to count numbers in the range [ 0 , X ] whose product of digit is K ; Stores count of numbers in the range [ L , R ] whose product of digit is K ; Iterate over the range [ L , R ] ; If product of digits of i equal to K ; Update cnt ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "6002-6002",
        "Code": "def countVowelPermutation ( n ) : NEW_LINE INDENT MOD = 1e9 + 7 NEW_LINE dp = [ [ 0 for i in range ( 5 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT relation = [ [ 1 ] , [ 0 , 2 ] , [ 0 , 1 , 3 , 4 ] , [ 2 , 4 ] , [ 0 ] ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for u in range ( 5 ) : NEW_LINE INDENT dp [ i + 1 ] [ u ] = 0 NEW_LINE for v in relation [ u ] : NEW_LINE INDENT dp [ i + 1 ] [ u ] += dp [ i ] [ v ] % MOD NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans = ( ans + dp [ n ] [ i ] ) % MOD NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE print ( countVowelPermutation ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count all possible N | Function to find the number of vowel permutations possible ; To avoid the large output value ; Initialize 2D dp array ; Initialize dp [ 1 ] [ i ] as 1 since string of length 1 will consist of only one vowel in the string ; Directed graph using the adjacency matrix ; Iterate over the range [ 1 , N ] ; Traverse the directed graph ; Traversing the list ; Update dp [ i + 1 ] [ u ] ; Stores total count of permutations ; Return count of permutations ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6015-6015",
        "Code": "def FindSub ( sub , ch1 , str1 , res , i ) : NEW_LINE INDENT if ( i == len ( str1 ) ) : NEW_LINE INDENT sub . add ( res ) NEW_LINE return NEW_LINE DEDENT if ( str1 [ i ] not in ch1 ) : NEW_LINE INDENT ch1 . add ( str1 [ i ] ) NEW_LINE FindSub ( sub , ch1 , str1 , res + str1 [ i ] , i + 1 ) NEW_LINE res += str1 [ i ] NEW_LINE res = res [ 0 : len ( res ) - 1 ] NEW_LINE ch1 . remove ( str1 [ i ] ) NEW_LINE DEDENT FindSub ( sub , ch1 , str1 , res , i + 1 ) NEW_LINE DEDENT def printSubwithUniquech1ar ( str1 , N ) : NEW_LINE INDENT sub = set ( ) NEW_LINE ch1 = set ( ) NEW_LINE FindSub ( sub , ch1 , str1 , \" \" , 0 ) NEW_LINE temp = [ ] NEW_LINE for substr1ing in sub : NEW_LINE temp . append ( substr1ing ) NEW_LINE temp . sort ( reverse = False ) NEW_LINE for x in temp : NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str2 = \" abac \" NEW_LINE N = len ( str2 ) NEW_LINE printSubwithUniquech1ar ( str2 , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Subsequences of given string consisting of non | Function to find all the subsequences of the str1ing with non - repeating ch1aracters ; Base case ; Insert current subsequence ; If str1 [ i ] is not present in the current subsequence ; Insert str1 [ i ] into the set ; Insert str1 [ i ] into the current subsequence ; Remove str1 [ i ] from current subsequence ; Remove str1 [ i ] from the set ; Not including str1 [ i ] from the current subsequence ; Utility function to print all subsequences of str1ing with non - repeating ch1aracters ; Stores all possible subsequences with non - repeating ch1aracters ; Stores subsequence with non - repeating ch1aracters ; Traverse all possible subsequences containing non - repeating ch1aracters ; Print subsequence ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "6016-6016",
        "Code": "N = 8 NEW_LINE def check ( memo , i , j , A ) : NEW_LINE INDENT if ( i == N - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return memo [ i ] [ j ] NEW_LINE DEDENT flag = 0 NEW_LINE for k in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ k ] - A [ i ] > j + 1 ) : NEW_LINE break NEW_LINE if ( A [ k ] - A [ i ] >= j - 1 and A [ k ] - A [ i ] <= j + 1 ) : NEW_LINE flag = check ( memo , k , A [ k ] - A [ i ] , A ) NEW_LINE if ( flag != 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT memo [ i ] [ j ] = flag NEW_LINE return memo [ i ] [ j ] NEW_LINE DEDENT def checkEndReach ( A , K ) : NEW_LINE INDENT memo = [ [ 0 ] * N ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE memo [ i ] [ j ] = - 1 NEW_LINE DEDENT startIndex = 1 NEW_LINE if ( check ( memo , startIndex , K , A ) != 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 1 , 3 , 5 , 6 , 8 , 12 , 17 ] NEW_LINE K = 1 NEW_LINE checkEndReach ( A , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if end of a sorted Array can be reached by repeated jumps of one more , one less or same number of indices as previous jump | Python3 program for the above approach ; Utility function to check if it is possible to move from index 1 to N - 1 ; Successfully reached end index ; memo [ i ] [ j ] is already calculated ; Check if there is any index having value of A [ i ] + j - 1 , A [ i ] + j or A [ i ] + j + 1 ; If A [ k ] > A [ i ] + j + 1 , can 't make a move further ; It 's possible to move A[k] ; Check is it possible to move from index k having previously taken A [ k ] - A [ i ] steps ; If yes then break the loop ; Store value of flag in memo ; Return memo [ i ] [ j ] ; Function to check if it is possible to move from index 1 to N - 1 ; Stores the memoized state ; Initialize all values as - 1 ; Initially , starting index = 1 ; Function call ; Driver Code ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6019-6019",
        "Code": "def waysToArrangeKLengthStrings ( N , K ) : NEW_LINE INDENT column_sum = [ 0 for i in range ( N + 1 ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( K + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE column_sum [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += column_sum [ j - 1 ] NEW_LINE column_sum [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( dp [ K ] [ N ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 2 NEW_LINE waysToArrangeKLengthStrings ( N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count lexicographically increasing K | Function to count K - length strings from first N alphabets ; To keep track of column sum in dp ; Auxiliary 2d dp array ; Initialize dp [ 0 ] [ i ] = 1 and update the column_sum ; Iterate for K times ; Iterate for N times ; dp [ i ] [ j ] : Stores the number of ways to form i - length strings consisting of j letters ; Update the column_sum ; Print number of ways to arrange K - length strings with N alphabets ; Driver Code ; Given N and K ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6022-6022",
        "Code": "import sys NEW_LINE def removeSmallestSubarray ( arr , S , n , k ) : NEW_LINE INDENT target_remainder = S % k NEW_LINE map1 = { } NEW_LINE map1 [ 0 ] = - 1 NEW_LINE curr_remainder = 0 NEW_LINE res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_remainder = ( curr_remainder + arr [ i ] + k ) % k NEW_LINE map1 [ curr_remainder ] = i NEW_LINE mod = ( curr_remainder - target_remainder + k ) % k NEW_LINE if ( mod in map1 ) : NEW_LINE INDENT res = min ( res , i - map1 [ mod ] ) NEW_LINE DEDENT DEDENT if ( res == sys . maxsize or res == n ) : NEW_LINE INDENT res = - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def smstSubmatDeleted ( mat , N , M , K ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT S += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT min_area = N * M NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE width = 0 NEW_LINE area = 0 NEW_LINE prefixRowSm = [ 0 ] * N NEW_LINE for left in range ( M ) : NEW_LINE INDENT prefixRowSum = [ 0 ] * N NEW_LINE for right in range ( left , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT prefixRowSum [ i ] += mat [ i ] [ right ] NEW_LINE DEDENT width = removeSmallestSubarray ( prefixRowSum , S , N , K ) NEW_LINE if ( width != - 1 ) : NEW_LINE INDENT area = ( right - left + 1 ) * ( width ) NEW_LINE if ( area < min_area ) : NEW_LINE INDENT min_area = area NEW_LINE DEDENT DEDENT DEDENT DEDENT return min_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 6 , 2 , 6 ] , [ 3 , 2 , 8 ] , [ 2 , 5 , 3 ] ] NEW_LINE K = 3 NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE print ( smstSubmatDeleted ( mat , N , M , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest submatrix required to be removed such that sum of the remaining matrix is divisible by K | Python3 program to implement the above approach ; Function to find the length of the smallest subarray to be removed such that sum of elements is equal to S % K ; Remainder when total_sum is divided by K ; Stores curr_remainder and the most recent index at which curr_remainder has occured ; Stores required answer ; Add current element to curr_sum and take mod ; Update current remainder index ; If mod already exists in map the subarray exists ; Update res ; If not possible ; Return the result ; Function to find the smallest submatrix rqured to be deleted to make the sum of the matrix divisible by K ; Stores the sum of element of the matrix ; Traverse the matrix mat [ ] [ ] ; Update S ; Stores smallest area need to be deleted to get sum divisible by K ; Stores leftmost column of each matrix ; Stores rightmost column of each matrix ; Stores number of coulmns deleted of a matrix ; Store area of the deleted matrix ; prefixRowSum [ i ] : Store sum of sub matrix whose topmost left and bottommost right position is ( 0 , left ) ( i , right ) ; Iterate over all possible values of ( left , right ) ; Initialize all possible values of prefixRowSum [ ] to 0 ; Traverse each row from left to right column ; Update row_sum [ i ] ; Update width ; If no submatrix of the length ( right - left + 1 ) found to get the required output ; Update area ; If area is less than min_area ; Update min_area ; Driver Code ; Stores number of rows in the matrix ; Stores number of column in the matrix",
        "Category": "Sliding Window"
    },
    {
        "ID": "6027-6027",
        "Code": "dp = [ [ - 1 for x in range ( 9000 + 5 ) ] for y in range ( 1000 + 5 ) ] NEW_LINE mod = 1000000007 NEW_LINE def check ( sum , x , y ) : NEW_LINE INDENT while ( sum > 0 ) : NEW_LINE INDENT ln = sum % 10 NEW_LINE if ( ln != x and ln != y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def countNumbers ( n , x , y , sum ) : NEW_LINE INDENT global dp NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return check ( sum , x , y ) NEW_LINE DEDENT if ( dp [ n ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ sum ] % mod NEW_LINE DEDENT option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod NEW_LINE option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod NEW_LINE dp [ n ] [ sum ] = ( option1 + option2 ) % mod NEW_LINE return dp [ n ] [ sum ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE X = 1 NEW_LINE Y = 5 NEW_LINE print ( countNumbers ( N , X , Y , 0 ) % mod ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count N | Stores the value of overlapping states ; Function to check whether a number have only digits X or Y or not ; Until sum is positive ; If any digit is not X or Y then return 0 ; Return 1 ; Function to find the count of numbers that are formed by digits X and Y and whose sum of digit also have digit X or Y ; Initialize dp array ; Base Case ; Check if sum of digits formed by only X or Y ; Return the already computed ; Place the digit X at the current position ; Place the digit Y at the current position ; Update current state result ; Driver Code ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6042-6042",
        "Code": "maxN = 20 NEW_LINE dp = [ [ [ [ 0 for i in range ( maxN ) ] for j in range ( 27 ) ] for k in range ( 27 ) ] for l in range ( maxN ) ] NEW_LINE def solve ( s , n , idx , k , last , count ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ idx ] [ k ] [ ord ( last ) - ord ( ' a ' ) ] [ count ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = n + 1 NEW_LINE ans = min ( ans , solve ( s , n , idx + 1 , k - 1 , last , count ) ) NEW_LINE inc = 0 NEW_LINE if ( count == 1 or count == 9 or count == 99 ) : NEW_LINE INDENT inc = 1 NEW_LINE DEDENT if ( last == s [ idx ] ) : NEW_LINE INDENT ans = min ( ans , inc + solve ( s , n , idx + 1 , k , s [ idx ] , count + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , 1 + solve ( s , n , idx + 1 , k , s [ idx ] , 1 ) ) NEW_LINE DEDENT dp [ idx ] [ k ] [ ord ( last ) - ord ( ' a ' ) ] [ count ] = ans NEW_LINE print ( ans ) NEW_LINE return dp [ idx ] [ k ] [ ord ( last ) - ord ( ' a ' ) ] [ count ] NEW_LINE DEDENT def MinRunLengthEncoding ( s , n , k ) : NEW_LINE INDENT for i in range ( maxN ) : NEW_LINE INDENT for j in range ( 27 ) : NEW_LINE INDENT for k in range ( 27 ) : NEW_LINE INDENT for l in range ( maxN ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return solve ( s , n , 0 , k , chr ( 123 ) , 0 ) - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abbbcdcdd \" NEW_LINE N = 9 NEW_LINE K = 2 NEW_LINE print ( MinRunLengthEncoding ( S , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum length of Run Length Encoding possible by removing at most K characters from a given string | Python3 program to implement the above approach ; Function which solves the desired problem ; Base Case ; If the entire string has been traversed ; If precomputed subproblem occurred ; Minimum run length encoding by removing the current character ; Minimum run length encoding by retaining the current character ; If the current and the previous characters match ; Otherwise ; Function to return minimum run - length encoding for string s by removing atmost k characters ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6043-6043",
        "Code": "def noOfChars ( s , queries ) : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ [ 0 for i in range ( 26 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i + 1 ] [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = queries [ i ] [ 0 ] NEW_LINE r = queries [ i ] [ 1 ] NEW_LINE c = ord ( queries [ i ] [ 2 ] ) - ord ( ' a ' ) NEW_LINE print ( dp [ r ] - dp [ l - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabv \" NEW_LINE queries = [ [ 1 , 2 , ' a ' ] , [ 2 , 3 , ' b ' ] ] NEW_LINE noOfChars ( S , queries ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to count frequencies of a given character in a given range of indices | Function to prcount of char y present in the range [ l , r ] ; Length of the string ; Stores the precomputed results ; Iterate the given string ; Increment dp [ i ] [ y - ' a ' ] by 1 ; Pre - compute ; Number of queries ; Traverse each query ; Print the result for each query ; Driver Code ; Given string ; Given Queries ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6044-6044",
        "Code": "def LowerBound ( a , k , x ) : NEW_LINE INDENT l = - 1 NEW_LINE r = k NEW_LINE while ( l + 1 < r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( a [ m ] >= x ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def findLCS ( nums , N ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos = LowerBound ( nums , k , nums [ i ] ) NEW_LINE nums [ pos ] = nums [ i ] NEW_LINE if ( k == pos ) : NEW_LINE INDENT k = pos + 1 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT def minimumCost ( A , B , M , N , C ) : NEW_LINE INDENT nums = [ 0 ] * 100000 NEW_LINE index = [ - 1 ] * 100000 NEW_LINE for i in range ( N ) : NEW_LINE INDENT index [ B [ i ] ] = i NEW_LINE DEDENT k = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( index [ A [ i ] ] != - 1 ) : NEW_LINE INDENT k += 1 NEW_LINE nums [ k ] = index [ A [ i ] ] NEW_LINE DEDENT DEDENT lcs_length = findLCS ( nums , k ) NEW_LINE elements_to_be_added = N - lcs_length NEW_LINE min_cost = elements_to_be_added * C NEW_LINE print ( min_cost ) NEW_LINE DEDENT A = [ 1 , 6 , 3 , 5 , 10 ] NEW_LINE B = [ 3 , 1 , 5 ] NEW_LINE C = 2 NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE minimumCost ( A , B , M , N , C ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum cost required to rearrange a given array to make it equal to another given array | Function to find lower_bound ; Function to find length of the longest common subsequence ; Find position where element is to be inserted ; Return the length of LCS ; Function to find the minimum cost required to convert the sequence A exactly same as B ; Auxiliary array ; Stores positions of elements of A [ ] Initialize index array with - 1 ; Update the index array with index of corresponding elements of B ; Place only A 's array values  with its mapped values  into nums array ; Find LCS ; No of elements to be added in array A [ ] ; Stores minimum cost ; Print the minimum cost ; Given array A [ ] ; Given C ; Size of arr A ; Size of arr B ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "605-605",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data , next = None ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT class LinkedList : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . head = Node ( None ) NEW_LINE DEDENT def push ( self , data ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE node . next = self . head NEW_LINE self . head = node NEW_LINE DEDENT def printList ( self ) : NEW_LINE INDENT node = self . head NEW_LINE while node . next is not None : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def countNodes ( self ) : NEW_LINE INDENT count = 0 NEW_LINE node = self . head NEW_LINE while node . next is not None : NEW_LINE INDENT count += 1 NEW_LINE node = node . next NEW_LINE DEDENT return count NEW_LINE DEDENT def swapKth ( self , k ) : NEW_LINE INDENT n = self . countNodes ( ) NEW_LINE if n < k : NEW_LINE INDENT return NEW_LINE DEDENT if ( 2 * k - 1 ) == n : NEW_LINE INDENT return NEW_LINE DEDENT x = self . head NEW_LINE x_prev = Node ( None ) NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT x_prev = x NEW_LINE x = x . next NEW_LINE DEDENT y = self . head NEW_LINE y_prev = Node ( None ) NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT y_prev = y NEW_LINE y = y . next NEW_LINE DEDENT if x_prev is not None : NEW_LINE INDENT x_prev . next = y NEW_LINE DEDENT if y_prev is not None : NEW_LINE INDENT y_prev . next = x NEW_LINE DEDENT temp = x . next NEW_LINE x . next = y . next NEW_LINE y . next = temp NEW_LINE if k == 1 : NEW_LINE INDENT self . head = y NEW_LINE DEDENT if k == n : NEW_LINE INDENT self . head = x NEW_LINE DEDENT DEDENT DEDENT llist = LinkedList ( ) NEW_LINE for i in range ( 8 , 0 , - 1 ) : NEW_LINE INDENT llist . push ( i ) NEW_LINE DEDENT llist . printList ( ) NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT llist . swapKth ( i ) NEW_LINE print ( \" Modified ▁ List ▁ for ▁ k ▁ = ▁ \" , i ) NEW_LINE llist . printList ( ) NEW_LINE print ( \" \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Swap Kth node from beginning with Kth node from end in a Linked List | A Linked List node ; Utility function to insert a node at the beginning @ args : data : value of node ; Print linked list ; count number of node in linked list ; Function for swapping kth nodes from both ends of linked list ; Count nodes in linked list ; check if k is valid ; If x ( kth node from start ) and y ( kth node from end ) are same ; Find the kth node from beginning of linked list . We also find previous of kth node because we need to update next pointer of the previous . ; Similarly , find the kth node from end and its previous . kth node from end is ( n - k + 1 ) th node from beginning ; If x_prev exists , then new next of it will be y . Consider the case when y -> next is x , in this case , x_prev and y are same . So the statement \" x _ prev - > next ▁ = ▁ y \" creates a self loop . This self loop will be broken when we change y -> next . ; Same thing applies to y_prev ; Swap next pointers of x and y . These statements also break self loop if x -> next is y or y -> next is x ; Change head pointers when k is 1 or n ; Driver Code",
        "Category": "Linked List"
    },
    {
        "ID": "6051-6051",
        "Code": "def maxSum ( a , n , k ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option = maxSum ( a , n - 1 , k ) NEW_LINE if ( k >= a [ n - 1 ] ) : NEW_LINE INDENT option = max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) NEW_LINE DEDENT return option NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 50 , 10 , 20 , 30 , 40 ] NEW_LINE N = len ( arr ) NEW_LINE K = 100 NEW_LINE print ( maxSum ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum possible sum of non | Function to find the maximum sum not exceeding K possible by selecting a subset of non - adjacent elements ; Base Case ; Not selecting current element ; If selecting current element is possible ; Return answer ; Driver Code ; Given array arr [ ] ; Given K ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6053-6053",
        "Code": "def checkStr ( str , P , Q ) : NEW_LINE INDENT N = len ( str ) NEW_LINE prev = str [ 0 ] NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == prev ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == '1' and cnt >= Q ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prev == '0' and cnt >= P ) : NEW_LINE INDENT return False NEW_LINE DEDENT cnt = 1 NEW_LINE DEDENT prev = str [ i ] NEW_LINE DEDENT if ( prev == '1' and cnt >= Q ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prev == '0' and cnt >= P ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def cntBinStr ( str , N , P , Q ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE if ( lenn == N ) : NEW_LINE INDENT if ( checkStr ( str , P , Q ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT X = cntBinStr ( str + '0' , N , P , Q ) NEW_LINE Y = cntBinStr ( str + '1' , N , P , Q ) NEW_LINE return X + Y NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE P = 2 NEW_LINE Q = 3 NEW_LINE print ( cntBinStr ( \" \" , N , P , Q ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count possible binary strings of length N without P consecutive 0 s and Q consecutive 1 s | Function to check if a satisfy the given condition or not ; Stores the length of string ; Stores the previous character of the string ; Stores the count of consecutive equal characters ; Traverse the string ; If current character is equal to the previous character ; If count of consecutive 1 s is more than Q ; If count of consecutive 0 s is more than P ; Reset value of cnt ; If count of consecutive 1 s is more than Q ; If count of consecutive 0 s is more than P ; Function to count all distinct binary strings that satisfy the given condition ; Stores the length of str ; If length of str is N ; If str satisfy the given condition ; If str does not satisfy the given condition ; Append a character '0' at end of str ; Append a character '1' at end of str ; Return total count of binary strings ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "6055-6055",
        "Code": "def maxCount ( arr , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 , 1 ) : NEW_LINE INDENT table [ i ] = - 1 NEW_LINE for i in range ( 1 , V + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( arr [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - arr [ j ] ] NEW_LINE if ( sub_res != - 1 and sub_res + 1 > table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 25 , 10 , 5 ] NEW_LINE m = len ( arr ) NEW_LINE V = 30 NEW_LINE print ( f ' Maximum number of array elements required : { maxCount ( arr , m , V ) } ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize count of array elements required to obtain given sum | Function that count the maximum number of elements to obtain sum V ; Stores the maximum number of elements required to obtain V ; Base Case ; Initialize all table values as Infinite ; Find the max arr required for all values from 1 to V ; Go through all arr smaller than i ; If current coin value is less than i ; Update table [ i ] ; Return the final count ; Driver Code ; Given array ; Given sum V ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6060-6060",
        "Code": "def solve ( a , s , n , prev , mask , dp ) : NEW_LINE INDENT if ( mask == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ mask ] [ prev + 1 ] != - 1 ) : NEW_LINE INDENT return dp [ mask ] [ prev + 1 ] ; NEW_LINE DEDENT ans = 10000 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT id = ord ( s [ i ] ) - ord ( ' a ' ) ; NEW_LINE if ( check ( mask , id ) ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT ans = min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , a [ prev ] [ id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; NEW_LINE DEDENT DEDENT DEDENT dp [ mask ] [ prev + 1 ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT def check ( mask , i ) : NEW_LINE INDENT c = ( mask & ( 1 << i ) ) ; NEW_LINE return c != 0 ; NEW_LINE DEDENT def generatePermutation ( mask , n , a , s ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( n + 5 ) ] for j in range ( ( 1 << n ) + 5 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT id = ord ( s [ i ] ) - ord ( ' a ' ) ; NEW_LINE mask |= ( 1 << id ) ; NEW_LINE DEDENT print ( solve ( a , s , n , - 1 , mask , dp ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE str = \" abcde \" ; NEW_LINE mat = [ [ 0 , 5 , 1 , 5 , 3 ] , [ 4 , 0 , 9 , 4 , 2 ] , [ 7 , 9 , 0 , 10 , 7 ] , [ 1 , 2 , 8 , 0 , 2 ] , [ 3 , 9 , 7 , 7 , 0 ] ] ; NEW_LINE generatePermutation ( 0 , N , mat , str ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost to generate any permutation of the given string | Function to find the minimum cost to form any permutation of string s ; Base Case ; Return the precomputed state ; Iterate over the string and check all possible characters available for current position ; Check if character can be placed at current position ; As there is no previous character so the cost for 1 st character is 0 ; Find the cost of current character and move to next position ; Store the answer for each current state ; Function that returns True if the current bit is set ; Function that generates any permutation of the given string with minimum cost ; Initialize dp table ; Set all the bits of the current character id ; Minimum cost of generating the permutation ; Driver Code ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6065-6065",
        "Code": "def Max_Sum ( arr , K , N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE prefix = [ None ] * ( N + 1 ) NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = prefix [ i ] NEW_LINE DEDENT for i in range ( K , N + 1 ) : NEW_LINE INDENT for j in range ( i , i - K , - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j - 1 ] + prefix [ i ] - prefix [ j ] ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 12 , 22 , 18 , 34 , 12 , 25 ] NEW_LINE N = len ( arr ) NEW_LINE K = 5 NEW_LINE print ( Max_Sum ( arr , K , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum subsequence sum such that no K elements are consecutive | Function to find the maximum sum of a subsequence consisting of no K consecutive array elements ; Stores states of dp ; Stores the prefix sum ; Update the prefix sum ; Base case for i < K ; For indices less than k take all the elements ; For i >= K case ; Skip each element from i to ( i - K + 1 ) to ensure that no K elements are consecutive ; Update the current dp state ; dp [ N ] stores the maximum sum ; Driver Code ; Given array arr [ ] ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6079-6079",
        "Code": "inf = 1000000008 NEW_LINE def minSteps ( m , n ) : NEW_LINE INDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return inf NEW_LINE DEDENT min_cost = inf NEW_LINE for i in range ( 2 , m , 2 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 6 NEW_LINE N = 24 NEW_LINE minimum_cost = minSteps ( M , N ) NEW_LINE if minimum_cost == inf : NEW_LINE INDENT minimum_cost = - 1 NEW_LINE DEDENT print ( minimum_cost ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost to convert M to N by repeated addition of its even divisors | Python3 program for the above approach ; Function to find the value of minimum steps to convert m to n ; Base Case ; If n exceeds m ; Iterate through all possible even divisors of m ; If m is divisible by i , then find the minimum cost ; Add the cost to convert m to m + i and recursively call next state ; Return min_cost ; Driver Code ; Function call ; If conversion is not possible ; Print the cost",
        "Category": "Backtracking"
    },
    {
        "ID": "608-608",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def pairSum ( head , x ) : NEW_LINE INDENT first = head NEW_LINE second = head NEW_LINE while ( second . next != None ) : NEW_LINE INDENT second = second . next NEW_LINE DEDENT found = False NEW_LINE while ( first != second and second . next != first ) : NEW_LINE INDENT if ( ( first . data + second . data ) == x ) : NEW_LINE INDENT found = True NEW_LINE print ( \" ( \" , first . data , \" , \" , second . data , \" ) \" ) NEW_LINE first = first . next NEW_LINE second = second . prev NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( first . data + second . data ) < x ) : NEW_LINE INDENT first = first . next NEW_LINE DEDENT else : NEW_LINE INDENT second = second . prev NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( \" No ▁ pair ▁ found \" ) NEW_LINE DEDENT DEDENT def insert ( head , data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE if not head : NEW_LINE INDENT head = temp NEW_LINE DEDENT else : NEW_LINE INDENT temp . next = head NEW_LINE head . prev = temp NEW_LINE head = temp NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insert ( head , 9 ) NEW_LINE head = insert ( head , 8 ) NEW_LINE head = insert ( head , 6 ) NEW_LINE head = insert ( head , 5 ) NEW_LINE head = insert ( head , 4 ) NEW_LINE head = insert ( head , 2 ) NEW_LINE head = insert ( head , 1 ) NEW_LINE x = 7 NEW_LINE pairSum ( head , x ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find pairs with given sum in doubly linked list | Structure of node of doubly linked list ; Function to find pair whose sum equal to given value x . ; Set two pointers , first to the beginning of DLL and second to the end of DLL . ; To track if we find a pair or not ; The loop terminates when they cross each other ( second . next == first ) , or they become same ( first == second ) ; Pair found ; Move first in forward direction ; Move second in backward direction ; If pair is not present ; A utility function to insert a new node at the beginning of doubly linked list ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "6081-6081",
        "Code": "def minCountOfNumbers ( N ) : NEW_LINE INDENT k = N % 10 NEW_LINE z = N - ( 9 * ( 9 - k ) ) NEW_LINE if ( z >= 9 and z % 10 == 9 ) : NEW_LINE INDENT return 10 - k NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 156 NEW_LINE print ( minCountOfNumbers ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Represent a number as the sum of positive numbers ending with 9 | Function to find the minimum count of numbers ending with 9 to form N ; Extract last digit of N ; Calculate the last digit ; If the last digit satisfies the condition ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "6085-6085",
        "Code": "dp = [ [ 0 ] * 1010 ] * 1010 NEW_LINE def solve ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE r = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE if ( i > 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT if ( s [ i ] == t [ j ] ) : NEW_LINE INDENT ans = 1 NEW_LINE if ( i > 0 and j > 0 ) : NEW_LINE INDENT ans = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , ans ) NEW_LINE r = max ( r , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( n - r ) NEW_LINE DEDENT s = \" abcde \" NEW_LINE t = \" edacb \" NEW_LINE print ( solve ( s , t ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum operations to transform given string to another by moving characters to front or end | Python3 program for the above approach ; Function that finds the minimum number of steps to find the minimum characters must be moved to convert string s to t ; r = maximum value over all dp [ i ] [ j ] computed so far ; dp [ i ] [ j ] stores the longest contiguous suffix of T [ 0. . j ] that is subsequence of S [ 0. . i ] ; Update the maximum length ; Return the resulting length ; Given string s , t ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6096-6096",
        "Code": "fib = [ 0 ] * 101 NEW_LINE dp1 = [ 0 ] * 101 NEW_LINE dp2 = [ 0 ] * 101 NEW_LINE v = [ 0 ] * 101 NEW_LINE def fibonacci ( ) : NEW_LINE INDENT fib [ 1 ] = 1 NEW_LINE fib [ 2 ] = 2 NEW_LINE for i in range ( 3 , 87 + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT def find ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 87 , 0 , - 1 ) : NEW_LINE INDENT if ( num >= fib [ i ] ) : NEW_LINE INDENT v [ cnt ] = i NEW_LINE cnt += 1 NEW_LINE num -= fib [ i ] NEW_LINE DEDENT DEDENT v [ : : - 1 ] NEW_LINE dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = ( v [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , cnt ) : NEW_LINE INDENT dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] NEW_LINE dp2 [ i ] = ( ( ( v [ i ] - v [ i - 1 ] ) // 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) // 2 ) * dp1 [ i - 1 ] ) NEW_LINE DEDENT return dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] NEW_LINE DEDENT fibonacci ( ) NEW_LINE num = 13 NEW_LINE print ( find ( num ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of ways in which N can be represented as sum of Fibonacci numbers without repetition | Python3 program for the above approach ; Function to generate the fibonacci number ; First two number of fibonacci sqequence ; Function to find maximum ways to represent num as the sum of fibonacci number ; Generate the Canonical form of given number ; Reverse the number ; Base condition of dp1 and dp2 ; Iterate from 1 to cnt ; Calculate dp1 [ ] ; Calculate dp2 [ ] ; Return final ans ; Function call to generate the fibonacci numbers ; Given number ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6099-6099",
        "Code": "inf = 10000000 NEW_LINE def minCost ( a , i , j , k , prefix , dp ) : NEW_LINE INDENT if ( i >= j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT best_cost = inf NEW_LINE for pos in range ( i , j ) : NEW_LINE INDENT left = minCost ( a , i , pos , k , prefix , dp ) NEW_LINE right = minCost ( a , pos + 1 , j , k , prefix , dp ) NEW_LINE best_cost = min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) NEW_LINE DEDENT dp [ i ] [ j ] = best_cost NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT def preprocess ( a , n ) : NEW_LINE INDENT p = [ 0 ] * n NEW_LINE p [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p [ i ] = p [ i - 1 ] + a [ i ] NEW_LINE DEDENT return p NEW_LINE DEDENT def Combine ( p , i , j ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return p [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return p [ j ] - p [ i - 1 ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE a = [ 4 , 5 , 6 , 7 ] NEW_LINE k = 3 NEW_LINE dp = [ [ - 1 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE prefix = preprocess ( a , n ) NEW_LINE print ( minCost ( a , 0 , n - 1 , k , prefix , dp ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize Cost to reduce the Array to a single element by given operations | Python3 program for the above approach ; Function to minimize the cost to add the array elements to a single element ; Check if the value is already stored in the array ; Compute left subproblem ; Compute left subproblem ; Calculate minimum cost ; Store the answer to avoid recalculation ; Function to generate the cost using Prefix Sum Array technique ; Function to combine the sum of the two subproblems ; Driver Code ; Initialise dp array ; Preprocessing the array",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6100-6100",
        "Code": "def countNums ( N ) : NEW_LINE INDENT l = pow ( 10 , N - 1 ) NEW_LINE r = pow ( 10 , N ) - 1 NEW_LINE count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT xorr = 0 NEW_LINE temp = i NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT xorr = xorr ^ ( temp % 10 ) NEW_LINE temp //= 10 NEW_LINE DEDENT if ( xorr <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT N = 2 NEW_LINE countNums ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Count of N | Function to find count of N - digit numbers with single digit XOR ; Range of numbers ; Calculate XOR of digits ; If XOR <= 9 , then increment count ; Print the count ; Given number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "6117-6117",
        "Code": "N = 10 ** 5 + 5 NEW_LINE v = [ [ ] for i in range ( N ) ] NEW_LINE dp = [ 0 ] * N NEW_LINE leaves = [ 0 ] * ( N ) NEW_LINE n = 0 NEW_LINE def dfs ( a , par ) : NEW_LINE INDENT leaf = 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT leaf = 0 NEW_LINE dfs ( i [ 0 ] , a ) NEW_LINE DEDENT if ( leaf == 1 ) : NEW_LINE INDENT leaves [ a ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT leaves [ a ] += leaves [ i [ 0 ] ] NEW_LINE dp [ a ] = ( dp [ a ] + dp [ i [ 0 ] ] + leaves [ i [ 0 ] ] * i [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def dfs2 ( a , par ) : NEW_LINE INDENT for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT leafOutside = leaves [ a ] - leaves [ i [ 0 ] ] NEW_LINE dp [ i [ 0 ] ] += ( dp [ a ] - dp [ i [ 0 ] ] ) NEW_LINE dp [ i [ 0 ] ] += i [ 1 ] * ( leafOutside - leaves [ i [ 0 ] ] ) NEW_LINE leaves [ i [ 0 ] ] += leafOutside NEW_LINE dfs2 ( i [ 0 ] , a ) NEW_LINE DEDENT DEDENT def answerQueries ( queries ) : NEW_LINE INDENT dfs ( 1 , 0 ) NEW_LINE dfs2 ( 1 , 0 ) NEW_LINE for i in range ( len ( queries ) ) : NEW_LINE INDENT print ( dp [ queries [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE v [ 1 ] . append ( [ 4 , 4 ] ) NEW_LINE v [ 4 ] . append ( [ 1 , 4 ] ) NEW_LINE v [ 1 ] . append ( [ 2 , 2 ] ) NEW_LINE v [ 2 ] . append ( [ 1 , 2 ] ) NEW_LINE v [ 2 ] . append ( [ 3 , 3 ] ) NEW_LINE v [ 3 ] . append ( [ 2 , 3 ] ) NEW_LINE v [ 2 ] . append ( [ 5 , 5 ] ) NEW_LINE v [ 5 ] . append ( [ 2 , 5 ] ) NEW_LINE queries = [ 1 , 3 , 5 ] NEW_LINE answerQueries ( queries ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to find sum of distance of a given node to every leaf node in a Weighted Tree | MAX size ; Graph with { destination , weight } ; For storing the sum for ith node ; Leaves in subtree of ith . ; dfs to find sum of distance of leaves in the subtree of a node ; flag is the node is leaf or not ; Skipping if parent ; Setting flag to false ; Doing dfs call ; Doing calculation in postorder . ; If the node is leaf then we just increment the no . of leaves under the subtree of a node ; Adding num of leaves ; Calculating answer for the sum in the subtree ; dfs function to find the sum of distance of leaves outside the subtree ; Number of leaves other than the leaves in the subtree of i ; Adding the contribution of leaves outside to the ith node ; Adding the leafs outside to ith node 's leaves. ; Calculating the sum of distance of leaves in the subtree of a node assuming the root of the tree is 1 ; Calculating the sum of distance of leaves outside the subtree of node assuming the root of the tree is 1 ; Answering the queries ; Driver Code ; 1 ( 4 ) / \\ ( 2 ) / \\ 4 2 ( 5 ) / \\ ( 3 ) / \\ 5 3 ; Initialising tree",
        "Category": "Graph Theory"
    },
    {
        "ID": "6120-6120",
        "Code": "def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE Max_element = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT Max_element = max ( Max_element , matrix [ i ] [ j ] ) NEW_LINE DEDENT DEDENT freq = [ [ 0 for i in range ( Max_element + 1 ) ] for j in range ( dist ) ] NEW_LINE for i in range ( dist ) : NEW_LINE INDENT for j in range ( Max_element + 1 ) : NEW_LINE INDENT freq [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( Max_element + 1 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += total_values - maximum NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 7 , 0 , 3 , 1 , 8 , 1 , 3 ] , [ 0 , 4 , 0 , 1 , 0 , 4 , 0 ] , [ 3 , 1 , 8 , 3 , 1 , 0 , 7 ] ] NEW_LINE minChanges = countChanges ( mat , 3 , 7 ) NEW_LINE print ( minChanges ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum changes required to make each path in a matrix palindrome | Function for counting changes ; Maximum distance possible is ( n - 1 + m - 1 ) ; Stores the maximum element ; Update the maximum ; Stores frequencies of values for respective distances ; Initialize frequencies of cells as 0 ; Count frequencies of cell values in the matrix ; Increment frequency of value at distance i + j ; Store the most frequent value at i - th distance from ( 0 , 0 ) and ( N - 1 , M - 1 ) ; Calculate max frequency and total cells at distance i ; Count changes required to convert all cells at i - th distance to most frequent value ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "6125-6125",
        "Code": "dp = [ [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 2 ) ] for i in range ( 10 ) ] for j in range ( 1002 ) ] NEW_LINE def possibleNumber ( pos , previous , tight , start , N , K ) : NEW_LINE INDENT if ( pos == len ( N ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ previous ] [ tight ] [ start ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ previous ] [ tight ] [ start ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight ) : NEW_LINE INDENT upper_limit = ord ( N [ pos ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT upper_limit = 9 NEW_LINE DEDENT if ( not start ) : NEW_LINE INDENT res = possibleNumber ( pos + 1 , previous , False , False , N , K ) NEW_LINE for i in range ( 1 , upper_limit + 1 ) : NEW_LINE INDENT if ( tight and i == upper_limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_tight = 0 NEW_LINE DEDENT res += possibleNumber ( pos + 1 , i , new_tight , True , N , K ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( upper_limit + 1 ) : NEW_LINE INDENT if ( tight and i == upper_limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_tight = 0 NEW_LINE DEDENT if ( abs ( i - previous ) <= K ) : NEW_LINE INDENT res += possibleNumber ( pos + 1 , i , new_tight , True , N , K ) NEW_LINE DEDENT DEDENT DEDENT dp [ pos ] [ previous ] [ tight ] [ start ] = res NEW_LINE return dp [ pos ] [ previous ] [ tight ] [ start ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = \"20\" NEW_LINE K = 2 NEW_LINE print ( possibleNumber ( 0 , 0 , True , False , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of numbers upto N having absolute difference of at most K between any two adjacent digits | Table to store solution of each subproblem ; Function to calculate all possible numbers ; Check if position reaches end that is equal to length of N ; Check if the result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is false , means number has already become smaller so we can place any digit , otherwise N [ pos ] ; Chekc if start is false the number has not started yet ; Check if we do not start the number at pos then recur forward ; If we start the number we can place any digit from 1 to upper_limit ; Finding the new tight ; Condition if the number has already started ; We can place digit upto upperbound & absolute difference with previous digit much be atmost K ; Absolute difference atmost K ; Store the solution to this subproblem ; Driver code ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6131-6131",
        "Code": "X = 6 NEW_LINE Z = 2 NEW_LINE def existPath ( V , edges , u , v ) : NEW_LINE INDENT mat = [ [ False for i in range ( V ) ] for j in range ( V ) ] NEW_LINE for i in range ( X ) : NEW_LINE INDENT mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = True NEW_LINE DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j ] or mat [ i ] [ k ] and mat [ k ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( u >= V or v >= V ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( mat [ u ] [ v ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT V = 4 NEW_LINE edges = [ [ 0 , 2 ] , [ 0 , 1 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 2 , 0 ] , [ 3 , 3 ] ] NEW_LINE u , v = 1 , 3 NEW_LINE if ( existPath ( V , edges , u , v ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if there is a path between two vertices in a directed graph | Set 2 | Python3 program to find if there is a path between two vertices in a directed graph using Dynamic Programming ; Function to find if there is a path between two vertices in a directed graph ; dp matrix ; Set dp [ i ] [ j ] = true if there is edge between i to j ; Check for all intermediate vertex ; If vertex is invalid ; If there is a path ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6140-6140",
        "Code": "import math NEW_LINE def OddDivisorsCount ( n , q , a , Query ) : NEW_LINE INDENT DP = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( math . sqrt ( a [ i ] ) ) ; NEW_LINE if ( x * x == a [ i ] ) : NEW_LINE INDENT DP [ i ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT DP [ i ] = DP [ i - 1 ] + DP [ i ] ; NEW_LINE DEDENT l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = Query [ i ] [ 0 ] ; NEW_LINE r = Query [ i ] [ 1 ] ; NEW_LINE if ( l == 0 ) : NEW_LINE INDENT print ( DP [ r ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( DP [ r ] - DP [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE Q = 3 ; NEW_LINE arr = [ 2 , 4 , 5 , 6 , 9 ] NEW_LINE Query = [ [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] ] NEW_LINE OddDivisorsCount ( N , Q , arr , Query ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of elements having odd number of divisors in index range [ L , R ] for Q queries | Python3 program for the above approach ; Function count the number of elements having odd number of divisors ; Initialise dp [ ] array ; Precomputation ; Find the Prefix Sum ; Iterate for each query ; Find the answer for each query ; Driver code ; Given array arr [ ] ; Given Query ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6145-6145",
        "Code": "def reduceZero ( N ) : NEW_LINE INDENT dp = [ 1e9 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for c in str ( i ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - ( ord ( c ) - 48 ) ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT N = 25 NEW_LINE print ( reduceZero ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Min number of operations to reduce N to 0 by subtracting any digits from N | Function to reduce an integer N to Zero in minimum operations by removing digits from N ; Initialise dp [ ] to steps ; Iterate for all elements ; For each digit in number i ; Either select the number or do not select it ; dp [ N ] will give minimum step for N ; Given Number ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6150-6150",
        "Code": "def countStableNum ( Str , N ) : NEW_LINE INDENT count1 = [ [ 0 for j in range ( 10 ) ] for i in range ( N ) ] NEW_LINE count2 = [ [ 0 for j in range ( 10 ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count1 [ i ] [ j ] , count2 [ i ] [ j ] = 0 , 0 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count1 [ i ] [ j ] = ( count1 [ i ] [ j ] + count1 [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT count1 [ i ] [ ord ( Str [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i != N - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] NEW_LINE DEDENT DEDENT count2 [ i ] [ ord ( Str [ i ] ) - ord ( '0' ) ] = count2 [ i ] [ ord ( Str [ i ] ) - ord ( '0' ) ] + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT if ( Str [ i ] == '9' ) : NEW_LINE INDENT continue NEW_LINE DEDENT c1 = count1 [ i - 1 ] [ ord ( Str [ i ] ) - ord ( '0' ) ] NEW_LINE c2 = count2 [ i + 1 ] [ ord ( Str [ i ] ) - ord ( '0' ) + 1 ] NEW_LINE if ( c2 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) // 2 ) ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT Str = \"224353\" NEW_LINE N = len ( Str ) NEW_LINE print ( countStableNum ( Str , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of subsequences of length 4 in form ( x , x , x + 1 , x + 1 ) | Set 2 | Function to count the numbers ; Array that stores the digits from left to right ; Array that stores the digits from right to left ; Initially both array store zero ; Fill the table for count1 array ; Update the count of current character ; Fill the table for count2 array ; Update the count of cuuent character ; Variable that stores the count of the numbers ; Traverse Input string and get the count of digits from count1 and count2 array such that difference b / w digit is 1 & store it int c1 & c2 . And store it in variable c1 and c2 ; Update the ans ; Return the final count ; Given String ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6152-6152",
        "Code": "dp1 = [ 0 for i in range ( 100005 ) ] NEW_LINE dp2 = [ 0 for i in range ( 100005 ) ] NEW_LINE def dfs1 ( u , par , g , weight ) : NEW_LINE INDENT dp1 [ u ] = weight [ u ] NEW_LINE for c in g [ u ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT dfs1 ( c , u , g , weight ) NEW_LINE dp1 [ u ] += max ( 0 , dp1 ) NEW_LINE DEDENT DEDENT DEDENT def dfs2 ( u , par , g , weight ) : NEW_LINE INDENT if ( par != 0 ) : NEW_LINE INDENT maxSumAncestors = dp2 [ par ] - max ( 0 , dp1 [ u ] ) NEW_LINE dp2 [ u ] = dp1 [ u ] + max ( 0 , maxSumAncestors ) NEW_LINE DEDENT for c in g [ u ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT dfs2 ( c , u , g , weight ) NEW_LINE DEDENT DEDENT DEDENT def addEdge ( u , v , g ) : NEW_LINE INDENT g [ u ] . append ( v ) NEW_LINE g [ v ] . append ( u ) NEW_LINE DEDENT def maxSumSegments ( g , weight , n ) : NEW_LINE INDENT dfs1 ( 1 , 0 , g , weight ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp2 [ i ] = dp1 [ i ] NEW_LINE DEDENT dfs2 ( 1 , 0 , g , weight ) NEW_LINE DEDENT def printAns ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( dp2 [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE u = 0 NEW_LINE v = 0 NEW_LINE g = [ [ ] for i in range ( 100005 ) ] NEW_LINE addEdge ( 1 , 2 , g ) NEW_LINE addEdge ( 1 , 3 , g ) NEW_LINE addEdge ( 2 , 4 , g ) NEW_LINE addEdge ( 2 , 5 , g ) NEW_LINE addEdge ( 3 , 6 , g ) NEW_LINE addEdge ( 4 , 7 , g ) NEW_LINE weight = [ 0 for i in range ( n + 1 ) ] NEW_LINE weight [ 1 ] = - 8 NEW_LINE weight [ 2 ] = 9 NEW_LINE weight [ 3 ] = 7 NEW_LINE weight [ 4 ] = - 4 NEW_LINE weight [ 5 ] = 5 NEW_LINE weight [ 6 ] = - 10 NEW_LINE weight [ 7 ] = - 6 NEW_LINE maxSumSegments ( g , weight , n ) NEW_LINE printAns ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum sum possible for every node by including it in a segment of N | Stores the maximum sum possible for every node by including them in a segment with their successors ; Stores the maximum sum possible for every node by including them in a segment with their ancestors ; Store the maximum sum for every node by including it in a segment with its successors ; Update the maximum sums for each node by including them in a sequence with their ancestors ; Condition to check , if current node is not root ; Add edges ; Function to find the maximum answer for each node ; Compute the maximum sums with successors ; Store the computed maximums ; Update the maximum sums by including their ancestors ; Print the desired result ; Driver code ; Number of nodes ; Graph ; Add edges ; Weight of each node ; Compute the max sum of segments for each node ; Print the answer for every node",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6167-6167",
        "Code": "def isKPartitionPossible ( arr , N , K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( N < K ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % K != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT target = sum / K NEW_LINE dp = [ 0 for i in range ( 1 << 15 ) ] NEW_LINE for i in range ( ( 1 << N ) ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for mask in range ( ( 1 << N ) ) : NEW_LINE INDENT if ( dp [ mask ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( mask & ( 1 << i ) == 0 ) and dp [ mask ] + arr [ i ] <= target ) : NEW_LINE INDENT dp [ mask ( 1 << i ) ] = ( ( dp [ mask ] + arr [ i ] ) % target ) NEW_LINE DEDENT DEDENT DEDENT if ( dp [ ( 1 << N ) - 1 ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 5 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( isKPartitionPossible ( arr , N , K ) ) : NEW_LINE INDENT print ( \" Partitions ▁ into ▁ equal ▁ \" \\ \" sum ▁ is ▁ possible . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Partitions ▁ into ▁ equal ▁ sum ▁ \" \\ \" is ▁ not ▁ possible . \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Partition of a set into K subsets with equal sum using BitMask and DP | Function to check whether K required partitions are possible or not ; Return true as the entire array is the answer ; If total number of partitions exceeds size of the array ; If the array sum is not divisible by K ; No such partitions are possible ; Required sum of each subset ; Initialize dp array with - 1 ; Sum of empty subset is zero ; Iterate over all subsets / masks ; If current mask is invalid , continue ; Iterate over all array elements ; Check if the current element can be added to the current subset / mask ; Transition ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6168-6168",
        "Code": "MAX = 1e18 NEW_LINE v = [ [ 0 , 0 ] ] * ( 151 ) NEW_LINE dp = [ [ - 1 for i in range ( 151 ) ] for i in range ( 151 ) ] NEW_LINE def min_operation ( i , j , val , x ) : NEW_LINE INDENT if ( i == n - 1 and j == m - 1 ) : NEW_LINE INDENT if ( val > v [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE return MAX NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = v [ i ] [ j ] - val NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i == n or j == m ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE return MAX NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( val > v [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = MAX NEW_LINE return MAX NEW_LINE DEDENT tmp = v [ i ] [ j ] - val NEW_LINE tmp += min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) NEW_LINE dp [ i ] [ j ] = tmp NEW_LINE return tmp NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT ans = 10 ** 19 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT val = v [ i ] [ j ] - x * ( i + j ) NEW_LINE for ii in range ( 151 ) : NEW_LINE INDENT for jj in range ( 151 ) : NEW_LINE INDENT dp [ ii ] [ jj ] = - 1 NEW_LINE DEDENT DEDENT val = min_operation ( 0 , 0 , val , x ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE x = 3 NEW_LINE v [ 0 ] = [ 15 , 153 ] NEW_LINE v [ 1 ] = [ 135 , 17 ] NEW_LINE print ( solve ( x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost path in a Matrix by moving only on value difference of X | Python3 implementation to find the minimum number of operations required to move from ( 1 , 1 ) to ( N , M ) ; Function to find the minimum operations required to move to bottom - right cell of matrix ; Condition to check if the current cell is the bottom - right cell of the matrix ; Condition to check if the current cell is out of matrix ; Condition to check if the current indices is already computed ; Condition to check that the movement with the current value is not possible ; Recursive call to compute the number of operation required to compute the value ; Function to find the minimum number of operations required to reach the bottom - right cell ; Loop to iterate over every possible cell of the matrix ; Driver Code ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6182-6182",
        "Code": "def squareOfZeroes ( ) : NEW_LINE INDENT global matrix , cache NEW_LINE lastIdx = len ( matrix ) - 1 NEW_LINE return hasSquareOfZeroes ( 0 , 0 , lastIdx , lastIdx ) NEW_LINE DEDENT def hasSquareOfZeroes ( r1 , c1 , r2 , c2 ) : NEW_LINE INDENT global matrix , cache NEW_LINE if ( r1 >= r2 or c1 >= c2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT key = ( str ( r1 ) + ' - ' + str ( c1 ) + ' - ' + str ( r2 ) + ' - ' + str ( c2 ) ) NEW_LINE if ( key in cache ) : NEW_LINE INDENT return cache [ key ] NEW_LINE DEDENT cache [ key ] = ( isSquareOfZeroes ( r1 , c1 , r2 , c2 ) or hasSquareOfZeroes ( r1 + 1 , c1 + 1 , r2 - 1 , c2 - 1 ) ) NEW_LINE cache [ key ] = ( cache [ key ] or hasSquareOfZeroes ( r1 , c1 + 1 , r2 - 1 , c2 ) or hasSquareOfZeroes ( r1 + 1 , c1 , r2 , c2 - 1 ) ) NEW_LINE cache [ key ] = ( cache [ key ] or hasSquareOfZeroes ( r1 + 1 , c1 + 1 , r2 , c2 ) or hasSquareOfZeroes ( r1 , c1 , r2 - 1 , c2 - 1 ) ) NEW_LINE return cache [ key ] NEW_LINE DEDENT def isSquareOfZeroes ( r1 , c1 , r2 , c2 ) : NEW_LINE INDENT global matrix NEW_LINE for row in range ( r1 , r2 + 1 ) : NEW_LINE INDENT if ( matrix [ row ] [ c1 ] != 0 or matrix [ row ] [ c2 ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for col in range ( c1 , c2 + 1 ) : NEW_LINE INDENT if ( matrix [ r1 ] [ col ] != 0 or matrix [ r2 ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT cache = { } NEW_LINE matrix = [ [ 1 , 1 , 1 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 , 0 , 1 ] , [ 0 , 0 , 0 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 1 , 0 , 1 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] ] NEW_LINE ans = squareOfZeroes ( ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a matrix contains a square submatrix with 0 as boundary element | Function checks if square with all 0 's in boundary exists in the matrix ; r1 is the top row , c1 is the left col r2 is the bottom row , c2 is the right ; Function checks if the boundary of the square consists of 0 's ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "6189-6189",
        "Code": "Col = 3 ; NEW_LINE def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def sumPathCost ( grid , m , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT count = ( nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ) ; NEW_LINE sum += count * grid [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 2 ; NEW_LINE n = 2 ; NEW_LINE grid = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE print ( int ( sumPathCost ( grid , m , n ) ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of cost of all paths to reach a given cell in a Matrix | Python3 implementation to find the sum of cost of all paths to reach ( M , N ) ; Function for computing combination ; Function to find the factorial of N ; Loop to find the factorial of a given number ; Function for coumputing the sum of all path cost ; Loop to find the contribution of each ( i , j ) in the all possible ways ; Count number of times ( i , j ) visited ; Add the contribution of grid [ i ] [ j ] in the result ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "6191-6191",
        "Code": "import math NEW_LINE N = 100005 ; NEW_LINE level = [ 0 for i in range ( N ) ] NEW_LINE LG = 20 ; NEW_LINE dp = [ [ 0 for j in range ( N ) ] for i in range ( LG ) ] NEW_LINE mx = [ [ 0 for j in range ( N ) ] for i in range ( LG ) ] NEW_LINE v = [ [ ] for i in range ( N ) ] NEW_LINE n = 0 NEW_LINE def dfs_lca ( a , par , lev ) : NEW_LINE INDENT dp [ 0 ] [ a ] = par ; NEW_LINE level [ a ] = lev ; NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( i [ 0 ] == par ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT mx [ 0 ] [ i [ 0 ] ] = i [ 1 ] ; NEW_LINE dfs_lca ( i [ 0 ] , a , lev + 1 ) ; NEW_LINE DEDENT DEDENT def find_ancestor ( ) : NEW_LINE INDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ; NEW_LINE mx [ i ] [ j ] = max ( mx [ i - 1 ] [ j ] , mx [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ) ; NEW_LINE DEDENT DEDENT DEDENT def getMax ( a , b ) : NEW_LINE INDENT if ( level [ b ] < level [ a ] ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT ans = 0 ; NEW_LINE diff = level [ b ] - level [ a ] ; NEW_LINE while ( diff > 0 ) : NEW_LINE INDENT log = int ( math . log2 ( diff ) ) ; NEW_LINE ans = max ( ans , mx [ log ] [ b ] ) ; NEW_LINE b = dp [ log ] [ b ] ; NEW_LINE diff -= ( 1 << log ) ; NEW_LINE DEDENT while ( a != b ) : NEW_LINE INDENT i = int ( math . log2 ( level [ a ] ) ) ; NEW_LINE while ( i > 0 and dp [ i ] [ a ] == dp [ i ] [ b ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT ans = max ( ans , mx [ i ] [ a ] ) ; NEW_LINE ans = max ( ans , mx [ i ] [ b ] ) ; NEW_LINE a = dp [ i ] [ a ] ; NEW_LINE b = dp [ i ] [ b ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def compute_lca ( ) : NEW_LINE INDENT dfs_lca ( 1 , 0 , 0 ) ; NEW_LINE find_ancestor ( ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE v [ 1 ] . append ( [ 2 , 2 ] ) ; NEW_LINE v [ 2 ] . append ( [ 1 , 2 ] ) ; NEW_LINE v [ 1 ] . append ( [ 3 , 5 ] ) ; NEW_LINE v [ 3 ] . append ( [ 1 , 5 ] ) ; NEW_LINE v [ 3 ] . append ( [ 4 , 3 ] ) ; NEW_LINE v [ 4 ] . append ( [ 3 , 4 ] ) ; NEW_LINE v [ 3 ] . append ( [ 5 , 1 ] ) ; NEW_LINE v [ 5 ] . append ( [ 3 , 1 ] ) ; NEW_LINE compute_lca ( ) ; NEW_LINE queries = [ [ 3 , 5 ] , [ 2 , 3 ] , [ 2 , 4 ] ] NEW_LINE q = 3 ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT max_edge = getMax ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ; NEW_LINE print ( max_edge ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Maximum weighted edge in path between two nodes in an N | Python3 implementation to find the maximum weighted edge in the simple path between two nodes in N - ary Tree ; Depths of Nodes ; Parent at every 2 ^ i level ; Maximum node at every 2 ^ i level ; Graph that stores destinations and its weight ; Function to traverse the nodes using the Depth - First Search Traversal ; Condition to check if its equal to its parent then skip ; DFS Recursive Call ; Function to find the ansector ; Loop to set every 2 ^ i distance ; Loop to calculate for each node in the N - ary tree ; Storing maximum edge ; Swaping if node a is at more depth than node b because we will always take at more depth ; Difference between the depth of the two given nodes ; Changing Node B to its parent at 2 ^ i distance ; Subtracting distance by 2 ^ i ; Take both a , b to its lca and find maximum ; Loop to find the maximum 2 ^ ith parent the is different for both a and b ; Updating ans ; Changing value to its parent ; Function to compute the Least common Ansector ; Driver code ; Undirected tree ; Computing LCA",
        "Category": "Graph Theory"
    },
    {
        "ID": "62-62",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printLeaves ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT printLeaves ( root . left ) NEW_LINE if root . left is None and root . right is None : NEW_LINE INDENT print ( root . data ) , NEW_LINE DEDENT printLeaves ( root . right ) NEW_LINE DEDENT DEDENT def printBoundaryLeft ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT if ( root . left ) : NEW_LINE INDENT print ( root . data ) NEW_LINE printBoundaryLeft ( root . left ) NEW_LINE DEDENT elif ( root . right ) : NEW_LINE INDENT print ( root . data ) NEW_LINE printBoundaryLeft ( root . right ) NEW_LINE DEDENT DEDENT DEDENT def printBoundaryRight ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT if ( root . right ) : NEW_LINE INDENT printBoundaryRight ( root . right ) NEW_LINE print ( root . data ) NEW_LINE DEDENT elif ( root . left ) : NEW_LINE INDENT printBoundaryRight ( root . left ) NEW_LINE print ( root . data ) NEW_LINE DEDENT DEDENT DEDENT def printBoundary ( root ) : NEW_LINE INDENT if ( root ) : NEW_LINE INDENT print ( root . data ) NEW_LINE printBoundaryLeft ( root . left ) NEW_LINE printLeaves ( root . left ) NEW_LINE printLeaves ( root . right ) NEW_LINE printBoundaryRight ( root . right ) NEW_LINE DEDENT DEDENT root = Node ( 20 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 12 ) NEW_LINE root . left . right . left = Node ( 10 ) NEW_LINE root . left . right . right = Node ( 14 ) NEW_LINE root . right = Node ( 22 ) NEW_LINE root . right . right = Node ( 25 ) NEW_LINE printBoundary ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Boundary Traversal of binary tree | A binary tree node ; A simple function to print leaf nodes of a Binary Tree ; Print it if it is a leaf node ; A function to print all left boundary nodes , except a leaf node . Print the nodes in TOP DOWN manner ; to ensure top down order , print the node before calling itself for left subtree ; A function to print all right boundary nodes , except a leaf node . Print the nodes in BOTTOM UP manner ; to ensure bottom up order , first call for right subtree , then print this node ; A function to do boundary traversal of a given binary tree ; Print the left boundary in top - down manner ; Print all leaf nodes ; Print the right boundary in bottom - up manner ; Driver program to test above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "6201-6201",
        "Code": "from collections import defaultdict NEW_LINE def get_max_sum ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT dp = [ 0 ] * 100001 NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq [ 0 ] NEW_LINE for i in range ( 2 , 100000 + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + i * freq [ i ] ) NEW_LINE DEDENT return dp [ 100000 ] NEW_LINE DEDENT N = 3 NEW_LINE arr = [ 2 , 2 , 3 ] NEW_LINE print ( get_max_sum ( arr , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum sum subsequence with values differing by at least 2 | Python3 program to find maximum sum subsequence with values differing by at least 2 ; Function to find maximum sum subsequence such that two adjacent values elements are not selected ; Map to store the frequency of array elements ; Make a dp array to store answer upto i th value ; Base cases ; Iterate for all possible values of arr [ i ] ; Return the last value ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6208-6208",
        "Code": "def PossibleSum ( n , m , v , k ) : NEW_LINE INDENT dp = [ [ 0 ] * ( k + 1 ) for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] == 1 : NEW_LINE INDENT for d in range ( m ) : NEW_LINE INDENT if ( j + v [ i ] [ d ] ) <= k : NEW_LINE INDENT dp [ i + 1 ] [ j + v [ i ] [ d ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if dp [ n ] [ k ] == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT N = 2 NEW_LINE M = 10 NEW_LINE K = 5 NEW_LINE arr = [ [ 4 , 0 , 15 , 3 , 2 , 20 , 10 , 1 , 5 , 4 ] , [ 4 , 0 , 10 , 3 , 2 , 25 , 4 , 1 , 5 , 4 ] ] NEW_LINE PossibleSum ( N , M , arr , K ) NEW_LINE",
        "Type": "py",
        "NL": "Check if it is possible to get given sum by taking one element from each row | Function that prints whether is it possible to make sum equal to K ; Base case ; Condition if we can make sum equal to current column by using above rows ; Iterate through current column and check whether we can make sum less than or equal to k ; Printing whether is it possible or not ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "621-621",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . info = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT head = None NEW_LINE tail = None NEW_LINE def nodeInsetail ( key ) : NEW_LINE INDENT global head NEW_LINE global tail NEW_LINE p = Node ( 0 ) NEW_LINE p . info = key NEW_LINE p . next = None NEW_LINE if ( ( head ) == None ) : NEW_LINE INDENT ( head ) = p NEW_LINE ( tail ) = p NEW_LINE ( head ) . prev = None NEW_LINE return NEW_LINE DEDENT if ( ( p . info ) < ( ( head ) . info ) ) : NEW_LINE INDENT p . prev = None NEW_LINE ( head ) . prev = p NEW_LINE p . next = ( head ) NEW_LINE ( head ) = p NEW_LINE return NEW_LINE DEDENT if ( ( p . info ) > ( ( tail ) . info ) ) : NEW_LINE INDENT p . prev = ( tail ) NEW_LINE ( tail ) . next = p NEW_LINE ( tail ) = p NEW_LINE return NEW_LINE DEDENT temp = ( head ) . next NEW_LINE while ( ( temp . info ) < ( p . info ) ) : NEW_LINE INDENT temp = temp . next NEW_LINE DEDENT ( temp . prev ) . next = p NEW_LINE p . prev = temp . prev NEW_LINE temp . prev = p NEW_LINE p . next = temp NEW_LINE DEDENT def printList ( temp ) : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT print ( temp . info , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT nodeInsetail ( 30 ) NEW_LINE nodeInsetail ( 50 ) NEW_LINE nodeInsetail ( 90 ) NEW_LINE nodeInsetail ( 10 ) NEW_LINE nodeInsetail ( 40 ) NEW_LINE nodeInsetail ( 110 ) NEW_LINE nodeInsetail ( 60 ) NEW_LINE nodeInsetail ( 95 ) NEW_LINE nodeInsetail ( 23 ) NEW_LINE print ( \" Doubly linked list on printing from left to right \" ) NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Sorted insert in a doubly linked list with head and tail pointers | Linked List node ; Function to insetail new node ; If first node to be insetailed in doubly linked list ; If node to be insetailed has value less than first node ; If node to be insetailed has value more than last node ; Find the node before which we need to insert p . ; Insert new node before temp ; Function to print nodes in from left to right ; Driver program to test above functions",
        "Category": "Linked List"
    },
    {
        "ID": "6217-6217",
        "Code": "def printMatrix ( A ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT for j in range ( len ( A [ 0 ] ) ) : NEW_LINE INDENT print ( A [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def getMaxNeighbour ( A , K ) : NEW_LINE INDENT ans = A ; NEW_LINE for q in range ( 1 , K + 1 ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT for j in range ( len ( A [ 0 ] ) ) : NEW_LINE INDENT maxi = ans [ i ] [ j ] ; NEW_LINE if ( i > 0 ) : NEW_LINE INDENT maxi = max ( maxi , ans [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT maxi = max ( maxi , ans [ i ] [ j - 1 ] ) ; NEW_LINE DEDENT if ( i < len ( A ) - 1 ) : NEW_LINE INDENT maxi = max ( maxi , ans [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT if ( j < len ( A [ 0 ] ) - 1 ) : NEW_LINE INDENT maxi = max ( maxi , ans [ i ] [ j + 1 ] ) ; NEW_LINE DEDENT A [ i ] [ j ] = maxi ; NEW_LINE DEDENT DEDENT ans = A ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT B = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE printMatrix ( getMaxNeighbour ( B , 2 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum neighbor element in a matrix within distance K | Function to print the matrix ; Loop to iterate over the matrix ; Function to find the maximum neighbor within the distance of less than equal to K ; Loop to find the maximum element within the distance of less than K ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "6226-6226",
        "Code": "def maxDistance ( grid ) : NEW_LINE INDENT q = [ ] NEW_LINE M = len ( grid ) NEW_LINE N = len ( grid [ 0 ] ) NEW_LINE ans = - 1 NEW_LINE dirs = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT q . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( q ) == 0 or M * N == len ( q ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( len ( q ) > 0 ) : NEW_LINE INDENT cnt = len ( q ) NEW_LINE while ( cnt > 0 ) : NEW_LINE INDENT p = q [ 0 ] NEW_LINE q . pop ( ) NEW_LINE for Dir in dirs : NEW_LINE INDENT x = p [ 0 ] + Dir [ 0 ] NEW_LINE y = p [ 1 ] + Dir [ 1 ] NEW_LINE if ( x < 0 or x >= M or y < 0 or y >= N or grid [ x ] [ y ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( [ x , y ] ) NEW_LINE grid [ x ] [ y ] = 1 NEW_LINE DEDENT cnt -= 1 NEW_LINE DEDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ [ 0 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE print ( maxDistance ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum of all distances to the nearest 1 cell from any 0 cell in a Binary matrix | Function to find the maximum distance ; Queue to store all 1 - cells ; Grid dimensions ; Directions traversable from a given a particular cell ; If the grid contains only 0 s or only 1 s ; Access every 1 - cell ; Traverse all possible directions from the cells ; Check if the cell is within the boundaries or contains a 1 ; Driver code",
        "Category": "Breadth-First Search (BFS) is the core algorithmic technique used here, which falls under **Graph Theory**. The code performs a multi-source BFS starting from all 1-cells to compute the maximum distance to any 0"
    },
    {
        "ID": "6236-6236",
        "Code": "dp = [ [ - 1 ] * ( ( 1 << 10 ) + 5 ) ] * 5000 NEW_LINE def getmask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ] NEW_LINE for i in range ( 1 , 15 ) : NEW_LINE INDENT if val % prime [ i ] == 0 : NEW_LINE INDENT mask = mask | ( 1 << i ) NEW_LINE DEDENT DEDENT return mask NEW_LINE DEDENT def calculate ( pos , mask , a , n ) : NEW_LINE INDENT if ( ( pos == n ) or ( mask == ( 1 << n - 1 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ mask ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ mask ] NEW_LINE DEDENT size = 0 NEW_LINE size = max ( size , calculate ( pos + 1 , mask , a , n ) ) NEW_LINE if ( getmask ( a [ pos ] ) & mask ) == 0 : NEW_LINE INDENT new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) NEW_LINE size = max ( size , 1 + calculate ( pos + 1 , new_mask , a , n ) ) NEW_LINE DEDENT dp [ pos ] [ mask ] = size NEW_LINE return dp [ pos ] [ mask ] NEW_LINE DEDENT def largestSubset ( A , n ) : NEW_LINE INDENT return calculate ( 0 , 0 , A , n ) ; NEW_LINE DEDENT A = [ 2 , 3 , 13 , 5 , 14 , 6 , 7 , 11 ] NEW_LINE N = len ( A ) NEW_LINE print ( largestSubset ( A , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the length of the Largest subset such that all elements are Pairwise Coprime | Dynamic programming table ; Function to obtain the mask for any integer ; List of prime numbers till 50 ; Iterate through all prime numbers to obtain the mask ; Set this prime 's bit ON in the mask ; Return the mask value ; Function to count the number of ways ; Check if subproblem has been solved ; Excluding current element in the subset ; Check if there are no common prime factors then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6250-6250",
        "Code": "def getmask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE if val == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( val ) : NEW_LINE INDENT d = val % 10 ; NEW_LINE mask |= ( 1 << d ) NEW_LINE val = val // 10 NEW_LINE DEDENT return mask NEW_LINE DEDENT def countWays ( pos , mask , a , n ) : NEW_LINE INDENT if pos == n : NEW_LINE INDENT if mask > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ pos ] [ mask ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ mask ] NEW_LINE DEDENT count = 0 NEW_LINE count = ( count + countWays ( pos + 1 , mask , a , n ) ) NEW_LINE if ( getmask ( a [ pos ] ) & mask ) == 0 : NEW_LINE INDENT new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) NEW_LINE count = ( count + countWays ( pos + 1 , new_mask , a , n ) ) NEW_LINE DEDENT dp [ pos ] [ mask ] = count NEW_LINE return count NEW_LINE DEDENT def numberOfSubarrays ( a , n ) : NEW_LINE INDENT return countWays ( 0 , 0 , a , n ) NEW_LINE DEDENT dp = [ [ - 1 for i in range ( cols ) ] for j in range ( rows ) ] NEW_LINE print ( numberOfSubarrays ( A , N ) ) NEW_LINE N = 4 NEW_LINE A = [ 1 , 12 , 23 , 34 ] NEW_LINE rows = 5000 NEW_LINE cols = 1100 NEW_LINE",
        "Type": "py",
        "NL": "Count of subarrays of an Array having all unique digits | Function to obtain the mask for any integer ; Function to count the number of ways ; Subarray must not be empty ; If subproblem has been solved ; Excluding this element in the subarray ; If there are no common digits then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; Initializing dp ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6252-6252",
        "Code": "MAX = 100005 ; NEW_LINE totBackEdges = 0 NEW_LINE countAdj = [ 0 for i in range ( MAX ) ] NEW_LINE small = [ 0 for i in range ( MAX ) ] NEW_LINE isPossible = [ 0 for i in range ( MAX ) ] NEW_LINE depth = [ 0 for i in range ( MAX ) ] NEW_LINE adj = [ [ ] for i in range ( MAX ) ] NEW_LINE vis = [ 0 for i in range ( MAX ) ] NEW_LINE def change ( p , x ) : NEW_LINE INDENT if ( p [ 1 ] > x ) : NEW_LINE INDENT p [ 1 ] = x ; NEW_LINE DEDENT if ( p [ 0 ] > p [ 1 ] ) : NEW_LINE tmp = p [ 0 ] ; NEW_LINE p [ 0 ] = p [ 1 ] ; NEW_LINE p [ 1 ] = tmp ; NEW_LINE DEDENT def dfs ( v , p = - 1 , de = 0 ) : NEW_LINE INDENT global vis , totBackEdges NEW_LINE answer = [ 100000000 , 100000000 ] NEW_LINE depth [ v ] = de ; NEW_LINE vis [ v ] = 1 ; NEW_LINE isPossible [ v ] = 1 ; NEW_LINE for u in adj [ v ] : NEW_LINE INDENT if ( ( u ^ p ) != 0 ) : NEW_LINE INDENT if ( vis [ u ] == 0 ) : NEW_LINE INDENT x = dfs ( u , v , de + 1 ) ; NEW_LINE small [ v ] += small [ u ] ; NEW_LINE change ( answer , x [ 1 ] ) ; NEW_LINE change ( answer , x [ 0 ] ) ; NEW_LINE if ( x [ 1 ] < de ) : NEW_LINE INDENT isPossible [ v ] = 0 ; NEW_LINE DEDENT DEDENT elif ( vis [ u ] == 1 ) : NEW_LINE INDENT totBackEdges += 1 NEW_LINE countAdj [ v ] += 1 NEW_LINE countAdj [ u ] += 1 NEW_LINE small [ p ] += 1 NEW_LINE small [ u ] -= 1 NEW_LINE change ( answer , depth [ u ] ) ; NEW_LINE DEDENT DEDENT DEDENT vis [ v ] = 2 ; NEW_LINE return answer ; NEW_LINE DEDENT def minNodetoRemove ( n , edges ) : NEW_LINE INDENT for i in range ( len ( edges ) ) : NEW_LINE INDENT adj [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) ; NEW_LINE adj [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) ; NEW_LINE DEDENT global vis , totBackEdges NEW_LINE vis = [ 0 for i in range ( len ( vis ) ) ] NEW_LINE totBackEdges = 0 ; NEW_LINE for v in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( vis [ v ] == 0 ) : NEW_LINE INDENT dfs ( v ) ; NEW_LINE DEDENT DEDENT if ( totBackEdges == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT node = - 1 ; NEW_LINE for v in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( countAdj [ v ] + small [ v ] == totBackEdges ) and isPossible [ v ] != 0 ) : NEW_LINE INDENT node = v ; NEW_LINE DEDENT if ( node != - 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return node ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE edges = [ ] NEW_LINE edges . append ( [ 5 , 1 ] ) ; NEW_LINE edges . append ( [ 5 , 2 ] ) ; NEW_LINE edges . append ( [ 1 , 2 ] ) ; NEW_LINE edges . append ( [ 2 , 3 ] ) ; NEW_LINE edges . append ( [ 2 , 4 ] ) ; NEW_LINE print ( minNodetoRemove ( N , edges ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum labelled node to be removed from undirected Graph such that there is no cycle | Python3 implementation to find the minimum labelled node to be removed such that there is no cycle in the undirected graph ; Variables to store if a node V has at - most one back edge and store the depth of the node for the edge ; Function to swap the pairs of the graph ; If the second value is greater than x ; Put the pair in the ascending order internally ; Function to perform the DFS ; Initialise with the large value ; Storing the depth of this vertex ; Mark the vertex as visited ; Iterating through the graph ; If the node is a child node ; If the child node is unvisited ; Move to the child and increase the depth ; increase according to algorithm ; If the node is not having exactly K backedges ; If the child is already visited and in current dfs ( because colour is 1 ) then this is a back edge ; Increase the countAdj values ; Colour this vertex 2 as we are exiting out of dfs for this node ; Function to find the minimum labelled node to be removed such that there is no cycle in the undirected graph ; Construct the graph ; Mark visited as false for each node ; Apply dfs on all unmarked nodes ; If no backedges in the initial graph this means that there is no cycle So , return - 1 ; Iterate through the vertices and return the first node that satisfies the condition ; Check whether the count sum of small [ v ] and count is the same as the total back edges and if the vertex v can be removed ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "6254-6254",
        "Code": "N = 3 NEW_LINE M = 5 NEW_LINE Large = int ( 1e6 ) ; NEW_LINE prime = [ ] ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ True ] * ( Large + 1 ) ; NEW_LINE for p in range ( 2 , int ( Large ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , Large + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , Large + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def Display ( arr , row ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT print ( arr [ row ] [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT def countDivisorsMult ( arr ) : NEW_LINE INDENT mp = { } ; NEW_LINE row_no = 0 ; max_factor = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT no = arr [ i ] [ j ] NEW_LINE for k in range ( len ( prime ) ) : NEW_LINE INDENT while ( no > 1 and no % prime [ k ] == 0 ) : NEW_LINE INDENT no //= prime [ k ] ; NEW_LINE if prime [ k ] not in mp : NEW_LINE INDENT mp [ prime [ k ] ] = 0 NEW_LINE DEDENT mp [ prime [ k ] ] += 1 ; NEW_LINE DEDENT if ( no == 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT res = 1 ; NEW_LINE for it in mp : NEW_LINE INDENT res *= mp [ it ] ; NEW_LINE DEDENT if ( max_factor < res ) : NEW_LINE INDENT row_no = i ; NEW_LINE max_factor = res ; NEW_LINE DEDENT mp . clear ( ) ; NEW_LINE DEDENT Display ( arr , row_no ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 10 , 23 ] , [ 4 , 5 , 6 , 7 , 8 ] , [ 7 , 8 , 9 , 15 , 45 ] ] ; NEW_LINE SieveOfEratosthenes ( ) ; NEW_LINE countDivisorsMult ( arr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the row whose product has maximum count of prime factors | Python3 implementation to find the row whose product has maximum number of prime factors ; function for SieveOfEratosthenes ; Create a boolean array \" isPrime [ 0 . . N ] \" and initialize all entries it as true . A value in isPrime [ i ] will finally be false if i is not a prime , else true . ; check if isPrime [ p ] is not changed ; Update all multiples of p ; Print all isPrime numbers ; function to display the answer ; function to Count the row number of divisors in particular row multiplication ; Find count of occurrences of each prime factor ; Compute count of all divisors ; Update row number if factors of this row is max ; Clearing map to store prime factors for next row ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "6257-6257",
        "Code": "MOD = 1e9 + 7 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def calculate ( pos , g , n , k ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT return g NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT answer = ( answer % MOD + calculate ( pos + 1 , gcd ( g , i ) , n , k ) % MOD ) NEW_LINE answer %= MOD NEW_LINE DEDENT return answer NEW_LINE DEDENT def sumofGCD ( n , k ) : NEW_LINE INDENT return calculate ( 0 , 0 , n , k ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( sumofGCD ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of GCD of all possible sequences | Pyhton3 implementation of the above approach ; A recursive function that generates all the sequence and find GCD ; If we reach the sequence of length N g is the GCD of the sequence ; Initialise answer to 0 ; Placing all possible values at this position and recursively find the GCD of the sequence ; Take GCD of GCD calculated uptill now i . e . g with current element ; Take modulo to avoid overflow ; Return the final answer ; Function that finds the sum of GCD of all the subsequence of N length ; Recursive function that generates the sequence and return the GCD ; Driver code ; Function Call",
        "Category": "Backtracking"
    },
    {
        "ID": "6258-6258",
        "Code": "MOD = ( int ) ( 1e9 + 7 ) NEW_LINE def fastexpo ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE a = a % MOD NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) != 0 ) : NEW_LINE INDENT res = ( res * a ) % MOD NEW_LINE DEDENT a = a * a NEW_LINE a = a % MOD NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def sumofGCD ( n , k ) : NEW_LINE INDENT count = [ 0 ] * ( k + 1 ) NEW_LINE for g in range ( k , 0 , - 1 ) : NEW_LINE INDENT count_multiples = k // g NEW_LINE temp = fastexpo ( count_multiples , n ) NEW_LINE temp = temp % MOD NEW_LINE extra = 0 NEW_LINE for j in range ( g * 2 , k + 1 , g ) : NEW_LINE INDENT extra = extra + count [ j ] NEW_LINE extra = extra % MOD NEW_LINE DEDENT count [ g ] = temp - extra + MOD NEW_LINE count [ g ] = count [ g ] % MOD NEW_LINE DEDENT Sum = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT add = count [ i ] % MOD * i % MOD NEW_LINE add = add % MOD NEW_LINE Sum = Sum + add NEW_LINE Sum = Sum % MOD NEW_LINE DEDENT return Sum NEW_LINE DEDENT N , K = 3 , 2 NEW_LINE print ( sumofGCD ( N , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of GCD of all possible sequences | Python3 implementation of the above approach ; Function to find a ^ b in log ( b ) ; Function that finds the sum of GCD of all the subsequence of N length ; To stores the number of sequences with gcd i ; Find contribution of each gcd to happen ; To count multiples ; possible sequences with overcounting ; to avoid overflow ; Find extra element which will not form gcd = i ; Find overcounting ; Remove the overcounting ; To store the final answer ; Return Final answer ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "6264-6264",
        "Code": "def getPrimesFromSeive ( primes ) : NEW_LINE INDENT prime = [ True ] * ( 1000001 ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE i = 2 NEW_LINE while ( i * i <= 1000000 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * i , 1000001 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , 1000001 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT primes . append ( str ( i ) ) NEW_LINE DEDENT DEDENT DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT numLen = len ( number ) NEW_LINE splitDP = [ - 1 ] * ( numLen + 1 ) NEW_LINE primes = [ ] NEW_LINE getPrimesFromSeive ( primes ) NEW_LINE for i in range ( 1 , numLen + 1 ) : NEW_LINE INDENT if ( i <= 6 and ( number [ 0 : i ] in primes ) ) : NEW_LINE INDENT splitDP [ i ] = 1 NEW_LINE DEDENT if ( splitDP [ i ] != - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j <= 6 and ( i + j <= numLen ) ) : NEW_LINE INDENT if ( number [ i : i + j ] in primes ) : NEW_LINE INDENT if ( splitDP [ i + j ] == - 1 ) : NEW_LINE INDENT splitDP [ i + j ] = 1 + splitDP [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT splitDP [ i + j ] = min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return splitDP [ numLen ] NEW_LINE DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE",
        "Type": "py",
        "NL": "Split the given string into Primes : Digit DP | Function to precompute all the primes upto 1000000 and store it in a set using Sieve of Eratosthenes ; Here str ( ) is used for converting int to string ; A function to find the minimum number of segments the given string can be divided such that every segment is a prime ; Declare a splitdp [ ] array and initialize to - 1 ; Call sieve function to store primes in primes array ; Build the DP table in a bottom - up manner ; If the prefix is prime then the prefix will be found in the prime set ; If the Given Prefix can be split into Primes then for the remaining string from i to j Check if Prime . If yes calculate the minimum split till j ; To check if the substring from i to j is a prime number or not ; If it is a prime , then update the dp array ; Return the minimum number of splits for the entire string ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6266-6266",
        "Code": "M = 18 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE dp = [ [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 90 ) ] for k in range ( 90 ) ] for l in range ( M ) ] NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( curr <= 100 ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def count ( pos , even , odd , tight , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT if ( ( len ( num ) & 1 ) ) : NEW_LINE INDENT val = odd NEW_LINE odd = even NEW_LINE even = val NEW_LINE DEDENT d = even - odd NEW_LINE if ( d in fib ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ even ] [ odd ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ even ] [ odd ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( tight == 1 ) : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT else : NEW_LINE INDENT limit = num [ pos ] NEW_LINE DEDENT for d in range ( limit ) : NEW_LINE INDENT currF = tight NEW_LINE currEven = even NEW_LINE currOdd = odd NEW_LINE if ( d < num [ pos ] ) : NEW_LINE INDENT currF = 1 NEW_LINE DEDENT if ( pos & 1 ) : NEW_LINE INDENT currOdd += d NEW_LINE DEDENT else : NEW_LINE INDENT currEven += d NEW_LINE DEDENT ans += count ( pos + 1 , currEven , currOdd , currF , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num = num [ : : - 1 ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT fibonacci ( ) NEW_LINE L = 1 NEW_LINE R = 50 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) + 1 ) NEW_LINE L = 50 NEW_LINE R = 100 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) + 2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Numbers with a Fibonacci difference between Sum of digits at even and odd positions in a given range | Python3 program to count the numbers in the range having the difference between the sum of digits at even and odd positions as a Fibonacci Number ; To store all the Fibonacci numbers ; Function to generate Fibonacci numbers upto 100 ; Adding the first two Fibonacci numbers in the set ; Computing the remaining Fibonacci numbers using the first two Fibonacci numbers ; Function to return the count of required numbers from 0 to num ; Base Case ; Check if the difference is equal to any fibonacci number ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; If the current position is odd add it to currOdd , otherwise to currEven ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Driver Code ; Generate fibonacci numbers",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6268-6268",
        "Code": "import sys NEW_LINE def maximumOccurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = [ 0 ] * ( 26 ) NEW_LINE dp = [ [ 0 for i in range ( 26 ) ] for j in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = ( ord ( s [ i ] ) - ord ( ' a ' ) ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT dp [ j ] += freq [ j ] NEW_LINE DEDENT freq += 1 NEW_LINE DEDENT answer = - sys . maxsize NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT answer = max ( answer , freq [ i ] ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT answer = max ( answer , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" xxxyy \" NEW_LINE print ( maximumOccurrence ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count maximum occurrence of subsequence in string such that indices in subsequence is in A . P . | Python3 implementation to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Frequency for characters ; Loop to count the occurrence of ith character before jth character in the given String ; Increase the frequency of s [ i ] or c of String ; Maximum occurrence of subsequence of length 1 in given String ; Maximum occurrence of subsequence of length 2 in given String ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6269-6269",
        "Code": "mod = 1000000007 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for i in range ( 105 ) ] for i in range ( 1005 ) ] NEW_LINE powers = [ 0 ] * 1005 NEW_LINE powersModk = [ 0 ] * 1005 NEW_LINE def calculate ( pos , rem , z , k , n ) : NEW_LINE INDENT if ( rem == 0 and z ) : NEW_LINE INDENT if ( pos != n ) : NEW_LINE INDENT return ( powers [ n - pos - 1 ] * 9 ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( pos == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ rem ] [ z ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ rem ] [ z ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ rem ] [ z ] = count NEW_LINE return count NEW_LINE DEDENT def countNumbers ( n , k ) : NEW_LINE INDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powers [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powersModk [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT return calculate ( 0 , 0 , 0 , k , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE K = 2 NEW_LINE print ( countNumbers ( N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count the numbers with N digits and whose suffix is divisible by K | Python3 implementation to Count the numbers with N digits and whose suffix is divisible by K ; Suffix of length pos with remainder rem and Z representing whether the suffix has a non zero digit until now ; Base case ; If count of digits is less than n ; Placing all possible digits in remaining positions ; If remainder non zero and suffix has n digits ; If the subproblem is already solved ; Placing all digits at MSB of suffix and increasing it 's length by 1 ; Non zero digit is placed ; Store and return the solution to this subproblem ; Function to Count the numbers with N digits and whose suffix is divisible by K ; Since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; Since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; Initialising dp table values - 1 represents subproblem hasn 't  been solved yet  memset(dp, -1, sizeof(dp)) ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6277-6277",
        "Code": "MAX_SIZE = 100005 NEW_LINE fib = [ 0 ] * ( MAX_SIZE + 1 ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX_SIZE + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT def printLevel ( level ) : NEW_LINE INDENT left_index = pow ( 2 , level - 1 ) NEW_LINE right_index = pow ( 2 , level ) - 1 NEW_LINE for i in range ( left_index , right_index + 1 ) : NEW_LINE INDENT print ( fib [ i - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT fibonacci ( ) NEW_LINE K = 4 NEW_LINE printLevel ( K ) NEW_LINE",
        "Type": "py",
        "NL": "Find the numbers present at Kth level of a Fibonacci Binary Tree | Initializing the max value ; Array to store all the fibonacci numbers ; Function to generate fibonacci numbers using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Add the previous two numbers in the series and store it ; Function to print the Fibonacci numbers present at Kth level of a Binary Tree ; Finding the left and right index ; Iterating and printing the numbers ; Precomputing Fibonacci numbers",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "629-629",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def insertEnd ( value ) : NEW_LINE INDENT global start NEW_LINE if ( start == None ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = value NEW_LINE new_node . next = new_node . prev = new_node NEW_LINE start = new_node NEW_LINE return NEW_LINE DEDENT last = ( start ) . prev NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = value NEW_LINE new_node . next = start NEW_LINE ( start ) . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE DEDENT def insertBegin ( value ) : NEW_LINE INDENT global start NEW_LINE last = ( start ) . prev NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = value NEW_LINE new_node . next = start NEW_LINE new_node . prev = last NEW_LINE last . next = ( start ) . prev = new_node NEW_LINE start = new_node NEW_LINE DEDENT def insertAfter ( value1 , value2 ) : NEW_LINE INDENT global start NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = value1 NEW_LINE temp = start NEW_LINE while ( temp . data != value2 ) : NEW_LINE INDENT temp = temp . next NEW_LINE DEDENT next = temp . next NEW_LINE temp . next = new_node NEW_LINE new_node . prev = temp NEW_LINE new_node . next = next NEW_LINE next . prev = new_node NEW_LINE DEDENT def display ( ) : NEW_LINE INDENT global start NEW_LINE temp = start NEW_LINE print ( \" Traversal ▁ in ▁ forward ▁ direction : \" ) NEW_LINE while ( temp . next != start ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE print ( \" Traversal ▁ in ▁ reverse ▁ direction : \" ) NEW_LINE last = start . prev NEW_LINE temp = last NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT global start NEW_LINE start = None NEW_LINE insertEnd ( 5 ) NEW_LINE insertBegin ( 4 ) NEW_LINE insertEnd ( 7 ) NEW_LINE insertEnd ( 8 ) NEW_LINE insertAfter ( 6 , 5 ) NEW_LINE print ( \" Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ \" ) NEW_LINE display ( ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Doubly Circular Linked List | Set 1 ( Introduction and Insertion ) | Structure of a Node ; Function to insert at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Create Node dynamically ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Function to insert Node at the beginning of the List , ; Pointer points to last Node ; Inserting the data ; setting up previous and next of new node ; Update next and previous pointers of start and last . ; Update start pointer ; Function to insert node with value as value1 . The new node is inserted after the node with with value2 ; Inserting the data ; Find node having value2 and next node of it ; insert new_node between temp and next . ; Driver Code ; Start with the empty list ; Insert 5. So linked list becomes 5. None ; Insert 4 at the beginning . So linked list becomes 4.5 ; Insert 7 at the end . So linked list becomes 4.5 . 7 ; Insert 8 at the end . So linked list becomes 4.5 . 7.8 ; Insert 6 , after 5. So linked list becomes 4.5 . 6.7 . 8",
        "Category": "Linked List"
    },
    {
        "ID": "6297-6297",
        "Code": "import numpy as np NEW_LINE LAS = np . zeros ( ( 1000 , 2 ) ) NEW_LINE for i in range ( 1000 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT LAS [ i ] [ j ] = False NEW_LINE DEDENT DEDENT def solve ( arr , n , i , pos ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( LAS [ i ] [ pos ] ) : NEW_LINE INDENT return LAS [ i ] [ pos ] ; NEW_LINE DEDENT inc = 0 ; exc = 0 ; NEW_LINE if ( arr [ i ] > 0 and pos == True ) : NEW_LINE INDENT pos = False ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT elif ( arr [ i ] < 0 and pos == False ) : NEW_LINE INDENT pos = True ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT exc = solve ( arr , n , i + 1 , pos ) ; NEW_LINE LAS [ i ] [ pos ] = max ( inc , exc ) ; NEW_LINE return LAS [ i ] [ pos ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , 4 , 5 , - 6 , 8 , - 99 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( max ( solve ( arr , n , 0 , 0 ) , solve ( arr , n , 0 , 1 ) ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest alternating subsequence in terms of positive and negative integers | Python3 program to find the length of longest alternate subsequence ; LAS [ i ] [ pos ] array to find the length of LAS till index i by including or excluding element arr [ i ] on the basis of value of pos ; Base Case ; If current element is positive and pos is true Include the current element and change pos to false ; Recurr for the next iteration ; If current element is negative and pos is false Include the current element and change pos to true ; Recurr for the next iteration ; If current element is excluded , reccur for next iteration ; Driver 's Code ; Print LAS",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "63-63",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def heighAndSize ( node , size ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = heighAndSize ( node . left , size ) NEW_LINE r = heighAndSize ( node . right , size ) NEW_LINE size [ 0 ] += 1 NEW_LINE return l + 1 if ( l > r ) else r + 1 NEW_LINE DEDENT def density ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT size = [ 0 ] NEW_LINE _height = heighAndSize ( root , size ) NEW_LINE return size [ 0 ] / _height NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE print ( \" Density ▁ of ▁ given ▁ binary ▁ tree ▁ is ▁ \" , density ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Density of Binary Tree in One Traversal | A binary tree node ; Function to compute height and size of a binary tree ; compute height of each subtree ; increase size by 1 ; return larger of the two ; function to calculate density of a binary tree ; To store size ; Finds height and size ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "6328-6328",
        "Code": "import numpy as np NEW_LINE import sys NEW_LINE MAXI = 50 NEW_LINE INT_MAX = sys . maxsize NEW_LINE dp = np . ones ( ( MAXI , MAXI , MAXI * MAXI ) ) ; NEW_LINE dp *= - 1 NEW_LINE def minDifference ( x , y , k , b , c ) : NEW_LINE INDENT if ( x >= n or y >= m ) : NEW_LINE INDENT return INT_MAX ; NEW_LINE DEDENT if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE return min ( abs ( k - diff ) , abs ( k + diff ) ) ; NEW_LINE DEDENT ans = dp [ x ] [ y ] [ k ] ; NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT ans = INT_MAX ; NEW_LINE diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; m = 2 ; b = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; NEW_LINE c = [ [ 3 , 2 ] , [ 3 , 1 ] ] ; NEW_LINE print ( minDifference ( 0 , 0 , 0 , b , c ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the minimum difference path from ( 0 , 0 ) to ( N | Python3 implementation of the approach ; Function to return the minimum difference path from ( 0 , 0 ) to ( N - 1 , M - 1 ) ; Terminating case ; Base case ; If it is already visited ; Recursive calls ; Return the value ; Driver code ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6330-6330",
        "Code": "V_SUM_MAX = 1000 NEW_LINE N_MAX = 100 NEW_LINE W_MAX = 10000000 NEW_LINE dp = [ [ 0 for i in range ( N_MAX ) ] for i in range ( V_SUM_MAX + 1 ) ] NEW_LINE v = [ [ 0 for i in range ( N_MAX ) ] for i in range ( V_SUM_MAX + 1 ) ] NEW_LINE def solveDp ( r , i , w , val , n ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return W_MAX NEW_LINE DEDENT if ( v [ r ] [ i ] ) : NEW_LINE INDENT return dp [ r ] [ i ] NEW_LINE DEDENT v [ r ] [ i ] = 1 NEW_LINE dp [ r ] [ i ] = min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) NEW_LINE return dp [ r ] [ i ] NEW_LINE DEDENT def maxWeight ( w , val , n , c ) : NEW_LINE INDENT for i in range ( V_SUM_MAX , - 1 , - 1 ) : NEW_LINE INDENT if ( solveDp ( i , 0 , w , val , n ) <= c ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = [ 3 , 4 , 5 ] NEW_LINE val = [ 30 , 50 , 60 ] NEW_LINE n = len ( w ) NEW_LINE C = 8 NEW_LINE print ( maxWeight ( w , val , n , C ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Knapsack with large Weights | Python3 implementation of the approach ; To store the states of DP ; Function to solve the recurrence relation ; Base cases ; Marking state as solved ; Recurrence relation ; Function to return the maximum weight ; Iterating through all possible values to find the the largest value that can be represented by the given weights ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6338-6338",
        "Code": "def maxLengthOf1s ( arr , n ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i - 2 ] == 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = 0 NEW_LINE DEDENT DEDENT suffix = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i + 2 ] == 1 ) : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = max ( ans , prefix [ i + 1 ] + suffix [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT n = 6 NEW_LINE arr = [ 1 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE maxLengthOf1s ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize length of Subarray of 1 's after removal of a pair of consecutive Array elements | Python program to find the maximum count of 1 s ; If arr [ i - 2 ] = = 1 then we increment the count of occurences of 1 's ; Else we initialise the count with 0 ; If arr [ i + 2 ] = = 1 then we increment the count of occurences of 1 's ; Else we initialise the count with 0 ; We get the maximum count by skipping the current and the next element . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "634-634",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printReverse ( head_ref , n ) : NEW_LINE INDENT j = 0 NEW_LINE current = head_ref NEW_LINE while ( current != None ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < 2 * ( n - j ) ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT print ( current . data , end = \" \" ) NEW_LINE current = current . next NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref ; NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT i = 0 NEW_LINE temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE i = i + 1 NEW_LINE DEDENT return i NEW_LINE DEDENT head = None NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 6 ) NEW_LINE print ( \" Given ▁ linked ▁ list : \" ) NEW_LINE n = printList ( head ) NEW_LINE print ( \" Reversed Linked list : \" ) NEW_LINE printReverse ( head , n ) NEW_LINE print ( ) NEW_LINE",
        "Type": "py",
        "NL": "An interesting method to print reverse of a linked list | Link list node ; Function to reverse the linked list ; For each node , print proper number of spaces before printing it ; use of carriage return to move back and print . ; Function to push a node ; Function to print linked list and find its length ; i for finding length of list ; Start with the empty list ; list nodes are as 6 5 4 3 2 1 ; printlist print the list and return the size of list ; print reverse list with help of carriage return function",
        "Category": "Linked List"
    },
    {
        "ID": "6347-6347",
        "Code": "def findCount ( N ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , 20 ) : NEW_LINE INDENT sum += 2 ** i NEW_LINE list . append ( sum ) NEW_LINE DEDENT for value in list : NEW_LINE INDENT if ( value >= N ) : NEW_LINE INDENT return ( list . index ( value ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of coins that can generate all the values in the given range | Function to return the count of minimum coins required ; To store the required sequence ; Creating list of the sum of all previous bit values including that bit value ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "6359-6359",
        "Code": "import numpy as np NEW_LINE maxN = 20 NEW_LINE maxSum = 50 NEW_LINE minSum = 50 NEW_LINE base = 50 NEW_LINE dp = np . zeros ( ( maxN , maxSum + minSum ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxSum + minSum ) ) ; NEW_LINE def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT v [ i ] [ required_sum + base ] = 1 ; NEW_LINE dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 6 ; NEW_LINE print ( findCnt ( arr , 0 , x , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of subsets with sum equal to X | Python3 implementation of the approach ; To store the states of DP ; Function to return the required count ; Base case ; If the state has been solved before return the value of the state ; Setting the state as solved ; Recurrence relation ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6374-6374",
        "Code": "def cntSubsets ( arr , n ) : NEW_LINE INDENT max = pow ( 2 , n ) NEW_LINE result = 0 NEW_LINE for i in range ( max ) : NEW_LINE INDENT counter = i NEW_LINE if ( counter & ( counter >> 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 3 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntSubsets ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of subsets not containing adjacent elements | Function to return the count of possible subsets ; Total possible subsets of n sized array is ( 2 ^ n - 1 ) ; To store the required count of subsets ; Run from i 000. .0 to 111. .1 ; If current subset has consecutive elements from the array ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6377-6377",
        "Code": "def perfix_calculate ( A , row , col ) : NEW_LINE INDENT n = len ( A ) NEW_LINE m = len ( A [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT row [ i ] [ 0 ] = A [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT row [ i ] [ j ] = row [ i ] [ j - 1 ] + A [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT col [ 0 ] [ i ] = A [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT col [ j ] [ i ] = A [ j ] [ i ] + col [ j - 1 ] [ i ] NEW_LINE DEDENT DEDENT DEDENT def perimeter ( i , j , k , row , col , A ) : NEW_LINE INDENT row_s , col_s = 0 , 0 NEW_LINE if ( j == 0 ) : NEW_LINE INDENT row_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT row_s = row [ i ] [ j - 1 ] NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT col_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT col_s = col [ i - 1 ] [ j ] NEW_LINE DEDENT upper_row = row [ i ] [ j + k ] - row_s NEW_LINE left_col = col [ i + k ] [ j ] - col_s NEW_LINE if ( j == 0 ) : NEW_LINE INDENT row_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT row_s = row [ i + k ] [ j - 1 ] NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT col_s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT col_s = col [ i - 1 ] [ j + k ] NEW_LINE DEDENT lower_row = row [ i + k ] [ j + k ] - row_s NEW_LINE right_col = col [ i + k ] [ j + k ] - col_s NEW_LINE sum = upper_row + lower_row + left_col + right_col NEW_LINE sum -= ( A [ i ] [ j ] + A [ i + k ] [ j ] +   \\ A [ i ] [ j + k ] + A [ i + k ] [ j + k ] ) NEW_LINE return sum NEW_LINE DEDENT def maxPerimeter ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE m = len ( A [ 0 ] ) NEW_LINE row = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] NEW_LINE col = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] NEW_LINE perfix_calculate ( A , row , col ) NEW_LINE maxPer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( min ( n - i , m - j ) ) : NEW_LINE INDENT perimtr = perimeter ( i , j , k , row , col , A ) NEW_LINE maxPer = max ( maxPer , perimtr ) NEW_LINE DEDENT DEDENT DEDENT return maxPer NEW_LINE DEDENT A = [ [ 1 , 1 , 0 ] , [ 1 , 1 , 1 ] , [ 0 , 1 , 1 ] ] NEW_LINE print ( maxPerimeter ( A ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum perimeter of a square in a 2D grid | Function to calculate the perfix sum of the rows and the columns of the given matrix ; Number of rows and cols ; First column of the row prefix array ; Update the prefix sum for the rows ; First row of the column prefix array ; Update the prefix sum for the columns ; Function to return the perimeter of the square having top - left corner at ( i , j ) and size k ; i and j represent the top left corner of the square and k is the size ; Get the upper row sum ; Get the left column sum ; At the distance of k in both direction ; The perimeter will be sum of all the values ; Since all the corners are included twice , they need to be subtract from the sum ; Function to return the maximum perimeter of a square in the given matrix ; Number of rows and cols ; Function call to calculate the prefix sum of rows and cols ; To store the maximum perimeter ; Nested loops to choose the top - left corner of the square ; Loop for the size of the square ; Get the perimeter of the current square ; Update the maximum perimeter so far ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "6387-6387",
        "Code": "from math import gcd as __gcd NEW_LINE MAX = 100 NEW_LINE def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return - 10 ** 9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ cnt ] = ans NEW_LINE return ans NEW_LINE DEDENT a = [ 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 ; NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( n ) ] NEW_LINE print ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) NEW_LINE",
        "Type": "py",
        "NL": "Subsequence X of length K such that gcd ( X [ 0 ] , X [ 1 ] ) + ( X [ 2 ] , X [ 3 ] ) + ... is maximized | Python3 program to find the sum of the addition of all possible subsets ; Recursive function to find the maximum value of the given recurrence ; If we get K elements ; If we have reached the end and K elements are not there ; If the state has been visited ; Iterate for every element as the next possible element and take the element which gives the maximum answer ; If this element is the first element in the individual pair in the subsequence then simply recurrence with the last element as i - th index ; If this element is the second element in the individual pair , the find gcd with the previous element and add to the answer and recur for the next element ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6388-6388",
        "Code": "def find ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c = 1 NEW_LINE d = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT d += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 + len ( d ) ] NEW_LINE if ( s2 == d ) : NEW_LINE INDENT c = 1 + find ( s [ i + 1 : ] ) NEW_LINE break NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT s = \" abababab \" NEW_LINE print ( find ( s ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum number of given operations to remove the entire string | Function to return the maximum number of given operations required to remove the given entirely ; If length of the is zero ; Single operation can delete the entire string ; To store the prefix of the string which is to be deleted ; Prefix s [ 0. . i ] ; To store the subs [ i + 1. . .2 * i + 1 ] ; If the prefix s [ 0. . . i ] can be deleted ; 1 operation to remove the current prefix and then recursively find the count of operations for the subs [ i + 1. . . n - 1 ] ; Entire has to be deleted ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "639-639",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def fun1 ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT fun1 ( head . next ) NEW_LINE print ( head . data , end = \" ▁ \" ) NEW_LINE DEDENT def fun2 ( start ) : NEW_LINE INDENT if ( start == None ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( start . data , end = \" ▁ \" ) NEW_LINE if ( start . next != None ) : NEW_LINE INDENT fun2 ( start . next . next ) NEW_LINE DEDENT print ( start . data , end = \" ▁ \" ) NEW_LINE DEDENT def push ( head , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT head = None NEW_LINE head = Node ( 5 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE print ( \" Output ▁ of ▁ fun1 ( ) ▁ for ▁ list ▁ 1 - > 2 - > 3 - > 4 - > 5\" ) NEW_LINE fun1 ( head ) NEW_LINE print ( \" Output of fun2 ( ) for list 1 -> 2 -> 3 -> 4 -> 5 \" ) NEW_LINE fun2 ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Practice questions for Linked List and Recursion | A linked list node ; Prints a linked list in reverse manner ; prints alternate nodes of a Linked List , first from head to end , and then from end to head . ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; put in the data ; link the old list off the new node ; move the head to poto the new node ; Start with the empty list ; Using push ( ) to construct below list 1.2 . 3.4 . 5",
        "Category": "Linked List"
    },
    {
        "ID": "6392-6392",
        "Code": "' NEW_LINE def checkpossible ( mask , arr , prefix , n , k ) : NEW_LINE ' NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for l in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ l ] [ j - 1 ] and ( ( ( prefix [ i ] - prefix [ l ] ) & mask ) == mask ) ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT def Partition ( arr , n , k ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i ] NEW_LINE DEDENT LOGS = 20 NEW_LINE ans = 0 NEW_LINE for i in range ( LOGS , - 1 , - 1 ) : NEW_LINE INDENT if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) : NEW_LINE INDENT ans = ans | ( 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 7 , 10 , 23 , 21 , 6 , 8 , 7 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) - 1 NEW_LINE print ( Partition ( arr , n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Partition the array in K segments such that bitwise AND of individual segment sum is maximized | Function to check whether a k segment partition is possible such that bitwise AND is 'mask ; dp [ i ] [ j ] stores whether it is possible to partition first i elements into j segments such that all j segments are 'good ; Initialising dp ; Filling dp in bottom - up manner ; Finding a cut such that first l elements can be partitioned into j - 1 ' good ' segments and arr [ l + 1 ] + ... + arr [ i ] is a ' good ' segment ; Function to find maximum possible AND ; Array to store prefix sums ; Maximum no of bits in the possible answer ; This will store the final answer ; Constructing answer greedily selecting from the higher most bit ; Checking if array can be partitioned such that the bitwise AND is ans | ( 1 << i ) ; if possible , update the answer ; Return the final answer ; Driver code ; n = 11 , first element is zero to make array 1 based indexing . So , number of elements are 10 ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6403-6403",
        "Code": "def memo ( index , evenSum , oddSum , tight ) : NEW_LINE INDENT if index == len ( v ) : NEW_LINE INDENT if evenSum > oddSum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = v [ index ] if tight else 9 NEW_LINE ans = 0 NEW_LINE for d in range ( limit + 1 ) : NEW_LINE INDENT currTight = 0 NEW_LINE if d == v [ index ] : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if d % 2 != 0 : NEW_LINE INDENT ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) NEW_LINE DEDENT DEDENT dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT def countNum ( n ) : NEW_LINE INDENT global dp , v NEW_LINE v . clear ( ) NEW_LINE num = [ ] NEW_LINE while n : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT v . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 180 ) ] for j in range ( 180 ) ] for k in range ( 18 ) ] NEW_LINE return memo ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dp = [ ] NEW_LINE v = [ ] NEW_LINE L = 2 NEW_LINE R = 10 NEW_LINE print ( countNum ( R ) - countNum ( L - 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers in given range such that sum of even digits is greater than sum of odd digits | Python code to count number in the range having the sum of even digits greater than the sum of odd digits ; Base Case ; check if condition satisfied or not ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 0 , means number has already become smaller so we can place any digit , otherwise num [ index ] ; if current digit is odd ; if current digit is even ; Function to convert n into its digit vector and uses memo ( ) function to return the required count ; Initialize dp ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6405-6405",
        "Code": "import numpy as np NEW_LINE def Probability ( p , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , n + 1 ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0.0 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 1.0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT ans = 0.0 ; NEW_LINE for i in range ( ( n + 1 ) // 2 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = [ 0.0 , 0.3 , 0.4 , 0.7 ] ; NEW_LINE n = len ( p ) - 1 ; NEW_LINE print ( Probability ( p , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability of getting more heads than tails when N biased coins are tossed | Python3 implementation of the above approach ; Function to return the probability when number of heads is greater than the number of tails ; Declaring the DP table ; Base case ; Iterating for every coin ; j represents the numbers of heads ; If number of heads is equal to zero there there is only one possibility ; When the number of heads is greater than ( n + 1 ) / 2 it means that heads are greater than tails as no of tails + no of heads is equal to n for any permutation of heads and tails ; Driver Code ; 1 based indexing ; Number of coins ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6414-6414",
        "Code": "dp = [ 0 ] * 1024 ; NEW_LINE def get_binary ( u ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( u ) : NEW_LINE INDENT rem = u % 10 ; NEW_LINE ans |= ( 1 << rem ) ; NEW_LINE u //= 10 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def recur ( u , array , n ) : NEW_LINE INDENT if ( u == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ u ] != - 1 ) : NEW_LINE INDENT return dp [ u ] ; NEW_LINE DEDENT temp = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = get_binary ( array [ i ] ) ; NEW_LINE if ( ( mask u ) == u ) : NEW_LINE INDENT dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; NEW_LINE DEDENT DEDENT return dp [ u ] ; NEW_LINE DEDENT def solve ( array , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT dp [ i ] = - 1 ; NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 ; NEW_LINE i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT ans = max ( ans , recur ( i , array , n ) ) ; NEW_LINE i += 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 22 , 132 , 4 , 45 , 12 , 223 ] ; NEW_LINE n = len ( array ) ; NEW_LINE print ( solve ( array , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum subset sum such that no two elements in set have same digit in them | Python3 implementation of above approach ; Function to create mask for every number ; Recursion for Filling DP array ; Base Condition ; Recurrence Relation ; Function to find Maximum Subset Sum ; Initialize DP array ; Iterate over all possible masks of 10 bit number ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6415-6415",
        "Code": "import numpy as np NEW_LINE MAX_INDEX = 51 NEW_LINE MAX_SUM = 2505 NEW_LINE dp = np . ones ( ( MAX_INDEX , MAX_SUM , MAX_INDEX ) ) * - 1 ; NEW_LINE def waysutil ( index , sum , count , arr , K ) : NEW_LINE INDENT if ( index < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT if ( count == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT remainder = sum % count ; NEW_LINE if ( remainder != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT average = sum // count ; NEW_LINE if ( average == K ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT if ( dp [ index ] [ sum ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ sum ] [ count ] ; NEW_LINE DEDENT dontpick = waysutil ( index - 1 , sum , count , arr , K ) ; NEW_LINE pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) ; NEW_LINE total = pick + dontpick ; NEW_LINE dp [ index ] [ sum ] [ count ] = total ; NEW_LINE return total ; NEW_LINE DEDENT def ways ( N , K , arr ) : NEW_LINE INDENT Arr = [ ] ; NEW_LINE Arr . append ( - 1 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT Arr . append ( arr [ i ] ) ; NEW_LINE DEDENT answer = waysutil ( N , 0 , 0 , Arr , K ) ; NEW_LINE return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 8 , 7 , 6 , 5 , 9 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 5 ; NEW_LINE print ( ways ( N , K , arr ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways to choose elements from the array such that their average is K | Python implementation of above approach ; Initialize dp array by - 1 ; Base cases Index can 't be less than 0 ; No element is picked hence average cannot be calculated ; If remainder is non zero , we cannot divide the sum by count i . e . the average will not be an integer ; If we find an average return 1 ; If we have already calculated this function simply return it instead of calculating it again ; If we don 't pick the current element  simple recur for index -1 ; If we pick the current element add it to our current sum and increment count by 1 ; Store the value for the current function ; Function to return the number of ways ; Push - 1 at the beginning to make it 1 - based indexing ; Call recursive function waysutil to calculate total ways ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6416-6416",
        "Code": "import numpy as np NEW_LINE arrSize = 51 NEW_LINE maxSum = 201 NEW_LINE MAX = 100 NEW_LINE inf = 999999 NEW_LINE dp = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE visit = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE def RetClose ( a , b , s ) : NEW_LINE INDENT if ( abs ( a - s ) < abs ( b - s ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return b ; NEW_LINE DEDENT DEDENT def MinDiff ( i , sum , arr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( visit [ i ] [ sum + MAX ] ) : NEW_LINE INDENT return dp [ i ] [ sum + MAX ] ; NEW_LINE DEDENT visit [ i ] [ sum + MAX ] = 1 ; NEW_LINE dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) ; NEW_LINE return dp [ i ] [ sum + MAX ] ; NEW_LINE DEDENT def FindClose ( arr , n ) : NEW_LINE INDENT ans = inf ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 25 , - 9 , - 10 , - 4 , - 7 , - 33 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE FindClose ( arr , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Subset with sum closest to zero | Python3 Code for above implementation ; Variable to store states of dp ; Function to return the number closer to integer s ; To find the sum closest to zero Since sum can be negative , we will add MAX to it to make it positive ; Base cases ; Checks if a state is already solved ; Recurrence relation ; Returning the value ; Function to calculate the closest sum value ; Calculate the Closest value for every subarray arr [ i - 1 : n ] ; Driver function ; Input array",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6418-6418",
        "Code": "x = 100 NEW_LINE dp = [ [ 0 for i in range ( x ) ] for i in range ( x ) ] NEW_LINE v = [ [ 0 for i in range ( x ) ] for i in range ( x ) ] NEW_LINE exp_c = [ ] NEW_LINE def FindMax ( i , r , w , n , c , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] NEW_LINE DEDENT v [ i ] [ r ] = 1 NEW_LINE dp [ i ] [ r ] = FindMax ( i + 1 , r , w , n , c , k ) NEW_LINE for j in range ( k ) : NEW_LINE INDENT x = ( r // exp_c [ j ] ) % ( c + 1 ) NEW_LINE if ( x - w [ i ] >= 0 ) : NEW_LINE INDENT dp [ i ] [ r ] = max ( dp [ i ] [ r ] , w [ i ] + FindMax ( i + 1 , r - w [ i ] * exp_c [ j ] , w , n , c , k ) ) NEW_LINE DEDENT DEDENT return dp [ i ] [ r ] NEW_LINE DEDENT ' NEW_LINE def PreCompute ( n , c , k ) : NEW_LINE INDENT exp_c . append ( 1 ) NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT exp_c [ i ] = ( exp_c [ i - 1 ] * ( c + 1 ) ) NEW_LINE DEDENT R = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT R += exp_c [ i ] * c NEW_LINE DEDENT return R NEW_LINE DEDENT w = [ 3 , 8 , 9 ] NEW_LINE k = 1 NEW_LINE c = 11 NEW_LINE n = len ( w ) NEW_LINE r = PreCompute ( n , c , k ) NEW_LINE print ( FindMax ( 0 , r , w , n , c , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum items that can be filled in K Knapsacks of given Capacity | 2 - d array to store states of DP ; 2 - d array to store if a state has been solved ; Vector to store power of variable ' C ' . ; function to compute the states ; Base case ; Checking if a state has been solved ; Setting a state as solved ; Recurrence relation ; Returning the solved state ; Function to initialize global variables and find the initial value of 'R ; Resizing the variables ; Variable to store the initial value of R ; Input array ; number of knapsacks and capacity ; Performing required pre - computation ; finding the required answer",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6427-6427",
        "Code": "mod = 3803 NEW_LINE d = 26 NEW_LINE hash_b = 0 NEW_LINE hash_a = [ ] NEW_LINE mul = [ ] NEW_LINE def mi ( x ) : NEW_LINE INDENT global mod NEW_LINE p = mod - 2 NEW_LINE s = 1 NEW_LINE while p != 1 : NEW_LINE INDENT if p % 2 == 1 : NEW_LINE INDENT s = ( s * x ) % mod NEW_LINE DEDENT x = ( x * x ) % mod NEW_LINE p //= 2 NEW_LINE DEDENT return ( s * x ) % mod NEW_LINE DEDENT def genHash ( a , b ) : NEW_LINE INDENT global hash_b , hash_a , mul , d , mod NEW_LINE hash_a = [ 0 ] * len ( a ) NEW_LINE mul = [ 0 ] * len ( a ) NEW_LINE for i in range ( len ( b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT hash_b = ( hash_b * d + ( ord ( b [ i ] ) - 97 ) ) % mod NEW_LINE DEDENT mul [ 0 ] = 1 NEW_LINE hash_a [ 0 ] = ( ord ( a [ 0 ] ) - 97 ) % mod NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT mul [ i ] = ( mul [ i - 1 ] * d ) % mod NEW_LINE hash_a [ i ] = ( hash_a [ i - 1 ] + mul [ i ] * ( ord ( a [ i ] ) - 97 ) ) % mod NEW_LINE DEDENT DEDENT def checkEqual ( i , len_a , len_b ) : NEW_LINE INDENT global hash_b , hash_a , mul , d , mod NEW_LINE x = - 1 NEW_LINE if i == 0 : NEW_LINE INDENT x = hash_a [ len_b - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = ( hash_a [ i + len_b - 1 ] - hash_a [ i - 1 ] + 2 * mod ) % mod NEW_LINE x = ( x * mi ( mul [ i ] ) ) % mod NEW_LINE DEDENT if x == hash_b : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abababababa \" NEW_LINE b = \" aba \" NEW_LINE genHash ( a , b ) NEW_LINE queries = [ 0 , 1 , 2 , 3 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT if checkEqual ( queries [ i ] , len ( a ) , len ( b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Queries to check if string B exists as substring in string A | Python3 implementation of the approach ; Function to return the modular inverse using Fermat 's little theorem ; Function to generate hash ; To store prefix - sum of rolling hash ; Multiplier for different values of i ; Generating hash value for string b ; Generating prefix - sum of hash of a ; Function that returns true if the required sub - string in a is equal to b ; To store hash of required sub - string of A ; If i = 0 then requires hash value ; Required hash if i != 0 ; Comparing hash with hash of B ; Driver Code ; Generating hash ; Queries ; Perform queries",
        "Category": "Substring"
    },
    {
        "ID": "6429-6429",
        "Code": "import numpy as np NEW_LINE def MaximumMarks ( marksarr , timearr , h , n , p ) : NEW_LINE INDENT no_of_topics = n + 1 ; NEW_LINE total_time = h + 1 ; NEW_LINE T = np . zeros ( ( no_of_topics , total_time ) ) ; NEW_LINE for i in range ( no_of_topics ) : NEW_LINE INDENT T [ i ] [ 0 ] = 0 ; NEW_LINE DEDENT for j in range ( total_time ) : NEW_LINE INDENT T [ 0 ] [ j ] = 0 ; NEW_LINE DEDENT for i in range ( 1 , no_of_topics ) : NEW_LINE INDENT for j in range ( 1 , total_time ) : NEW_LINE INDENT if ( j < timearr [ i ] ) : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT i = no_of_topics - 1 ; j = total_time - 1 ; NEW_LINE sum = 0 ; NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += timearr [ i ] ; NEW_LINE j -= timearr [ i ] ; NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; NEW_LINE if ( marks < p ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; h = 10 ; p = 10 ; NEW_LINE marksarr = [ 0 , 6 , 4 , 2 , 8 ] ; NEW_LINE timearr = [ 0 , 4 , 6 , 2 , 7 ] ; NEW_LINE print ( MaximumMarks ( marksarr , timearr , h , n , p ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find maximum topics to prepare in order to pass the exam | Python3 implementation of the approach ; Function to return the maximum marks by considering topics which can be completed in the given time duration ; If we are given 0 time then nothing can be done So all values are 0 ; If we are given 0 topics then the time required will be 0 for sure ; Calculating the maximum marks that can be achieved under the given time constraints ; If time taken to read that topic is more than the time left now at position j then do no read that topic ; Two cases arise : 1 ) Considering current topic 2 ) Ignoring current topic We are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; Moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; It means we have not considered reading this topic for max weightage sum ; Adding the topic time ; Evaluating the left over time after considering this current topic ; One topic completed ; It contains the maximum weightage sum formed by considering the topics ; Condition when exam cannot be passed ; Return the marks that can be obtained after passing the exam ; Driver code ; Number of topics , hours left and the passing marks ; n + 1 is taken for simplicity in loops Array will be indexed starting from 1",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "643-643",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printsqrtn ( head ) : NEW_LINE INDENT sqrtn = None NEW_LINE i = 1 NEW_LINE j = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( i == j * j ) : NEW_LINE INDENT if ( sqrtn == None ) : NEW_LINE INDENT sqrtn = head NEW_LINE DEDENT else : NEW_LINE INDENT sqrtn = sqrtn . next NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE head = head . next NEW_LINE DEDENT return sqrtn . data NEW_LINE DEDENT def print_1 ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT print ( \" ▁ \" ) NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 40 ) NEW_LINE head = push ( head , 30 ) NEW_LINE head = push ( head , 20 ) NEW_LINE head = push ( head , 10 ) NEW_LINE print ( \" Given ▁ linked ▁ list ▁ is : \" ) NEW_LINE print_1 ( head ) NEW_LINE print ( \" sqrt ( n ) th ▁ node ▁ is ▁ \" , printsqrtn ( head ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Squareroot ( n ) | Python3 program to find sqrt ( n ) 'th node  of a linked list  Node class  ; Function to initialise the node object ; Function to get the sqrt ( n ) th node of a linked list ; Traverse the list ; check if j = sqrt ( i ) ; for first node ; increment j if j = sqrt ( i ) ; return node 's data  ; function to add a new node at the beginning of the list ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver Code ; Start with the empty list",
        "Category": "Linked List"
    },
    {
        "ID": "6430-6430",
        "Code": "import numpy as np NEW_LINE max_size = 20 NEW_LINE max_k = 20 NEW_LINE dp = np . zeros ( ( max_size , max_k ) ) ; NEW_LINE v = np . zeros ( ( max_size , max_k ) ) ; NEW_LINE sum = 0 ; NEW_LINE def findSum ( arr , n ) : NEW_LINE INDENT global sum NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT def cntWays ( arr , i , ck , k , n , curr_sum ) : NEW_LINE INDENT if ( sum % k != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i != n and ck == k + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT if ( ck == k + 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ ck ] ) : NEW_LINE INDENT return dp [ i ] [ ck ] ; NEW_LINE DEDENT curr_sum += arr [ i ] ; NEW_LINE v [ i ] [ ck ] = 1 ; NEW_LINE dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; NEW_LINE if ( curr_sum == ( sum / k ) * ck ) : NEW_LINE INDENT dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; NEW_LINE DEDENT return dp [ i ] [ ck ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , - 1 , 1 , - 1 , 1 , - 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE findSum ( arr , n ) ; NEW_LINE print ( cntWays ( arr , 0 , 1 , k , n , 0 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways to divide an array into K equal sum sub | Python3 implementation of the approach ; Array to store the states of DP ; Array to check if a state has been solved before ; To store the sum of the array elements ; Function to find the sum of all the array elements ; Function to return the number of ways ; If sum is not divisible by k answer will be zero ; Base case ; To check if a state has been solved before ; Sum of all the numbers from the beginning of the array ; Setting the current state as solved ; Recurrence relation ; Returning solved state ; Driver code ; Function call to find the sum of the array elements ; Print the number of ways",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6439-6439",
        "Code": "import numpy as np ; NEW_LINE def palindromeSubStrs ( s ) : NEW_LINE INDENT dp = np . zeros ( ( len ( s ) , len ( s ) ) ) ; NEW_LINE m = { } ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 ; NEW_LINE m [ s [ i : i + 1 ] ] = 1 ; NEW_LINE DEDENT for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 1 ; NEW_LINE m [ s [ i : i + 2 ] ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 0 ; NEW_LINE DEDENT DEDENT for length in range ( 3 , len ( s ) + 1 ) : NEW_LINE INDENT for st in range ( len ( s ) - length + 1 ) : NEW_LINE INDENT end = st + length - 1 ; NEW_LINE if ( s [ st ] == s [ end ] and dp [ st + 1 ] [ end - 1 ] ) : NEW_LINE INDENT dp [ st ] [ end ] = 1 ; NEW_LINE m [ s [ st : end + 1 ] ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ st ] [ end ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT return len ( m ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abaaa \" ; NEW_LINE print ( palindromeSubStrs ( s ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Distinct palindromic sub | Python3 implementation of the approach ; Function to return the count of distinct palindromic sub - strings of the given string s ; To store the positions of palindromic sub - strings ; Map to store the sub - strings ; Sub - strings of length 1 are palindromes ; Store continuous palindromic sub - strings ; Store palindromes of size 2 ; If str [ i ... ( i + 1 ) ] is not a palindromic then set dp [ i ] [ i + 1 ] = 0 ; Find palindromic sub - strings of length >= 3 ; End of palindromic substring ; If s [ start ] = = s [ end ] and dp [ start + 1 ] [ end - 1 ] is already palindrome then s [ start ... . end ] is also a palindrome ; Set dp [ start ] [ end ] = 1 ; Not a palindrome ; Return the count of distinct palindromes ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6447-6447",
        "Code": "def ispower ( n ) : NEW_LINE INDENT if ( n < 125 ) : NEW_LINE INDENT return ( n == 1 or n == 5 or n == 25 ) NEW_LINE DEDENT if ( n % 125 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ispower ( n // 125 ) NEW_LINE DEDENT DEDENT def number ( s , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ x ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def minCuts ( s , n ) : NEW_LINE INDENT dp = [ n + 1 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT num = number ( s , j , i ) NEW_LINE if ( not ispower ( num ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT if dp [ n ] < n + 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"101101101\" NEW_LINE n = len ( s ) NEW_LINE print ( minCuts ( s , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of sub | Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Allocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6454-6454",
        "Code": "N = 100 NEW_LINE def pre_process ( dp , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - j + 1 ) : NEW_LINE INDENT if ( j <= 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = True NEW_LINE DEDENT DEDENT elif ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPairs ( s ) : NEW_LINE INDENT dp = [ [ False for i in range ( N ) ] for j in range ( N ) ] NEW_LINE pre_process ( dp , s ) NEW_LINE n = len ( s ) NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE left [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( dp [ j ] [ i ] == 1 ) : NEW_LINE INDENT left [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT right [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += left [ i ] * right [ i + 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" abacaba \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count pairs of non | Python3 implementation of the approach ; Pre - processing function ; Get the size of the string ; Initially mark every position as false ; For the length ; Iterate for every index with length j ; If the length is less than 2 ; If characters are equal ; Check for equal ; Function to return the number of pairs ; Create the dp table initially ; Declare the left array ; Declare the right array ; Initially left [ 0 ] is 1 ; Count the number of palindrome pairs to the left ; Initially right most as 1 ; Count the number of palindrome pairs to the right ; Count the number of pairs ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6463-6463",
        "Code": "n = 3 NEW_LINE MAX = 60 NEW_LINE dp = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE v = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE m = 5 NEW_LINE print ( findCount ( mat , n - 1 , n - 1 , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of ways to reach a given score in a Matrix | Python3 implementation of the approach ; To store the states of dp ; To check whether a particular state of dp has been solved ; Function to find the ways using memoization ; Base cases ; If required score becomes negative ; If current state has been reached before ; Set current state to visited ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6465-6465",
        "Code": "global maxn NEW_LINE maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ - 1 for i in range ( maxn ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE v = [ 4 , 6 , 9 ] NEW_LINE for i in range ( 1 , maxn , 1 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = v [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = int ( ( n - maxn ) / 4 ) + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( ) NEW_LINE print ( Maximum_Summands ( dp , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the maximum number of composite summands of a number | Python 3 implementation of the above approach ; Function to generate the dp array ; combination of three integers ; take the maximum number of summands ; Function to find the maximum number of summands ; If n is a smaller number , less than 16 , return dp [ n ] ; Else , find a minimal number t as explained in solution ; Driver code ; Generate dp array",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6466-6466",
        "Code": "mod = 1000000007 NEW_LINE RUNMAX = 300 NEW_LINE BALLMAX = 50 NEW_LINE WICKETMAX = 10 NEW_LINE def CountWays ( r , b , l , R , B , W , dp ) : NEW_LINE INDENT if ( l > W ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( r > R ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( b == B and r == R ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( b == B ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ r ] [ b ] [ l ] != - 1 ) : NEW_LINE INDENT return dp [ r ] [ b ] [ l ] NEW_LINE DEDENT ans = 0 ; NEW_LINE ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE dp [ r ] [ b ] [ l ] = ans NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 40 NEW_LINE B = 10 NEW_LINE W = 40 NEW_LINE dp = [ [ [ - 1 for k in range ( WICKETMAX ) ] for j in range ( BALLMAX ) ] for i in range ( RUNMAX ) ] NEW_LINE print ( CountWays ( 0 , 0 , 0 , R , B , W , dp ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways of scoring R runs in B balls with at most W wickets | Python3 implementation of the approach ; Function to return the number of ways to score R runs in B balls with at most W wickets ; If the wickets lost are more ; If runs scored are more ; If condition is met ; If no run got scored ; Already visited state ; If scored 0 run ; If scored 1 run ; If scored 2 runs ; If scored 3 runs ; If scored 4 runs ; If scored 6 runs ; If scored no run and lost a wicket ; Memoize and return ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "65-65",
        "Code": "class newNode ( ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def modifytree ( root ) : NEW_LINE INDENT right = root . right NEW_LINE rightMost = root NEW_LINE if ( root . left ) : NEW_LINE INDENT rightMost = modifytree ( root . left ) NEW_LINE root . right = root . left NEW_LINE root . left = None NEW_LINE DEDENT if ( not right ) : NEW_LINE INDENT return rightMost NEW_LINE DEDENT rightMost . right = right NEW_LINE rightMost = modifytree ( right ) NEW_LINE return rightMost NEW_LINE DEDENT def printpre ( root ) : NEW_LINE INDENT while ( root != None ) : NEW_LINE INDENT print ( root . data , end = \" ▁ \" ) NEW_LINE root = root . right NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE modifytree ( root ) NEW_LINE printpre ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify a binary tree to get preorder traversal using right pointers only | A binary tree node has data , left child and right child ; Function to modify tree ; if the left tree exists ; get the right - most of the original left subtree ; set root right to left subtree ; if the right subtree does not exists we are done ! ; set right pointer of right - most of the original left subtree ; modify the rightsubtree ; printing using right pointer only ; Driver code ; Constructed binary tree is 10 / \\ 8 2 / \\ 3 5",
        "Category": "Binary Tree"
    },
    {
        "ID": "650-650",
        "Code": "def search ( root , key ) : NEW_LINE INDENT if root is None or root . val == key : NEW_LINE INDENT return root NEW_LINE DEDENT if root . val < key : NEW_LINE INDENT return search ( root . right , key ) NEW_LINE DEDENT return search ( root . left , key ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Binary Search Tree | Set 1 ( Search and Insertion ) | A utility function to search a given key in BST ; Base Cases : root is null or key is present at root ; Key is greater than root 's key ; Key is smaller than root 's key",
        "Category": "Binary Tree"
    },
    {
        "ID": "6507-6507",
        "Code": "INF = 99999 NEW_LINE size = 10 NEW_LINE def findMinimumSteps ( mat , x , y , n ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE i , j , k = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT dist [ i ] [ j ] = INF NEW_LINE DEDENT else : NEW_LINE INDENT dist [ i ] [ j ] = 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT dist [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( dist [ x ] [ y ] < INF ) : NEW_LINE INDENT return dist [ x ] [ y ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT mat = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ] ] NEW_LINE x , y = 2 , 3 NEW_LINE print ( findMinimumSteps ( mat , x , y , size ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum steps required to convert X to Y where a binary matrix represents the possible conversions | Pyton3 implementation of the above approach ; dist [ ] [ ] will be the output matrix that will finally have the shortest distances between every pair of numbers ; Initially same as mat ; Add all numbers one by one to the set of intermediate numbers . Before start of an iteration , we have shortest distances between all pairs of numbers such that the shortest distances consider only the numbers in set { 0 , 1 , 2 , . . k - 1 } as intermediate numbers . After the end of an iteration , vertex no . k is added to the set of intermediate numbers and the set becomes { 0 , 1 , 2 , . . k } ; Pick all numbers as source one by one ; Pick all numbers as destination for the above picked source ; If number k is on the shortest path from i to j , then update the value of dist [ i ] [ j ] ; If no path ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "6508-6508",
        "Code": "r = 4 NEW_LINE c = 4 NEW_LINE def findmatch ( mat , pat , x , y , nrow , ncol , level ) : NEW_LINE INDENT l = len ( pat ) NEW_LINE if ( level == l ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( x < 0 or y < 0 or x >= nrow or y >= ncol ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( mat [ x ] [ y ] == pat [ level ] ) : NEW_LINE INDENT temp = mat [ x ] [ y ] NEW_LINE mat [ x ] . replace ( mat [ x ] [ y ] , ' # ' ) NEW_LINE res = ( findmatch ( mat , pat , x - 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x + 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y - 1 , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y + 1 , nrow , ncol , level + 1 ) ) NEW_LINE mat [ x ] . replace ( mat [ x ] [ y ] , temp ) NEW_LINE return res NEW_LINE return False NEW_LINE DEDENT DEDENT def checkMatch ( mat , pat , nrow , ncol ) : NEW_LINE INDENT l = len ( pat ) NEW_LINE if ( l > nrow * ncol ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( nrow ) : NEW_LINE INDENT for j in range ( ncol ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == pat [ 0 ] ) : NEW_LINE INDENT if ( findmatch ( mat , pat , i , j , nrow , ncol , 0 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT grid = [ \" axmy \" , \" bgdf \" , \" xeet \" , \" raks \" ] NEW_LINE if ( checkMatch ( grid , \" geeks \" , r , c ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a word exists in a grid or not | Python3 program to check if the word exists in the grid or not ; Function to check if a word exists in a grid starting from the first match in the grid level : index till which pattern is matched x , y : current position in 2D array ; Pattern matched ; Out of Boundary ; If grid matches with a letter while recursion ; Marking this cell as visited ; finding subpattern in 4 directions ; marking this cell as unvisited again ; else : Not matching then false ; Function to check if the word exists in the grid or not ; if total characters in matrix is less then pattern lenghth ; Traverse in the grid ; If first letter matches , then recur and check ; Driver Code ; Function to check if word exists or not",
        "Category": "Backtracking"
    },
    {
        "ID": "6518-6518",
        "Code": "def solve ( x ) : NEW_LINE INDENT ans , temp = 0 , x NEW_LINE if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT last = x % 10 NEW_LINE while ( x ) : NEW_LINE INDENT first = x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( first <= last ) : NEW_LINE INDENT ans = 9 + temp // 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 8 + temp // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT L , R = 2 , 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE L , R = 1 , 1000 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of Numbers in Range where first digit is equal to last digit of the number | Python3 program to implement the above approach ; Base Case ; Calculating the last digit ; Calculating the first digit ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "6521-6521",
        "Code": "r = 4 NEW_LINE col = 5 NEW_LINE def findMinSteps ( mat , n , m , dp , vis ) : NEW_LINE INDENT if ( n == 0 or m == 0 or n == ( r - 1 ) or m == ( col - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ m ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ m ] NEW_LINE DEDENT vis [ n ] [ m ] = True NEW_LINE ans1 , ans2 , ans3 , ans4 = 10 ** 9 , 10 ** 9 , 10 ** 9 , 10 ** 9 NEW_LINE if ( mat [ n - 1 ] [ m ] == 0 ) : NEW_LINE INDENT if ( vis [ n - 1 ] [ m ] == False ) : NEW_LINE INDENT ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n ] [ m + 1 ] == 0 ) : NEW_LINE INDENT if ( vis [ n ] [ m + 1 ] == False ) : NEW_LINE INDENT ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n ] [ m - 1 ] == 0 ) : NEW_LINE INDENT if ( vis [ n ] [ m - 1 ] == False ) : NEW_LINE INDENT ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n + 1 ] [ m ] == 0 ) : NEW_LINE INDENT if ( vis [ n + 1 ] [ m ] == False ) : NEW_LINE INDENT ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) NEW_LINE DEDENT DEDENT dp [ n ] [ m ] = min ( ans1 , min ( ans2 , min ( ans3 , ans4 ) ) ) NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT def minimumSteps ( mat , n , m ) : NEW_LINE INDENT twox = - 1 NEW_LINE twoy = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 2 ) : NEW_LINE INDENT twox = i NEW_LINE twoy = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( twox != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp = [ [ - 1 for i in range ( col ) ] for i in range ( r ) ] NEW_LINE vis = [ [ False for i in range ( col ) ] for i in range ( r ) ] NEW_LINE res = findMinSteps ( mat , twox , twoy , dp , vis ) NEW_LINE if ( res >= 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 1 , 0 , 1 ] , [ 1 , 0 , 2 , 0 , 1 ] , [ 0 , 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 0 ] ] NEW_LINE print ( minimumSteps ( mat , r , col ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum steps to reach any of the boundary edges of a matrix | Set 1 | Python program to find Minimum steps to reach any of the boundary edges of a matrix ; Function to find out minimum steps ; boundary edges reached ; already had a route through this point , hence no need to re - visit ; visiting a position ; vertically up ; horizontally right ; horizontally left ; vertically down ; minimum of every path ; Function that returns the minimum steps ; index to store the location at which you are standing ; find '2' in the matrix ; Initialize dp matrix with - 1 ; Initialize vis matrix with false ; Call function to find out minimum steps using memoization and recursion ; if not possible ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6522-6522",
        "Code": "def nCr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT ans *= ( n - i ) NEW_LINE ans /= ( i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countDerangements ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 3 ) ] NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT def countPermutations ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - k , n + 1 ) : NEW_LINE INDENT ways = nCr ( n , i ) NEW_LINE ans += ways * countDerangements ( n - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n , k = 5 , 3 NEW_LINE print ( countPermutations ( n , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count the number of special permutations | function to return the number of ways to chooser objects out of n objects ; function to return the number of degrangemnets of n ; function to return the required number of permutations ; ways to chose i indices from n indices ; Dearrangements of ( n - i ) indices ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6545-6545",
        "Code": "def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 1 , n ) : NEW_LINE INDENT count = 1 NEW_LINE c = 1 NEW_LINE for i in range ( 1 , row_num ) : NEW_LINE INDENT c = c * ( row_num - i ) / i NEW_LINE if ( c % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 16 ; NEW_LINE gouldSequence ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Gould 's Sequence | Function to generate gould 's Sequence ; loop to generate each row of pascal 's Triangle up to nth row ; Loop to generate each element of ith row ; if c is odd increment count ; print count of odd elements ; Get n ; Function call",
        "Category": "Math"
    },
    {
        "ID": "6551-6551",
        "Code": "def getNumberOfWays ( N , Coins ) : NEW_LINE INDENT ways = [ 0 ] * ( N + 1 ) ; NEW_LINE ways [ 0 ] = 1 ; NEW_LINE for i in range ( len ( Coins ) ) : NEW_LINE INDENT for j in range ( len ( ways ) ) : NEW_LINE INDENT if ( Coins [ i ] <= j ) : NEW_LINE INDENT ways [ j ] += ways [ ( int ) ( j - Coins [ i ] ) ] ; NEW_LINE DEDENT DEDENT DEDENT return ways [ N ] ; NEW_LINE DEDENT def printArray ( coins ) : NEW_LINE INDENT for i in coins : NEW_LINE INDENT print ( i ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Coins = [ 1 , 5 , 10 ] ; NEW_LINE print ( \" The ▁ Coins ▁ Array : \" ) ; NEW_LINE printArray ( Coins ) ; NEW_LINE print ( \" Solution : \" , end = \" \" ) ; NEW_LINE print ( getNumberOfWays ( 12 , Coins ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Understanding The Coin Change Problem With Dynamic Programming | We have input values of N and an array Coins that holds all of the coins . We use data type of because long we want to be able to test large values without integer overflow ; Create the ways array to 1 plus the amount to stop overflow ; Set the first way to 1 because its 0 and there is 1 way to make 0 with 0 coins ; Go through all of the coins ; Make a comparison to each index value of ways with the coin value . ; Update the ways array ; return the value at the Nth position of the ways array . ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6576-6576",
        "Code": "def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE print ( f1 , end = \" ▁ \" ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = \" ▁ \" ) ; NEW_LINE DEDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE DEDENT DEDENT N = 15 ; NEW_LINE alternateFib ( N ) ; NEW_LINE",
        "Type": "py",
        "NL": "Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6578-6578",
        "Code": "def countPartitions ( n , k ) : NEW_LINE INDENT dp = [ [ 0 ] * 201 ] * 201 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT if ( dp [ n ] [ k ] >= 0 ) : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT if ( n < k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n < 2 * k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT answer = ( answer + countPartitions ( n - i , i ) ) NEW_LINE DEDENT dp [ n ] [ k ] = answer NEW_LINE return answer NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ Aggregate ▁ sum ▁ of ▁ all ▁ \" \" Valid ▁ Partitions : ▁ \" , countPartitions ( n , k ) * n ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of elements of all partitions of number such that no element is less than K | Function that returns total number of valid partitions of integer N ; Global declaration of 2D dp array which will be later used for memoization ; Initializing 2D dp array with - 1 we will use this 2D array for memoization ; If this subproblem is already previously calculated , then directly return that answer ; If N < K , then no valid partition is possible ; If N is between K to 2 * K then there is only one partition and that is the number N itself ; Initialize answer with 1 as the number N itself is always a valid partition ; For loop to iterate over K to N and find number of possible valid partitions recursively . ; Memoization is done by storing this calculated answer ; Returning number of valid partitions ; Driver code ; Printing total number of valid partitions",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6580-6580",
        "Code": "import math NEW_LINE def recursive ( idx , sum , tight , st , dp , num ) : NEW_LINE INDENT if ( idx == num ) : NEW_LINE INDENT return sum == 0 NEW_LINE DEDENT if ( dp [ idx ] [ tight ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ tight ] [ sum ] NEW_LINE DEDENT ans = 0 NEW_LINE for d in range ( 10 ) : NEW_LINE INDENT newTight = False NEW_LINE if ( tight and ord ( st [ idx ] ) - ord ( '0' ) < d ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( tight and ord ( st [ idx ] ) - ord ( '0' ) == d ) : NEW_LINE INDENT newTight = True NEW_LINE DEDENT if ( sum >= d ) : NEW_LINE INDENT ans += recursive ( idx + 1 , sum - d , newTight , st , dp , num ) NEW_LINE DEDENT DEDENT dp [ idx ] [ tight ] [ sum ] = ans NEW_LINE return dp [ idx ] [ tight ] [ sum ] NEW_LINE DEDENT def formArray ( N ) : NEW_LINE INDENT dp = [ [ [ - 1 for x in range ( 166 ) ] for y in range ( 2 ) ] for z in range ( 20 ) ] NEW_LINE st = str ( N ) NEW_LINE num = len ( st ) NEW_LINE arr = [ ] NEW_LINE for i in range ( 1 , 163 ) : NEW_LINE INDENT arr . append ( recursive ( 0 , i , 1 , st , dp , num ) ) NEW_LINE DEDENT return arr NEW_LINE DEDENT def findPair ( a , b ) : NEW_LINE INDENT arr_smaller = formArray ( a - 1 ) NEW_LINE arr_greater = formArray ( b ) NEW_LINE for i in range ( len ( arr_greater ) ) : NEW_LINE INDENT arr_greater [ i ] -= arr_smaller [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 163 ) : NEW_LINE INDENT for j in range ( i + 1 , 163 ) : NEW_LINE INDENT if ( math . gcd ( i , j ) == 1 ) : NEW_LINE INDENT ans = ( ans + arr_greater [ i - 1 ] * arr_greater [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 NEW_LINE b = 15 NEW_LINE print ( findPair ( a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of Co | Python3 program to count the pairs whose sum of digits is co - prime ; Recursive function to return the frequency of numbers having their sum of digits i ; Returns 1 or 0 ; Returns value of the dp if already stored ; Loop from digit 0 to 9 ; To change the tight to 1 ; Calling the recursive function to find the frequency ; Function to find out frequency of numbers from 1 to N having their sum of digits from 1 to 162 and store them in array ; Number to string conversion ; Calling the recursive function and pushing it into array ; Function to find the pairs ; Calling the formArray function of a - 1 numbers ; Calling the formArray function of b numbers ; Subtracting the frequency of higher number array with lower number array and thus finding the range of numbers from a to b having sum from 1 to 162 ; To find out total number of pairs which are co - prime ; Driver code ; Function to count the pairs",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6590-6590",
        "Code": "fib = [ 0 ] * 43 NEW_LINE def fibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , 43 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT def rec ( x , y , last ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Sum , i = 0 , last NEW_LINE while i >= 0 and fib [ i ] * y >= x : NEW_LINE INDENT if fib [ i ] > x : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT Sum += rec ( x - fib [ i ] , y - 1 , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fibonacci ( ) NEW_LINE n , k = 13 , 3 NEW_LINE print ( \" Possible ▁ ways ▁ are : \" , rec ( n , k , 42 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways to represent a number as sum of k fibonacci numbers | To store fibonacci numbers 42 second number in fibonacci series largest possible integer ; Function to generate fibonacci series ; Recursive function to return the number of ways ; base condition ; for recursive function call ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "66-66",
        "Code": "class newNode ( ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def modifytree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT nodeStack = [ ] NEW_LINE nodeStack . append ( root ) NEW_LINE pre = None NEW_LINE while ( len ( nodeStack ) ) : NEW_LINE INDENT node = nodeStack [ - 1 ] NEW_LINE nodeStack . pop ( ) NEW_LINE if ( node . right ) : NEW_LINE INDENT nodeStack . append ( node . right ) NEW_LINE DEDENT if ( node . left ) : NEW_LINE INDENT nodeStack . append ( node . left ) NEW_LINE DEDENT if ( pre != None ) : NEW_LINE INDENT pre . right = node NEW_LINE DEDENT pre = node NEW_LINE DEDENT DEDENT def printpre ( root ) : NEW_LINE INDENT while ( root != None ) : NEW_LINE INDENT print ( root . data , end = \" ▁ \" ) NEW_LINE root = root . right NEW_LINE DEDENT DEDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE modifytree ( root ) NEW_LINE printpre ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Modify a binary tree to get preorder traversal using right pointers only | A binary tree node has data , left child and right child ; An iterative process to set the right pointer of Binary tree ; Base Case ; Create an empty stack and append root to it ; Pop all items one by one . Do following for every popped item a ) prit b ) append its right child c ) append its left child Note that right child is appended first so that left is processed first ; Pop the top item from stack ; append right and left children of the popped node to stack ; check if some previous node exists ; set the right pointer of previous node to currrent ; set previous node as current node ; printing using right pointer only ; Constructed binary tree is 10 / \\ 8 2 / \\ 3 5",
        "Category": "Binary Tree"
    },
    {
        "ID": "6616-6616",
        "Code": "def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lds [ i ] ) : NEW_LINE INDENT max = lds [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ LDS ▁ is \" , lds ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Decreasing Subsequence | Function that returns the length of the longest decreasing subsequence ; Initialize LDS with 1 for all index The minimum LDS starting with any element is always 1 ; Compute LDS from every index in bottom up manner ; Select the maximum of all the LDS values ; returns the length of the LDS ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6628-6628",
        "Code": "class Data : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . element = - 1 NEW_LINE self . position = - 1 NEW_LINE DEDENT DEDENT def findMinElement ( arr , n ) : NEW_LINE INDENT result = Data ( ) NEW_LINE prefixSum = [ 0 ] * n NEW_LINE suffixSum = [ 0 ] * n NEW_LINE prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] suffixSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ] NEW_LINE DEDENT mini = suffixSum [ 0 ] NEW_LINE pos = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if abs ( suffixSum [ i + 1 ] - prefixSum [ i ] ) < mini : NEW_LINE INDENT mini = abs ( suffixSum [ i + 1 ] - prefixSum [ i ] ) NEW_LINE if suffixSum [ i + 1 ] < prefixSum [ i ] : NEW_LINE INDENT pos = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = i NEW_LINE DEDENT DEDENT DEDENT result . element = mini NEW_LINE result . position = pos NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE values = Data ( ) NEW_LINE values = findMinElement ( arr , n ) NEW_LINE print ( \" Minimum ▁ element ▁ : \" , values . element ,   \" Position : \" , values . position ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Partitioning into two contiguous element subarrays with equal sums | Class to store the minimum element and its position ; initialize prefix and suffix sum arrays with 0 ; add current element to Sum ; add current element to Sum ; initialize the minimum element to be a large value ; check for the minimum absolute difference between current prefix sum and the next suffix sum element ; if prefixsum has a greater value then position is the next element , else it 's the same element. ; return the data in class . ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "6633-6633",
        "Code": "def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L // pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R // pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Integers from the range that are composed of a single distinct digit | Function to return the count of digits of a number ; Function to return a number that contains only digit ' d ' repeated exactly count times ; Function to return the count of integers that are composed of a single distinct digit only ; Count of digits in L and R ; First digits of L and R ; If L has lesser number of digits than R ; If the number that starts with firstDigitL and has number of digits = countDigitsL is within the range include the number ; Exclude the number ; If the number that starts with firstDigitR and has number of digits = countDigitsR is within the range include the number ; Exclude the number ; If both L and R have equal number of digits ; Include the number greater than L upto the maximum number whose digit = coutDigitsL ; Exclude the numbers which are greater than R ; Return the count ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "6641-6641",
        "Code": "ans = 0 ; NEW_LINE def findMaxValUtil ( arr , n , num , maxLimit , ind ) : NEW_LINE INDENT global ans NEW_LINE if ( ind == n ) : NEW_LINE INDENT ans = max ( ans , num ) NEW_LINE return NEW_LINE DEDENT if ( num - arr [ ind ] >= 0 ) : NEW_LINE INDENT findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 ) NEW_LINE DEDENT if ( num + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 ) NEW_LINE DEDENT DEDENT def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT global ans NEW_LINE ind = 0 NEW_LINE findMaxValUtil ( arr , n , num , maxLimit , ind ) NEW_LINE return ans NEW_LINE DEDENT num = 1 NEW_LINE arr = [ 3 , 10 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE maxLimit = 15 NEW_LINE print ( findMaxVal ( arr , n , num , maxLimit ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize array elements upto given number | variable to store maximum value that can be obtained . ; If entire array is traversed , then compare current value in num to overall maximum obtained so far . ; Case 1 : Subtract current element from value so far if result is greater than or equal to zero . ; Case 2 : Add current element to value so far if result is less than or equal to maxLimit . ; def to find maximum possible value that can be obtained using array elements and given number . ; variable to store current index position . ; call to utility def to find maximum possible value that can be obtained . ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "6651-6651",
        "Code": "def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE INF = 1000000000 NEW_LINE MAX = 50 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT max_value = - 1 * INF NEW_LINE min_value = INF NEW_LINE for i in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( \" Maximum Value : { } Minimum Value : { } \" . format ( max_value , min_value ) ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE minMaxValues ( arr , n , m ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum and Minimum Values of an Algebraic Expression | Python3 program to find the maximum and minimum values of an Algebraic expression of given form ; Finding sum of array elements ; shifting the integers by 50 so that they become positive ; dp [ i ] [ j ] represents true if sum j can be reachable by choosing i numbers ; if dp [ i ] [ j ] is true , that means it is possible to select i numbers from ( n + m ) numbers to sum upto j ; k can be at max n because the left expression has n numbers ; checking if a particular sum can be reachable by choosing n numbers ; getting the actual sum as we shifted the numbers by 50 to avoid negative indexing in array ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6671-6671",
        "Code": "import numpy as np NEW_LINE import sys NEW_LINE dp = np . zeros ( ( 1000 , 1000 ) ) NEW_LINE def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def initialize ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 40 , 60 , 20 ] NEW_LINE n = len ( a ) NEW_LINE initialize ( n ) NEW_LINE print ( int ( solve ( a , 0 , n - 1 ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum sum of multiplications of n numbers | Python3 program to find the minimum sum of multiplication of n numbers ; Used in recursive memoized solution ; function to calculate the cumulative sum from a [ i ] to a [ j ] ; base case ; memoization , if the partition has been called before then return the stored value ; store a max value ; we break them into k partitions ; store the min of the formula thus obtained ; return the minimum ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6676-6676",
        "Code": "def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( s1 [ i ] . isupper ( ) == False ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" daBcd \" NEW_LINE s2 = \" ABC \" NEW_LINE if ( check ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to transform one string to another | function to check if a string can be converted to another string by performing following operations ; calculates length ; mark 1 st position as true ; traverse for all DPi , j ; if possible for to convert i characters of s1 to j characters of s2 ; if upper_case ( s1 [ i ] ) == s2 [ j ] is same ; if not upper then deletion is possible ; driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6677-6677",
        "Code": "def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = \"11000010001\" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | Returns the length of substring with maximum difference of zeroes and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s ▁ ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means all ones otherwise max_sum ; Driven Program",
        "Category": "Sliding Window"
    },
    {
        "ID": "6682-6682",
        "Code": "import math NEW_LINE def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_sum = [ ] NEW_LINE prefix_sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr1 = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( maximumSumSubarray ( arr1 , n1 ) ) NEW_LINE arr2 = [ 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maximumSumSubarray ( arr2 , n2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum subarray sum in O ( n ) using prefix sum | Python3 program to find out maximum subarray sum in linear time using prefix sum . ; Function to compute maximum subarray sum in linear time . ; Initialize minimum prefix sum to 0. ; Initialize maximum subarray sum so far to - infinity . ; Initialize and compute the prefix sum array . ; loop through the array keep track of minimum prefix sum so far and maximum subarray sum . ; Test case 1 ; Test case 2",
        "Category": "Array"
    },
    {
        "ID": "6684-6684",
        "Code": "row = 5 NEW_LINE col = 5 NEW_LINE def isPath ( arr ) : NEW_LINE INDENT Dir = [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] NEW_LINE q = [ ] NEW_LINE q . append ( ( 0 , 0 ) ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT p = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE arr [ p [ 0 ] ] [ p [ 1 ] ] = - 1 NEW_LINE if ( p == ( row - 1 , col - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT a = p [ 0 ] + Dir [ i ] [ 0 ] NEW_LINE b = p [ 1 ] + Dir [ i ] [ 1 ] NEW_LINE if ( a >= 0 and b >= 0 and a < row and b < col and arr [ a ] [ b ] != - 1 ) : NEW_LINE INDENT q . append ( ( a , b ) ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] NEW_LINE if ( isPath ( arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check for possible path in 2D matrix | Python3 program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; directions ; queue ; insert the top right corner . ; until queue is empty ; mark as visited ; destination is reached . ; check all four directions ; using the direction array ; not blocked and valid ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ]",
        "Category": "Graph Theory"
    },
    {
        "ID": "669-669",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE newNode . left = None NEW_LINE newNode . right = None NEW_LINE return newNode NEW_LINE DEDENT def LevelOrder ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT root = getNode ( data ) NEW_LINE return root NEW_LINE DEDENT if ( data <= root . data ) : NEW_LINE INDENT root . left = LevelOrder ( root . left , data ) NEW_LINE DEDENT else : NEW_LINE INDENT root . right = LevelOrder ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def constructBst ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return None NEW_LINE DEDENT root = None NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT root = LevelOrder ( root , arr [ i ] ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inorderTraversal ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT inorderTraversal ( root . left ) NEW_LINE print ( root . data , end = \" ▁ \" ) NEW_LINE inorderTraversal ( root . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 4 , 12 , 3 , 6 , 8 , 1 , 5 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE root = constructBst ( arr , n ) NEW_LINE print ( \" Inorder ▁ Traversal : ▁ \" , end = \" \" ) NEW_LINE root = inorderTraversal ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct BST from its given level order traversal | Python implementation to construct a BST from its level order traversal ; node of a BST ; function to get a new node ; Allocate memory ; put in the data ; function to construct a BST from its level order traversal ; function to print the inorder traversal ; Driver program",
        "Category": "Binary Tree"
    },
    {
        "ID": "6697-6697",
        "Code": "dp = [ 0 ] * MAXN NEW_LINE nck = [ [ 0 for i in range ( MAXN ) ] for j in range ( MAXN ) ] NEW_LINE log2 = [ 0 ] * MAXN NEW_LINE def choose ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( nck [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return nck [ n ] [ k ] NEW_LINE DEDENT answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) NEW_LINE nck [ n ] [ k ] = answer NEW_LINE return answer NEW_LINE DEDENT def getLeft ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = log2 [ n ] NEW_LINE last = n - ( ( 1 << h ) - 1 ) NEW_LINE if ( last >= ( numh // 2 ) ) : NEW_LINE else : NEW_LINE INDENT return ( 1 << h ) - 1 - ( ( numh // 2 ) - last ) NEW_LINE DEDENT DEDENT def numberOfHeaps ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT left = getLeft ( n ) NEW_LINE ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) NEW_LINE dp [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT nck [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT currLog2 = - 1 NEW_LINE currPower2 = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( currPower2 == i ) : NEW_LINE INDENT currLog2 += 1 NEW_LINE currPower2 *= 2 NEW_LINE DEDENT log2 [ i ] = currLog2 NEW_LINE DEDENT return numberOfHeaps ( n ) NEW_LINE DEDENT n = 10 NEW_LINE print ( solve ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of ways to form a heap with n distinct integers | dp [ i ] = number of max heaps for i distinct integers ; nck [ i ] [ j ] = number of ways to choose j elements form i elements , no order ; log2 [ i ] = floor of logarithm of base 2 of i ; to calculate nCk ; calculate l for give value of n ; number of elements that are actually present in last level ( hth level ) ( 2 ^ h - 1 ) ; if more than half - filled ; return ( 1 << h ) - 1 ( 2 ^ h ) - 1 ; find maximum number of heaps for n ; function to initialize arrays ; for each power of two find logarithm ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6704-6704",
        "Code": "depth = 16 NEW_LINE ways = [ [ [ 0 for i in range ( 17 ) ] for i in range ( 17 ) ] for i in range ( 17 ) ] NEW_LINE def preprocess ( list , steps ) : NEW_LINE INDENT ways [ 0 ] [ 8 ] [ 8 ] = 1 NEW_LINE for N in range ( 1 , 16 , 1 ) : NEW_LINE INDENT for i in range ( 1 , depth , 1 ) : NEW_LINE INDENT for j in range ( 1 , depth , 1 ) : NEW_LINE INDENT ways [ N ] [ i ] [ j ] = ( ways [ N - 1 ] [ i ] [ j + 1 ] + ways [ N - 1 ] [ i ] [ j - 1 ] + ways [ N - 1 ] [ i + 1 ] [ j ] + ways [ N - 1 ] [ i - 1 ] [ j ] + ways [ N - 1 ] [ i + 1 ] [ j - 1 ] + ways [ N - 1 ] [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT list [ N ] = ways [ N ] [ 8 ] [ 8 ] NEW_LINE DEDENT print ( \" Number ▁ of ▁ walks ▁ possible ▁ is / are \" , list [ steps ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT list = [ 0 for i in range ( 16 ) ] NEW_LINE steps = 4 NEW_LINE preprocess ( list , steps ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of possible hexagonal walks | Python 3 implementation of counting number of possible hexagonal walks ; We initialize our origin with 1 ; For each N = 1 to 14 , we traverse in all possible direction . Using this 3D array we calculate the number of ways at each step and the total ways for a given step shall be found at ways [ step number ] [ 8 ] [ 8 ] because all the steps after that will be used to trace back to the original point index 0 : 0 according to the image . ; This array stores the number of ways possible for a given step ; Driver Code ; Preprocessing all possible ways",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6711-6711",
        "Code": "MAX = 256 NEW_LINE def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ ] for _ in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ ord ( B [ i ] ) ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos [ j ] : NEW_LINE INDENT if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = \" aa \" NEW_LINE B = \" baaa \" NEW_LINE N = len ( A ) NEW_LINE M = len ( B ) NEW_LINE print ( numberofways ( A , B , N , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of ways to insert a character to increase the LCS by one | Python Program to Number of ways to insert a character to increase LCS by one ; Return the Number of ways to insert a character to increase the Longest Common Subsequence by one ; Insert all positions of all characters in string B ; Longest Common Subsequence ; Longest Common Subsequence from reverse ; inserting character between position i and i + 1 ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6720-6720",
        "Code": "N = 105 NEW_LINE R = 3 NEW_LINE C = 4 NEW_LINE def maximumValue ( n , m , p , grid ) : NEW_LINE INDENT dp = [ [ [ False for i in range ( N ) ] for j in range ( N ) ] for k in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT k = grid [ i ] [ j ] NEW_LINE while ( k <= p ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( k == grid [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = True NEW_LINE DEDENT DEDENT elif ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] or dp [ i ] [ j - 1 ] [ k - grid [ i ] [ j ] ] ) NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] or dp [ i - 1 ] [ j ] [ k - grid [ i ] [ j ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] or dp [ i ] [ j - 1 ] [ k - grid [ i ] [ j ] ] ) NEW_LINE dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] or dp [ i - 1 ] [ j ] [ k - grid [ i ] [ j ] ] ) NEW_LINE dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] or dp [ i - 1 ] [ j - 1 ] [ k - grid [ i ] [ j ] ] ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT ans = k NEW_LINE while ( ans >= 0 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ m - 1 ] [ ans ] ) : NEW_LINE INDENT break NEW_LINE DEDENT ans -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 3 NEW_LINE m = 4 NEW_LINE p = 9 NEW_LINE grid = [ [ 2 , 3 , 4 , 1 ] , [ 6 , 5 , 5 , 3 ] , [ 5 , 2 , 3 , 4 ] ] NEW_LINE print ( maximumValue ( n , m , p , grid ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if possible to cross the matrix with given power | Python3 program to find if it is possible to cross the matrix with given power ; For each value of dp [ i ] [ j ] [ k ] ; For first cell and for each value of k ; For first cell of each row ; For first cell of each column ; For rest of the cell ; Down movement . ; Right movement . ; Diagonal movement . ; Finding maximum k . ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "674-674",
        "Code": "import sys NEW_LINE import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def storeBSTNodes ( root , nodes ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT storeBSTNodes ( root . left , nodes ) NEW_LINE nodes . append ( root ) NEW_LINE storeBSTNodes ( root . right , nodes ) NEW_LINE DEDENT def buildTreeUtil ( nodes , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return None NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE node = nodes [ mid ] NEW_LINE node . left = buildTreeUtil ( nodes , start , mid - 1 ) NEW_LINE node . right = buildTreeUtil ( nodes , mid + 1 , end ) NEW_LINE return node NEW_LINE DEDENT def buildTree ( root ) : NEW_LINE INDENT nodes = [ ] NEW_LINE storeBSTNodes ( root , nodes ) NEW_LINE n = len ( nodes ) NEW_LINE return buildTreeUtil ( nodes , 0 , n - 1 ) NEW_LINE DEDENT def preOrder ( root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT print ( \" { } ▁ \" . format ( root . data ) , end = \" \" ) NEW_LINE preOrder ( root . left ) NEW_LINE preOrder ( root . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . left . left = Node ( 7 ) NEW_LINE root . left . left . left = Node ( 6 ) NEW_LINE root . left . left . left . left = Node ( 5 ) NEW_LINE root = buildTree ( root ) NEW_LINE print ( \" Preorder ▁ traversal ▁ of ▁ balanced ▁ BST ▁ is ▁ : \" ) NEW_LINE preOrder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert a normal BST to Balanced BST | Python3 program to convert a left unbalanced BST to a balanced BST ; A binary tree node has data , pointer to left child and a pointer to right child ; This function traverse the skewed binary tree and stores its nodes pointers in vector nodes [ ] ; Base case ; Store nodes in Inorder ( which is sorted order for BST ) ; Recursive function to construct binary tree ; base case ; Get the middle element and make it root ; Using index in Inorder traversal , construct left and right subtress ; This functions converts an unbalanced BST to a balanced BST ; Store nodes of given BST in sorted order ; Constucts BST from nodes [ ] ; Function to do preorder traversal of tree ; Driver code ; Constructed skewed binary tree is 10 / 8 / 7 / 6 / 5",
        "Category": "Binary Tree"
    },
    {
        "ID": "6741-6741",
        "Code": "def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for k in range ( n + 1 ) ] for l in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Repeated Subsequence | Refer https : www . geeksforgeeks . org / longest - repeating - subsequence / for complete code . This function mainly returns LCS ( str , str ) with a condition that same characters at same index are not considered . ; Create and initialize DP table ; Fill dp table ( similar to LCS loops ) ; If characters match and indices are not same ; If characters do not match",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6767-6767",
        "Code": "def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 1 NEW_LINE while dp [ i ] <= N : NEW_LINE INDENT i = i + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT N = 10 NEW_LINE print ( maxGameByWinner ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum games played by winner | method returns maximum games a winner needs to play in N - player tournament ; for 0 games , 1 player is needed for 1 game , 2 players are required ; loop until i - th Fibonacci number is less than or equal to N ; result is ( i - 1 ) because i will be incremented one extra in while loop and we want the last value which is smaller than N , so ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6775-6775",
        "Code": "def ans ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return n % 6 + 10 * ( ans ( n // 6 ) ) - 1 NEW_LINE DEDENT def getSpecialNumber ( N ) : NEW_LINE INDENT return ans ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 17 NEW_LINE answer = getSpecialNumber ( N ) NEW_LINE print ( answer ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "n | Python3 code to find nth number with digits 0 , 1 , 2 , 3 , 4 , 5 ; If the Number is less than 6 return the number as it is . ; Call the function again and again the get the desired result . And convert the number to base 6. ; Decrease the Number by 1 and Call ans function to convert N to base 6 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "6779-6779",
        "Code": "MAX = 300 NEW_LINE dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def minimumSquare ( m , n ) : NEW_LINE INDENT vertical_min = 10000000000 NEW_LINE horizontal_min = 10000000000 NEW_LINE if n == 13 and m == 11 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if m == 13 and n == 11 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if m == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ m ] [ n ] != 0 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT for i in range ( 1 , m // 2 + 1 ) : NEW_LINE INDENT horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) NEW_LINE DEDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) NEW_LINE DEDENT dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 30 NEW_LINE n = 35 NEW_LINE print ( minimumSquare ( m , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Paper Cut into Minimum Number of Squares | Set 2 | Python3 program to find minimum number of squares to cut a paper using Dynamic Programming ; Returns min number of squares needed ; Initializing max values to vertical_min and horizontal_min ; N = 11 & M = 13 is a special case ; If the given rectangle is already a square ; If the answer for the given rectangle is previously calculated return that answer ; The rectangle is cut horizontally and vertically into two parts and the cut with minimum value is found for every recursive call . ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Minimum of the vertical cut or horizontal cut to form a square is the answer ; Driver code ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6784-6784",
        "Code": "def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT n = 2 NEW_LINE print ( \" Number ▁ of ▁ Non - Decreasing ▁ digits : ▁ \" , nCr ( n + 9 , 9 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of n | Returns factorial of n ; returns nCr ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "6786-6786",
        "Code": "def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 3 , 2 NEW_LINE print ( countWays ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Painting Fence Algorithm | Returns count of ways to color k posts using k colors ; There are k ways to color first post ; There are 0 ways for single post to violate ( same color_ and k ways to not violate ( different color ) ; Fill for 2 posts onwards ; Current same is same as previous diff ; We always have k - 1 choices for next post ; Total choices till i . ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6794-6794",
        "Code": "def sumOfSubstrings ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE INDENT mf = 1 NEW_LINE for i in range ( len ( num ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ( num [ i ] ) ) * ( i + 1 ) * mf NEW_LINE mf = mf * 10 + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = \"6759\" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all substrings of a string representing a number | Set 2 ( Constant Extra Space ) | Returns sum of all substring of num ; Initialize result ; Here traversing the array in reverse order . Initializing loop from last element . mf is multiplying factor . ; Each time sum is added to its previous sum . Multiplying the three factors as explained above . int ( s [ i ] ) is done to convert char to int . ; Making new multiplying factor as explained above . ; Driver code to test above methods",
        "Category": "Math"
    },
    {
        "ID": "6795-6795",
        "Code": "def minPyramidCost ( arr : list , N ) : NEW_LINE INDENT left = [ 0 ] * N NEW_LINE right = [ 0 ] * N NEW_LINE left [ 0 ] = min ( arr [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT left [ i ] = min ( arr [ i ] , min ( left [ i - 1 ] + 1 , i + 1 ) ) NEW_LINE DEDENT right [ N - 1 ] = min ( arr [ N - 1 ] , 1 ) NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = min ( arr [ i ] , min ( right [ i + 1 ] + 1 , N - i ) ) NEW_LINE DEDENT tot = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT tot [ i ] = min ( right [ i ] , left [ i ] ) NEW_LINE DEDENT max_ind = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if tot [ i ] > tot [ max_ind ] : NEW_LINE INDENT max_ind = i NEW_LINE DEDENT DEDENT cost = 0 NEW_LINE height = tot [ max_ind ] NEW_LINE for x in range ( max_ind , - 1 , - 1 ) : NEW_LINE INDENT cost += arr [ x ] - height NEW_LINE if height > 0 : NEW_LINE INDENT height -= 1 NEW_LINE DEDENT DEDENT height = tot [ max_ind ] - 1 NEW_LINE for x in range ( max_ind + 1 , N ) : NEW_LINE INDENT cost += arr [ x ] - height NEW_LINE if height > 0 : NEW_LINE INDENT height -= 1 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 2 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minPyramidCost ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Pyramid form ( increasing then decreasing ) consecutive array using reduce operations | Returns minimum cost to form a pyramid ; Store the maximum possible pyramid height ; Maximum height at start is 1 ; For each position calculate maximum height ; Maximum height at end is 1 ; For each position calculate maximum height ; Find minimum possible among calculated values ; Find maximum height of pyramid ; Calculate cost of this pyramid ; Calculate cost of left half ; Calculate cost of right half ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "681-681",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def lca ( root , n1 , n2 ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . data > n1 and root . data > n2 : NEW_LINE INDENT root = root . left NEW_LINE DEDENT elif root . data < n1 and root . data < n2 : NEW_LINE INDENT root = root . right NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT root = Node ( 20 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . right = Node ( 22 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 12 ) NEW_LINE root . left . right . left = Node ( 10 ) NEW_LINE root . left . right . right = Node ( 14 ) NEW_LINE n1 = 10 ; n2 = 14 NEW_LINE t = lca ( root , n1 , n2 ) NEW_LINE print \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d \" % ( n1 , n2 , t . data ) NEW_LINE n1 = 14 ; n2 = 8 NEW_LINE t = lca ( root , n1 , n2 ) NEW_LINE print \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d \" % ( n1 , n2 , t . data ) NEW_LINE n1 = 10 ; n2 = 22 NEW_LINE t = lca ( root , n1 , n2 ) NEW_LINE print \" LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d \" % ( n1 , n2 , t . data ) NEW_LINE",
        "Type": "py",
        "NL": "Lowest Common Ancestor in a Binary Search Tree . | A recursive python program to find LCA of two nodes n1 and n2 A Binary tree node ; Function to find LCA of n1 and n2 . The function assumes that both n1 and n2 are present in BST ; If both n1 and n2 are smaller than root , then LCA lies in left ; If both n1 and n2 are greater than root , then LCA lies in right ; Let us construct the BST shown in the figure",
        "Category": "Binary Tree"
    },
    {
        "ID": "6814-6814",
        "Code": "def lis ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( result < lis [ i ] ) : NEW_LINE INDENT result = lis [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def minimumNumberOfDeletions ( arr , n ) : NEW_LINE INDENT len = lis ( arr , n ) NEW_LINE return ( n - len ) NEW_LINE DEDENT arr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ \" , minimumNumberOfDeletions ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of deletions to make a sorted sequence | lis ( ) returns the length of the longest increasing subsequence in arr [ ] of size n ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Pick resultimum of all LIS values ; Function to calculate minimum number of deletions ; Find longest increasing subsequence ; After removing elements other than the lis , we get sorted sequence . ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6824-6824",
        "Code": "def utility_fun_for_del ( Str , i , j ) : NEW_LINE INDENT if ( i >= j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( Str [ i ] == Str [ j ] ) : NEW_LINE INDENT return utility_fun_for_del ( Str , i + 1 , j - 1 ) NEW_LINE DEDENT return ( 1 + min ( utility_fun_for_del ( Str , i + 1 , j ) , utility_fun_for_del ( Str , i , j - 1 ) ) ) NEW_LINE DEDENT def min_ele_del ( Str ) : NEW_LINE INDENT return utility_fun_for_del ( Str , 0 , len ( Str ) - 1 ) NEW_LINE DEDENT Str = \" abefbac \" NEW_LINE print ( \" Minimum ▁ element ▁ of ▁ deletions ▁ = \" , min_ele_del ( Str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of deletions to make a string palindrome | Utility function for calculating Minimum element to delete ; Condition to compare characters ; Recursive function call ; Return value , increamenting by 1 return minimum Element between two values ; Function to calculate the minimum Element required to delete for Making string pelindrom ; Utility function call ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6825-6825",
        "Code": "def transformation ( s1 , s2 , i , j , dp ) : NEW_LINE INDENT if i >= len ( s1 ) or j >= len ( s2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if s1 [ i ] == s2 [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + transformation ( s1 , s2 , i + 1 , j + 1 , dp ) NEW_LINE DEDENT if dp [ i ] [ j ] != - 1 : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( transformation ( s1 , s2 , i , j + i , dp ) , transformation ( s1 , s2 , i + 1 , j , dp ) ) NEW_LINE DEDENT return dp [ - 1 ] [ - 1 ] NEW_LINE DEDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeks \" NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE / * Driver code * / NEW_LINE dp = [ [ - 1 for _ in range ( len ( s1 ) + 1 ) ] for _ in range ( len ( s2 ) + 1 ) ] NEW_LINE print ( \" MINIMUM ▁ NUMBER ▁ OF ▁ DELETIONS : ▁ \" , len ( s1 ) - transformation ( s1 , s2 , 0 , 0 , dp ) , end = \" ▁ \" ) NEW_LINE print ( \" MINIMUM ▁ NUMBER ▁ OF ▁ INSERTIONS : ▁ \" , len ( s2 ) - transformation ( s1 , s2 , 0 , 0 , dp ) , end = \" ▁ \" ) NEW_LINE print ( \" LCS ▁ LENGTH : ▁ \" , transformation ( s1 , s2 , 0 , 0 , dp ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of deletions to make a string palindrome | function definition ; base cases ; checking the ndesired condition ; if yes increment the cunt ; if no ; return the value form the table ; else store the max tranforamtion from the subsequence ; return the dp [ - 1 ] [ - 1 ] ;  ; initialize the array with - 1",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6828-6828",
        "Code": "from typing import List NEW_LINE class Temple : NEW_LINE INDENT def __init__ ( self , l : int , r : int ) : NEW_LINE INDENT self . L = l NEW_LINE self . R = r NEW_LINE DEDENT DEDENT def offeringNumber ( n : int , templeHeight : List [ int ] ) -> int : NEW_LINE INDENT chainSize = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT chainSize [ i ] = Temple ( - 1 , - 1 ) NEW_LINE DEDENT chainSize [ 0 ] . L = 1 NEW_LINE chainSize [ - 1 ] . R = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if templeHeight [ i - 1 ] < templeHeight [ i ] : NEW_LINE INDENT chainSize [ i ] . L = chainSize [ i - 1 ] . L + 1 NEW_LINE DEDENT else : NEW_LINE INDENT chainSize [ i ] . L = 1 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if templeHeight [ i + 1 ] < templeHeight [ i ] : NEW_LINE INDENT chainSize [ i ] . R = chainSize [ i + 1 ] . R + 1 NEW_LINE DEDENT else : NEW_LINE INDENT chainSize [ i ] . R = 1 NEW_LINE DEDENT DEDENT sm = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm += max ( chainSize [ i ] . L , chainSize [ i ] . R ) NEW_LINE DEDENT return sm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 1 , 2 , 2 ] NEW_LINE print ( offeringNumber ( 3 , arr1 ) ) NEW_LINE arr2 = [ 1 , 4 , 3 , 6 , 2 , 1 ] NEW_LINE print ( offeringNumber ( 6 , arr2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Temple Offerings | Python3 program to find temple offerings required ; To store count of increasing order temples on left and right ( including current temple ) ; Returns count of minimum offerings for n temples of given heights . ; Initialize counts for all temples ; Values corner temples ; Filling left and right values using same values of previous ( or next ; Computing max of left and right for all temples and returing sum ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6836-6836",
        "Code": "' NEW_LINE def solve ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to solve a Dynamic Programming Problem ? | Returns the number of arrangements to form 'n ; Base case",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6837-6837",
        "Code": "' NEW_LINE def solve ( n , lookup = { } ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n not in lookup : NEW_LINE INDENT lookup [ n ] = ( solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ) NEW_LINE DEDENT return lookup [ n ] NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to solve a Dynamic Programming Problem ? | This function returns the number of arrangements to form 'n ; lookup dictionary / hashmap is initialized ; Base cases negative number can 't be  produced, return 0 ; 0 can be produced by not taking any number whereas 1 can be produced by just taking 1 ; Checking if number of way for producing n is already calculated or not if calculated , return that , otherwise calulcate and then return",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6839-6839",
        "Code": "M = 26 NEW_LINE def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ ] for i in range ( M ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) NEW_LINE DEDENT lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT for C in range ( 0 , 26 , 1 ) : NEW_LINE INDENT for j in range ( 0 , len ( position [ C ] ) , 1 ) : NEW_LINE INDENT p = position [ C ] [ j ] NEW_LINE if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT str1 = \" abcabc \" NEW_LINE str2 = \" abcd \" NEW_LINE print ( waysToIncreaseLCSBy1 ( str1 , str2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count ways to increase LCS length of two strings by one | Python3 program to get number of ways to increase LCS by 1 ; Method returns total ways to increase LCS length by 1 ; Fill positions of each character in vector vector < int > position [ M ] ; ; Initializing 2D array by 0 values ; Filling LCS array for prefix substrings ; Filling LCS array for suffix substrings ; Looping for all possible insertion positions in first string ; Trying all possible lower case characters ; Now for each character , loop over same character positions in second string ; If both , left and right substrings make total LCS then increase result by 1 ; Driver code to test above methods",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6840-6840",
        "Code": "def countSubsequences ( s ) : NEW_LINE ' NEW_LINE INDENT aCount = 0 NEW_LINE DEDENT ' NEW_LINE INDENT bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abbc \" NEW_LINE print ( countSubsequences ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of subsequences of the form a ^ i b ^ j c ^ k | Returns count of subsequences of the form a ^ i b ^ j c ^ k ; Initialize counts of different subsequences caused by different combination of 'a ; Initialize counts of different subsequences caused by different combination of ' a ' and different combination of 'b ; Initialize counts of different subsequences caused by different combination of ' a ' , ' b ' and ' c ' . ; Traverse all characters of given string ; If current character is ' a ' , then there are following possibilities : a ) Current character begins a new subsequence . b ) Current character is part of aCount subsequences . c ) Current character is not part of aCount subsequences . ; If current character is ' b ' , then there are following possibilities : a ) Current character begins a new subsequence of b 's with aCount subsequences. b) Current character is part of bCount subsequences. c) Current character is not  part of bCount subsequences. ; If current character is ' c ' , then there are following possibilities : a ) Current character begins a new subsequence of c 's with bCount subsequences. b) Current character is part of cCount subsequences. c) Current character is not  part of cCount subsequences. ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6847-6847",
        "Code": "def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 ] * ( m + 1 ) NEW_LINE nxtbb = 0 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; NEW_LINE DEDENT nxtbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 20 NEW_LINE x = [ 6 , 7 , 12 , 13 , 14 ] NEW_LINE revenue = [ 5 , 6 , 5 , 3 , 1 ] NEW_LINE n = len ( x ) NEW_LINE t = 5 NEW_LINE print ( maxRevenue ( m , x , revenue , n , t ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Highway Billboard Problem | Python3 program to find maximum revenue by placing billboard on the highway with given constraints . ; Array to store maximum revenue at each miles . ; actual minimum distance between 2 billboards . ; check if all billboards are already placed . ; check if we have billboard for that particular mile . If not , copy the previous maximum revenue . ; we do have billboard for this mile . ; If current position is less than or equal to t , then we can have only one billboard . ; Else we may have to remove previously placed billboard ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "685-685",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isBST ( root , l = None , r = None ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( l != None and root . data <= l . data ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( r != None and root . data >= r . data ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isBST ( root . left , l , root ) and isBST ( root . right , root , r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 3 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 4 ) NEW_LINE if ( isBST ( root , None , None ) ) : NEW_LINE INDENT print ( \" Is ▁ BST \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ BST \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "A program to check if a binary tree is BST or not |  ; Helper function that allocates a new node with the given data and None left and right poers . ; Returns true if given tree is BST . ; Base condition ; if left node exist then check it has correct data or not i . e . left node ' s ▁ data ▁ ▁ should ▁ be ▁ less ▁ than ▁ root ' s data ; if right node exist then check it has correct data or not i . e . right node ' s ▁ data ▁ ▁ should ▁ be ▁ greater ▁ than ▁ root ' s data ; check recursively for every node . ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "6851-6851",
        "Code": "' NEW_LINE N = 4 NEW_LINE def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT ' NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE DEDENT / * initialize all dp matrix as '0' * / NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT Mat = [ [ 4 , 2 , 3 , 4 ] , [ 2 , 9 , 1 , 10 ] , [ 15 , 1 , 3 , 0 ] , [ 16 , 92 , 41 , 44 ] ] NEW_LINE print ( MaximumPath ( Mat ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum path sum that starting with any cell of 0 | Python3 program to find Maximum path sum start any column in row '0' and ends up to any column in row 'n-1 ; function find maximum sum path ; create 2D matrix to store the sum of the path initialize all dp matrix as '0 ;  ; copy all element of first column into dp first column ; Find maximum path sum that end ups at any column of last row 'N-1 ; return maximum sum path ; driver program to test above function",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6852-6852",
        "Code": "from typing import List NEW_LINE def findLIS ( arr : List [ int ] , n : int ) -> List [ int ] : NEW_LINE INDENT L = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] = [ ] NEW_LINE DEDENT L [ 0 ] . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( len ( L [ i ] ) < len ( L [ j ] ) ) ) : NEW_LINE INDENT L [ i ] = L [ j ] . copy ( ) NEW_LINE DEDENT DEDENT L [ i ] . append ( arr [ i ] ) NEW_LINE DEDENT maxSize = 1 NEW_LINE lis : List [ int ] = [ ] NEW_LINE for x in L : NEW_LINE INDENT if ( len ( x ) > maxSize ) : NEW_LINE INDENT lis = x . copy ( ) NEW_LINE maxSize = len ( x ) NEW_LINE DEDENT DEDENT return lis NEW_LINE DEDENT def minimize ( input : List [ int ] , n : int ) -> None : NEW_LINE INDENT arr = input . copy ( ) NEW_LINE while len ( arr ) : NEW_LINE INDENT lis = findLIS ( arr , len ( arr ) ) NEW_LINE if ( len ( lis ) < 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( arr ) and len ( lis ) > 0 : NEW_LINE INDENT if ( arr [ i ] == lis [ 0 ] ) : NEW_LINE INDENT arr . remove ( arr [ i ] ) NEW_LINE i -= 1 NEW_LINE lis . remove ( lis [ 0 ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input = [ 3 , 2 , 6 , 4 , 5 , 1 ] NEW_LINE n = len ( input ) NEW_LINE minimize ( input , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Size of array after repeated deletion of LIS | Function to construct Maximum Sum LIS ; L [ i ] - The Maximum Sum Increasing Subsequence that ends with arr [ i ] ; L [ 0 ] is equal to arr [ 0 ] ; start from index 1 ; for every j less than i ; L [ i ] = MaxSum ( L [ j ] ) + arr [ i ] where j < i and arr [ j ] < arr [ i ] ; L [ i ] ends with arr [ i ] ; set lis = LIS whose size is max among all ; The > sign makes sure that the LIS ending first is chose . ; Function to minimize array ; Find LIS of current array ; If all elements are in decreasing order ; Remove lis elements from current array . Note that both lis [ ] and arr [ ] are sorted in increasing order . ; If first element of lis [ ] is found ; Remove lis element from arr [ ] ; Erase first element of lis [ ] ; print remaining element of array ; print - 1 for empty array ; Driver function ; minimize array after deleting LIS",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6853-6853",
        "Code": "MAX = 21 NEW_LINE fact = [ 0 ] * MAX NEW_LINE def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) NEW_LINE DEDENT ans = ans / ( 1 << n ) NEW_LINE return ans NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE fact [ 1 ] = 1 NEW_LINE for i in range ( 2 , 20 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE print ( probability ( 2 , 3 ) ) NEW_LINE print ( probability ( 3 , 6 ) ) NEW_LINE print ( probability ( 12 , 18 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability of getting at least K heads in N tosses of Coins | Naive approach in Python3 to find probability of at least k heads ; Returns probability of getting at least k heads in n tosses . ; Probability of getting exactly i heads out of n heads ; Note : 1 << n = pow ( 2 , n ) ; Preprocess all factorial only upto 19 , as after that it will overflow ; Driver code ; Probability of getting 2 head out of 3 coins ; Probability of getting 3 head out of 6 coins ; Probability of getting 12 head out of 18 coins",
        "Category": "Math"
    },
    {
        "ID": "6854-6854",
        "Code": "from math import log2 NEW_LINE MAX = 100001 NEW_LINE dp = [ 0 ] * MAX NEW_LINE def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT res = dp [ n ] - dp [ i ] - dp [ n - i ] - n NEW_LINE ans = ans + pow ( 2.0 , res ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT dp [ i ] = log2 ( i ) + dp [ i - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE print ( probability ( 2 , 3 ) ) NEW_LINE print ( probability ( 3 , 6 ) ) NEW_LINE print ( probability ( 500 , 1000 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability of getting at least K heads in N tosses of Coins | Dynamic and Logarithm approach find probability of at least k heads ; dp [ i ] is going to store Log ( i ! ) in base 2 ; Initialize result ; Iterate from k heads to n heads ; Preprocess all the logarithm value on base 2 ; Driver code ; Probability of getting 2 head out of 3 coins ; Probability of getting 3 head out of 6 coins ; Probability of getting 500 head out of 10000 coins",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6865-6865",
        "Code": "M = 3 NEW_LINE N = 3 NEW_LINE def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] NEW_LINE op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] NEW_LINE ans = max ( ans , max ( op1 , op2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT / * input the calories burnt matrix * / NEW_LINE A = [ [ 100 , 100 , 100 ] , [ 100 , 1 , 100 ] , [ 100 , 100 , 100 ] ] NEW_LINE print ( \" Max ▁ Points ▁ : ▁ \" , findMaxPoints ( A ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum points collected by two persons allowed to meet once | Python program to find maximum points that can be collected by two persons in a matrix . ; To store points collected by Person P1 when he / she begins journy from start and from end . ; To store points collected by Person P2 when he / she begins journey from start and from end . ; Table for P1 's journey from  start to meeting cell ; Table for P1 's journey from  end to meet cell ; Table for P2 's journey from start to meeting cell ; Table for P2 's journey from end to meeting cell ; Now iterate over all meeting positions ( i , j ) ;",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6867-6867",
        "Code": "R , C = 5 , 3 NEW_LINE def precompute ( mat , ryt , dwn ) : NEW_LINE INDENT for j in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( 0 , R ) : NEW_LINE INDENT if mat [ i ] [ j ] == 0 : NEW_LINE INDENT ryt [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ryt [ i ] [ j ] = ryt [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT if mat [ i ] [ j ] == 0 : NEW_LINE INDENT dwn [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dwn [ i ] [ j ] = dwn [ i + 1 ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def solveRowSwap ( ryt ) : NEW_LINE INDENT b = [ 0 ] * R NEW_LINE ans = 0 NEW_LINE for j in range ( 0 , C ) : NEW_LINE INDENT for i in range ( 0 , R ) : NEW_LINE INDENT b [ i ] = ryt [ i ] [ j ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , R ) : NEW_LINE INDENT ans = max ( ans , b [ i ] * ( R - i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def solveColumnSwap ( dwn ) : NEW_LINE INDENT b = [ 0 ] * C NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT b [ j ] = dwn [ i ] [ j ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , C ) : NEW_LINE INDENT ans = max ( ans , b [ i ] * ( C - i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def findMax1s ( mat ) : NEW_LINE INDENT ryt = [ [ 0 for i in range ( C + 2 ) ] for j in range ( R + 2 ) ] NEW_LINE dwn = [ [ 0 for i in range ( C + 2 ) ] for j in range ( R + 2 ) ] NEW_LINE precompute ( mat , ryt , dwn ) NEW_LINE rswap = solveRowSwap ( ryt ) NEW_LINE cswap = solveColumnSwap ( dwn ) NEW_LINE if rswap > cswap : print ( \" Row Swap \" , rswap ) NEW_LINE else : print ( \" Column Swap \" , cswap ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 0 ] , [ 1 , 1 , 0 ] , [ 1 , 1 , 0 ] , [ 0 , 0 , 0 ] , [ 1 , 1 , 0 ] ] NEW_LINE findMax1s ( mat ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether row or column swaps produce maximum size binary sub | Python3 program to find maximum binary sub - matrix with row swaps and column swaps . ; Precompute the number of consecutive 1 below the ( i , j ) in j - th column and the number of consecutive 1 s on right side of ( i , j ) in i - th row . ; Travesing the 2d matrix from top - right . ; If ( i , j ) contain 0 , do nothing ; Counting consecutive 1 on right side ; Travesing the 2d matrix from bottom - left . ; If ( i , j ) contain 0 , do nothing ; Counting consecutive 1 down to ( i , j ) . ; Return maximum size submatrix with row swap allowed . ; Copying the column ; Sort the copied array ; Find maximum submatrix size . ; Return maximum size submatrix with column swap allowed . ; Copying the row . ; Sort the copied array ; Find maximum submatrix size . ; Solving for row swap and column swap ; Comparing both . ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "6869-6869",
        "Code": "N = 8 NEW_LINE dx = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE dy = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE def inside ( x , y ) : NEW_LINE INDENT return ( x >= 0 and x < N and y >= 0 and y < N ) NEW_LINE DEDENT def findProb ( start_x , start_y , steps ) : NEW_LINE INDENT dp1 = [ [ [ 0 for i in range ( N + 5 ) ] for j in range ( N + 5 ) ] for k in range ( steps + 5 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp1 [ i ] [ j ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT for s in range ( 1 , steps + 1 ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT for y in range ( N ) : NEW_LINE INDENT prob = 0.0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT nx = x + dx [ i ] NEW_LINE ny = y + dy [ i ] NEW_LINE if ( inside ( nx , ny ) ) : NEW_LINE INDENT prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 NEW_LINE DEDENT DEDENT dp1 [ x ] [ y ] [ s ] = prob NEW_LINE DEDENT DEDENT DEDENT return dp1 [ start_x ] [ start_y ] [ steps ] NEW_LINE DEDENT K = 3 NEW_LINE print ( findProb ( 0 , 0 , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Probability of Knight to remain in the chessboard | size of the chessboard ; Direction vector for the Knight ; returns true if the knight is inside the chessboard ; Bottom up approach for finding the probability to go out of chessboard . ; dp array ; For 0 number of steps , each position will have probability 1 ; for every number of steps s ; for every position ( x , y ) after s number of steps ; For every position reachable from ( x , y ) ; if this position lie inside the board ; store the result ; return the result ; number of steps ; Function Call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6902-6902",
        "Code": "M = 100 NEW_LINE def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Path with maximum average value | Maximum number of rows and / or columns ; method returns maximum average of all path of cost matrix ; Initialize first column of total cost ( dp ) array ; Initialize first row of dp array ; Construct rest of the dp array ; divide maximum sum by constant path length : ( 2 N - 1 ) for getting average ; Driver program to test above function",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6905-6905",
        "Code": "def countPS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT str = \" abcb \" NEW_LINE print ( \" Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ \" , countPS ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count All Palindromic Subsequence in a given String | Function return the total palindromic subsequence ; Create a 2D array to store the count of palindromic subsequence ; palindromic subsequence of length 1 ; check subsequence of length L is palindrome or not ; return total palindromic subsequence ; Driver program",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6906-6906",
        "Code": "str = \" abcb \" NEW_LINE def countPS ( i , j ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dp = [ [ - 1 for x in range ( 1000 ) ] for y in range ( 1000 ) ] NEW_LINE n = len ( str ) NEW_LINE print ( \" Total ▁ palindromic ▁ subsequence ▁ are ▁ : \" , countPS ( 0 , n - 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count All Palindromic Subsequence in a given String | Python 3 program to counts Palindromic Subsequence in a given String using recursion ; Function return the total palindromic subsequence ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6913-6913",
        "Code": "def minimum ( a , b , c ) : NEW_LINE INDENT return min ( min ( a , b ) , c ) ; NEW_LINE DEDENT def findMinSum ( arr , n ) : NEW_LINE INDENT sum = [ ] NEW_LINE sum . append ( arr [ 0 ] ) NEW_LINE sum . append ( arr [ 1 ] ) NEW_LINE sum . append ( arr [ 2 ] ) NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT sum . append ( arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ) NEW_LINE DEDENT return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 20 , 2 , 10 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Min ▁ Sum ▁ is ▁ \" , findMinSum ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find minimum sum such that one of every three consecutive elements is taken | A utility function to find minimum of 3 elements ; Returns minimum possible sum of elements such that an element out of every three consecutive elements is picked . ; Create a DP table to store results of subproblems . sum [ i ] is going to store minimum possible sum when arr [ i ] is part of the solution . ; When there are less than or equal to 3 elements ; Iterate through all other elements ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6927-6927",
        "Code": "def lenOfLongestGP ( sett , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 2 if ( sett [ 1 ] % sett [ 0 ] == 0 ) else 1 NEW_LINE DEDENT sett . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE llgp = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if sett [ n - 1 ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE if 2 > llgp : NEW_LINE INDENT llgp = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT L [ n - 1 ] [ n - 1 ] = 1 NEW_LINE for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k <= n - 1 : NEW_LINE INDENT if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE if L [ i ] [ j ] > llgp : NEW_LINE INDENT llgp = L [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT return llgp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set1 = [ 1 , 3 , 9 , 27 , 81 , 243 ] NEW_LINE n1 = len ( set1 ) NEW_LINE print ( lenOfLongestGP ( set1 , n1 ) ) NEW_LINE set2 = [ 1 , 3 , 4 , 9 , 7 , 27 ] NEW_LINE n2 = len ( set2 ) NEW_LINE print ( lenOfLongestGP ( set2 , n2 ) ) NEW_LINE set3 = [ 2 , 3 , 5 , 7 , 11 , 13 ] NEW_LINE n3 = len ( set3 ) NEW_LINE print ( lenOfLongestGP ( set3 , n3 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Geometric Progression | Returns length of the longest GP subset of sett [ ] ; Base cases ; let us sort the sett first ; An entry L [ i ] [ j ] in this table stores LLGP with sett [ i ] and sett [ j ] as first two elements of GP and j > i . ; Initialize result ( A single element is always a GP ) ; Initialize values of last column ; Consider every element as second element of GP ; Search for i and k for j ; Two cases when i , j and k don 't form  a GP. ; i , j and k form GP , LLGP with i and j as first two elements is equal to LLGP with j and k as first two elements plus 1. L [ j ] [ k ] must have been filled before as we run the loop from right side ; Update overall LLGP ; Change i and k to fill more L [ i ] [ j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entries in column j as 1 or 2 based on divisibility of sett [ j ] by sett [ i ] ; Return result ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6940-6940",
        "Code": "def printShortestSuperSeq ( x , y ) : NEW_LINE INDENT m = len ( x ) NEW_LINE n = len ( y ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT string = \" \" NEW_LINE i = m NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : NEW_LINE INDENT string += y [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while i > 0 : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT while j > 0 : NEW_LINE INDENT string += y [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT string = list ( string ) NEW_LINE string . reverse ( ) NEW_LINE return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = \" AGGTAB \" NEW_LINE y = \" GXTXAYB \" NEW_LINE print ( printShortestSuperSeq ( x , y ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Printing Shortest Common Supersequence | returns shortest supersequence of X and Y ; dp [ i ] [ j ] contains length of shortest supersequence for X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; Fill table in bottom up manner ; Below steps follow recurrence relation ; string to store the shortest supersequence ; Start from the bottom right corner and one by one push characters in output string ; If current character in X and Y are same , then current character is part of shortest supersequence ; Put current character in result ; reduce values of i , j and index ; If current character in X and Y are different ; Put current character of Y in result ; reduce values of j and index ; Put current character of X in result ; reduce values of i and index ; If Y reaches its end , put remaining characters of X in the result string ; If X reaches its end , put remaining characters of Y in the result string ; reverse the string and return it ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6945-6945",
        "Code": "def maxLeftSubArraySum ( a , size , sum ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE sum [ 0 ] = max_so_far NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE sum [ i ] = max_so_far NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def maxRightSubArraySum ( a , n , sum ) : NEW_LINE INDENT max_so_far = a [ n ] NEW_LINE curr_max = a [ n ] NEW_LINE sum [ n ] = max_so_far NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE sum [ i ] = max_so_far NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def findMaxAbsDiff ( arr , n ) : NEW_LINE INDENT leftMax = [ 0 for i in range ( n ) ] NEW_LINE maxLeftSubArraySum ( arr , n , leftMax ) NEW_LINE rightMax = [ 0 for i in range ( n ) ] NEW_LINE maxRightSubArraySum ( arr , n - 1 , rightMax ) NEW_LINE invertArr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT invertArr [ i ] = - arr [ i ] NEW_LINE DEDENT leftMin = [ 0 for i in range ( n ) ] NEW_LINE maxLeftSubArraySum ( invertArr , n , leftMin ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftMin [ i ] = - leftMin [ i ] NEW_LINE DEDENT rightMin = [ 0 for i in range ( n ) ] NEW_LINE maxRightSubArraySum ( invertArr , n - 1 , rightMin ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT rightMin [ i ] = - rightMin [ i ] NEW_LINE DEDENT result = - 2147483648 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT absValue = max ( abs ( leftMax [ i ] - rightMin [ i + 1 ] ) , abs ( leftMin [ i ] - rightMax [ i + 1 ] ) ) NEW_LINE if ( absValue > result ) : NEW_LINE INDENT result = absValue NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMaxAbsDiff ( a , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum absolute difference between sum of two contiguous sub | Find maximum subarray sum for subarray [ 0. . i ] using standard Kadane ' s ▁ algorithm . ▁ This ▁ version ▁ ▁ of ▁ Kadane ' s Algorithm will work if all numbers are negative . ; Find maximum subarray sum for subarray [ i . . n ] using Kadane ' s ▁ algorithm . ▁ This ▁ version ▁ of ▁ Kadane ' s Algorithm will work if all numbers are negative ; The function finds two non - overlapping contiguous sub - arrays such that the absolute difference between the sum of two sub - array is maximum . ; create and build an array that stores maximum sums of subarrays that lie in arr [ 0. . . i ] ; create and build an array that stores maximum sums of subarrays that lie in arr [ i + 1. . . n - 1 ] ; Invert array ( change sign ) to find minumum sum subarrays . ; create and build an array that stores minimum sums of subarrays that lie in arr [ 0. . . i ] ; create and build an array that stores minimum sums of subarrays that lie in arr [ i + 1. . . n - 1 ] ; For each index i , take maximum of 1. abs ( max sum subarray that lies in arr [ 0. . . i ] - min sum subarray that lies in arr [ i + 1. . . n - 1 ] ) 2. abs ( min sum subarray that lies in arr [ 0. . . i ] - max sum subarray that lies in arr [ i + 1. . . n - 1 ] ) ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6946-6946",
        "Code": "def strrmatch ( strr , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif ( pattern [ j - 1 ] == ' ? ' or strr [ i - 1 ] == pattern [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT strr = \" baaabab \" NEW_LINE pattern = \" * * * * * ba * * * * * ab \" NEW_LINE if ( strrmatch ( strr , pattern , len ( strr ) , len ( pattern ) ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Wildcard Pattern Matching | Function that matches input strr with given wildcard pattern ; empty pattern can only match with empty string ; lookup table for storing results of subproblems ; empty pattern can match with empty string ; Only ' * ' can match with empty string ; fill the table in bottom - up fashion ; Two cases if we see a ' * ' a ) We ignore a * aTM character and move to next character in the pattern , i . e . , a * aTM indicates an empty sequence . b ) ' * ' character matches with ith character in input ; Current characters are considered as matching in two cases ( a ) current character of pattern is ' ? ' ( b ) characters actually match ; If characters don 't match ; Driver code ; char pattern [ ] = \" ba * * * * * ab \" char pattern [ ] = \" ba * ab \" char pattern [ ] = \" a * ab \" char pattern [ ] = \" a * * * * * ab \" char pattern [ ] = \" * a * * * * * ab \" char pattern [ ] = \" ba * ab * * * * \" char pattern [ ] = \" * * * * \" char pattern [ ] = \" * \" char pattern [ ] = \" aa ? ab \" char pattern [ ] = \" b * b \" char pattern [ ] = \" a * a \" char pattern [ ] = \" baaabab \" char pattern [ ] = \" ? baaabab \" char pattern [ ] = \" * baaaba * \"",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6947-6947",
        "Code": "def isKPalRec ( str1 , str2 , m , n ) : NEW_LINE INDENT if not m : return n NEW_LINE if not n : return m NEW_LINE if str1 [ m - 1 ] == str2 [ n - 1 ] : NEW_LINE INDENT return isKPalRec ( str1 , str2 , m - 1 , n - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def isKPal ( string , k ) : NEW_LINE INDENT revStr = string [ : : - 1 ] NEW_LINE l = len ( string ) NEW_LINE return ( isKPalRec ( string , revStr , l , l ) <= k * 2 ) NEW_LINE DEDENT string = \" acdcb \" NEW_LINE k = 2 NEW_LINE print ( \" Yes \" if isKPal ( string , k ) else \" No \" ) NEW_LINE",
        "Type": "py",
        "NL": "Find if string is K | Find if given string is K - Palindrome or not ; If first string is empty , the only option is to remove all characters of second string ; If second string is empty , the only option is to remove all characters of first string ; If last characters of two strings are same , ignore last characters and get count for remaining strings . ; If last characters are not same , 1. Remove last char from str1 and recur for m - 1 and n 2. Remove last char from str2 and recur for m and n - 1 Take minimum of above two operations res = 1 + min ( isKPalRec ( str1 , str2 , m - 1 , n ) , Remove from str1 ( isKPalRec ( str1 , str2 , m , n - 1 ) ) ) Remove from str2 ; Returns true if str is k palindrome . ; Driver program",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6968-6968",
        "Code": "def findMinRec ( arr , i , sumCalculated , sumTotal ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return abs ( ( sumTotal - sumCalculated ) - sumCalculated ) NEW_LINE DEDENT return min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) NEW_LINE DEDENT def findMin ( arr , n ) : NEW_LINE INDENT sumTotal = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumTotal += arr [ i ] NEW_LINE DEDENT return findMinRec ( arr , n , 0 , sumTotal ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 1 , 4 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ minimum ▁ difference ▁ \" + \" between ▁ two ▁ sets ▁ is ▁ \" , findMin ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Partition a set into two subsets such that the difference of subset sums is minimum | Function to find the minimum sum ; If we have reached last element . Sum of one subset is sumCalculated , sum of other subset is sumTotal - sumCalculated . Return absolute difference of two sums . ; For every item arr [ i ] , we have two choices ( 1 ) We do not include it first set ( 2 ) We include it in first set We return minimum of two choices ; Returns minimum possible difference between sums of two subsets ; Compute total sum of elements ; Compute result using recursive function ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "697-697",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , key ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return Node ( key ) NEW_LINE DEDENT if root . data > key : NEW_LINE INDENT root . left = insert ( root . left , key ) NEW_LINE DEDENT else : NEW_LINE INDENT root . right = insert ( root . right , key ) NEW_LINE DEDENT return root NEW_LINE DEDENT def seqExistUtil ( ptr , seq , index ) : NEW_LINE INDENT if ptr == None : NEW_LINE INDENT return NEW_LINE DEDENT seqExistUtil ( ptr . left , seq , index ) NEW_LINE if ptr . data == seq [ index [ 0 ] ] : NEW_LINE INDENT index [ 0 ] += 1 NEW_LINE DEDENT seqExistUtil ( ptr . right , seq , index ) NEW_LINE DEDENT def seqExist ( root , seq , n ) : NEW_LINE INDENT index = [ 0 ] NEW_LINE seqExistUtil ( root , seq , index ) NEW_LINE if index [ 0 ] == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 8 ) NEW_LINE root = insert ( root , 10 ) NEW_LINE root = insert ( root , 3 ) NEW_LINE root = insert ( root , 6 ) NEW_LINE root = insert ( root , 1 ) NEW_LINE root = insert ( root , 4 ) NEW_LINE root = insert ( root , 7 ) NEW_LINE root = insert ( root , 14 ) NEW_LINE root = insert ( root , 13 ) NEW_LINE seq = [ 4 , 6 , 8 , 14 ] NEW_LINE n = len ( seq ) NEW_LINE if seqExist ( root , seq , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given sorted sub | Constructor to create a new node ; A utility function to insert a given key to BST ; function to check if given sorted sub - sequence exist in BST index . iterator for given sorted sub - sequence seq [ ] . given sorted sub - sequence ; We traverse left subtree first in Inorder ; If current node matches with se [ index [ 0 ] ] then move forward in sub - sequence ; We traverse left subtree in the end in Inorder ; A wrapper over seqExistUtil . It returns true if seq [ 0. . n - 1 ] exists in tree . ; Initialize index in seq [ ] ; Do an inorder traversal and find if all elements of seq [ ] were present ; index would become n if all elements of seq [ ] were present ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "6979-6979",
        "Code": "def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT coeff = [ 2 , 2 , 5 ] NEW_LINE rhs = 4 NEW_LINE n = len ( coeff ) NEW_LINE print ( countSol ( coeff , 0 , n - 1 , rhs ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find number of solutions of a linear equation of n variables | Recursive function that returns count of solutions for given rhs value and coefficients coeff [ stat ... end ] ; Base case ; Initialize count of solutions ; One by one subtract all smaller or equal coefficients and recur ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "6991-6991",
        "Code": "def getMaxRec ( string , i , n , lookup ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if lookup [ i ] != - 1 : NEW_LINE INDENT return lookup [ i ] NEW_LINE DEDENT ans = 1 + getMaxRec ( string , i + 1 , n , lookup ) NEW_LINE if i + 1 < n : NEW_LINE INDENT if string [ i ] != string [ i + 1 ] : NEW_LINE INDENT ans = max ( 4 + getMaxRec ( string , i + 2 , n , lookup ) , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( 3 + getMaxRec ( string , i + 2 , n , lookup ) , ans ) NEW_LINE DEDENT DEDENT lookup [ i ] = ans NEW_LINE return ans NEW_LINE DEDENT def getMaxWeight ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE lookup = [ - 1 ] * ( n ) NEW_LINE return getMaxRec ( string , 0 , len ( string ) , lookup ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" AAAAABB \" NEW_LINE print ( \" Maximum ▁ weight ▁ of ▁ a ▁ transformation ▁ of \" , string , \" is \" , getMaxWeight ( string ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum weight transformation of a given string | Returns weight of the maximum weight transformation ; Base Case ; If this subproblem is already solved ; Don 't make pair, so  weight gained is 1 ; If we can make pair ; If elements are dissimilar ; if elements are similar so for making a pair we toggle any of them . Since toggle cost is 1 so overall weight gain becomes 3 ; save and return maximum of above cases ; Initializes lookup table and calls getMaxRec ( ) ; Create and initialize lookup table ; Call recursive function ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6992-6992",
        "Code": "def countRec ( digits , esum , osum , isOdd , n ) : NEW_LINE INDENT if digits == n : NEW_LINE INDENT return ( esum - osum == 1 ) NEW_LINE DEDENT if lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 : NEW_LINE INDENT return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] NEW_LINE DEDENT ans = 0 NEW_LINE if isOdd : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum , osum + i , False , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT DEDENT lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans NEW_LINE return ans NEW_LINE DEDENT def finalCount ( n ) : NEW_LINE INDENT global lookup NEW_LINE digits = 0 NEW_LINE lookup = [ [ [ [ - 1 , - 1 ] for i in range ( 500 ) ] for j in range ( 500 ) ] for k in range ( 50 ) ] NEW_LINE ans = 0 NEW_LINE esum = 0 NEW_LINE osum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT ans += countRec ( digits + 1 , esum + i , osum , True , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lookup = [ ] NEW_LINE n = 3 NEW_LINE print ( \" Count ▁ of ▁ % d ▁ digit ▁ numbers ▁ is ▁ % d \" % ( n , finalCount ( n ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count total number of N digit numbers such that the difference between sum of even and odd digits is 1 | Memoization based recursive function to count numbers with even and odd digit sum difference as 1. This function considers leading zero as a digit ; Base Case ; If current subproblem is already computed ; Initialize result ; If the current digit is odd , then add it to odd sum and recur ; Add to even sum and recur ; Store current result in lookup table and return the same ; This is mainly a wrapper over countRec . It explicitly handles leading digit and calls countRec ( ) for remaining digits . ; Initialize number digits considered so far ; Initialize all entries of lookup table ; Initialize final answer ; Initialize even and odd sums ; Explicitly handle first digit and call recursive function countRec for remaining digits . Note that the first digit is considered as even digit ; Driver Code ; A lookup table used for memoization .",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "6994-6994",
        "Code": "def countNumbersWith4 ( n ) : NEW_LINE INDENT for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( has4 ( x ) == True ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def has4 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ \" , n , \" ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ \" , countNumbersWith4 ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers from 1 to n that have 4 as a digit | Returns sum of all digits in numbers from 1 to n ; One by one compute sum of digits in every number from 1 to n ; A utility function to compute sum of digits in a given number x ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "6995-6995",
        "Code": "import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to \" , n , \" that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is \" , countNumbersWith4 ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count numbers from 1 to n that have 4 as a digit | Python3 program to count numbers having 4 as a digit ; Function to count numbers from 1 to n that have 4 as a digit ; Base case ; d = number of digits minus one in n . For 328 , d is 2 ; computing count of numbers from 1 to 10 ^ d - 1 , d = 0 a [ 0 ] = 0 d = 1 a [ 1 ] = count of numbers from 0 to 9 = 1 d = 2 a [ 2 ] = count of numbers from 0 to 99 = a [ 1 ] * 9 + 10 = 19 d = 3 a [ 3 ] = count of numbers from 0 to 999 = a [ 2 ] * 19 + 100 = 171 ; Computing 10 ^ d ; Most significant digit ( msd ) of n , For 328 , msd is 3 which can be obtained using 328 / 100 ; If MSD is 4. For example if n = 428 , then count of numbers is sum of following . 1 ) Count of numbers from 1 to 399 2 ) Count of numbers from 400 to 428 which is 29. ; IF MSD > 4. For example if n is 728 , then count of numbers is sum of following . 1 ) Count of numbers from 1 to 399 and count of numbers from 500 to 699 , i . e . , \" a [ 2 ] ▁ * ▁ 6\" 2 ) Count of numbers from 400 to 499 , i . e . 100 3 ) Count of numbers from 700 to 728 , recur for 28 ; IF MSD < 4. For example if n is 328 , then count of numbers is sum of following . 1 ) Count of numbers from 1 to 299 a 2 ) Count of numbers from 300 to 328 , recur for 28 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7010-7010",
        "Code": "def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return llap NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT set1 = [ 1 , 7 , 10 , 13 , 14 , 19 ] NEW_LINE n1 = len ( set1 ) NEW_LINE print ( lenghtOfLongestAP ( set1 , n1 ) ) NEW_LINE set2 = [ 1 , 7 , 10 , 15 , 27 , 29 ] NEW_LINE n2 = len ( set2 ) NEW_LINE print ( lenghtOfLongestAP ( set2 , n2 ) ) NEW_LINE set3 = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n3 = len ( set3 ) NEW_LINE print ( lenghtOfLongestAP ( set3 , n3 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Arithmetic Progression | DP | Returns length of the longest AP subset in a given set ; Create a table and initialize all values as 2. The value of L [ i ] [ j ] stores LLAP with set [ i ] and set [ j ] as first two elements of AP . Only valid entries are the entries where j > i ; Initialize the result ; Fill entries in last column as 2. There will always be two elements in AP with last number of set as second element in AP ; Consider every element as second element of AP ; Search for i and k for j ; Before changing i , set L [ i ] [ j ] as 2 ; Found i and k for j , LLAP with i and j as first two elements are equal to LLAP with j and k as first two elements plus 1. L [ j ] [ k ] must have been filled before as we run the loop from right side ; Update overall LLAP , if needed ; Change i and k to fill more L [ i ] [ j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entities in column j as 2 ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7020-7020",
        "Code": "def LCSubStr ( s , t , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( 2 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 NEW_LINE if ( dp [ i % 2 ] [ j ] > res ) : NEW_LINE INDENT res = dp [ i % 2 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT X = \" OldSite : GeeksforGeeks . org \" NEW_LINE Y = \" NewSite : GeeksQuiz . com \" NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( LCSubStr ( X , Y , m , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Longest Common Substring | DP | Function to find the length of the longest LCS ; Create DP table ; Driver Code ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7021-7021",
        "Code": "def lcs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" abcdxyz \" NEW_LINE Y = \" xyzabcd \" NEW_LINE n = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE print ( lcs ( n , m , 0 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Common Substring | DP | Returns length of function for longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7027-7027",
        "Code": "def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT class node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def LISS ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT size_excl = LISS ( root . left ) + LISS ( root . right ) NEW_LINE size_incl = 1 NEW_LINE if ( root . left != None ) : NEW_LINE INDENT size_incl += LISS ( root . left . left ) + LISS ( root . left . right ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT size_incl += LISS ( root . right . left ) + LISS ( root . right . right ) NEW_LINE DEDENT return max ( size_incl , size_excl ) NEW_LINE DEDENT def newNode ( data ) : NEW_LINE INDENT temp = node ( ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT root = newNode ( 20 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 12 ) NEW_LINE root . left . right . left = newNode ( 10 ) NEW_LINE root . left . right . right = newNode ( 14 ) NEW_LINE root . right = newNode ( 22 ) NEW_LINE root . right . right = newNode ( 25 ) NEW_LINE print ( \" Size ▁ of ▁ the ▁ Largest \" , \" ▁ Independent ▁ Set ▁ is ▁ \" , LISS ( root ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest Independent Set Problem | DP | A utility function to find max of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; The function returns size of the largest independent set in a given binary tree ; Calculate size excluding the current node ; Calculate size including the current node ; Return the maximum of two sizes ; A utility function to create a node ; Let us construct the tree given in the above diagram",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7034-7034",
        "Code": "def findWater ( i , j , X ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT print ( \" Incorrect ▁ Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) ; NEW_LINE index = 0 ; NEW_LINE glass [ index ] = X ; NEW_LINE for row in range ( 1 , i ) : NEW_LINE INDENT for col in range ( 1 , row + 1 ) : NEW_LINE INDENT X = glass [ index ] ; NEW_LINE glass [ index ] = 1.0 if ( X >= 1.0 ) else X ; NEW_LINE X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 ; NEW_LINE glass [ index + row ] += ( X / 2 ) ; NEW_LINE glass [ index + row + 1 ] += ( X / 2 ) ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT i = 2 ; NEW_LINE j = 2 ; NEW_LINE X = 2.0 ; NEW_LINE res = repr ( findWater ( i , j , X ) ) ; NEW_LINE print ( \" Amount ▁ of ▁ water ▁ in ▁ jth ▁ glass ▁ of ▁ ith ▁ row ▁ is : \" , res . ljust ( 8 , '0' ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find amount of water in a given glass | Returns the amount of water in jth glass of ith row ; A row number i has maximum i columns . So input column number must be less than i ; There will be i * ( i + 1 ) / 2 glasses till ith row ( including ith row ) and Initialize all glasses as empty ; Put all water in first glass ; Now let the water flow to the downward glasses till the row number is less than or / equal to i ( given row ) correction : X can be zero for side glasses as they have lower rate to fill ; Fill glasses in a given row . Number of columns in a row is equal to row number ; Get the water from current glass ; Keep the amount less than or equal to capacity in current glass ; Get the remaining amount ; Distribute the remaining amount to the down two glasses ; The index of jth glass in ith row will be i * ( i - 1 ) / 2 + j - 1 ; Driver Code ; Total amount of water",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7038-7038",
        "Code": "class Pair ( object ) : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT self . a = a NEW_LINE self . b = b NEW_LINE DEDENT DEDENT def maxChainLength ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE mcl = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] . a > arr [ j ] . b and mcl [ i ] < mcl [ j ] + 1 ) : NEW_LINE INDENT mcl [ i ] = mcl [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mcl [ i ] ) : NEW_LINE INDENT max = mcl [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ Pair ( 5 , 24 ) , Pair ( 15 , 25 ) , Pair ( 27 , 40 ) , Pair ( 50 , 60 ) ] NEW_LINE print ( ' Length ▁ of ▁ maximum ▁ size ▁ chain ▁ is ' , maxChainLength ( arr , len ( arr ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum Length Chain of Pairs | DP | Python program for above approach ; This function assumes that arr [ ] is sorted in increasing order according the first ( or smaller ) values in pairs . ; Initialize MCL ( max chain length ) values for all indices ; Compute optimized chain length values in bottom up manner ; Pick maximum of all MCL values ; Driver program to test above function",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "704-704",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , key ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT root = newNode ( key ) NEW_LINE DEDENT elif root . key > key : NEW_LINE INDENT root . left = insert ( root . left , key ) NEW_LINE DEDENT elif root . key < key : NEW_LINE INDENT root . right = insert ( root . right , key ) NEW_LINE DEDENT return root NEW_LINE DEDENT def distanceFromRoot ( root , x ) : NEW_LINE INDENT if root . key == x : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root . key > x : NEW_LINE INDENT return 1 + distanceFromRoot ( root . left , x ) NEW_LINE DEDENT return 1 + distanceFromRoot ( root . right , x ) NEW_LINE DEDENT def distanceBetween2 ( root , a , b ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if root . key > a and root . key > b : NEW_LINE INDENT return distanceBetween2 ( root . left , a , b ) NEW_LINE DEDENT if root . key < a and root . key < b : NEW_LINE INDENT return distanceBetween2 ( root . right , a , b ) NEW_LINE DEDENT if root . key >= a and root . key <= b : NEW_LINE INDENT return ( distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ) NEW_LINE DEDENT DEDENT def findDistWrapper ( root , a , b ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return distanceBetween2 ( root , a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 20 ) NEW_LINE insert ( root , 10 ) NEW_LINE insert ( root , 5 ) NEW_LINE insert ( root , 15 ) NEW_LINE insert ( root , 30 ) NEW_LINE insert ( root , 25 ) NEW_LINE insert ( root , 35 ) NEW_LINE a , b = 5 , 55 NEW_LINE print ( findDistWrapper ( root , 5 , 35 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Shortest distance between two nodes in BST | Python3 program to find distance between two nodes in BST ; Standard BST insert function ; This function returns distance of x from root . This function assumes that x exists in BST and BST is not NULL . ; Returns minimum distance beween a and b . This function assumes that a and b exist in BST . ; Both keys lie in left ; Both keys lie in right same path ; Lie in opposite directions ( Root is LCA of two nodes ) ; This function make sure that a is smaller than b before making a call to findDistWrapper ( ) ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7050-7050",
        "Code": "def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ \" + \" subsequence ▁ is ▁ \" + str ( maxSumIS ( arr , n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum Sum Increasing Subsequence | DP | maxSumIS ( ) returns the maximum sum of increasing subsequence in arr [ ] of size n ; Initialize msis values for all indexes ; Compute maximum sum values in bottom up manner ; Pick maximum of all msis values ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7091-7091",
        "Code": "def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT def countBST ( n ) : NEW_LINE INDENT count = catalan ( n ) NEW_LINE return count NEW_LINE DEDENT def countBT ( n ) : NEW_LINE INDENT count = catalan ( n ) NEW_LINE return count * factorial ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE count1 = countBST ( n ) NEW_LINE count2 = countBT ( n ) NEW_LINE print ( \" Count ▁ of ▁ BST ▁ with \" , n , \" nodes ▁ is \" , count1 ) NEW_LINE print ( \" Count ▁ of ▁ binary ▁ trees ▁ with \" , n , \" nodes ▁ is \" , count2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Total number of possible Binary Search Trees and Binary Trees with n keys | A function to find factorial of a given number ; Calculate value of [ 1 * ( 2 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn / ( n + 1 ) ; A function to count number of BST with n nodes using catalan ; find nth catalan number ; return nth catalan number ; A function to count number of binary trees with n nodes ; find count of BST with n numbers ; return count * n ! ; Driver Code ; find count of BST and binary trees with n nodes ; print count of BST and binary trees with n nodes",
        "Category": "Math"
    },
    {
        "ID": "7093-7093",
        "Code": "def checkArray ( arr , N , k ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT Sum = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT R = ( k * k + k + 1 ) NEW_LINE if ( Sum % R != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT Mid = k * ( Sum // R ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT temp += arr [ i - 1 ] NEW_LINE if ( arr [ i ] == Mid ) : NEW_LINE INDENT if ( temp == Mid // k ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 4 , 20 , 6 , 15 , 9 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( checkArray ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find position i to split Array such that prefix sum till i | Function to check if there is an element forming G . P . series having common ratio k ; If size of array is less than three then return - 1 ; Initialize the variables ; Calculate total sum of array ; Calculate Middle element of G . P . series ; Iterate over the range ; Store the first element of G . P . series in the variable temp ; Return position of middle element of the G . P . series if the first element is in G . P . of common ratio k ; Else return 0 ; if middle element is not found in arr [ ] ; Driver Code ; Given array",
        "Category": "Math"
    },
    {
        "ID": "7096-7096",
        "Code": "def minumumOperation ( N , arr ) : NEW_LINE INDENT sum_arr = sum ( arr ) NEW_LINE if sum_arr >= N : NEW_LINE INDENT print ( sum_arr - N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE arr = [ 8 , 4 , 6 , 2 ] NEW_LINE minumumOperation ( N , arr ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum numbers to be appended such that mean of Array is equal to 1 | Function to calculate minimum Number of operations ; Storing sum of array arr [ ] ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7097-7097",
        "Code": "def encodeString ( str ) : NEW_LINE INDENT res = \" \" NEW_LINE small = [ 0 for i in range ( 26 ) ] NEW_LINE capital = [ 0 for i in range ( 26 ) ] NEW_LINE num = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT num [ ord ( str [ i ] ) - 48 ] = i NEW_LINE DEDENT elif ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT small [ ord ( str [ i ] ) - 97 ] = i NEW_LINE DEDENT elif ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT capital [ ord ( str [ i ] ) - 65 ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) and small [ ord ( str [ i ] ) - 97 ] == i ) : NEW_LINE INDENT occ = ord ( str [ i ] ) - 96 NEW_LINE while ( occ > 0 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE occ -= 1 NEW_LINE DEDENT DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) and capital [ ord ( str [ i ] ) - 65 ] == i ) : NEW_LINE INDENT occ = ord ( str [ i ] ) - 64 NEW_LINE while ( occ > 0 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE occ -= 1 NEW_LINE DEDENT DEDENT elif ( ( str [ i ] >= '0' and str [ i ] <= '9' ) and num [ ord ( str [ i ] ) - 48 ] == i ) : NEW_LINE INDENT occ = ord ( str [ i ] ) - 48 NEW_LINE while ( occ > 0 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE occ -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" Ea2 , ▁ 0 , ▁ E \" NEW_LINE encodeString ( str ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Repeat last occurrence of each alphanumeric character to their position in character family times | Function to encode the given string ; Variable string to store the result ; Arrays to store the last occuring index of every character in the string ; Length of the string ; Iterate over the range ; If str [ i ] is between 0 and 9 ; If str [ i ] is between a and z ; If str [ i ] is between A and Z ; Iterate over the range ; If str [ i ] is between a and z and i is the last occurence in str ; If str [ i ] is between A and Z and i is the last occurence in str ; If str [ i ] is between 0 and 9 and i is the last occurence in str ; Print the result ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "7099-7099",
        "Code": "def possibleEqualArray ( A , N ) : NEW_LINE INDENT pref = [ 0 for i in range ( N ) ] NEW_LINE pref [ 0 ] = A [ 0 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] ^ A [ i ] NEW_LINE DEDENT if ( pref [ N - 1 ] == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT cur_xor = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT cur_xor ^= A [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( j ) : NEW_LINE INDENT middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] NEW_LINE left_xor = pref [ j - 1 ] NEW_LINE right_xor = cur_xor NEW_LINE if ( left_xor == middle_xor and middle_xor == right_xor ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT i -= 1 NEW_LINE DEDENT print ( \" NO \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 2 , 2 ] NEW_LINE N = len ( A ) NEW_LINE possibleEqualArray ( A , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Make Array elements equal by replacing adjacent elements with their XOR | Function to check if it is possible to make all the array elements equal using the given operation ; Stores the prefix XOR array ; Calculate prefix [ i ] ; Case 1 , check if the XOR of the input array is 0 ; Case 2 Iterate over all the ways to divide the array into three non empty subarrays ; XOR of Middle Block ; XOR of Left Block ; XOR of Right Block ; Not Possible ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "710-710",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def RangeTraversal ( root , n1 , n2 ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT curr = root NEW_LINE while curr : NEW_LINE INDENT if curr . left == None : NEW_LINE INDENT if curr . data <= n2 and curr . data >= n1 : NEW_LINE INDENT print ( curr . data , end = \" ▁ \" ) NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT pre = curr . left NEW_LINE while ( pre . right != None and pre . right != curr ) : NEW_LINE INDENT pre = pre . right NEW_LINE DEDENT if pre . right == None : NEW_LINE INDENT pre . right = curr ; NEW_LINE curr = curr . left NEW_LINE DEDENT else : NEW_LINE INDENT pre . right = None NEW_LINE if curr . data <= n2 and curr . data >= n1 : NEW_LINE INDENT print ( curr . data , end = \" ▁ \" ) NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 7 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 10 ) NEW_LINE RangeTraversal ( root , 4 , 12 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print BST keys in given Range | O ( 1 ) Space | Python3 code to print BST keys in given Range in constant space using Morris traversal . Helper function to create a new node ; Function to print the keys in range ; check if current node lies between n1 and n2 ; finding the inorder predecessor - inorder predecessor is the right most in left subtree or the left child , i . e in BST it is the maximum ( right most ) in left subtree . ; check if current node lies between n1 and n2 ; Driver Code ; Constructed binary tree is 4 / \\ 2 7 / \\ / \\ 1 3 6 10",
        "Category": "Binary Tree"
    },
    {
        "ID": "7100-7100",
        "Code": "def possibleEqualArray ( A , N ) : NEW_LINE INDENT tot_XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tot_XOR ^= A [ i ] NEW_LINE DEDENT if ( tot_XOR == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT cur_XOR = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_XOR ^= A [ i ] NEW_LINE if ( cur_XOR == tot_XOR ) : NEW_LINE INDENT cnt += 1 NEW_LINE cur_XOR = 0 NEW_LINE DEDENT DEDENT if ( cnt > 2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 2 , 2 ] NEW_LINE N = len ( A ) NEW_LINE possibleEqualArray ( A , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Make Array elements equal by replacing adjacent elements with their XOR | Function to check if it is possible to make all the array elements equal using the given operation ; Stores the XOR of all elements of array A [ ] ; Case 1 , check if the XOR of the array A [ ] is 0 ; Maintains the XOR till the current element ; Iterate over the array ; If the current XOR is equal to the total XOR increment the count and initialize current XOR as 0 ; Print Answer ; Driver Code ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7102-7102",
        "Code": "def GenerateArray ( N , X ) : NEW_LINE INDENT prev_xor = X NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( i ^ prev_xor , end = \" \" ) NEW_LINE if ( i != N ) : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT prev_xor = i NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE X = 3 NEW_LINE print ( \" The ▁ generated ▁ array ▁ is ▁ \" , end = \" \" ) NEW_LINE GenerateArray ( N , X ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct an array whose Prefix XOR array starting from X is an N | Function to print the required array ; Iteratie from 1 to N ; Print the i - th element ; Update prev_xor to i ; Driver Code ; Given Input ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "7103-7103",
        "Code": "def createGrid ( grid , is1 , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( is1 ) : NEW_LINE INDENT grid [ i ] [ j ] = '0' NEW_LINE is1 = False NEW_LINE DEDENT else : NEW_LINE INDENT grid [ i ] [ j ] = '1' NEW_LINE is1 = True NEW_LINE DEDENT DEDENT if ( M % 2 == 0 ) : NEW_LINE INDENT is1 = True if is1 == False else False NEW_LINE DEDENT DEDENT DEDENT def testGrid ( testGrid , Grid , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( Grid [ i ] [ j ] != ' * ' ) : NEW_LINE INDENT if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def printGrid ( grid , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( grid [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" , end ▁ = ▁ \" \" ) NEW_LINE DEDENT DEDENT def findPossibleGrid ( N , M , grid ) : NEW_LINE INDENT gridTest1 = [ [ ' ' for i in range ( 1001 ) ] for j in range ( N ) ] NEW_LINE gridTest2 = [ [ ' ' for i in range ( 1001 ) ] for j in range ( N ) ] NEW_LINE createGrid ( gridTest1 , True , N , M ) NEW_LINE createGrid ( gridTest2 , False , N , M ) NEW_LINE if ( testGrid ( gridTest1 , grid , N , M ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE printGrid ( gridTest1 , N , M ) NEW_LINE DEDENT elif ( testGrid ( gridTest2 , grid , N , M ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE printGrid ( gridTest2 , N , M ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 4 NEW_LINE grid = [ [ ' * ' , ' * ' , '1' , '0' ] , [ ' * ' , ' * ' , ' * ' , ' * ' ] , [ ' * ' , ' * ' , ' * ' , ' * ' ] , [ ' * ' , ' * ' , '0' , '1' ] ] NEW_LINE findPossibleGrid ( N , M , grid ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if elements of a Binary Matrix can be made alternating | Function to create the possible grids ; Function to test if any one of them matches with the given 2 - D array ; Function to print the grid , if possible ; Function to check if the grid can be made alternating or not ; Grids to store the possible grids ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "7105-7105",
        "Code": "N = 200 * 1000 + 13 NEW_LINE n = 0 NEW_LINE arr = [ 0 for i in range ( N ) ] NEW_LINE brr = [ 0 for i in range ( N ) ] NEW_LINE import sys NEW_LINE def brute ( ind , l , r ) : NEW_LINE INDENT if ( ind == n / 2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( brr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT sys . exit ( ) NEW_LINE DEDENT for i in range ( l , arr [ ind ] // 2 + 1 , 1 ) : NEW_LINE INDENT if ( arr [ ind ] - i <= r ) : NEW_LINE INDENT brr [ ind ] = i NEW_LINE brr [ n - ind - 1 ] = arr [ ind ] - i NEW_LINE brute ( ind + 1 , i , arr [ ind ] - i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE n *= 2 NEW_LINE arr [ 0 ] = 5 NEW_LINE arr [ 1 ] = 6 NEW_LINE INF64 = 1000000000000000000 NEW_LINE brute ( 0 , 0 , INF64 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find non | Python 3 program for the above approach . ; Function to find the possible output array ; Base case for the recursion ; If ind becomes half of the size then print the array . ; Exit the function . ; Iterate in the range . ; Put the values in the respective indices . ; Call the function to find values for other indices . ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "711-711",
        "Code": "def inRange ( root , low , high ) : NEW_LINE INDENT return root . data >= low and root . data <= high NEW_LINE DEDENT def getCountUtil ( root , low , high , count ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return True NEW_LINE DEDENT l = getCountUtil ( root . left , low , high , count ) NEW_LINE r = getCountUtil ( root . right , low , high , count ) NEW_LINE if l and r and inRange ( root , low , high ) : NEW_LINE INDENT count [ 0 ] += 1 NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT def getCount ( root , low , high ) : NEW_LINE INDENT count = [ 0 ] NEW_LINE getCountUtil ( root , low , high , count ) NEW_LINE return count NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 5 ) NEW_LINE root . right = newNode ( 50 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . right . left = newNode ( 40 ) NEW_LINE root . right . right = newNode ( 100 ) NEW_LINE l = 5 NEW_LINE h = 45 NEW_LINE print ( \" Count ▁ of ▁ subtrees ▁ in ▁ [ \" , l , \" , ▁ \" , h , \" ] ▁ is ▁ \" , getCount ( root , l , h ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count BST subtrees that lie in given range | A utility function to check if data of root is in range from low to high ; A recursive function to get count of nodes whose subtree is in range from low to high . This function returns true if nodes in subtree rooted under ' root ' are in range . ; Base case ; Recur for left and right subtrees ; If both left and right subtrees are in range and current node is also in range , then increment count and return true ; A wrapper over getCountUtil ( ) . This function initializes count as 0 and calls getCountUtil ( ) ; Utility function to create new node ; Driver Code ; Let us construct the BST shown in the above figure ; Let us constructed BST shown in above example 10 / \\ 5 50 / / \\ 1 40 100",
        "Category": "Binary Tree"
    },
    {
        "ID": "7111-7111",
        "Code": "def func2 ( L , R , K ) : NEW_LINE INDENT if ( R - L >= 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return min ( L , L ^ R ) NEW_LINE DEDENT def func3 ( L , R , K ) : NEW_LINE INDENT if ( ( R ^ L ) > L and ( R ^ L ) < R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return func2 ( L , R , K ) NEW_LINE DEDENT def func4 ( L , R , K ) : NEW_LINE INDENT if ( R - L >= 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) NEW_LINE return min ( minval , func3 ( L , R , K ) ) NEW_LINE DEDENT def minimumXor ( L , R , K ) : NEW_LINE INDENT if ( K > 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( K == 4 ) : NEW_LINE INDENT return func4 ( L , R , K ) NEW_LINE DEDENT elif ( K == 3 ) : NEW_LINE INDENT return func3 ( L , R , K ) NEW_LINE DEDENT elif ( K == 2 ) : NEW_LINE INDENT return func2 ( L , R , K ) NEW_LINE DEDENT else : NEW_LINE INDENT return L NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R , K = 1 , 3 , 3 NEW_LINE print ( minimumXor ( L , R , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum XOR of at most K elements in range [ L , R ] | Function for K = 2 ; Function for K = 2 ; Function for K = 2 ; Function to calculate the minimum XOR of at most K elements in [ L , R ] ; Driver code ; Input ; Function call",
        "Category": "Math"
    },
    {
        "ID": "7115-7115",
        "Code": "def setBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def findNthTerm ( N ) : NEW_LINE INDENT x = setBits ( N ^ ( N - 1 ) ) NEW_LINE print ( x ) NEW_LINE DEDENT N = 8 NEW_LINE findNthTerm ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Nth term of Ruler Function Series | Function to count the number of set bits in the number N ; Store the number of setbits ; Update the value of n ; Update the count ; Return the total count ; Function to find the Nth term of the Ruler Function Series ; Store the result ; Print the result ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7116-7116",
        "Code": "def findEquation ( A , B , C ) : NEW_LINE INDENT print ( \" ( \" + str ( C ) + \" ) \" + \" x ^ 2 ▁ + ( \" + str ( B ) + \" ) x ▁ + ▁ ( \" + str ( A ) + \" ) ▁ = ▁ 0\" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 1 NEW_LINE B = - 5 NEW_LINE C = 6 NEW_LINE findEquation ( A , B , C ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Quadratic equation whose roots are reciprocal to the roots of given equation | Function to find the quadratic equation having reciprocal roots ; Print quadratic equation ; Driver Code ; Given coefficients ; Function call to find the quadratic equation having reciprocal roots",
        "Category": "Math"
    },
    {
        "ID": "7118-7118",
        "Code": "def checkPro ( n , k ) : NEW_LINE INDENT KthRoot = int ( n ** ( 1 / k ) ) NEW_LINE product = 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT print ( product ) NEW_LINE if ( product == N ) : NEW_LINE INDENT return ( \" Yes \" ) NEW_LINE DEDENT for i in range ( 2 , KthRoot + 1 ) : NEW_LINE INDENT product = product * ( i + k - 1 ) NEW_LINE product = product / ( i - 1 ) NEW_LINE print ( product ) NEW_LINE if ( product == N ) : NEW_LINE INDENT return ( \" Yes \" ) NEW_LINE DEDENT DEDENT return ( \" No \" ) NEW_LINE DEDENT N = 210 NEW_LINE K = 3 NEW_LINE print ( checkPro ( N , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a given integer is the product of K consecutive integers | Function to check if N can be expressed as the product of K consecutive integers ; Stores the K - th root of N ; Stores the product of K consecutive integers ; Traverse over the range [ 1 , K ] ; Update the product ; If product is N , then return \" Yes \" ; Otherwise , traverse over the range [ 2 , Kthroot ] ; Update the value of product ; If product is equal to N ; Otherwise , return \" No \" ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "712-712",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return newNode ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT elif data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . data , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def leafDelete ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return None NEW_LINE DEDENT if root . left == None and root . right == None : NEW_LINE INDENT return None NEW_LINE DEDENT root . left = leafDelete ( root . left ) NEW_LINE root . right = leafDelete ( root . right ) NEW_LINE return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 20 ) NEW_LINE insert ( root , 10 ) NEW_LINE insert ( root , 5 ) NEW_LINE insert ( root , 15 ) NEW_LINE insert ( root , 30 ) NEW_LINE insert ( root , 25 ) NEW_LINE insert ( root , 35 ) NEW_LINE print ( \" Inorder ▁ before ▁ Deleting ▁ the ▁ leaf ▁ Node . \" ) NEW_LINE inorder ( root ) NEW_LINE leafDelete ( root ) NEW_LINE print ( ) NEW_LINE print ( \" INorder ▁ after ▁ Deleting ▁ the ▁ leaf ▁ Node . \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove all leaf nodes from the binary search tree | Python 3 program to delete leaf Node from binary search tree . Create a newNode in binary search tree . ; Constructor to create a new node ; Insert a Node in binary search tree . ; Function for inorder traversal in a BST . ; Delete leaf nodes from binary search tree . ; Else recursively delete in left and right subtrees . ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7123-7123",
        "Code": "def find ( N , Arr ) : NEW_LINE INDENT amount = 0 NEW_LINE mid_odd = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT siz = len ( Arr [ i ] ) NEW_LINE for j in range ( 0 , siz // 2 ) : NEW_LINE INDENT amount = amount + Arr [ i ] [ j ] NEW_LINE DEDENT if ( siz % 2 == 1 ) : NEW_LINE INDENT mid_odd . append ( Arr [ i ] [ siz // 2 ] ) NEW_LINE DEDENT DEDENT mid_odd . sort ( reverse = True ) NEW_LINE for i in range ( len ( mid_odd ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT amount = amount + mid_odd [ i ] NEW_LINE DEDENT DEDENT print ( amount ) NEW_LINE DEDENT N = 2 NEW_LINE Arr = [ [ 5 , 2 , 3 , 4 ] , [ 1 , 6 ] ] NEW_LINE find ( N , Arr ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum amount of money that can be collected by a player in a game of coins | Function to calculate the maximum amount collected by A ; Stores the money obtained by A ; Stores mid elements of odd sized rows ; Size of current row ; Increase money collected by A ; Add coins at even indices to the amount collected by A ; Print the amount ; Driver Code ; Function call to calculate the amount of coins collected by A",
        "Category": "Array"
    },
    {
        "ID": "7127-7127",
        "Code": "def getZarr ( st , Z ) : NEW_LINE INDENT n = len ( st ) NEW_LINE k = 0 NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i > R ) : NEW_LINE INDENT L = R = i NEW_LINE while ( R < n and st [ R - L ] == st [ R ] ) : NEW_LINE INDENT R += 1 NEW_LINE DEDENT Z [ i ] = R - L NEW_LINE R -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = i - L NEW_LINE if ( Z [ k ] < R - i + 1 ) : NEW_LINE INDENT Z [ i ] = Z [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT L = i NEW_LINE while ( R < n and st [ R - L ] == st [ R ] ) : NEW_LINE INDENT R += 1 NEW_LINE DEDENT Z [ i ] = R - L NEW_LINE R -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def goodStr ( st , word ) : NEW_LINE INDENT concat = word + \" $ \" + st NEW_LINE l = len ( concat ) NEW_LINE Z = [ 0 ] * l NEW_LINE getZarr ( concat , Z ) NEW_LINE res = \" \" NEW_LINE pSize = len ( word ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( i + pSize < l - 1 and Z [ i + pSize + 1 ] == pSize ) : NEW_LINE INDENT i += pSize - 1 NEW_LINE DEDENT elif ( i < len ( st ) ) : NEW_LINE INDENT res += st [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" Z - kmalgorithmkmiskmkmkmhelpfulkminkmsearching \" NEW_LINE word = \" km \" NEW_LINE print ( goodStr ( st , word ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove all occurrences of a word from a given string using Z | Function to fill the Z - array for str ; L Stores start index of window which matches with prefix of str ; R Stores end index of window which matches with prefix of str ; Iterate over the characters of str ; If i is greater thn R ; Update L and R ; If substring match with prefix ; Update R ; Update Z [ i ] ; Update R ; Update k ; if Z [ k ] is less than remaining interval ; Update Z [ i ] ; Start from R and check manually ; Update R ; Update Z [ i ] ; Update R ; Function to remove all the occurrences of word from str ; Create concatenated string \" P $ T \" ; Store Z array of concat ; Stores string , str by removing all the occurrences of word from str ; Stores length of word ; Traverse the array , Z [ ] ; if Z [ i + pSize + 1 ] equal to length of word ; Update i ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7128-7128",
        "Code": "def countPalindrome ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE Z = [ 0 ] * N NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if i <= r : NEW_LINE INDENT Z [ i ] = min ( r - i + 1 , Z [ i - 1 ] ) NEW_LINE DEDENT while ( ( i + Z [ i ] ) < N and ( S [ Z [ i ] ] == S [ i + Z [ i ] ] ) ) : NEW_LINE INDENT Z [ i ] += 1 NEW_LINE DEDENT if ( ( i + Z [ i ] - 1 ) > r ) : NEW_LINE INDENT l = ir = i + Z [ i ] - 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , len ( Z ) ) : NEW_LINE INDENT sum += Z [ i ] + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT S = \" abab \" NEW_LINE print ( countPalindrome ( S ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of palindromes that can be obtained by concatenating equal length prefix and substrings | Function to calculate the number of palindromes ; Calculation of Z - array ; Calculation of sigma ( Z [ i ] + 1 ) ; return the count ; Given String",
        "Category": "Substring"
    },
    {
        "ID": "7131-7131",
        "Code": "def findOccurrences ( S , T ) : NEW_LINE INDENT n1 = len ( S ) NEW_LINE n2 = len ( T ) NEW_LINE ans = 0 NEW_LINE last = 0 NEW_LINE for i in range ( n1 - n2 + 1 ) : NEW_LINE INDENT chk = True NEW_LINE for j in range ( n2 ) : NEW_LINE INDENT if ( T [ j ] != S [ i + j ] ) : NEW_LINE INDENT chk = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( chk ) : NEW_LINE INDENT ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) NEW_LINE last = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S , T = \" dabc \" , \" ab \" NEW_LINE findOccurrences ( S , T ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of substrings of a string containing another given string as a substring | Set 2 | Function to count the substrings of containing another given as a sub ; Store length of S ; Store length of T ; Store the required count of substrings ; Store the starting index of last occurence of T in S ; Iterate in range [ 0 , n1 - n2 ] ; Check if subfrom i to i + n2 is equal to T ; Check if subfrom i to i + n2 is equal to T ; Mark chk as false and break the loop ; If chk is true ; Add ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) to answer ; Update the last to i + 1 ; Prthe answer ; Driver code ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "7138-7138",
        "Code": "def printDiagonalTraversal ( nums ) : NEW_LINE INDENT m = len ( nums ) NEW_LINE q = [ ] NEW_LINE q . append ( [ 0 , 0 ] ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT p = q [ 0 ] NEW_LINE q . pop ( 0 ) ; NEW_LINE print ( nums [ p [ 0 ] ] [ p [ 1 ] ] , end = \" ▁ \" ) NEW_LINE if ( p [ 1 ] == 0 and p [ 0 ] + 1 < m ) : NEW_LINE INDENT q . append ( [ p [ 0 ] + 1 , p [ 1 ] ] ) ; NEW_LINE DEDENT if ( p [ 1 ] + 1 < len ( nums [ p [ 0 ] ] ) ) : NEW_LINE INDENT q . append ( [ p [ 0 ] , p [ 1 ] + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE printDiagonalTraversal ( arr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print matrix elements from top | Function to traverse the matrix diagonally upwards ; Store the number of rows ; Initialize queue ; Push the index of first element i . e . , ( 0 , 0 ) ; Get the front element ; Pop the element at the front ; Insert the element below if the current element is in first column ; Insert the right neighbour if it exists ; Driver Code ; Given vector of vectors arr ; Function call",
        "Category": "Matrix"
    },
    {
        "ID": "7141-7141",
        "Code": "import math NEW_LINE def isValid ( s ) : NEW_LINE INDENT n = int ( math . sqrt ( len ( s ) ) ) NEW_LINE check = s [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = i NEW_LINE y = i NEW_LINE while ( x >= 0 and y < n ) : NEW_LINE INDENT if ( s [ n * x + y ] != check or s [ n * x + x ] != check ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT x -= 1 NEW_LINE y += 1 NEW_LINE DEDENT DEDENT print ( \" Yes \" ) NEW_LINE DEDENT str = \" abacdaeaafaghaia \" NEW_LINE isValid ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Check if given string satisfies the following conditions | Python3 program for the above approach ; Function to check if given string satisfies the given conditions ; Dimensions ; Left diagonal ; Right diagonal ; Conditions not satisfied ; Print Yes ; Given String ; Function call",
        "Category": "Matrix"
    },
    {
        "ID": "7155-7155",
        "Code": "def checkOdd ( ch ) : NEW_LINE INDENT return ( ( ord ( ch ) - 48 ) & 1 ) NEW_LINE DEDENT def Insert_dash ( num_str ) : NEW_LINE INDENT result_str = num_str NEW_LINE x = 0 NEW_LINE while ( x < len ( num_str ) - 1 ) : NEW_LINE INDENT if ( checkOdd ( num_str [ x ] ) and checkOdd ( num_str [ x + 1 ] ) ) : NEW_LINE INDENT result_str = ( result_str [ : x + 1 ] + ' - ' + result_str [ x + 1 : ] ) NEW_LINE num_str = result_str NEW_LINE x += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return result_str NEW_LINE DEDENT str = \"1745389\" NEW_LINE print ( Insert_dash ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to insert dashes between two adjacent odd digits in given Number | Function to check if char ch is odd or not ; Function to insert dash - between any 2 consecutive digit in string str ; Traverse the string character by character ; Compare every consecutive character with the odd value ; Print the resultant string ; Given number in form of string ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "7166-7166",
        "Code": "import re NEW_LINE def removeLeadingZeros ( str ) : NEW_LINE INDENT regex = \" ^ 0 + ( ? ! $ ) \" NEW_LINE str = re . sub ( regex , \" \" , str ) NEW_LINE print ( str ) NEW_LINE DEDENT str = \"0001234\" NEW_LINE removeLeadingZeros ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Remove leading zeros from a Number given as a string | Python3 Program to implement the above approach ; Function to remove all leading zeros from a a given string ; Regex to remove leading zeros from a string ; Replaces the matched value with given string ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7168-7168",
        "Code": "def maximum_inversion ( n , k ) : NEW_LINE INDENT answer = 0 ; NEW_LINE k = min ( k , n // 2 ) ; NEW_LINE left = 1 ; NEW_LINE right = n ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE answer += 2 * ( right - left ) - 1 ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT print ( answer ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE K = 3 ; NEW_LINE maximum_inversion ( N , K ) ; NEW_LINE N = 4 ; NEW_LINE K = 1 ; NEW_LINE maximum_inversion ( N , K ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum inversions in a sequence of 1 to N after performing given operations at most K times | Function which computes the maximum number of inversions ; ' answer ' will store the required number of inversions ; We do this because we will never require more than floor ( n / 2 ) operations ; left pointer in the array ; right pointer in the array ; Doing k operations ; Incrementing ans by number of inversions increase due to this swapping ; Driver Code ; Input 1 ; Input 2",
        "Category": "Two Pointers"
    },
    {
        "ID": "7170-7170",
        "Code": "from math import log NEW_LINE def getFirstSetBitPos ( n ) : NEW_LINE INDENT return log ( n & - n , 2 ) + 1 NEW_LINE DEDENT def oddFirst ( a , b ) : NEW_LINE INDENT steps_a = getFirstSetBitPos ( a ) NEW_LINE steps_b = getFirstSetBitPos ( b ) NEW_LINE if ( steps_a == steps_b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( steps_a > steps_b ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( steps_a < steps_b ) : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( oddFirst ( a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "First number to leave an odd remainder after repetitive division by 2 | Python3 program to implement the above approach ; Function to return the position least significant set bit ; Function return the first number to be converted to an odd integer ; Stores the positions of the first set bit ; If both are same ; If A has the least significant set bit ; Otherwise ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7171-7171",
        "Code": "def possibleToReach ( x , y , z ) : NEW_LINE INDENT if ( z < abs ( x ) + abs ( y ) or ( z - abs ( x ) - abs ( y ) ) % 2 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE y = 5 NEW_LINE z = 11 NEW_LINE possibleToReach ( x , y , z ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to reach ( x , y ) from origin in exactly Z steps using only plus movements | Function to check if it is possible to reach ( x , y ) from origin in exactly z steps ; Condition if we can 't reach in Z steps ; Driver Code ; Destination pocoordinate ; Number of steps allowed ; Function call",
        "Category": "Math"
    },
    {
        "ID": "7181-7181",
        "Code": "def checkBitonic ( s ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] > s [ i - 1 ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( s [ i ] <= s [ i - 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( i == ( len ( s ) - 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ j ] < s [ j - 1 ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( s [ j ] >= s [ j - 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT i = j ; NEW_LINE if ( i != len ( s ) - 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT s = \" abcdfgcba \" NEW_LINE if ( checkBitonic ( s ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Bitonic string | Function to check if the given string is bitonic ; Check for increasing sequence ; If end of string has been reached ; Check for decreasing sequence ; If the end of string hasn 't  been reached ; Return true if bitonic ; Given string ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "7183-7183",
        "Code": "def findArray ( a , n , P ) : NEW_LINE INDENT mi = min ( a ) NEW_LINE ctr = 0 NEW_LINE mi = max ( 0 , mi - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= mi NEW_LINE ctr += mi NEW_LINE DEDENT i = P - 1 NEW_LINE start = - 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT a [ i ] -= 1 NEW_LINE ctr += 1 NEW_LINE i = ( i - 1 + n ) % n NEW_LINE DEDENT a [ start ] = ctr NEW_LINE print ( * a , sep = ' , ▁ ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE P = 2 NEW_LINE arr = [ 3 , 2 , 0 , 2 , 7 ] NEW_LINE findArray ( arr , N , P ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find initial sequence that produces a given Array by cyclic increments upto index P | Function to generate and return the required initial arrangement ; Store the minimum element in the array ; Store the number of increments ; Subtract mi - 1 from every index ; Start from the last index which had been incremented ; Stores the index chosen to distribute its element ; Traverse the array cyclically and find the index whose element was distributed ; If any index has its value reduced to 0 ; Index whose element was distributed ; Store the number of increments at the starting index ; Print the original array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "7190-7190",
        "Code": "import re NEW_LINE def isValidGUID ( str ) : NEW_LINE INDENT regex = \" \\\\b ( [ a - zA - Z0-9 ] ) \\\\1\\\\1 + \\\\b \" NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \" aaa \" NEW_LINE print ( isValidGUID ( str1 ) ) NEW_LINE str2 = \"11111\" NEW_LINE print ( isValidGUID ( str2 ) ) NEW_LINE str3 = \" aaab \" NEW_LINE print ( isValidGUID ( str3 ) ) NEW_LINE str4 = \" abc \" NEW_LINE print ( isValidGUID ( str4 ) ) NEW_LINE str5 = \" aa \" NEW_LINE print ( isValidGUID ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check three or more consecutive identical characters or numbers | Python3 program to check three or more consecutiveidentical characters or numbers using regular expression ; Function to check three or more consecutiveidentical characters or numbers using regular expression ; Regex to check three or more consecutive identical characters or numbers ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7194-7194",
        "Code": "def checkstateA ( n ) : NEW_LINE INDENT if ( n [ 0 ] == '0' ) : NEW_LINE INDENT stateB ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT def stateB ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( \" string ▁ not ▁ accepted \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '1' ) : NEW_LINE INDENT stateC ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT def stateC ( n ) : NEW_LINE INDENT print ( \" String ▁ accepted \" ) NEW_LINE DEDENT def stateD ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( \" string ▁ not ▁ accepted \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '1' ) : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateE ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT def stateE ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( \" string ▁ not ▁ accepted \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '0' ) : NEW_LINE INDENT stateE ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateF ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT def stateF ( n ) : NEW_LINE INDENT if ( len ( n ) == 0 ) : NEW_LINE INDENT print ( \" string ▁ accepred \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n [ 0 ] == '1' ) : NEW_LINE INDENT stateD ( n [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stateE ( n [ 1 : ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = \"0100101\" NEW_LINE checkstateA ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Build a DFA to accept Binary strings that starts or ends with \"01\" | Function for transition state A ; State transition to B if the character is 0 ; State transition to D if the character is 1 ; Function for transition state B ; Check if the string has ended ; State transition to C if the character is 1 ; State transition to D if the character is 0 ; Function for transition state C ; Function for transition state D ; State transition to D if the character is 1 ; State transition to E if the character is 0 ; Function for transition state E ; State transition to E if the character is 0 ; State transition to F if the character is 1 ; Function for transition state F ; State transition to D if the character is 1 ; State transition to E if the character is 0 ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "7195-7195",
        "Code": "import re NEW_LINE def isValidMACAddress ( str ) : NEW_LINE INDENT regex = ( \" ^ ( [0-9A - Fa - f ] {2 } [ : - ] ) \" + \" { 5 } ( [0-9A - Fa - f ] {2 } ) | \" + \" ( [0-9a - fA - F ] {4 } \\\\ . \" + \" [ 0-9a - fA - F ] {4 } \\\\ . \" + \" [ 0-9a - fA - F ] {4 } ) $ \" ) NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \"01-23-45-67-89 - AB \" NEW_LINE print ( isValidMACAddress ( str1 ) ) NEW_LINE str2 = \"01:23:45:67:89 : AB \" NEW_LINE print ( isValidMACAddress ( str2 ) ) NEW_LINE str3 = \"0123.4567.89AB \" NEW_LINE print ( isValidMACAddress ( str3 ) ) NEW_LINE str4 = \"01-23-45-67-89 - AH \" NEW_LINE print ( isValidMACAddress ( str4 ) ) NEW_LINE str5 = \"01-23-45-67 - AH \" NEW_LINE print ( isValidMACAddress ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate MAC address using Regular Expression | Python3 program to validate MAC address using using regular expression ; Function to validate MAC address . ; Regex to check valid MAC address ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7196-7196",
        "Code": "import re NEW_LINE def isValidGUID ( str ) : NEW_LINE INDENT regex = \" ^ [ { ] ? [ 0-9a - fA - F ] {8 } \" + \" - ( [ 0-9a - fA - F ] {4 } - ) \" + \" { 3 } [ 0-9a - fA - F ] {12 } [ } ] ? $ \" NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \"123e4567 - e89b - 12d3\" + \" - a456-9AC7CBDCEE52\" NEW_LINE print ( isValidGUID ( str1 ) ) NEW_LINE str2 = \" { 123e4567 - e89b - 12d3 - \" + \" a456-9AC7CBDCEE52 } \" NEW_LINE print ( isValidGUID ( str2 ) ) NEW_LINE str3 = \"123e4567 - h89b - 12d3 - a456\" + \" - 9AC7CBDCEE52\" NEW_LINE print ( isValidGUID ( str3 ) ) NEW_LINE str4 = \"123e4567 - h89b - 12d3 - a456\" NEW_LINE print ( isValidGUID ( str4 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate GUID ( Globally Unique Identifier ) using Regular Expression | Python3 program to validate GUID ( Globally Unique Identifier ) using regular expression ; Function to validate GUID ( Globally Unique Identifier ) ; Regex to check valid GUID ( Globally Unique Identifier ) ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 :",
        "Category": "Substring"
    },
    {
        "ID": "7197-7197",
        "Code": "import re NEW_LINE def isValidLicenseNo ( str ) : NEW_LINE INDENT regex = ( \" ^ ( ( [ A - Z ] {2 } [ 0-9 ] { 2 } ) \" + \" ( ▁ ) | ( [ A - Z ] {2 } - [0-9 ] \" + \" { 2 } ) ) ( (19 ▁ 20 ) [ 0-9 ] \" + \" [ 0-9 ] ) [0-9 ] { 7 } $ \" ) NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \" HR - 0619850034761\" NEW_LINE print ( isValidLicenseNo ( str1 ) ) NEW_LINE str2 = \" UP14 ▁ 20160034761\" NEW_LINE print ( isValidLicenseNo ( str2 ) ) NEW_LINE str3 = \"12HR - 37200602347\" NEW_LINE print ( isValidLicenseNo ( str3 ) ) NEW_LINE str4 = \" MH27 ▁ 30123476102\" NEW_LINE print ( isValidLicenseNo ( str4 ) ) NEW_LINE str5 = \" GJ - 2420180\" NEW_LINE print ( isValidLicenseNo ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate Indian driving license number using Regular Expression | Python program to validate Indian driving license number using regular expression ; Function to validate Indian driving license number . ; Regex to check valid Indian driving license number ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "72-72",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def insertLevelOrder ( arr , root , i , n ) : NEW_LINE INDENT if i < n : NEW_LINE INDENT temp = newNode ( arr [ i ] ) NEW_LINE root = temp NEW_LINE root . left = insertLevelOrder ( arr , root . left , 2 * i + 1 , n ) NEW_LINE root . right = insertLevelOrder ( arr , root . right , 2 * i + 2 , n ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inOrder ( root . left ) NEW_LINE print ( root . data , end = \" ▁ \" ) NEW_LINE inOrder ( root . right ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 6 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE root = None NEW_LINE root = insertLevelOrder ( arr , root , 0 , n ) NEW_LINE inOrder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct a complete binary tree from given array in level order fashion | Helper function that allocates a new node ; Function to insert nodes in level order ; Base case for recursion ; insert left child ; insert right child ; Function to print tree nodes in InOrder fashion ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "720-720",
        "Code": "def findPreSuc ( root , pre , suc , key ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT while root != None : NEW_LINE INDENT if root . key == key : NEW_LINE INDENT if root . right : NEW_LINE INDENT suc [ 0 ] = root . right NEW_LINE while suc [ 0 ] . left : NEW_LINE INDENT suc [ 0 ] = suc [ 0 ] . left NEW_LINE DEDENT DEDENT if root . left : NEW_LINE INDENT pre [ 0 ] = root . left NEW_LINE while pre [ 0 ] . right : NEW_LINE INDENT pre [ 0 ] = pre [ 0 ] . right NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT elif root . key < key : NEW_LINE INDENT pre [ 0 ] = root NEW_LINE root = root . right NEW_LINE DEDENT else : NEW_LINE INDENT suc [ 0 ] = root NEW_LINE root = root . left NEW_LINE DEDENT DEDENT DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT key = 65 NEW_LINE root = None NEW_LINE root = insert ( root , 50 ) NEW_LINE insert ( root , 30 ) NEW_LINE insert ( root , 20 ) NEW_LINE insert ( root , 40 ) NEW_LINE insert ( root , 70 ) NEW_LINE insert ( root , 60 ) NEW_LINE insert ( root , 80 ) NEW_LINE pre , suc = [ None ] , [ None ] NEW_LINE findPreSuc ( root , pre , suc , key ) NEW_LINE if pre [ 0 ] != None : NEW_LINE INDENT print ( \" Predecessor ▁ is \" , pre [ 0 ] . key ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT if suc [ 0 ] != None : NEW_LINE INDENT print ( \" Successor ▁ is \" , suc [ 0 ] . key ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Inorder predecessor and successor for a given key in BST | Iterative Approach | Function that finds predecessor and successor of key in BST . ; Search for given key in BST . ; If root is given key . ; the minimum value in right subtree is predecessor . ; the maximum value in left subtree is successor . ; If key is greater than root , then key lies in right subtree . Root could be predecessor if left subtree of key is null . ; If key is smaller than root , then key lies in left subtree . Root could be successor if right subtree of key is null . ; A utility function to create a new BST node ; A utility function to insert a new node with given key in BST ; Driver Code ; Key to be searched in BST ; Let us create following BST 50 / \\ / \\ 30 70 / \\ / \\ / \\ / \\ 20 40 60 80",
        "Category": "Binary Tree"
    },
    {
        "ID": "7200-7200",
        "Code": "import re NEW_LINE def isValidPassportNo ( string ) : NEW_LINE INDENT regex = \" ^ [ A - PR - WYa - pr - wy ] [1-9 ] \\\\d \" + p = re . compile ( regex ) NEW_LINE if ( string == ' ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT m = re . match ( p , string ) NEW_LINE if m is None : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" A21 ▁ 90457\" NEW_LINE print ( isValidPassportNo ( str1 ) ) NEW_LINE str2 = \" A0296457\" NEW_LINE print ( isValidPassportNo ( str2 ) ) NEW_LINE str3 = \" Q2096453\" NEW_LINE print ( isValidPassportNo ( str3 ) ) NEW_LINE str4 = \"12096457\" NEW_LINE print ( isValidPassportNo ( str4 ) ) NEW_LINE str5 = \" A209645704\" NEW_LINE print ( isValidPassportNo ( str5 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to validate Indian Passport number using Regular Expression | Python3 program to validate passport number of India using regular expression ; Function to validate the pin code of India . ; Regex to check valid pin code of India . ; Compile the ReGex ; If the string is empty return false ; Pattern class contains matcher ( ) method to find matching between given string and regular expression . ; Return True if the string matched the ReGex else False ; Driver code . ; Test Case 1 ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7201-7201",
        "Code": "import re NEW_LINE def isValidVisaCardNo ( string ) : NEW_LINE INDENT regex = \" ^ 4[0-9 ] { 12 } ( ? : [0-9 ] { 3 } ) ? $ \" ; NEW_LINE p = re . compile ( regex ) ; NEW_LINE if ( string == ' ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT m = re . match ( p , string ) ; NEW_LINE if m is None : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"4155279860457\" ; NEW_LINE print ( isValidVisaCardNo ( str1 ) ) ; NEW_LINE str2 = \"4155279860457201\" ; NEW_LINE print ( isValidVisaCardNo ( str2 ) ) ; NEW_LINE str3 = \"4155279\" ; NEW_LINE print ( isValidVisaCardNo ( str3 ) ) ; NEW_LINE str4 = \"6155279860457\" ; NEW_LINE print ( isValidVisaCardNo ( str4 ) ) ; NEW_LINE print ( isValidVisaCardNo ( str5 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to validate Visa Card number using Regular Expression | Python3 program to validate Visa Card number using regular expression ; Function to validate Visa Card number using regular expression . ; Regex to check valid Visa Card number ; Compile the ReGex ; If the string is empty return false ; Pattern class contains matcher ( ) method to find matching between given string and regular expression . ; Return True if the string matched the ReGex else False ; Driver code ; Test Case 1 ; Test Case 2 ; Test Case 3 ; Test Case 4 ; Test Case 5 str5 = \"415a2760457\" ;",
        "Category": "Substring"
    },
    {
        "ID": "7202-7202",
        "Code": "import re NEW_LINE def isValidMasterCardNo ( str ) : NEW_LINE INDENT regex = \" ^ 5[1-5 ] [ 0-9 ] { 14 } | \" + NEW_LINE INDENT \" ^ ( 222[1-9 ] ▁ 22[3-9 ] \\\\d ▁ \" + \"2[3-6 ] \\\\d { 2 } ▁ 27[0-1 ] \\\\d ▁ \" + \"2720 ) [ 0-9 ] { 12 } $ \" NEW_LINE DEDENT p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \"5114496353984312\" NEW_LINE print ( isValidMasterCardNo ( str1 ) ) NEW_LINE str2 = \"2720822463109651\" NEW_LINE print ( isValidMasterCardNo ( str2 ) ) NEW_LINE str3 = \"5582822410\" NEW_LINE print ( isValidMasterCardNo ( str3 ) ) NEW_LINE str4 = \"6082822463100051\" NEW_LINE print ( isValidMasterCardNo ( str4 ) ) NEW_LINE print ( isValidMasterCardNo ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate MasterCard number using Regular Expression | Python3 program to validate Master Card number using regular expression ; Function to validate Master Card number using regular expression . ; Regex to check valid Master Card number . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 : str5 = \"2221149a635843\"",
        "Category": "Substring"
    },
    {
        "ID": "7209-7209",
        "Code": "import re NEW_LINE def isValidIFSCode ( str ) : NEW_LINE INDENT regex = \" ^ [ A - Z ] {4}0 [ A - Z0-9 ] { 6 } $ \" NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \" SBIN0125620\" NEW_LINE print ( isValidIFSCode ( str1 ) ) NEW_LINE str2 = \" SBIN0125\" NEW_LINE print ( isValidIFSCode ( str2 ) ) NEW_LINE str3 = \"1234SBIN012\" NEW_LINE print ( isValidIFSCode ( str3 ) ) NEW_LINE str4 = \" SBIN7125620\" NEW_LINE print ( isValidIFSCode ( str4 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate IFSC Code using Regular Expression | Python3 program to validate IFSC ( Indian Financial System ) Code using regular expression ; Function to validate IFSC ( Indian Financial System ) Code using regular expression . ; Regex to check valid IFSC Code . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 :",
        "Category": "Substring"
    },
    {
        "ID": "7210-7210",
        "Code": "import re NEW_LINE def isValidMasterCardNo ( str ) : NEW_LINE INDENT regex = \" ^ [ 0-9 ] { 2 } [ A - Z ] {5 } [ 0-9 ] { 4 } \" + NEW_LINE INDENT \" [ A - Z ] {1 } [ 1-9A - Z ] {1 } \" + NEW_LINE DEDENT p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \"06BZAHM6385P6Z2\" NEW_LINE print ( isValidMasterCardNo ( str1 ) ) NEW_LINE str2 = \"06BZAF67\" NEW_LINE print ( isValidMasterCardNo ( str2 ) ) NEW_LINE str3 = \" AZBZAHM6385P6Z2\" NEW_LINE print ( isValidMasterCardNo ( str3 ) ) NEW_LINE str4 = \"06BZ63AHM85P6Z2\" NEW_LINE print ( isValidMasterCardNo ( str4 ) ) NEW_LINE str5 = \"06BZAHM6385P6F2\" NEW_LINE print ( isValidMasterCardNo ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate GST ( Goods and Services Tax ) number using Regular Expression | Python3 program to validate GST ( Goods and Services Tax ) number using regular expression ; Function to validate GST ( Goods and Services Tax ) number . ; Regex to check valid GST ( Goods and Services Tax ) number ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7212-7212",
        "Code": "import re NEW_LINE def isValidDomain ( str ) : NEW_LINE INDENT regex = \" ^ ( ( ? ! - ) [ A - Za - z0-9 - ] \" + NEW_LINE INDENT \" { 1,63 } ( ? < ! - ) \\\\ . ) \" + NEW_LINE DEDENT p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \" geeksforgeeks . org \" NEW_LINE print ( isValidDomain ( str1 ) ) NEW_LINE str2 = \" contribute . geeksforgeeks . org \" NEW_LINE print ( isValidDomain ( str2 ) ) NEW_LINE str3 = \" - geeksforgeeks . org \" NEW_LINE print ( isValidDomain ( str3 ) ) NEW_LINE str4 = \" geeksforgeeks . o \" NEW_LINE print ( isValidDomain ( str4 ) ) NEW_LINE str5 = \" . org \" NEW_LINE print ( isValidDomain ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate a domain name using Regular Expression | Python3 program to validate domain name using regular expression ; Function to validate domain name . ; Regex to check valid domain name . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7213-7213",
        "Code": "import re NEW_LINE def isValidSSN ( str ) : NEW_LINE INDENT regex = \" ^ ( ? ! 666 ▁ 000 ▁ 9\\\\d { 2 } ) \\\\d { 3 } - ( ? !00 ) \\\\d { 2 } - ( ? !0{4 } ) \\\\d { 4 } $ \" NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \"856-45-6789\" NEW_LINE print ( isValidSSN ( str1 ) ) NEW_LINE str2 = \"000-45-6789\" NEW_LINE print ( isValidSSN ( str2 ) ) NEW_LINE str3 = \"856-452-6789\" NEW_LINE print ( isValidSSN ( str3 ) ) NEW_LINE str4 = \"856-45-0000\" NEW_LINE print ( isValidSSN ( str4 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate SSN ( Social Security Number ) using Regular Expression | Python3 program to validate SSN ( Social Security Number ) using regular expression ; Function to validate SSN ( Social Security Number ) . ; Regex to check valid SSN ( Social Security Number ) . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 :",
        "Category": "Substring"
    },
    {
        "ID": "7214-7214",
        "Code": "def checkQwertyRow ( x ) : NEW_LINE INDENT first_row = [ '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , ' - ' , ' = ' ] NEW_LINE second_row = [ ' Q ' , ' W ' , ' E ' , ' R ' , ' T ' , ' Y ' , ' U ' , ' I ' , ' O ' , ' P ' , ' [ ' , ' ] ' , ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' y ' , ' u ' , ' i ' , ' o ' , ' p ' ] NEW_LINE third_row = [ ' A ' , ' S ' , ' D ' , ' F ' , ' G ' , ' H ' , ' J ' , ' K ' , ' L ' , ' ; ' , ' : ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' h ' , ' j ' , ' k ' , ' l ' ] NEW_LINE fourth_row = [ ' Z ' , ' X ' , ' C ' , ' V ' , ' B ' , ' N ' , ' M ' , ' , ' , ' . ' , ' / ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' , ' n ' , ' m ' ] NEW_LINE if ( first_row . count ( x ) > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( second_row . count ( x ) > 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( third_row . count ( x ) > 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( fourth_row . count ( x ) > 0 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def checkValidity ( str ) : NEW_LINE INDENT x = str [ 0 ] NEW_LINE row = checkQwertyRow ( x ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT x = str [ i ] NEW_LINE if ( row != checkQwertyRow ( x ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str = \" GeeksforGeeks \" NEW_LINE if ( checkValidity ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether the string can be printed using same row of qwerty keypad | Function to find the row of the character in the qwerty keypad ; Sets to include the characters from the same row of the qwerty keypad ; Condition to check the row of the current character of the string ; Function to check the characters are from the same row of the qwerty keypad ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "7215-7215",
        "Code": "import re NEW_LINE def imageFile ( str ) : NEW_LINE INDENT regex = \" ( [ ^ \\\\s ] + ( \\\\ . ( ? i ) ( jpe ? g ▁ png ▁ gif ▁ bmp ) ) $ ) \" NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \" abc . png \" NEW_LINE print ( imageFile ( str1 ) ) NEW_LINE str2 = \" im . jpg \" NEW_LINE print ( imageFile ( str2 ) ) NEW_LINE str3 = \" . gif \" NEW_LINE print ( imageFile ( str3 ) ) NEW_LINE str4 = \" abc . mp3\" NEW_LINE print ( imageFile ( str4 ) ) NEW_LINE str5 = \" ▁ . jpg \" NEW_LINE print ( imageFile ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate image file extension using Regular Expression | Python3 program to validate image file extension using regex ; Function to validate image file extension . ; Regex to check valid image file extension . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7216-7216",
        "Code": "import re NEW_LINE def isValidAadharNumber ( str ) : NEW_LINE INDENT regex = ( \" ^ [ 2-9 ] { 1 } [ 0-9 ] { 3 } \\\\ \" + \" s [ 0-9 ] { 4 } \\\\s [ 0-9 ] { 4 } $ \" ) NEW_LINE p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \"3675 ▁ 9834 ▁ 6015\" NEW_LINE print ( isValidAadharNumber ( str1 ) ) NEW_LINE str2 = \"4675 ▁ 9834 ▁ 6012 ▁ 8\" NEW_LINE print ( isValidAadharNumber ( str2 ) ) NEW_LINE str3 = \"0175 ▁ 9834 ▁ 6012\" NEW_LINE print ( isValidAadharNumber ( str3 ) ) NEW_LINE print ( isValidAadharNumber ( str4 ) ) NEW_LINE str5 = \"417598346012\" NEW_LINE print ( isValidAadharNumber ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to check Aadhar number is valid or not using Regular Expression | Python3 program to validate Aadhar number using regex . ; Function to validate Aadhar number . ; Regex to check valid Aadhar number . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : str4 = \"3675 ▁ 98AF ▁ 602\" ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7218-7218",
        "Code": "import math NEW_LINE def printSinX ( N ) : NEW_LINE INDENT Xi = 0 ; NEW_LINE num = 1 ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT print ( \" X \" , num , \" = \" , Xi , end = \" ▁ \" ) ; NEW_LINE print ( \" sin ( X \" , num , \" ) ▁ = \" , end = \" ▁ \" ) ; NEW_LINE print ( \" { : . 6f } \" . format ( math . sin ( Xi ) ) ,   \" \" ) ; NEW_LINE num += 1 ; NEW_LINE Xi += 710 ; NEW_LINE N = N - 1 ; NEW_LINE DEDENT DEDENT N = 5 ; NEW_LINE printSinX ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Find N values of X1 , X2 , ... Xn such that X1 < X2 < ... < XN and sin ( X1 ) < sin ( X2 ) < ... < sin ( XN ) | Python3 program for the above approach ; Function to print all such Xi s . t . all Xi and sin ( Xi ) are strictly increasing ; Till N becomes zero ; Find the value of sin ( ) using inbuilt function ; increment by 710 ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7222-7222",
        "Code": "def countCharacters ( arr , chars ) : NEW_LINE INDENT res = 0 NEW_LINE freq = dict ( ) NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT freq [ chars [ i ] ] = freq . get ( chars [ i ] , 0 ) + 1 NEW_LINE DEDENT for st in arr : NEW_LINE INDENT flag = True NEW_LINE for c in st : NEW_LINE INDENT if ( c not in freq ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT res += len ( st ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" hi \" , \" data \" , \" geeksforgeeks \" ] NEW_LINE chars = \" tiadhae \" NEW_LINE print ( countCharacters ( arr , chars ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Total length of string from given Array of strings composed using given characters | Function to count the total length ; Unordered_map for keeping frequency of characters ; Calculate the frequency ; Iterate in the N strings ; Iterates in the string ; Checks if given character of string string appears in it or not ; Adds the length of string if all characters are present ; Return the final result ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7223-7223",
        "Code": "import re NEW_LINE def isValidPinCode ( pinCode ) : NEW_LINE INDENT regex = \" ^ [ 1-9 ] { 1 } [ 0-9 ] { 2 } \\\\s { 0,1 } [ 0-9 ] { 3 } $ \" ; NEW_LINE p = re . compile ( regex ) ; NEW_LINE if ( pinCode == ' ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT m = re . match ( p , pinCode ) ; NEW_LINE if m is None : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num1 = \"132103\" ; NEW_LINE print ( num1 , \" : ▁ \" , isValidPinCode ( num1 ) ) ; NEW_LINE num2 = \"201 ▁ 305\" ; NEW_LINE print ( num2 , \" : ▁ \" , isValidPinCode ( num2 ) ) ; NEW_LINE num3 = \"014205\" ; NEW_LINE print ( num3 , \" : ▁ \" , isValidPinCode ( num3 ) ) ; NEW_LINE num4 = \"1473598\" ; NEW_LINE print ( num4 , \" : ▁ \" , isValidPinCode ( num4 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to validate pin code of India using Regular Expression | Python3 program to validate the pin code of India using Regular Expression . ; Function to validate the pin code of India . ; Regex to check valid pin code of India . ; Compile the ReGex ; If the pin code is empty return false ; Pattern class contains matcher ( ) method to find matching between given pin code and regular expression . ; Return True if the pin code matched the ReGex else False ; Driver code ; Test case 1 ; Test case 2 : ; Test case 3 : ; Test case 4 :",
        "Category": "Substring"
    },
    {
        "ID": "7224-7224",
        "Code": "import re NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT regex = \" ^ ( [01 ] ? [0-9 ] ▁ 2[0-3 ] ) : [ 0-5 ] [ 0-9 ] $ \" ; NEW_LINE p = re . compile ( regex ) ; NEW_LINE if ( time == \" \" ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT m = re . search ( p , time ) ; NEW_LINE if m is None : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"13:05\" ; NEW_LINE print ( str1 , \" : ▁ \" , isValidTime ( str1 ) ) ; NEW_LINE str2 = \"02:15\" ; NEW_LINE print ( str2 , \" : ▁ \" , isValidTime ( str2 ) ) ; NEW_LINE str3 = \"24:00\" ; NEW_LINE print ( str3 , \" : ▁ \" , isValidTime ( str3 ) ) ; NEW_LINE str4 = \"10:60\" ; NEW_LINE print ( str4 , \" : ▁ \" , isValidTime ( str4 ) ) ; NEW_LINE str5 = \"10:15 ▁ PM \" ; NEW_LINE print ( str5 , \" : ▁ \" , isValidTime ( str5 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to validate time in 24 | Python3 program to validate the time in 24 - hour format using Regular Expression . ; Function to validate the time in 24 - hour format ; Regex to check valid time in 24 - hour format . ; Compile the ReGex ; If the time is empty return false ; Pattern class contains matcher ( ) method to find matching between given time and regular expression . ; Return True if the time matched the ReGex otherwise False ; Driver Code . ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7226-7226",
        "Code": "import re NEW_LINE def isValidHexaCode ( str ) : NEW_LINE INDENT p = re . compile ( regex ) NEW_LINE if ( str == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT print ( str1 , \" : \" , isValidHexaCode ( str1 ) ) NEW_LINE print ( str2 , \" : \" , isValidHexaCode ( str2 ) ) NEW_LINE str3 = \"123456\" NEW_LINE print ( str3 , \" : \" , isValidHexaCode ( str3 ) ) NEW_LINE print ( str4 , \" : \" , isValidHexaCode ( str4 ) ) NEW_LINE print ( str5 , \" : \" , isValidHexaCode ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate Hexadecimal Color Code using Regular Expression | Python3 program to validate hexadecimal colour code using Regular Expression ; Function to validate hexadecimal color code . ; Compile the ReGex ; If the string is empty return false ; Return if the string matched the ReGex ; Test Case 1 : str1 = \"1AFFa1\" ; Test Case 2 : str2 = \" F00\" ; Test Case 3 : ; Test Case 4 : str4 = \"123abce \" ; Test Case 5 : str5 = \" afafah \"",
        "Category": "Substring"
    },
    {
        "ID": "7227-7227",
        "Code": "def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT hexCode = \" \" NEW_LINE if ( i == 2 ) : NEW_LINE INDENT hexCode = hexCode + hexaDeciNum [ 0 ] NEW_LINE hexCode = hexCode + hexaDeciNum [ 1 ] NEW_LINE DEDENT elif ( i == 1 ) : NEW_LINE INDENT hexCode = \"0\" NEW_LINE hexCode = hexCode + hexaDeciNum [ 0 ] NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT hexCode = \"00\" NEW_LINE DEDENT return hexCode NEW_LINE DEDENT def convertRGBtoHex ( R , G , B ) : NEW_LINE INDENT if ( ( R >= 0 and R <= 255 ) and ( G >= 0 and G <= 255 ) and ( B >= 0 and B <= 255 ) ) : NEW_LINE INDENT hexCode = hexCode + decToHexa ( R ) NEW_LINE hexCode = hexCode + decToHexa ( G ) NEW_LINE hexCode = hexCode + decToHexa ( B ) NEW_LINE return hexCode NEW_LINE DEDENT else : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT DEDENT R = 0 NEW_LINE G = 0 NEW_LINE B = 0 NEW_LINE print ( convertRGBtoHex ( R , G , B ) ) NEW_LINE R = 255 NEW_LINE G = 255 NEW_LINE B = 255 NEW_LINE print ( convertRGBtoHex ( R , G , B ) ) NEW_LINE R = 25 NEW_LINE G = 56 NEW_LINE B = 123 NEW_LINE print ( convertRGBtoHex ( R , G , B ) ) NEW_LINE R = 2 NEW_LINE G = 3 NEW_LINE B = 4 NEW_LINE print ( convertRGBtoHex ( R , G , B ) ) NEW_LINE R = 255 NEW_LINE G = 255 NEW_LINE B = 256 NEW_LINE print ( convertRGBtoHex ( R , G , B ) ) NEW_LINE",
        "Type": "py",
        "NL": "Convert the given RGB color code to Hex color code | Function to convert decimal to hexadecimal ; char array to store hexadecimal number ; Counter for hexadecimal number array ; Temporary variable to store remainder ; Storing remainder in temp variable . ; Check if temp < 10 ; Return the equivalent hexadecimal color code ; Function to convert the RGB code to Hex color code ; The hex color code doesn 't exist ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7230-7230",
        "Code": "import re NEW_LINE def isValidPanCardNo ( panCardNo ) : NEW_LINE INDENT regex = \" [ A - Z ] {5 } [ 0-9 ] { 4 } [ A - Z ] {1 } \" NEW_LINE p = re . compile ( regex ) NEW_LINE if ( panCardNo == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( re . search ( p , panCardNo ) and len ( panCardNo ) == 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str1 = \" BNZAA2318J \" NEW_LINE print ( isValidPanCardNo ( str1 ) ) NEW_LINE str2 = \"23ZAABN18J \" NEW_LINE print ( isValidPanCardNo ( str2 ) ) NEW_LINE str3 = \" BNZAA2318JM \" NEW_LINE print ( isValidPanCardNo ( str3 ) ) NEW_LINE str4 = \" BNZAA23184\" NEW_LINE print ( isValidPanCardNo ( str4 ) ) NEW_LINE str5 = \" BNZAA ▁ 23184\" NEW_LINE print ( isValidPanCardNo ( str5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "How to validate PAN Card number using Regular Expression | Python3 program to validate the PAN Card number using Regular Expression ; Function to validate the PAN Card number . ; Regex to check valid PAN Card number ; Compile the ReGex ; If the PAN Card number is empty return false ; Return if the PAN Card number matched the ReGex ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 : ; Test Case 5 :",
        "Category": "Substring"
    },
    {
        "ID": "7231-7231",
        "Code": "import re NEW_LINE def isValidTime ( time ) : NEW_LINE INDENT regexPattern = \" ( 1[012 ] ▁ [ 1-9 ] ) : \" + \" [ 0-5 ] [ 0-9 ] ( \\\\s ) \" + \" ? ( ? i ) ( am ▁ pm ) \" ; NEW_LINE compiledPattern = re . compile ( regexPattern ) ; NEW_LINE if ( time == None ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if re . search ( compiledPattern , time ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \"12:15 ▁ AM \" ; NEW_LINE print ( isValidTime ( str1 ) ) ; NEW_LINE str2 = \"9:45PM \" ; NEW_LINE print ( isValidTime ( str2 ) ) ; NEW_LINE str3 = \"1:15\" ; NEW_LINE print ( isValidTime ( str3 ) ) ; NEW_LINE str4 = \"17:30\" ; NEW_LINE print ( isValidTime ( str4 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to validate time in 12 | Python3 program to validate the time in 12 - hour format using Regular Expression . ; Function to validate the time in 12 - hour format . ; Regex to check valid time in 12 - hour format . ; Compile the ReGex ; If the time is empty return false ; Return if the time matched the ReGex ; Driver Code . ; Test Case 1 : ; Test Case 2 : ; Test Case 3 : ; Test Case 4 :",
        "Category": "Substring"
    },
    {
        "ID": "7238-7238",
        "Code": "def isKAlternating ( s , k ) : NEW_LINE INDENT if ( len ( s ) < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT for i in range ( k , len ( s ) ) : NEW_LINE INDENT if ( s [ i - k ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" acdeac \" NEW_LINE K = 4 NEW_LINE if ( isKAlternating ( st , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string is made up of K alternating characters | Function to check if a string is made up of k alternating characters ; Check if all the characters at indices 0 to K - 1 are different ; If that bit is already set in checker , return false ; Otherwise update and continue by setting that bit in the checker ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7240-7240",
        "Code": "def findPalindrome ( C ) : NEW_LINE INDENT S = C [ : : - 1 ] NEW_LINE C = C [ : ] + ' & ' + S NEW_LINE n = len ( C ) NEW_LINE longestPalindrome = [ 0 for i in range ( n ) ] NEW_LINE longestPalindrome [ 0 ] = 0 NEW_LINE ll = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( C [ i ] == C [ ll ] ) : NEW_LINE INDENT ll += 1 NEW_LINE longestPalindrome [ i ] = ll NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ll != 0 ) : NEW_LINE INDENT ll = longestPalindrome [ ll - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT longestPalindrome [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT ans = C [ 0 : longestPalindrome [ n - 1 ] ] NEW_LINE return ans NEW_LINE DEDENT def findAns ( s ) : NEW_LINE INDENT A = \" \" NEW_LINE B = \" \" NEW_LINE F = \" \" NEW_LINE i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE ll = len ( s ) NEW_LINE while ( i < j and s [ i ] == s [ j ] ) : NEW_LINE INDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT A = s [ 0 : i ] NEW_LINE B = s [ ll - i : ll ] NEW_LINE DEDENT if ( ll > 2 * i ) : NEW_LINE INDENT C = s [ i : i + ( len ( s ) - 2 * i ) ] NEW_LINE D = findPalindrome ( C ) NEW_LINE C = C [ : : - 1 ] NEW_LINE E = findPalindrome ( C ) NEW_LINE if ( len ( D ) > len ( E ) ) : NEW_LINE INDENT F = D NEW_LINE DEDENT else : NEW_LINE INDENT F = E NEW_LINE DEDENT DEDENT answer = A + F + B NEW_LINE return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abcdefghiedcba \" NEW_LINE print ( findAns ( str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest palindromic string possible after removal of a substring | Function to find the longest palindrome from the start of the string using KMP match ; Append S ( reverse of C ) to C ; Use KMP algorithm ; Function to return longest palindromic string possible from the given string after removal of any substring ; Initialize three strings A , B AND F ; Loop to find longest substrings from both ends which are reverse of each other ; Proceed to third step of our approach ; Remove the substrings A and B ; Find the longest palindromic substring from beginning of C ; Find the longest palindromic substring from end of C ; Store the maximum of D and E in F ; Find the final answer ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "7245-7245",
        "Code": "def countSubstring ( S , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT cnt0 = 0 ; cnt1 = 0 ; NEW_LINE if ( S [ i ] == '0' ) : NEW_LINE INDENT while ( i < n and S [ i ] == '0' ) : NEW_LINE INDENT cnt0 += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT j = i ; NEW_LINE while ( j < n and S [ j ] == '1' ) : NEW_LINE INDENT cnt1 += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( i < n and S [ i ] == '1' ) : NEW_LINE INDENT cnt1 += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT j = i ; NEW_LINE while ( j < n and S [ j ] == '0' ) : NEW_LINE INDENT cnt0 += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT ans += min ( cnt0 , cnt1 ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0001110010\" ; NEW_LINE n = len ( S ) ; NEW_LINE print ( countSubstring ( S , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of sub | Function to find the count of substrings with equal no . of consecutive 0 ' s ▁ and ▁ 1' s ; To store the total count of substrings ; Traversing the string ; Count of consecutive 0 ' s ▁ & ▁ 1' s ; Counting subarrays of type \"01\" ; Count the consecutive 0 's ; If consecutive 0 ' s ▁ ▁ ends ▁ then ▁ check ▁ for ▁ ▁ consecutive ▁ 1' s ; Counting consecutive 1 's ; Counting subarrays of type \"10\" ; Count consecutive 1 's ; If consecutive 1 ' s ▁ ▁ ends ▁ then ▁ check ▁ for ▁ ▁ consecutive ▁ 0' s ; Count consecutive 0 's ; Update the total count of substrings with minimum of ( cnt0 , cnt1 ) ; Return answer ; Driver code ; Function to print the count of substrings",
        "Category": "Substring"
    },
    {
        "ID": "7247-7247",
        "Code": "from math import sqrt , ceil NEW_LINE def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = n // 8 ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def nDigitPerfectSquares ( n ) : NEW_LINE INDENT decimal = pow ( ceil ( sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; NEW_LINE decToOctal ( decimal ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest N digit Octal number which is a Perfect square | Python3 implementation to find the maximum N - digit octal number which is perfect square ; Function to convert decimal number to a octal number ; Array to store octal number ; Counter for octal number array ; Store remainder in octal array ; Print octal number array in reverse order ; Largest n - digit perfect square ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7251-7251",
        "Code": "def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT if ( i == s . length ( ) ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abbaabb \" ; NEW_LINE q0 ( s , 0 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to build a DFA to accept strings that start and end with same character | Function for the state Q1 ; Condition to check end of string ; State transitions ' a ' takes to q1 , and ' b ' takes to q2 ; Function for the state Q2 ; Condition to check end of string ; State transitions ' a ' takes to q1 , and ' b ' takes to q2 ; Function for the state Q3 ; Condition to check end of string ; State transitions ' a ' takes to q4 , and ' b ' takes to q3 ; Function for the state Q4 ; Condition to check end of string ; State transitions ' a ' takes to q4 , and ' b ' takes to q3 ; Function for the state Q0 ; Condition to check end of string ; State transitions ' a ' takes to q1 , and ' b ' takes to q3 ; Driver Code ; Since q0 is the starting state Send the string to q0",
        "Category": "Graph Theory"
    },
    {
        "ID": "7254-7254",
        "Code": "def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 4 ; NEW_LINE pi = 1 ; po = 1 ; NEW_LINE n = N ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 ; NEW_LINE n -= 1 ; NEW_LINE po *= 2 ; NEW_LINE DEDENT nth = ( first_term * pi ) // po ; NEW_LINE return nth ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... | Function to find Nth term ; Nth term ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7256-7256",
        "Code": "def q1 ( s , i ) : NEW_LINE INDENT print ( \" q1 - > \" , end = \" \" ) ; NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT print ( \" q2 - > \" , end = \" \" ) ; NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT print ( \" q3 - > \" , end = \" \" ) ; NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT print ( \" q4 - > \" , end = \" \" ) ; NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT print ( \" q0 - > \" , end = \" \" ) ; NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010101\" ; NEW_LINE print ( \" State ▁ transitions ▁ are \" , end = \" ▁ \" ) ; NEW_LINE q0 ( s , 0 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to build a DFA that checks if a string ends with \"01\" or \"10\" | End position is checked using the string length value . q0 is the starting state . q1 and q2 are intermediate states . q3 and q4 are final states . ; state transitions 0 takes to q1 , 1 takes to q3 ; state transitions 0 takes to q4 , 1 takes to q2 ; state transitions 0 takes to q4 , 1 takes to q2 ; state transitions 0 takes to q1 , 1 takes to q3 ; state transitions 0 takes to q1 , 1 takes to q2 ; Driver Code ; all state transitions are printed . if string is accpetable , YES is printed . else NO is printed",
        "Category": "Graph Theory"
    },
    {
        "ID": "7262-7262",
        "Code": "def squareDigitSum ( num ) : NEW_LINE INDENT lengthN = len ( num ) NEW_LINE result = ( lengthN // 9 ) * 81 + ( lengthN % 9 ) ** 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of the digits of square of the given number which has only 1 's as its digits | Function to return the sum of the digits of num ^ 2 ; To store the number of 1 's ; Find the sum of the digits of num ^ 2 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7266-7266",
        "Code": "def getString ( x ) : NEW_LINE INDENT return x NEW_LINE DEDENT def solve ( s1 , s2 ) : NEW_LINE INDENT a = getString ( s1 [ 0 ] ) NEW_LINE b = getString ( s2 [ 0 ] ) NEW_LINE for i in range ( 1 , len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] != s1 [ i - 1 ] : NEW_LINE INDENT a += getString ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( s2 ) ) : NEW_LINE INDENT if s2 [ i ] != s2 [ i - 1 ] : NEW_LINE INDENT b += getString ( s2 [ i ] ) NEW_LINE DEDENT DEDENT if a == b : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s1 = \" Geeks \" NEW_LINE s2 = \" Geks \" NEW_LINE if solve ( s1 , s2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether two strings contain same characters in same order | Python3 implementation of the approach ; string class has a constructor that allows us to specify the size of string as first parameter and character to be filled in given size as the second parameter . ; Function that returns true if the given strings contain same characters in same order ; Get the first character of both strings ; Now if there are adjacent similar character remove that character from s1 ; Now if there are adjacent similar character remove that character from s2 ; If both the strings are equal then return true ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7267-7267",
        "Code": "def checkSequence ( a , b ) : NEW_LINE INDENT if len ( b ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( a ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" Geeks \" NEW_LINE s2 = \" Geks \" NEW_LINE if ( checkSequence ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether two strings contain same characters in same order | Python3 implementation of approach ; if length of the b = 0 then we return true ; if length of a = 0 that means b is not present in a so we return false ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7269-7269",
        "Code": "def LengthlongestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE len1 = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE lps [ i ] = len1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len1 != 0 ) : NEW_LINE INDENT len1 = lps [ len1 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > int ( n / 2 ) ) : NEW_LINE INDENT return int ( n / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT def longestPrefixSuffix ( s ) : NEW_LINE INDENT len1 = LengthlongestPrefixSuffix ( s ) NEW_LINE prefix = \" \" NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT prefix += s [ i ] NEW_LINE DEDENT return prefix NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abcab \" NEW_LINE ans = longestPrefixSuffix ( s ) NEW_LINE if ( ans == \" \" ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Print the longest prefix of the given string which is also the suffix of the same string | Returns length of the longest prefix which is also suffix and the two do not overlap . This function mainly is copy of computeLPSArray ( ) in KMP Algorithm ; Length of the previous longest prefix suffix ; Loop to calculate lps [ i ] for i = 1 to n - 1 ; This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step . ; If len = 0 ; Since we are looking for non overlapping parts ; Function that returns the prefix ; Get the length of the longest prefix ; Stores the prefix ; Traverse and add characters ; Returns the prefix ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "727-727",
        "Code": "class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxDiffUtil ( ptr , k , min_diff , min_diff_key ) : NEW_LINE INDENT if ptr == None : NEW_LINE INDENT return NEW_LINE DEDENT if ptr . key == k : NEW_LINE INDENT min_diff_key [ 0 ] = k NEW_LINE return NEW_LINE DEDENT if min_diff > abs ( ptr . key - k ) : NEW_LINE INDENT min_diff = abs ( ptr . key - k ) NEW_LINE min_diff_key [ 0 ] = ptr . key NEW_LINE DEDENT if k < ptr . key : NEW_LINE INDENT maxDiffUtil ( ptr . left , k , min_diff , min_diff_key ) NEW_LINE DEDENT else : NEW_LINE INDENT maxDiffUtil ( ptr . right , k , min_diff , min_diff_key ) NEW_LINE DEDENT DEDENT def maxDiff ( root , k ) : NEW_LINE INDENT min_diff , min_diff_key = 999999999999 , [ - 1 ] NEW_LINE maxDiffUtil ( root , k , min_diff , min_diff_key ) NEW_LINE return min_diff_key [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 9 ) NEW_LINE root . left = newnode ( 4 ) NEW_LINE root . right = newnode ( 17 ) NEW_LINE root . left . left = newnode ( 3 ) NEW_LINE root . left . right = newnode ( 6 ) NEW_LINE root . left . right . left = newnode ( 5 ) NEW_LINE root . left . right . right = newnode ( 7 ) NEW_LINE root . right . right = newnode ( 22 ) NEW_LINE root . right . right . left = newnode ( 20 ) NEW_LINE k = 18 NEW_LINE print ( maxDiff ( root , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the closest element in Binary Search Tree | Utility that allocates a new node with the given key and NULL left and right pointers . ; Function to find node with minimum absolute difference with given K min_diff -- > minimum difference till now min_diff_key -- > node having minimum absolute difference with K ; If k itself is present ; update min_diff and min_diff_key by checking current node value ; if k is less than ptr -> key then move in left subtree else in right subtree ; Wrapper over maxDiffUtil ( ) ; Initialize minimum difference ; Find value of min_diff_key ( Closest key in tree with k ) ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "7270-7270",
        "Code": "from math import pow NEW_LINE ' NEW_LINE def no_of_characters ( M ) : NEW_LINE INDENT k = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow ( 2 , k + 1 ) - 2 < M ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT ' NEW_LINE def print_string ( M ) : NEW_LINE INDENT k = no_of_characters ( M ) NEW_LINE N = M - ( pow ( 2 , k ) - 2 ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT num = pow ( 2 , k - 1 ) NEW_LINE if ( num >= N ) : NEW_LINE INDENT print ( \" A \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" , end = \" \" ) NEW_LINE N -= num NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 30 ; NEW_LINE print_string ( M ) NEW_LINE M = 55 NEW_LINE print_string ( M ) NEW_LINE M = 100 NEW_LINE print_string ( M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print a number as string of ' A ' and ' B ' in lexicographic order | Python 3 program to implement the above approach ; Function to calculate number of characters in corresponding string of ' A ' and 'B ; Since the minimum number of characters will be 1 ; Calculating number of characters ; Since k length string can represent at most pow ( 2 , k + 1 ) - 2 that is if k = 4 , it can represent at most pow ( 2 , 4 + 1 ) - 2 = 30 so we have to calculate the length of the corresponding string ; return the length of the corresponding string ; Function to print corresponding string of ' A ' and 'B ; Find length of string ; Since the first number that can be represented by k length string will be ( pow ( 2 , k ) - 2 ) + 1 and it will be AAA ... A , k times , therefore , N will store that how much we have to print ; At a particular time , we have to decide whether we have to print ' A ' or ' B ' , this can be check by calculating the value of pow ( 2 , k - 1 ) ; Print new line ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7271-7271",
        "Code": "def updateString ( S , A , B ) : NEW_LINE INDENT l = len ( A ) NEW_LINE i = 0 NEW_LINE while i + l <= len ( S ) : NEW_LINE INDENT curr = S [ i : i + l ] NEW_LINE if curr == A : NEW_LINE INDENT new_string = S [ 0 : i ] + B + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_string = S [ 0 : i ] + A + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return S NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" aab \" NEW_LINE A = \" aa \" NEW_LINE B = \" bb \" NEW_LINE print ( updateString ( S , A , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Replace two substrings ( of a string ) with each other | Function to return the resultant string ; Iterate through all positions i ; Current sub - string of length = len ( A ) = len ( B ) ; If current sub - string gets equal to A or B ; Update S after replacing A ; Update S after replacing B ; Return the updated string ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7274-7274",
        "Code": "def endsWith ( str1 , pat ) : NEW_LINE INDENT patLen = len ( pat ) NEW_LINE str1Len = len ( str1 ) NEW_LINE if ( patLen > str1Len ) : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE str1Len -= 1 NEW_LINE while ( patLen >= 0 ) : NEW_LINE INDENT if ( pat [ patLen ] != str1 [ str1Len ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE str1Len -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countOfstr1ings ( pat , n , sArr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( endsWith ( sArr [ i ] , pat ) == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT pat = \" ks \" NEW_LINE n = 4 NEW_LINE sArr = [ \" geeks \" , \" geeksforgeeks \" , \" games \" , \" unit \" ] NEW_LINE print ( countOfstr1ings ( pat , n , sArr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count strings that end with the given pattern | Function that return true if str1 ends with pat ; Pattern is larger in length than the str1ing ; We match starting from the end while patLen is greater than or equal to 0. ; If at any index str1 doesn 't match  with pattern ; If str1 ends with the given pattern ; Function to return the count of required str1ings ; If current str1ing ends with the given pattern ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7280-7280",
        "Code": "from collections import defaultdict NEW_LINE def getFrequencyMap ( arr , n ) : NEW_LINE INDENT hashMap = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashMap [ arr [ i ] ] += 1 NEW_LINE DEDENT return hashMap NEW_LINE DEDENT def hasDigit ( hashMap , digit ) : NEW_LINE INDENT if hashMap [ digit ] > 0 : NEW_LINE INDENT hashMap [ digit ] -= 1 NEW_LINE return True NEW_LINE DEDENT return False NEW_LINE DEDENT def getMaxtime_value ( arr , n ) : NEW_LINE INDENT hashMap = getFrequencyMap ( arr , n ) NEW_LINE flag = False NEW_LINE time_value = \" \" NEW_LINE for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT if hasDigit ( hashMap , i ) == True : NEW_LINE INDENT flag = True NEW_LINE time_value += str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT flag = False NEW_LINE if ( time_value [ 0 ] == '2' ) : NEW_LINE INDENT for i in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT if hasDigit ( hashMap , i ) == True : NEW_LINE INDENT flag = True NEW_LINE time_value += str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if hasDigit ( hashMap , i ) == True : NEW_LINE INDENT flag = True NEW_LINE time_value += str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not flag : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT time_value += \" : \" NEW_LINE flag = False NEW_LINE for i in range ( 5 , - 1 , - 1 ) : NEW_LINE INDENT if hasDigit ( hashMap , i ) == True : NEW_LINE INDENT flag = True NEW_LINE time_value += str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT flag = False NEW_LINE for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if hasDigit ( hashMap , i ) == True : NEW_LINE INDENT flag = True NEW_LINE time_value += str ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT return time_value NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 0 , 0 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxtime_value ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum possible time that can be formed from four digits | Python3 implementation of the approach ; Function to return the updated frequency map for the array passed as argument ; Function that returns true if the passed digit is present in the map after decrementing it 's frequency by 1 ; If map contains the digit ; Decrement the frequency of the digit by 1 ; True here indicates that the digit was found in the map ; Digit not found ; Function to return the maximum possible time_value in 24 - Hours format ; First digit of hours can be from the range [ 0 , 2 ] ; If no valid digit found ; If first digit of hours was chosen as 2 then the second digit of hours can be from the range [ 0 , 3 ] ; Else it can be from the range [ 0 , 9 ] ; Hours and minutes separator ; First digit of minutes can be from the range [ 0 , 5 ] ; Second digit of minutes can be from the range [ 0 , 9 ] ; Return the maximum possible time_value ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7285-7285",
        "Code": "def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] != ' * ' and B [ i ] != ' * ' : NEW_LINE INDENT if A [ i ] != B [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" gee * sforgeeks \" NEW_LINE B = \" geeksforgeeks \" NEW_LINE print ( int ( doMatch ( A , B ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "String matching with * ( that matches with any ) in any of the two strings | Function to check if the two strings can be matched or not ; if the string don 't have *  then character t that position  must be same. ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7286-7286",
        "Code": "def isVowel ( c ) : NEW_LINE INDENT vowel = \" aeiou \" NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT name = \" alex \" NEW_LINE typed = \" aaalaeex \" NEW_LINE if ( printRLE ( name , typed ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a string is the typed name of the given name | Check if the character is vowel or not ; Returns true if ' typed ' is a typed name given str ; Traverse through all characters of str ; If current characters do not match ; If not vowel , simply move ahead in both ; Count occurrences of current vowel in str ; Count occurrence of current vowel in typed ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7302-7302",
        "Code": "def Substr ( Str , target ) : NEW_LINE INDENT t = 0 NEW_LINE Len = len ( Str ) NEW_LINE i = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( t == len ( target ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( Str [ i ] == target [ t ] ) : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = 0 NEW_LINE DEDENT DEDENT if ( t < len ( target ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( i - t ) NEW_LINE DEDENT DEDENT print ( Substr ( \" GeeksForGeeks \" , \" Fr \" ) ) NEW_LINE print ( Substr ( \" GeeksForGeeks \" , \" For \" ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a string is substring of another | Python program for the above approach ; Iterate from 0 to Len - 1 ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7303-7303",
        "Code": "def censor ( text , word ) : NEW_LINE INDENT word_list = text . split ( ) NEW_LINE result = ' ' NEW_LINE stars = ' * ' * len ( word ) NEW_LINE count = 0 NEW_LINE index = 0 ; NEW_LINE for i in word_list : NEW_LINE INDENT if i == word : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT result = ' ▁ ' . join ( word_list ) NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT extract = \" GeeksforGeeks ▁ is ▁ a ▁ computer ▁ science ▁ portal ▁ for ▁ geeks . \\ STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL I ▁ am ▁ pursuing ▁ my ▁ major ▁ in ▁ computer ▁ science . ▁ \" NEW_LINE cen = \" computer \" NEW_LINE print ( censor ( extract , cen ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to replace a word with asterisks in a sentence | Function takes two parameter ; Break down sentence by ' ▁ ' spaces and store each individual word in a different list ; A new string to store the result ; Creating the censor which is an asterisks \" * \" text of the length of censor word ; count variable to access our word_list ; Iterating through our list of extracted words ; changing the censored word to created asterisks censor ; join the words ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "7304-7304",
        "Code": "def split ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE if ( Len == 1 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE return NEW_LINE DEDENT s1 , s2 = \" \" , \" \" NEW_LINE for i in range ( ( Len // 2 ) + 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE s1 = Str [ 0 : i + 1 ] NEW_LINE num1 = int ( s1 ) NEW_LINE num2 = num1 + 1 NEW_LINE s2 = str ( num2 ) NEW_LINE k = i + 1 NEW_LINE while ( flag == 0 ) : NEW_LINE INDENT l = len ( s2 ) NEW_LINE if ( k + l > Len ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ( Str [ k : k + l ] == s2 ) ) : NEW_LINE INDENT flag = 0 NEW_LINE num2 += 1 NEW_LINE k = k + l NEW_LINE if ( k == Len ) : NEW_LINE INDENT break NEW_LINE DEDENT s2 = str ( num2 ) NEW_LINE l = len ( s2 ) NEW_LINE if ( k + 1 > len ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Possible \" , s1 ) NEW_LINE break NEW_LINE DEDENT elif ( flag == 1 and i > ( Len // 2 ) - 1 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT Str = \"99100\" NEW_LINE split ( Str ) NEW_LINE",
        "Type": "py",
        "NL": "Splitting a Numeric String | Function accepts a string and checks if string can be split . ; if there is only 1 number in the string then it is not possible to split it ; storing the substring from 0 to i + 1 to form initial number of the increasing sequence ; convert string to integer and add 1 and again convert back to string s2 ; if s2 is not a substring of number than not possible ; if s2 is the next substring of the numeric string ; Incearse num2 by 1 i . e the next number to be looked for ; check if string is fully traversed then break ; If next string doesnot occurs in a given numeric string then it is not possible ; if the string was fully traversed and conditions were satisfied ; if conditions failed to hold ; Driver code ; Call the split function for splitting the string",
        "Category": "Substring"
    },
    {
        "ID": "7305-7305",
        "Code": "def internalSearch ( ii , needle , row , col , hay , row_max , col_max ) : NEW_LINE INDENT found = 0 NEW_LINE if ( row >= 0 and row <= row_max and col >= 0 and col <= col_max and needle [ ii ] == hay [ row ] [ col ] ) : NEW_LINE INDENT match = needle [ ii ] NEW_LINE ii += 1 NEW_LINE hay [ row ] [ col ] = 0 NEW_LINE if ( ii == len ( needle ) ) : NEW_LINE INDENT found = 1 NEW_LINE DEDENT else : NEW_LINE INDENT found += internalSearch ( ii , needle , row , col + 1 , hay , row_max , col_max ) NEW_LINE found += internalSearch ( ii , needle , row , col - 1 , hay , row_max , col_max ) NEW_LINE found += internalSearch ( ii , needle , row + 1 , col , hay , row_max , col_max ) NEW_LINE found += internalSearch ( ii , needle , row - 1 , col , hay , row_max , col_max ) NEW_LINE DEDENT hay [ row ] [ col ] = match NEW_LINE DEDENT return found NEW_LINE DEDENT def searchString ( needle , row , col , strr , row_count , col_count ) : NEW_LINE INDENT found = 0 NEW_LINE for r in range ( row_count ) : NEW_LINE INDENT for c in range ( col_count ) : NEW_LINE INDENT found += internalSearch ( 0 , needle , r , c , strr , row_count - 1 , col_count - 1 ) NEW_LINE DEDENT DEDENT return found NEW_LINE DEDENT needle = \" MAGIC \" NEW_LINE inputt = [ \" BBABBM \" , \" CBMBBA \" , \" IBABBG \" , \" GOZBBI \" , \" ABBBBC \" , \" MCIGAM \" ] NEW_LINE strr = [ 0 ] * len ( inputt ) NEW_LINE for i in range ( len ( inputt ) ) : NEW_LINE INDENT strr [ i ] = list ( inputt [ i ] ) NEW_LINE DEDENT print ( \" count : ▁ \" , searchString ( needle , 0 , 0 , strr , len ( strr ) , len ( strr [ 0 ] ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of number of given string in 2D character array | utility function to search complete string from any given index of 2d array ; through Backtrack searching in every directions ; Function to search the string in 2d array ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "7310-7310",
        "Code": "def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 ; counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT str = \"1001ab010abc01001\" NEW_LINE ans = patternCount ( str ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Find all the patterns of \"1(0 + ) 1\" in a given string | SET 1 ( General Approach ) | Function to count patterns ; Variable to store the last character ; We found 0 and last character was '1' , state change ; After the stream of 0 ' s , ▁ we ▁ got ▁ a ▁ ' 1 ',  counter incremented ; Last character stored ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7311-7311",
        "Code": "def preprocess_strong_suffix ( shift , bpos , pat , m ) : NEW_LINE INDENT i = m NEW_LINE j = m + 1 NEW_LINE bpos [ i ] = j NEW_LINE while i > 0 : NEW_LINE INDENT while j <= m and pat [ i - 1 ] != pat [ j - 1 ] : NEW_LINE INDENT if shift [ j ] == 0 : NEW_LINE INDENT shift [ j ] = j - i NEW_LINE DEDENT j = bpos [ j ] NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE bpos [ i ] = j NEW_LINE DEDENT DEDENT def preprocess_case2 ( shift , bpos , pat , m ) : NEW_LINE INDENT j = bpos [ 0 ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT if shift [ i ] == 0 : NEW_LINE INDENT shift [ i ] = j NEW_LINE DEDENT if i == j : NEW_LINE INDENT j = bpos [ j ] NEW_LINE DEDENT DEDENT DEDENT def search ( text , pat ) : NEW_LINE INDENT s = 0 NEW_LINE m = len ( pat ) NEW_LINE n = len ( text ) NEW_LINE bpos = [ 0 ] * ( m + 1 ) NEW_LINE shift = [ 0 ] * ( m + 1 ) NEW_LINE preprocess_strong_suffix ( shift , bpos , pat , m ) NEW_LINE preprocess_case2 ( shift , bpos , pat , m ) NEW_LINE while s <= n - m : NEW_LINE INDENT j = m - 1 NEW_LINE while j >= 0 and pat [ j ] == text [ s + j ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT print ( \" pattern ▁ occurs ▁ at ▁ shift ▁ = ▁ % d \" % s ) NEW_LINE s += shift [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT s += shift [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT text = \" ABAAAABAACD \" NEW_LINE pat = \" ABA \" NEW_LINE search ( text , pat ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Boyer Moore Algorithm | Good Suffix heuristic | preprocessing for strong good suffix rule ; m is the length of pattern ; if character at position i - 1 is not equivalent to character at j - 1 , then continue searching to right of the pattern for border ; the character preceding the occurrence of t in pattern P is different than the mismatching character in P , we stop skipping the occurrences and shift the pattern from i to j ; Update the position of next border ; p [ i - 1 ] matched with p [ j - 1 ] , border is found . store the beginning position of border ; Preprocessing for case 2 ; set the border position of the first character of the pattern to all indices in array shift having shift [ i ] = 0 ; suffix becomes shorter than bpos [ 0 ] , use the position of next widest border as value of j ; Search for a pattern in given text using Boyer Moore algorithm with Good suffix rule ; s is shift of the pattern with respect to text ; initialize all occurrence of shift to 0 ; do preprocessing ; Keep reducing index j of pattern while characters of pattern and text are matching at this shift s ; If the pattern is present at the current shift , then index j will become - 1 after the above loop ; pat [ i ] != pat [ s + j ] so shift the pattern shift [ j + 1 ] times ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7328-7328",
        "Code": "maxi = 0 ; NEW_LINE ans1 = \" \" ; NEW_LINE def calculate ( ans ) : NEW_LINE INDENT global maxi , ans1 ; NEW_LINE dp = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT dp [ ord ( ans [ i ] ) - ord ( ' A ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( dp [ i ] % 2 == 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT DEDENT if ( maxi < len ( ans ) ) : NEW_LINE INDENT maxi = len ( ans ) ; NEW_LINE ans1 = ans ; NEW_LINE DEDENT DEDENT def longestString ( arr , index , string ) : NEW_LINE INDENT if ( index == len ( arr ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT longestString ( arr , index + 1 , string ) ; NEW_LINE string += arr [ index ] ; NEW_LINE calculate ( string ) ; NEW_LINE longestString ( arr , index + 1 , string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ \" ABAB \" , \" ABF \" , \" CDA \" , \" AD \" , \" CCC \" ] ; NEW_LINE longestString ( A , 0 , \" \" ) ; NEW_LINE print ( ans1 , len ( ans1 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum length of string formed by concatenation having even frequency of each character | Python3 implementation of the above approach ; Function to check the string ; Count the frequency of the string ; Check the frequency of the string ; Store the length of the new String ; Function to find the longest concatenated string having every character of even frequency ; Checking the string ; Dont Include the string ; Include the string ; Driver code ; Call the function ; Print the answer",
        "Category": "Backtracking"
    },
    {
        "ID": "7333-7333",
        "Code": "def countSubsequence ( S , N , K ) : NEW_LINE INDENT C = 0 NEW_LINE C1 = 0 NEW_LINE C0 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT C1 += 1 NEW_LINE DEDENT elif ( S [ i ] == '0' ) : NEW_LINE INDENT C0 += 1 NEW_LINE DEDENT DEDENT B1 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT B1 += 1 NEW_LINE DEDENT elif ( S [ i ] == '0' ) : NEW_LINE INDENT C = C + ( C1 - B1 ) NEW_LINE DEDENT DEDENT ans = C * K NEW_LINE ans += ( C1 * C0 * ( ( ( K ) * ( K - 1 ) ) // 2 ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"230013110087\" NEW_LINE K = 2 NEW_LINE N = len ( S ) NEW_LINE print ( countSubsequence ( S , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count subsequences 01 in string generated by concatenation of given numeric string K times | Function to calculate the number of subsequences of \"01\" ; Store count of 0 ' s ▁ and ▁ 1' s ; Count of subsequences without concatenation ; Case 1 ; Case 2 ; Return the total count ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7338-7338",
        "Code": "def TotalPossibleJumps ( N ) : NEW_LINE INDENT if ( ( N - 1 ) == 0 ) : NEW_LINE INDENT newvec = [ ] NEW_LINE newvec . append ( \" \" ) NEW_LINE return newvec NEW_LINE DEDENT else : NEW_LINE INDENT if ( N < 0 ) : NEW_LINE INDENT newvec = [ ] NEW_LINE return newvec NEW_LINE DEDENT DEDENT jump1 = TotalPossibleJumps ( N - 1 ) NEW_LINE jump2 = TotalPossibleJumps ( N - 2 ) NEW_LINE totaljumps = [ ] NEW_LINE for s in jump1 : NEW_LINE INDENT totaljumps . append ( \"1\" + s ) NEW_LINE DEDENT for s in jump2 : NEW_LINE INDENT totaljumps . append ( \"2\" + s ) NEW_LINE DEDENT return totaljumps NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE Ans = TotalPossibleJumps ( N ) NEW_LINE for it in Ans : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Print all ways to reach the Nth stair with the jump of 1 or 2 units at a time | Function to find all the ways to reach Nth stair using one or two jumps ; Base Cases ; Recur for jump1 and jump2 ; Stores the total possible jumps ; Add \"1\" with every element present in jump1 ; Add \"2\" with every element present in jump2 ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "7340-7340",
        "Code": "def findString ( arr , N ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += '1' if arr [ i ] [ i ] == '0' else '0' NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"111\" , \"011\" , \"001\" ] NEW_LINE N = len ( arr ) NEW_LINE print ( findString ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find any permutation of Binary String of given size not present in Array | Function to find a binary string of N bits that does not occur in the givrn array arr [ ] ; Stores the resultant string ; Loop to iterate over all the given strings in a diagonal order ; Append the complement of element at current index into ans ; Return Answer ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7341-7341",
        "Code": "def commonSubstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ans = \" \" NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" True \" ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" abca \" NEW_LINE commonSubstring ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the string has a reversible equal substring at the ends | Function to print longest substring that appears at beginning of string and also at end in reverse order ; Stores the resultant string ; If the characters are same ; Otherwise , break ; If the string can 't be formed ; Otherwise print resultant string ; Driver Code",
        "Category": "Two Pointers"
    },
    {
        "ID": "7343-7343",
        "Code": "def findMinimumSubsequence ( S ) : NEW_LINE INDENT flag = False NEW_LINE dummy = ' ' NEW_LINE for j in range ( len ( S ) ) : NEW_LINE INDENT if ( S [ j ] != '2' and S [ j ] != '3' and S [ j ] != '5' and S [ j ] != '7' ) : NEW_LINE INDENT print ( 1 ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT for j in range ( len ( S ) ) : NEW_LINE INDENT for j1 in range ( j + 1 , len ( S ) , 1 ) : NEW_LINE INDENT dummy = S [ j ] + S [ j1 ] NEW_LINE if ( dummy != \"23\" and dummy != \"37\" and dummy != \"53\" and dummy != \"73\" ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT if ( len ( S ) >= 3 ) : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"237\" NEW_LINE findMinimumSubsequence ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of Smallest Non Prime Subsequence in given numeric String | Function to find the smallest length of resultant subsequence ; Check for a subsequence of size 1 ; Check for a subsequence of size 2 ; If none of the above check is successful then subsequence must be of size 3 ; Never executed ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7346-7346",
        "Code": "def findSubsequence ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = [ '0' for i in range ( n ) ] NEW_LINE for pos in range ( 10 ) : NEW_LINE INDENT lst1 = '0' NEW_LINE flag = 1 NEW_LINE lst2 = chr ( pos + 48 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( lst2 <= str [ i ] ) : NEW_LINE INDENT res [ i ] = '2' NEW_LINE lst2 = str [ i ] NEW_LINE DEDENT elif ( lst1 <= str [ i ] ) : NEW_LINE INDENT res [ i ] = '1' NEW_LINE lst1 = str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( lst1 > chr ( pos + 48 ) ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT S1 = \" \" NEW_LINE S2 = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( res [ i ] == '1' ) : NEW_LINE INDENT S1 += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT S2 += str [ i ] NEW_LINE DEDENT DEDENT print ( S1 , S2 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"040425524644\" NEW_LINE findSubsequence ( S ) NEW_LINE S = \"123456789\" NEW_LINE findSubsequence ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Divide given numeric string into at most two increasing subsequences which form an increasing string upon concatenation | Function to check for valid subsequences ; Stores which element belongs to which subsequence ; Check for each pos if a possible subsequence exist or not ; Last member of 1 subsequence ; Last Member of 2 nd subsequence ; Check if current element can go to 2 nd subsequence ; Check if the current elements belongs to first subsequence ; If the current element does not belong to any subsequence ; Check if last digit of first subsequence is greater than pos ; If a subsequence is found , find the subsequences ; Stores the resulting subsequences ; Print the subsequence ; If no subsequence found , print - 1 ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7348-7348",
        "Code": "def findMissingDigit ( a , b , c ) : NEW_LINE INDENT w = 1 NEW_LINE a_mod_11 = 0 NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT a_mod_11 = ( a_mod_11 + w * ( ord ( a [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE w = w * - 1 NEW_LINE DEDENT b_mod_11 = 0 NEW_LINE w = 1 NEW_LINE for i in range ( len ( b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT b_mod_11 = ( b_mod_11 + w * ( ord ( b [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE w = w * - 1 NEW_LINE DEDENT c_mod_11 = 0 NEW_LINE xSignIsPositive = True NEW_LINE w = 1 NEW_LINE for i in range ( len ( c ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( c [ i ] == ' x ' ) : NEW_LINE INDENT xSignIsPositive = ( w == 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c_mod_11 = ( c_mod_11 + w * ( ord ( c [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE DEDENT w = w * - 1 NEW_LINE DEDENT x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 NEW_LINE if ( not xSignIsPositive ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT return ( x % 11 + 11 ) % 11 NEW_LINE DEDENT A = \"123456789\" NEW_LINE B = \"987654321\" NEW_LINE C = \"12193263111x635269\" NEW_LINE print ( findMissingDigit ( A , B , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the missing digit in given product of large positive integers | Function to find the replaced digit in the product of a * b ; Keeps track of the sign of the current digit ; Stores the value of a % 11 ; Find the value of a mod 11 for large value of a as per the derived formula ; Stores the value of b % 11 ; Find the value of b mod 11 for large value of a as per the derived formula ; Stores the value of c % 11 ; Keeps track of the sign of x ; If the current digit is the missing digit , then keep the track of its sign ; Find the value of x using the derived equation ; Check if x has a negative sign ; Return positive equivaluent of x mod 11 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7350-7350",
        "Code": "def validInsertionstring ( S1 , S2 ) : NEW_LINE INDENT N = len ( S1 ) NEW_LINE M = len ( S2 ) NEW_LINE st = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT st . append ( S1 [ i ] ) NEW_LINE if ( S1 [ i ] == S2 [ M - 1 ] ) : NEW_LINE INDENT idx = M - 1 NEW_LINE while ( idx >= 0 ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE if ( c != S2 [ idx ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( len ( st ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT S1 = \" aabb \" NEW_LINE S2 = \" ab \" NEW_LINE if validInsertionstring ( S1 , S2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if string S1 can be formed using repeated insertions of another string S2 | Function to check a valid insertion ; Store the size of string ; Maintain a stack for characters ; Iterate through the string ; push the current character on top of the stack ; If the current character is the last character of string S2 then pop characters until S2 is not formed ; index of last character of the string S2 ; pop characters till 0 - th index ; Check if stack in non - empty ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "7351-7351",
        "Code": "def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] NEW_LINE r = 2 NEW_LINE n = len ( house ) NEW_LINE print ( number_of_tower ( house , r , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of towers required such that every house is in the range of at least one tower | Function to count the number of tower ; first we sort the house numbers ; for count number of towers ; for iterate all houses ; count number of towers ; find find the middle location ; traverse till middle location ; this is point to middle house where we insert the tower ; now find the last location ; traverse till last house of the range ; return the number of tower ; Driver code ; given elements ; print number of towers",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7357-7357",
        "Code": "' NEW_LINE def maxlength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = 1 NEW_LINE j = i + 1 NEW_LINE while ( j <= n - 1 and s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = \"11101110\" ; NEW_LINE print ( maxlength ( s ) ) NEW_LINE",
        "Type": "py",
        "NL": "Longest Substring containing '1' | Function to find length of longest substring containing '1 ; Count the number of contiguous 1 's ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7362-7362",
        "Code": "def KthCharacter ( s , t , k ) : NEW_LINE INDENT f = 1 NEW_LINE ss = 2 NEW_LINE tmp = \" \" NEW_LINE lenn = len ( tmp ) NEW_LINE while ( lenn < k ) : NEW_LINE INDENT tf = f NEW_LINE ts = ss NEW_LINE while ( tf != 0 ) : NEW_LINE INDENT tf -= 1 NEW_LINE tmp += s NEW_LINE DEDENT while ( ts != 0 ) : NEW_LINE INDENT ts -= 1 NEW_LINE tmp += t NEW_LINE DEDENT f += 2 NEW_LINE ss += 2 NEW_LINE lenn = len ( tmp ) NEW_LINE DEDENT output = tmp [ k - 1 ] NEW_LINE return output NEW_LINE DEDENT S1 = \" a \" NEW_LINE S2 = \" bc \" NEW_LINE k = 4 NEW_LINE ans = KthCharacter ( S1 , S2 , k ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Find character at Kth index by appending S1 ( M ) times and S2 ( M + 1 ) times | Python program to solve the above approach ; initializing first and second variable as to store how many string ' s ' and string ' t ' will be appended ; storing tmp length ; if length of string tmp is greater than k , then we have reached our destination string now we can return character at index k ; appending s to tmp , f times ; appending t to tmp , s times ; extracting output character ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7368-7368",
        "Code": "def findIfPossible ( N , str_ ) : NEW_LINE INDENT countG = 0 NEW_LINE countF = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if str_ [ i ] == ' G ' : NEW_LINE INDENT countG += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countF += 1 NEW_LINE DEDENT DEDENT if 2 * countF != countG : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT id = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if str_ [ i ] == ' G ' : NEW_LINE INDENT countG -= 1 NEW_LINE id += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countF -= 1 NEW_LINE id -= 1 NEW_LINE DEDENT if id < 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if countG < countF : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT n = 6 NEW_LINE str_ = \" GFGFGG \" NEW_LINE findIfPossible ( n , str_ ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a string can be made empty by repeatedly removing given subsequence | Function to check if a string can be made empty by removing all subsequences of the form \" GFG \" or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7370-7370",
        "Code": "def isPossible ( str1 , str2 ) : NEW_LINE INDENT arr = { } NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE possible = True NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT arr [ str1 [ i ] ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if str2 [ i ] != ' ▁ ' : NEW_LINE INDENT if arr [ str2 [ i ] ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if possible : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT str1 = \" we ▁ all ▁ love ▁ geeksforgeeks \" NEW_LINE str2 = \" we ▁ all ▁ love ▁ geeks \" NEW_LINE isPossible ( str1 , str2 ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether second string can be formed from characters of first string used any number of times | Function to check if str2 can be made by characters of str1 or not ; To store the occurrence of every character ; Length of the two strings ; Assume that it is possible to compose the string str2 from str1 ; Iterate over str1 ; Store the presence or every element ; Iterate over str2 ; Ignore the spaces ; Check for the presence of character in str1 ; If it is possible to make str2 from str1 ; Given strings ; Function call .",
        "Category": "Hash Table"
    },
    {
        "ID": "7371-7371",
        "Code": "def countCamelCase ( S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if ( ord ( S [ i ] ) >= 65 and ord ( S [ i ] ) <= 91 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" ckjkUUYII \" NEW_LINE countCamelCase ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of camel case characters present in a given string | Function to count all the camelcase characters in the string S ; Stores the total count of camelcase characters ; Traverse the string S ; If ASCII value of character lies over the range [ 65 , 91 ] then increment the count ; Print the total count obtained ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7373-7373",
        "Code": "def findRepetition ( a ) : NEW_LINE INDENT if a <= ' z ' and a >= ' a ' : NEW_LINE INDENT return ord ( a ) - 97 NEW_LINE DEDENT elif a <= ' Z ' and a >= ' A ' : NEW_LINE INDENT return ord ( a ) - 65 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def decodeString ( str_ ) : NEW_LINE INDENT output = \" \" NEW_LINE i = 0 NEW_LINE while ( i < len ( str_ ) ) : NEW_LINE INDENT output += str_ [ i ] NEW_LINE i += findRepetition ( str_ [ i ] ) + 1 NEW_LINE DEDENT print ( \" Decrypted ▁ code ▁ is ▁ { \" + output + \" } \" ) NEW_LINE DEDENT str_ = \" abbbb ▁ acccdddd \" NEW_LINE decodeString ( str_ ) NEW_LINE",
        "Type": "py",
        "NL": "Decode a given string by removing duplicate occurrences | Function to count the appearances of each character ; If the character is lower case ; If the character is uppercase ; If the character is a punctuation mark ; Function to decode the given encoded string ; Iterate the given string str ; Find the index of the next character to be printed ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7374-7374",
        "Code": "def printString ( S , N ) : NEW_LINE INDENT plaintext = [ None ] * 5 NEW_LINE freq = [ 0 ] * 26 NEW_LINE freqSorted = [ None ] * 26 NEW_LINE used = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] != ' ▁ ' : NEW_LINE INDENT freq [ ord ( S [ i ] ) - 65 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT freqSorted [ i ] = freq [ i ] NEW_LINE DEDENT T = \" ETAOINSHRDLCUMWFGYPBVKJXQZ \" NEW_LINE freqSorted . sort ( reverse = True ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ch = - 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if freqSorted [ i ] == freq [ j ] and used [ j ] == 0 : NEW_LINE INDENT used [ j ] = 1 NEW_LINE ch = j NEW_LINE break NEW_LINE DEDENT DEDENT if ch == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT x = ord ( T [ i ] ) - 65 NEW_LINE x = x - ch NEW_LINE curr = \" \" NEW_LINE for k in range ( N ) : NEW_LINE INDENT if S [ k ] == ' ▁ ' : NEW_LINE INDENT curr += \" ▁ \" NEW_LINE continue NEW_LINE DEDENT y = ord ( S [ k ] ) - 65 NEW_LINE y += x NEW_LINE if y < 0 : NEW_LINE INDENT y += 26 NEW_LINE DEDENT if y > 25 : NEW_LINE INDENT y -= 26 NEW_LINE DEDENT curr += chr ( y + 65 ) NEW_LINE DEDENT plaintext [ i ] = curr NEW_LINE DEDENT for i in range ( 5 ) : NEW_LINE INDENT print ( plaintext [ i ] ) NEW_LINE DEDENT DEDENT S = \" B ▁ TJNQMF ▁ NFTTBHF \" NEW_LINE N = len ( S ) NEW_LINE printString ( S , N ) NEW_LINE",
        "Type": "py",
        "NL": "Program to perform a letter frequency attack on a monoalphabetic substitution cipher | Function to decrypt a monoalphabetic substitution cipher using the letter frequency attack ; Stores final 5 possible deciphered plaintext ; Store the frequency of each letter in cipher text ; Stores the frequency of each letter in cipher text in descending order ; Store which alphabet is used already ; Traverse the string S ; Copy the frequency array ; Stores the string formed from concatanating the english letters in the decreasing frequency in the english language ; Sort the array in descending order ; Itearate over the range [ 0 , 5 ] ; Iterate over the range [ 0 , 26 ] ; Store the numerical equivalent of letter at ith index of array letter_frequency ; Calculate the probable shift used in monoalphabetic cipher ; Temporary string to generate one plaintext at a time ; Generate the probable ith plaintext string using the shift calculated above ; Insert whitespaces as it is ; Shift the kth letter of the cipher by x ; Add the kth calculated / shifted letter to temporary string ; Print the generated 5 possible plaintexts ; Given string ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "7376-7376",
        "Code": "def generateLetters ( S , P , M ) : NEW_LINE INDENT if ( P == len ( S ) ) : NEW_LINE INDENT print ( S ) ; NEW_LINE return NEW_LINE DEDENT generateLetters ( S , P + 1 , M ) ; NEW_LINE S = S . replace ( S [ P ] , M [ S [ P ] ] ) NEW_LINE generateLetters ( S , P + 1 , M ) ; NEW_LINE DEDENT S = \" aBc \" ; NEW_LINE M = { } ; NEW_LINE M [ ' a ' ] = ' $ ' NEW_LINE M [ ' B ' ] = ' # ' NEW_LINE M [ ' c ' ] = ' ^ ' NEW_LINE M [ ' d ' ] = ' & ' NEW_LINE M [ '1' ] = ' * ' NEW_LINE M [ '2' ] = ' ! ' NEW_LINE M [ ' E ' ] = ' @ ' NEW_LINE generateLetters ( S , 0 , M ) ; NEW_LINE",
        "Type": "py",
        "NL": "Generate all possible strings formed by replacing letters with given respective symbols | Function to generate all possible string by replacing the characters with mapped symbols ; Base Case ; Function call with the P - th character not replaced ; Replace the P - th character ; Function call with the P - th character replaced ; Driver Code ; Function Call",
        "Category": "Backtracking"
    },
    {
        "ID": "7383-7383",
        "Code": "import sys NEW_LINE ansSwaps = 0 NEW_LINE def check ( S ) : NEW_LINE INDENT for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( S [ i - 1 ] == S [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minimumSwaps ( S , swaps , idx ) : NEW_LINE INDENT global ansSwaps NEW_LINE if ( check ( S ) ) : NEW_LINE INDENT ansSwaps = 1 + min ( ansSwaps , swaps ) NEW_LINE DEDENT for i in range ( idx , len ( S ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( S ) ) : NEW_LINE INDENT swap ( S , i , j ) NEW_LINE minimumSwaps ( S , swaps + 1 , i + 1 ) NEW_LINE S = swap ( S , i , j ) NEW_LINE DEDENT DEDENT DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE return arr NEW_LINE DEDENT def findMinimumSwaps ( S ) : NEW_LINE INDENT global ansSwaps NEW_LINE ansSwaps = sys . maxsize NEW_LINE minimumSwaps ( S , 0 , 0 ) NEW_LINE if ( ansSwaps == sys . maxsize ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ansSwaps ) NEW_LINE DEDENT DEDENT S = \" ABAACD \" NEW_LINE findMinimumSwaps ( S . split ( ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize swaps of pairs of characters required such that no two adjacent characters in the string are same | Python3 program for the above approach ; Function to check if S contains any pair of adjacent characters that are same ; Traverse the String S ; If current pair of adjacent characters are the same ; Return true ; Utility function to find the minimum number of swaps of pair of characters required to make all pairs of adjacent characters different ; Check if the required String is formed already ; Traverse the String S ; Swap the characters at i and j position ; Swap for Backtracking Step ; Function to find the minimum number of swaps of pair of characters required to make all pairs of adjacent characters different ; Stores the resultant minimum number of swaps required ; Function call to find the minimum swaps required ; Prvar the result ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "7387-7387",
        "Code": "def isSumEqual ( A , B , C ) : NEW_LINE INDENT L = len ( A ) NEW_LINE M = len ( B ) NEW_LINE N = len ( A ) NEW_LINE A = A [ : : - 1 ] NEW_LINE B = B [ : : - 1 ] NEW_LINE C = C [ : : - 1 ] NEW_LINE rem = 0 NEW_LINE for i in range ( max ( L , max ( M , N ) ) ) : NEW_LINE INDENT curr = rem NEW_LINE if ( i < L ) : NEW_LINE INDENT curr += ord ( A [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT if ( i < M ) : NEW_LINE INDENT curr += ord ( B [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT rem = curr // 10 NEW_LINE curr %= 10 NEW_LINE if ( i < N and curr != ord ( C [ i ] ) - ord ( ' a ' ) ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT if ( rem ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" acb \" NEW_LINE B = \" cba \" NEW_LINE C = \" cdb \" NEW_LINE print ( isSumEqual ( A , B , C ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if summation of two words is equal to target word | Function to check weather summation of two words equal to target word ; Store the length of each string ; Reverse the strings A , B and C ; Stores the remainder ; Iterate in the range [ 0 , max ( L , max ( M , N ) ) ] ; Stores the integer at ith position from the right in the sum of A and B ; If i is less than L ; If i is less than M ; Update rem and curr ; If i is less than N and curr is not equal to C [ i ] - ' a ' , return \" No \" ; If rem is greater than 0 , return \" No \" ; Otherwise , return \" Yes \" ; Driver Code ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7392-7392",
        "Code": "def minimumHammingDistance ( S , K ) : NEW_LINE INDENT n = len ( S ) NEW_LINE pref = [ 0 ] * n NEW_LINE pref [ 0 ] = ord ( S [ 0 ] ) - ord ( '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ( ord ( S [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT cnt = pref [ n - 1 ] NEW_LINE ans = cnt NEW_LINE for i in range ( n - K ) : NEW_LINE INDENT value = pref [ i + K - 1 ] - ( pref [ i - 1 ] if ( i - 1 ) >= 0 else 0 ) NEW_LINE ans = min ( ans , cnt - value + ( K - value ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"101\" NEW_LINE K = 2 NEW_LINE print ( minimumHammingDistance ( s , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize hamming distance in Binary String by setting only one K size substring bits | Function to find minimum Hamming Distance after atmost one operation ; Store the size of the string ; Store the prefix sum of 1 s ; Create Prefix Sum array ; Initialize cnt as number of ones in string S ; Store the required result ; Traverse the string , S ; Store the number of 1 s in the substring S [ i , i + K - 1 ] ; Update the answer ; Return the result ; Driver Code ; Given Input ; Function Call",
        "Category": "Sliding Window"
    },
    {
        "ID": "7393-7393",
        "Code": "from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkPermutation ( s1 , s2 ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for ch in s1 : NEW_LINE INDENT if ord ( ch ) - 97 in freq : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] = 1 NEW_LINE DEDENT DEDENT for ch in s2 : NEW_LINE INDENT if ord ( ch ) - 97 in freq : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ord ( ch ) - 97 ] = 1 NEW_LINE DEDENT DEDENT isAllChangesPrime = True NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( isPrime ( abs ( freq [ i ] ) ) == False ) : NEW_LINE INDENT isAllChangesPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isAllChangesPrime == False ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 = \" gekforgk \" NEW_LINE S2 = \" geeksforgeeks \" NEW_LINE checkPermutation ( S1 , S2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a permutation of S2 can be obtained by adding or removing characters from S1 | Python 3 program for the above approach ; Function to check if the given number is prime or not ; If the number is less than 2 ; If the number is 2 ; If N is a multiple of 2 ; Otherwise , check for the odds values ; Function to check if S1 can be a permutation of S2 by adding or removing characters from S1 ; Initialize a frequency array ; Decrement the frequency for occurrence in s1 ; Increment the frequency for occurence in s2 ; If frequency of current char is same in s1 and s2 ; Check the frequency for the current char is not prime ; Print the result ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "7394-7394",
        "Code": "def countWays ( S , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for mask in range ( ( 1 << N ) ) : NEW_LINE INDENT X , Y = \" \" , \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( mask >> i & 1 ) : NEW_LINE INDENT X += S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT Y += S [ i ] NEW_LINE DEDENT DEDENT Y = Y [ : : - 1 ] NEW_LINE if ( X == Y ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" mippiisssisssiipsspiim \" NEW_LINE N = len ( S ) NEW_LINE print ( countWays ( S , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count ways to split a string into two subsets that are reverse of each other | Function to find the total number of ways to partitiaon the string into two subset satisfying the conditions ; Stores the resultant number of ways of splitting ; Iterate over the range [ 0 , 2 ^ N ] ; Traverse the string S ; If ith bit is set , then append the character S [ i ] to X ; Otherwise , append the character S [ i ] to Y ; Reverse the second string ; If X is equal to Y ; Return the total number of ways ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "7400-7400",
        "Code": "def minimumTimeToConvertString ( S , N ) : NEW_LINE INDENT S = [ i for i in S ] NEW_LINE upper = 0 NEW_LINE lower = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT c = S [ i ] NEW_LINE if ( c . isupper ( ) ) : NEW_LINE INDENT upper += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lower += 1 NEW_LINE DEDENT DEDENT moves = 0 NEW_LINE if ( upper > N // 2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( upper > N // 2 and i < N ) : NEW_LINE INDENT if ( S [ i ] . isupper ( ) ) : NEW_LINE INDENT S [ i ] += 32 NEW_LINE moves += 1 NEW_LINE upper -= 1 NEW_LINE lower += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT elif ( lower > N // 2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( lower > N // 2 and i < N ) : NEW_LINE INDENT if ( S [ i ] . islower ( ) ) : NEW_LINE INDENT S [ i ] = chr ( ord ( S [ i ] ) - 32 ) NEW_LINE moves += 1 NEW_LINE upper += 1 NEW_LINE lower -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT print ( moves ) NEW_LINE print ( \" \" . join ( S ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" AbcdEf \" NEW_LINE N = len ( S ) NEW_LINE minimumTimeToConvertString ( S , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum moves to make count of lowercase and uppercase letters equal | Function to calculate minimum number of moves required to convert the string ; Stores Count of upper and lower case characters ; Traverse the S ; If current character is uppercase ; Increment count of Uppercase characters ; Otherwise , ; Increment count of Lowercase characters ; Stores minimum number of moves needed ; If there are more upper case characters ; Iterate until upper is greater than N / 2 ; Convert uppercase into lowercase until upper = N / 2 ; Increment the pointer ; If there are more lower case characters ; Iterate until lower is greater than N / 2 ; Convert lowercase into uppercase until lower = N / 2 ; Increment the pointer ; Print moves required ; Print resultant string ; Driver Code ; Given string ; Function call",
        "Category": "Math"
    },
    {
        "ID": "7406-7406",
        "Code": "def changeCharacters ( S , N , K ) : NEW_LINE INDENT flag = 1 NEW_LINE count = 0 NEW_LINE st = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if len ( st ) == 0 : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT count = 0 NEW_LINE st . append ( S [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == K ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE count = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"100100\" NEW_LINE N = len ( S ) NEW_LINE K = 2 NEW_LINE changeCharacters ( S , N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert given Binary string S to all 1 s by changing all 0 s to 1 s in range [ i + 1 , i + K ] if S [ i ] is 1 | Function to check whether all 0 s in the string can be changed into 1 s ; Store the count of 0 s converted for the last occurrence of 1 ; Declere a stack ; Traverse the string , S ; If stack is empty ; There is no 1 that can change this 0 to 1 ; Push 1 into the stack ; The last 1 has reached its limit ; New 1 has been found which can now change at most K 0 s ; If flag is 1 , pr \" YES \" else pr \" NO \" ; Driver code ; Given Input ; Function call",
        "Category": "Stack"
    },
    {
        "ID": "7410-7410",
        "Code": "def prefixDivisble ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % i != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 52248 NEW_LINE if ( prefixDivisble ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if all prefixes of a number is divisible by remaining count of digits | Function to check if all prefixes of a number is divisible by remaining count of digits or not ; Traverse and check divisibility for each updated number ; Update the original number ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7416-7416",
        "Code": "def zigzag ( s , rows ) : NEW_LINE INDENT interval = 2 * rows - 2 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT step = interval - 2 * i NEW_LINE for j in range ( i , len ( s ) , interval ) : NEW_LINE INDENT print ( s [ j ] , end = \" \" ) NEW_LINE if ( step > 0 and step < interval and step + j < len ( s ) ) : NEW_LINE INDENT for k in range ( ( interval - rows - i ) ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT print ( s [ j + step ] , end = \" \" ) NEW_LINE for k in range ( i - 1 ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for k in range ( interval - rows ) : NEW_LINE INDENT print ( end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"123456789ABCDEFGHIJKL \" \" MNOPQRSTUVWXYZabcdefghi \" rows = 9 NEW_LINE zigzag ( s , rows ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to print a string in vertical zigzag manner | Function to print any string in zigzag fashion ; Store the gap between the major columns ; Traverse through rows ; Store the step value for each row ; Iterate in the range [ 1 , N - 1 ] ; Print the character ; Print the spaces before character s [ j + step ] ; Print the character ; Print the spaces after character after s [ j + step ] ; Print the spaces for first and last rows ; Driver Code ; Given Input ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "7420-7420",
        "Code": "def isPrime ( num ) : NEW_LINE INDENT flag = False NEW_LINE if num > 1 : NEW_LINE INDENT for i in range ( 2 , num ) : NEW_LINE INDENT if ( num % i ) == 0 : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def order ( x ) : NEW_LINE INDENT n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT n = n + 1 NEW_LINE x = x // 10 NEW_LINE DEDENT return n NEW_LINE DEDENT def isArmstrong ( x ) : NEW_LINE INDENT n = order ( x ) NEW_LINE temp = x NEW_LINE sum1 = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT r = temp % 10 NEW_LINE sum1 = sum1 + r ** n NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sum1 == x ) NEW_LINE DEDENT def count_armstrong ( li ) : NEW_LINE INDENT c = 0 NEW_LINE for ele in li : NEW_LINE INDENT val = 0 NEW_LINE for che in ele : NEW_LINE INDENT val += ord ( che ) NEW_LINE DEDENT if isArmstrong ( val ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def count_prime ( li ) : NEW_LINE INDENT c = 0 NEW_LINE for ele in li : NEW_LINE INDENT val = 0 NEW_LINE for che in ele : NEW_LINE INDENT val += ord ( che ) NEW_LINE DEDENT if isPrime ( val ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT arr = [ \" geeksforgeeks \" , \" a \" , \" computer \" , \" science \" , \" portal \" , \" for \" , \" geeks \" ] NEW_LINE print ( \" Number ▁ of ▁ Armstrong ▁ Strings ▁ are : \" , count_armstrong ( arr ) ) NEW_LINE print ( \" Number ▁ of ▁ Prime ▁ Strings ▁ are : \" , count_prime ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count strings having sum of ASCII values of characters equal to a Prime or Armstrong Number | Function to check if a number is prime number ; Define a flag variable ; Check for factors of num ; If factor is found , set flag to True and break out of loop ; Check if flag is True ; Function to calculate order of the number x ; Function to check whether the given number is Armstrong number or not ; If the condition satisfies ; Function to count Armstrong valued strings ; Stores the count of Armstrong valued strings ; Iterate over the list ; Store the value of the string ; Find value of the string ; Check if it an Armstrong number ; Function to count prime valued strings ; Store the count of prime valued strings ; Iterate over the list ; Store the value of the string ; Find value of the string ; Check if it is a Prime Number ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7425-7425",
        "Code": "import sys NEW_LINE from collections import defaultdict NEW_LINE def findMinimumTime ( S , N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT maxfreq = - sys . maxsize NEW_LINE um = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT um [ S [ i ] ] += 1 NEW_LINE if ( um [ S [ i ] ] > maxfreq ) : NEW_LINE INDENT maxfreq = um [ S [ i ] ] NEW_LINE maxchar = S [ i ] NEW_LINE DEDENT DEDENT emptySlots = ( maxfreq - 1 ) * K NEW_LINE for it in um : NEW_LINE INDENT if ( it == maxchar ) : NEW_LINE INDENT continue NEW_LINE DEDENT emptySlots -= min ( um [ it ] , maxfreq - 1 ) NEW_LINE DEDENT ans = N + max ( 0 , emptySlots ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" AAABBB \" NEW_LINE K = 2 NEW_LINE N = len ( S ) NEW_LINE findMinimumTime ( S , N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum time required to complete all tasks with alteration of their order allowed | Python3 program for the above approach ; Function to find the minimum time required to complete the tasks if the order of tasks can be changed ; If there is no task , print 0 ; Store the maximum occurring character and its frequency ; Stores the frequency of each character ; Traverse the string S ; Increment the frequency of the current character ; Update maxfreq and maxchar ; Store the number of empty slots ; Traverse the hashmap , um ; Fill the empty slots ; Store the required result ; Print the result ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7430-7430",
        "Code": "def minLength ( S ) : NEW_LINE INDENT st = [ ] NEW_LINE for ch in S : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT top = st [ - 1 ] NEW_LINE if ( abs ( ord ( ch ) - ord ( top ) ) == 1 ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( ch ) NEW_LINE DEDENT DEDENT DEDENT return len ( st ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"12213\" NEW_LINE print ( minLength ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize length of a string by removing pairs of consecutive increasing or decreasing digits | Function to find the minimum length of the string possible after removing pairs of consecutive digits ; Initialize the stack st ; Traverse the string S ; If the stack is empty ; Otherwise ; Get the top character of the stack ; If cha and top are consecutive digits ; Otherwise , push the character ch ; Print the size of the stack ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "7434-7434",
        "Code": "def printSentence ( str1 ) : NEW_LINE INDENT nums = [ \" \" , \" \" , \" ABC \" , \" DEF \" , \" GHI \" , \" JKL \" , \" MNO \" , \" PQRS \" , \" TUV \" , \" WXYZ \" ] NEW_LINE i = 0 NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == ' . ' ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i + 1 < len ( str1 ) and str1 [ i + 1 ] and str1 [ i ] == str1 [ i + 1 ] ) : NEW_LINE INDENT if ( count == 2 and ( ( str1 [ i ] >= '2' and str1 [ i ] <= '6' ) or ( str1 [ i ] == '8' ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( count == 3 and ( str1 [ i ] == '7' or str1 [ i ] == '9' ) ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE i += 1 NEW_LINE if ( i < len ( str ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( str1 [ i ] == '7' or str1 [ i ] == '9' ) : NEW_LINE INDENT print ( nums [ ord ( str1 [ i ] ) - 48 ] [ count % 4 ] , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( nums [ ord ( str1 [ i ] ) - 48 ] [ count % 3 ] , end = \" \" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \"234\" NEW_LINE printSentence ( str1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert a Mobile Numeric Keypad sequence to equivalent sentence | Function to convert mobile numeric keypad sequence into its equivalent string ; Store the mobile keypad mappings ; Traverse the str1ing str1 ; If the current character is ' . ' , then continue to the next iteration ; Stores the number of continuous clicks ; Iterate a loop to find the count of same characters ; 2 , 3 , 4 , 5 , 6 and 8 keys will have maximum of 3 letters ; 7 and 9 keys will have maximum of 4 keys ; Handle the end condition ; Check if the current pressed key is 7 or 9 ; Else , the key pressed is either 2 , 3 , 4 , 5 , 6 or 8 ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "7436-7436",
        "Code": "def getString ( N ) : NEW_LINE INDENT ans = \" \" NEW_LINE while ( N >= 26 ) : NEW_LINE INDENT ans += ' z ' NEW_LINE N -= 26 NEW_LINE DEDENT ans += chr ( N + ord ( ' a ' ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 30 NEW_LINE print ( getString ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically largest string with sum of characters equal to N | Function to construct the lexicographically largest string having sum of characters as N ; Stores the resulting string ; Iterate until N is at least 26 ; Append ' z ' to the string ans ; Decrement N by 26 ; Append character at index ( N + ' a ' ) ; Return the resultant string ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7440-7440",
        "Code": "def subString ( s , n ) : NEW_LINE INDENT hash = { 0 : 1 } NEW_LINE pre = 0 NEW_LINE count = 0 NEW_LINE for i in s : NEW_LINE INDENT pre ^= ( 1 << ord ( i ) - 97 ) NEW_LINE count += hash . get ( pre , 0 ) NEW_LINE hash [ pre ] = hash . get ( pre , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT S = \" abbaa \" NEW_LINE N = len ( S ) NEW_LINE print ( subString ( S , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of substrings with each character occurring even times | Function to count substrings having even frequency of each character ; Stores the count of a character ; Stores bitmask ; Stores the count of substrings with even count of each character ; Traverse the string S ; Flip the ord ( i ) - 97 bits in pre ; Increment the count by hash [ pre ] ; Increment count of pre in hash ; Return the total count obtained ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7442-7442",
        "Code": "from collections import defaultdict NEW_LINE def atleastkDistinctChars ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = defaultdict ( int ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE ans = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT c = s [ end ] NEW_LINE mp += 1 NEW_LINE end += 1 NEW_LINE while ( len ( mp ) >= k ) : NEW_LINE INDENT pre = s [ begin ] NEW_LINE mp [ pre ] -= 1 NEW_LINE if ( mp [ pre ] == 0 ) : NEW_LINE INDENT del mp [ pre ] NEW_LINE DEDENT ans += len ( s ) - end + 1 NEW_LINE begin += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" abcca \" NEW_LINE K = 3 NEW_LINE atleastkDistinctChars ( S , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count number of substrings having at least K distinct characters | Python 3 program for the above approach ; Function to count number of substrings having atleast k distinct characters ; Stores the size of the string ; Initialize a HashMap ; Stores the start and end indices of sliding window ; Stores the required result ; Iterate while the end pointer is less than n ; Include the character at the end of the window ; Increment end pointer by 1 ; Iterate until count of distinct characters becomes less than K ; Remove the character from the beginning of window ; If its frequency is 0 , remove it from the map ; Update the answer ; Print the result ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "7445-7445",
        "Code": "def minimumMoves ( s , n , k ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT countOpen = s . count ( ' ( ' ) NEW_LINE countClose = s . count ( ' ) ' ) NEW_LINE if ( countOpen != countClose ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT ans = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt -= 1 NEW_LINE if ( cnt < 0 ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT if ( ans <= k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : S = \" ) ( \" NEW_LINE INDENT K = 1 NEW_LINE minimumMoves ( S , len ( S ) , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to obtain a Balanced Parenthesis by shifting brackets to either end at most K times | Function to check if a valid parenthesis can be obtained by moving characters to either end at most K number of times ; Base Case 1 ; Count of ' ( ' and ') ; Base Case 2 ; Store the count of moves required to make a valid parenthesis ; Traverse the string ; Increment cnt if opening bracket has occurred ; Otherwise , decrement cnt by 1 ; Decrement cnt by 1 ; If cnt is negative ; Update the cnt ; Increment the ans ; If ans is at most K , then print Yes . Otherwise print No ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7448-7448",
        "Code": "import random NEW_LINE def findRandom ( ) : NEW_LINE INDENT num = random . randint ( 0 , 1 ) NEW_LINE return num NEW_LINE DEDENT def generateBinaryString ( N ) : NEW_LINE INDENT S = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = findRandom ( ) NEW_LINE S += str ( x ) NEW_LINE DEDENT print ( S ) NEW_LINE DEDENT N = 7 NEW_LINE generateBinaryString ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Generate a random Binary String of length N | Python3 program for the above approach ; Function to find a random number between 0 or 1 ; Generate the random number ; Return the generated number ; Function to generate a random binary string of length N ; Stores the empty string ; Iterate over the range [ 0 , N - 1 ] ; Store the random number ; Append it to the string ; Print the resulting string ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "745-745",
        "Code": "def createThreaded ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return None NEW_LINE DEDENT if root . left == None and root . right == None : NEW_LINE INDENT return root NEW_LINE DEDENT if root . left != None : NEW_LINE INDENT l = createThreaded ( root . left ) NEW_LINE l . right = root NEW_LINE l . isThreaded = True NEW_LINE DEDENT if root . right == None : NEW_LINE INDENT return root NEW_LINE DEDENT return createThreaded ( root . right ) NEW_LINE DEDENT def leftMost ( root ) : NEW_LINE INDENT while root != None and root . left != None : NEW_LINE INDENT root = root . left NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT cur = leftMost ( root ) NEW_LINE while cur != None : NEW_LINE INDENT print ( cur . key , end = \" ▁ \" ) NEW_LINE if cur . isThreaded : NEW_LINE INDENT cur = cur . right NEW_LINE DEDENT else : NEW_LINE INDENT cur = leftMost ( cur . right ) NEW_LINE DEDENT DEDENT DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . left = self . right = None NEW_LINE self . key = key NEW_LINE self . isThreaded = None NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE createThreaded ( root ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ created \" , \" threaded ▁ tree ▁ is \" ) NEW_LINE inOrder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert a Binary Tree to Threaded binary tree | Set 2 ( Efficient ) | Converts tree with given root to threaded binary tree . This function returns rightmost child of root . ; Base cases : Tree is empty or has single node ; Find predecessor if it exists ; Find predecessor of root ( Rightmost child in left subtree ) ; Link a thread from predecessor to root . ; If current node is rightmost child ; Recur for right subtree . ; A utility function to find leftmost node in a binary tree rooted with ' root ' . This function is used in inOrder ( ) ; Function to do inorder traversal of a threaded binary tree ; Find the leftmost node in Binary Tree ; If this Node is a thread Node , then go to inorder successor ; Else go to the leftmost child in right subtree ; A utility function to create a new node ; Driver Code ; 1 / \\ 2 3 / \\ / \\ 4 5 6 7",
        "Category": "Binary Tree"
    },
    {
        "ID": "7450-7450",
        "Code": "from math import log2 NEW_LINE def countFrequency ( S , N ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ ord ( S [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT lg = int ( log2 ( freq [ i ] ) ) NEW_LINE a = pow ( 2 , lg ) NEW_LINE if ( a == freq [ i ] ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = \" \" ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aaacbb \" NEW_LINE N = len ( S ) NEW_LINE countFrequency ( S , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify string by sorting characters after removal of characters whose frequency is not equal to power of 2 | Python3 program for the above approach ; Function to remove all the characters from a that whose frequencies are not equal to a perfect power of 2 ; Stores the frequency of each character in S ; Iterate over characters of string ; Update frequency of current character in the array freq [ ] ; Traverse the array freq [ ] ; Check if the i - th letter is absent from S ; Calculate log of frequency of the current character in the S ; Calculate power of 2 of lg ; Check if freq [ i ] is a power of 2 ; Print letter i + ' a ' freq [ i ] times ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7451-7451",
        "Code": "class treeNode : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . square_sum = x NEW_LINE DEDENT DEDENT def buildTree ( s , tree , start , end , treeNode ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT tree [ treeNode ] . square_sum = pow ( ord ( s [ start ] ) - ord ( ' a ' ) + 1 , 2 ) NEW_LINE return NEW_LINE DEDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE buildTree ( s , tree , start , mid , 2 * treeNode ) NEW_LINE buildTree ( s , tree , mid + 1 , end , 1 + 2 * treeNode ) NEW_LINE tree [ treeNode ] . square_sum = ( tree [ ( 2 * treeNode ) ] . square_sum + tree [ ( 2 * treeNode ) + 1 ] . square_sum ) NEW_LINE DEDENT def querySquareSum ( tree , start , end , treeNode , l , r ) : NEW_LINE INDENT if ( ( l > end ) or ( r < start ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( l <= start ) and ( r >= end ) ) : NEW_LINE INDENT return tree [ treeNode ] . square_sum NEW_LINE DEDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE X = querySquareSum ( tree , start , mid , 2 * treeNode , l , r ) NEW_LINE Y = + querySquareSum ( tree , mid + 1 , end , 1 + 2 * treeNode , l , r ) NEW_LINE return X + Y NEW_LINE DEDENT def updateTree ( s , tree , start , end , treeNode , idx , X ) : NEW_LINE INDENT if ( ( start == end ) and ( idx == start ) ) : NEW_LINE INDENT s [ idx ] = X NEW_LINE tree [ treeNode ] . square_sum = pow ( ord ( X ) - ord ( ' a ' ) + 1 , 2 ) NEW_LINE return NEW_LINE DEDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE if ( idx <= mid ) : NEW_LINE INDENT updateTree ( s , tree , start , mid , ( 2 * treeNode ) , idx , X ) NEW_LINE DEDENT else : NEW_LINE INDENT updateTree ( s , tree , mid + 1 , end , ( 2 * treeNode ) + 1 , idx , X ) NEW_LINE DEDENT tree [ treeNode ] . square_sum = ( tree [ ( 2 * treeNode ) ] . square_sum + tree [ ( 2 * treeNode ) + 1 ] . square_sum ) NEW_LINE DEDENT def PerformQuery ( S , Q ) : NEW_LINE INDENT n = len ( S ) NEW_LINE tree = [ treeNode ( 0 ) for i in range ( ( 4 * n ) + 1 ) ] NEW_LINE for i in range ( 4 * n + 1 ) : NEW_LINE INDENT tree [ i ] . square_sum = 0 NEW_LINE DEDENT buildTree ( S , tree , 0 , n - 1 , 1 ) NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT if ( Q [ i ] [ 0 ] == \" S \" ) : NEW_LINE INDENT L = int ( Q [ i ] [ 1 ] ) NEW_LINE R = int ( Q [ i ] [ 2 ] ) NEW_LINE print ( querySquareSum ( tree , 0 , n - 1 , 1 , L , R ) ) NEW_LINE DEDENT elif ( Q [ i ] [ 0 ] == \" U \" ) : NEW_LINE INDENT I = int ( Q [ i ] [ 1 ] ) NEW_LINE updateTree ( S , tree , 0 , n - 1 , 1 , I , Q [ i ] [ 2 ] [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" geeksforgeeks \" NEW_LINE Q = [ [ \" S \" , \"0\" , \"2\" ] , [ \" S \" , \"1\" , \"2\" ] , [ \" U \" , \"1\" , \" a \" ] , [ \" S \" , \"0\" , \"2\" ] , [ \" S \" , \"4\" , \"5\" ] ] NEW_LINE PerformQuery ( [ i for i in S ] , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to calculate sum of squares of ASCII values of characters of a substring with updates | Structure of a node of a Segment Tree ; Function to construct the Segment Tree ; If start and end are equa ; Assign squares of positions of the characters ; Stores the mid value of the range [ start , end ] ; Recursive call to left subtree ; Recursive call to right subtree ; Update the current node ; Function to perform the queries of type 2 ; No overlap ; If l <= start and r >= end ; Return the value of treeNode ; Calculate middle of the range [ start , end ] ; Function call to left subtree ; Function call to right subtree ; Return the sum of X and Y ; Function to perform update queries on a Segment Tree ; If start is equal to end and idx is equal to start ; Base Case ; Calculate middle of the range [ start , end ] ; If idx <= mid ; Function call to left subtree ; Otherwise ; Function call to the right subtree ; Update the current node ; Function to perform the given queries ; Stores the segment tree ; Traverse the segment tree ; Assign 0 to each node ; Builds segment tree ; Traverse the query array Q [ ] [ ] ; If query is of type S ; Stores the left boundary ; Stores the right boundary ; Prints the sum of squares of the alphabetic positions of the characters ; Otherwise ; Stores the index of the character to be updated ; Update the segment tree ; Driver Code ; Input ; Function call",
        "Category": "Segment Tree"
    },
    {
        "ID": "7452-7452",
        "Code": "def lcsBySwapping ( A , B ) : NEW_LINE INDENT N = len ( A ) NEW_LINE M = len ( B ) NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT freq [ ord ( A [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( B ) ) : NEW_LINE INDENT freq [ ord ( B [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt += freq [ i ] // 2 NEW_LINE DEDENT print ( min ( cnt , min ( N , M ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" abdeff \" NEW_LINE B = \" abbet \" NEW_LINE lcsBySwapping ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Common Subsequence ( LCS ) by repeatedly swapping characters of a string with characters of another string | Function to find the length of LCS possible by swapping any character of a with that of another string ; Store the size of the strings ; Stores frequency of characters ; Iterate over characters of the A ; Update frequency of character A [ i ] ; Iterate over characters of the B ; Update frequency of character B [ i ] ; Store the count of all pairs of similar characters ; Traverse the array freq [ ] ; Update cnt ; Print the minimum of cnt , N and M ; Driver Code ; Given strings",
        "Category": "Hash Table"
    },
    {
        "ID": "7453-7453",
        "Code": "def canSplit ( S ) : NEW_LINE INDENT frequency = [ 0 ] * 26 NEW_LINE cnt_singles = 0 NEW_LINE k = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT frequency [ ord ( S [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT odd = 0 NEW_LINE eve = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( frequency [ i ] ) : NEW_LINE INDENT odd += ( frequency [ i ] & 1 ) NEW_LINE eve += frequency [ i ] // 2 NEW_LINE DEDENT DEDENT if ( eve >= odd ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" aaabbbccc \" NEW_LINE canSplit ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange characters of a string to make it a concatenation of palindromic substrings | Function to check if a string can be modified such that it can be split into palindromic substrings of length >= 2 ; Stores frequencies of characters ; Traverse the string ; Update frequency of each character ; Traverse the frequency array ; Update values of odd and eve ; Print the result ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7454-7454",
        "Code": "def maximumTime ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE DEDENT ' NEW_LINE INDENT if ( s [ 0 ] == ' _ ' ) : NEW_LINE INDENT if ( ( s [ 1 ] == ' _ ' ) or ( s [ 1 ] >= '0' and s [ 1 ] < '4' ) ) : NEW_LINE INDENT s [ 0 ] = '2' NEW_LINE DEDENT else : NEW_LINE INDENT s [ 0 ] = '1' NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT if ( s [ 1 ] == ' _ ' ) : NEW_LINE DEDENT ' NEW_LINE INDENT if ( s [ 0 ] == '2' ) : NEW_LINE INDENT s [ 1 ] = '3' NEW_LINE DEDENT else : NEW_LINE INDENT s [ 1 ] = '9' NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( s [ 3 ] == ' _ ' ) : NEW_LINE INDENT s [ 3 ] = '5' NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( s [ 4 ] == ' _ ' ) : NEW_LINE INDENT s [ 4 ] = '9' NEW_LINE DEDENT s = ' ' . join ( s ) NEW_LINE return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"0 _ : 4 _ \" NEW_LINE print ( maximumTime ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize time by replacing ' _ ' in a given 24 Hour format time | Function to find the maximum time possible by replacing each ' _ ' with any digit ; If the first character is '_ ; If s [ 1 ] is ' _ ' or s [ 1 ] is less than 4 ; Update s [ 0 ] as 2 ; Otherwise , update s [ 0 ] = 1 ; If s [ 1 ] is equal to '_ ; If s [ 0 ] is equal to '2 ; Otherwise ; If S [ 3 ] is equal to '_ ; If s [ 4 ] is equal to '_ ; Return the modified string ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7455-7455",
        "Code": "def isPossible ( S , R , N ) : NEW_LINE ' NEW_LINE INDENT cntl = 0 NEW_LINE cntr = 0 NEW_LINE DEDENT ' NEW_LINE INDENT cntu = 0 NEW_LINE cntd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' L ' ) : NEW_LINE INDENT cntl += 1 NEW_LINE DEDENT elif ( S [ i ] == ' R ' ) : NEW_LINE INDENT cntr += 1 NEW_LINE DEDENT elif ( S [ i ] == ' U ' ) : NEW_LINE INDENT cntu += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntd += 1 NEW_LINE DEDENT DEDENT if ( max ( max ( cntl , cntr ) , max ( cntu , cntd ) ) >= R ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT mp = { } NEW_LINE r_square = R * R NEW_LINE i = 1 NEW_LINE while i * i <= r_square : NEW_LINE INDENT mp [ i * i ] = i NEW_LINE if ( ( r_square - i * i ) in mp ) : NEW_LINE INDENT if ( max ( cntl , cntr ) >= mp [ r_square - i * i ] and max ( cntu , cntd ) >= i ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT if ( max ( cntl , cntr ) >= i and max ( cntu , cntd ) >= mp [ r_square - i * i ] ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return \" No \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" RDLLDDLDU \" NEW_LINE R = 5 NEW_LINE N = len ( S ) NEW_LINE print ( isPossible ( S , R , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to reach any point on the circumference of a given circle from origin | Function to check if it is possible to reach any point on circumference of the given circle from ( 0 , 0 ) ; Stores the count of ' L ' , 'R ; Stores the count of ' U ' , 'D ; Traverse the string S ; Update the count of L ; Update the count of R ; Update the count of U ; Update the count of D ; Condition 1 for reaching the circumference ; Store the the value of ( i * i ) in the Map ; Check if ( r_square - i * i ) already present in HashMap ; If it is possible to reach the point ( mp [ r_square - i * i ] , i ) ; If it is possible to reach the point ( i , mp [ r_square - i * i ] ) ; If it is impossible to reach ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "746-746",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . key = item NEW_LINE self . parent = self . left = self . right = None NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE node . left . parent = node NEW_LINE DEDENT elif key > node . key : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE node . right . parent = node NEW_LINE DEDENT return node NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT leftdone = False NEW_LINE while root : NEW_LINE INDENT if leftdone == False : NEW_LINE INDENT while root . left : NEW_LINE INDENT root = root . left NEW_LINE DEDENT DEDENT print ( root . key , end = \" ▁ \" ) NEW_LINE leftdone = True NEW_LINE if root . right : NEW_LINE INDENT leftdone = False NEW_LINE root = root . right NEW_LINE DEDENT elif root . parent : NEW_LINE INDENT while root . parent and root == root . parent . right : NEW_LINE INDENT root = root . parent NEW_LINE DEDENT if root . parent == None : NEW_LINE INDENT break NEW_LINE DEDENT root = root . parent NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 24 ) NEW_LINE root = insert ( root , 27 ) NEW_LINE root = insert ( root , 29 ) NEW_LINE root = insert ( root , 34 ) NEW_LINE root = insert ( root , 14 ) NEW_LINE root = insert ( root , 4 ) NEW_LINE root = insert ( root , 10 ) NEW_LINE root = insert ( root , 22 ) NEW_LINE root = insert ( root , 13 ) NEW_LINE root = insert ( root , 3 ) NEW_LINE root = insert ( root , 2 ) NEW_LINE root = insert ( root , 6 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ is ▁ \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Inorder Non | A utility function to create a new BST node ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Function to print inorder traversal using parent pointer ; Start traversal from root ; If left child is not traversed , find the leftmost child ; Print root 's data ; Mark left as done ; If right child exists ; If right child doesn 't exist, move to parent ; If this node is right child of its parent , visit parent 's parent first ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7461-7461",
        "Code": "def getMaxRepetitions ( s1 , n1 , s2 , n2 ) : NEW_LINE INDENT if any ( c for c in set ( s2 ) if c not in set ( s1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s1_reps = 0 NEW_LINE DEDENT + Y4E4 : Z4C4E4 : W4E4 : Y4E4 : Z4E4 : AA4E4 : Z4E4 : Y4E4 : X4E4 : W4 NEW_LINE INDENT s2_reps = 0 NEW_LINE s2_index_to_reps = { 0 : ( 0 , 0 ) } NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while s1_reps < n1 : NEW_LINE INDENT if s1 [ i ] == s2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE if j == len ( s2 ) : NEW_LINE INDENT j = 0 NEW_LINE s2_reps += 1 NEW_LINE DEDENT if i == len ( s1 ) : NEW_LINE INDENT i = 0 NEW_LINE s1_reps += 1 NEW_LINE if j in s2_index_to_reps : NEW_LINE INDENT break NEW_LINE DEDENT s2_index_to_reps [ j ] = ( s1_reps , s2_reps ) NEW_LINE DEDENT DEDENT if s1_reps == n1 : NEW_LINE INDENT return s2_reps // n2 NEW_LINE DEDENT initial_s1_reps , initial_s2_reps = s2_index_to_reps [ j ] NEW_LINE loop_s1_reps = s1_reps - initial_s1_reps NEW_LINE loop_s2_reps = s2_reps - initial_s2_reps NEW_LINE loops = ( n1 - initial_s1_reps ) NEW_LINE s2_reps = initial_s2_reps + loops * loop_s2_reps NEW_LINE s1_reps = initial_s1_reps + loops * loop_s1_reps NEW_LINE while s1_reps < n1 : NEW_LINE INDENT if s1 [ i ] == s2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE if i == len ( s1 ) : NEW_LINE INDENT i = 0 NEW_LINE s1_reps += 1 NEW_LINE DEDENT if j == len ( s2 ) : NEW_LINE INDENT j = 0 NEW_LINE s2_reps += 1 NEW_LINE DEDENT DEDENT return s2_reps // n2 NEW_LINE DEDENT def getMaxRepetitions ( s1 , n1 , s2 , n2 ) : A4 : AJ4 NEW_LINE INDENT if any ( c for c in set ( s2 ) if c not in set ( s1 ) ) : NEW_LINE INDENT return 0 + E4 : W4 NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Maximize count of occurrences of S2 in S1 as a subsequence by concatenating N1 and N2 times respectively | Function to count maximum number of occurrences of s2 as subsequence in s1 by concatenating s1 , n1 times and s2 , n2 times ; Stores number of times s1 is traversed ; Stores number of times s2 is traversed ; Mapping index of s2 to number of times s1 and s2 are traversed ; Stores index of s1 circularly ; Stores index of s2 circularly ; Traverse the string s1 , n1 times ; If current character of both the string are equal ; Update j ; Update i ; If j is length of s2 ; Update j for circular traversal ; Update s2_reps ; If i is length of s1 ; Update i for circular traversal ; Update s1_reps ; If already mapped j to ( s1_reps , s2_reps ) ; Mapping j to ( s1_reps , s2_reps ) ; If s1 already traversed n1 times ; Otherwis , traverse string s1 by multiple of s1_reps and update both s1_reps and s2_reps ; Update s2_reps ; Update s1_reps ; If s1 is traversed less than n1 times ; If current character in both the string are equal ; Update j ; Update i ; If i is length of s1 ; Update i for circular traversal ; Update s1_reps ; If j is length of ss ; Update j for circular traversal ; Update s2_reps ; Function to count maximum number of occurrences of s2 as subsequence in s1 by concatenating s1 , n1 times and s2 , n2 times",
        "Category": "Substring"
    },
    {
        "ID": "7463-7463",
        "Code": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a // gcd ( a , b ) ) * b NEW_LINE DEDENT def findSmallestString ( s , t ) : NEW_LINE INDENT n , m = len ( s ) , len ( t ) NEW_LINE l = lcm ( n , m ) NEW_LINE s1 , t1 = \" \" , \" \" NEW_LINE for i in range ( l // n ) : NEW_LINE INDENT s1 += s NEW_LINE DEDENT for i in range ( l // m ) : NEW_LINE INDENT t1 += t NEW_LINE DEDENT if ( s1 == t1 ) : NEW_LINE INDENT print ( s1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S , T = \" baba \" , \" ba \" NEW_LINE findSmallestString ( S , T ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest string divisible by two given strings | Function to calculate GCD of two numbers ; Function to calculate LCM of two numbers ; Function to find the smallest string which is divisible by strings S and T ; Store the length of both strings ; Store LCM of n and m ; Temporary strings to store concatenated strings ; Concatenate s1 ( l / n ) times ; Concatenate t1 ( l / m ) times ; If s1 and t1 are equal ; Otherwise , pr - 1 ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7479-7479",
        "Code": "def countTotalFrequencies ( S1 , S2 ) : NEW_LINE INDENT bset = set ( S1 ) NEW_LINE count = 0 NEW_LINE for x in S2 : NEW_LINE INDENT if x in bset : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT S1 = \" geEksFOR \" NEW_LINE S2 = \" GeEksforgeEKS \" NEW_LINE countTotalFrequencies ( S1 , S2 ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of frequencies of characters of a string present in another string | Function to find sum of frequencies of characters of S1 present in S2 ; Insert all characters of string S1 in the set ; Traverse the string S2 ; Check if X is present in bset or not ; Increment count by 1 ; Finally , print the count ; Given strings",
        "Category": "Hash Table"
    },
    {
        "ID": "7484-7484",
        "Code": "def min_length ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE total_zeros = 0 NEW_LINE total_ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT total_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT total_ones += 1 NEW_LINE DEDENT DEDENT ans = min ( total_zeros , total_ones ) NEW_LINE cur_zeros = 0 NEW_LINE cur_ones = 0 NEW_LINE for x in str : NEW_LINE INDENT if ( x == '0' ) : NEW_LINE INDENT cur_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cur_ones += 1 NEW_LINE DEDENT ans = min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"10011\" NEW_LINE min_length ( str ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Make a given Binary String non | Function to return the length of smallest subsequence required to be removed to make the given string non - decreasing ; Length of the string ; Count of zeros and ones ; Traverse the string ; Count minimum removals to obtain strings of the form \"00000 . . . . \" or \"11111 . . . \" ; Increment count ; Remove 1 s and remaining 0 s ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "749-749",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def ceil ( root , inp ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if root . key == inp : NEW_LINE INDENT return root . key NEW_LINE DEDENT if root . key < inp : NEW_LINE INDENT return ceil ( root . right , inp ) NEW_LINE DEDENT val = ceil ( root . left , inp ) NEW_LINE return val if val >= inp else root . key NEW_LINE DEDENT root = Node ( 8 ) NEW_LINE root . left = Node ( 4 ) NEW_LINE root . right = Node ( 12 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . left . right = Node ( 6 ) NEW_LINE root . right . left = Node ( 10 ) NEW_LINE root . right . right = Node ( 14 ) NEW_LINE for i in range ( 16 ) : NEW_LINE INDENT print \" % ▁ d ▁ % ▁ d \" % ( i , ceil ( root , i ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Floor and Ceil from a BST | A Binary tree node ; Function to find ceil of a given input in BST . If input is more than the max key in BST , return - 1 ; Base Case ; We found equal key ; If root 's key is smaller, ceil must be in right subtree ; Else , either left subtre or root has the ceil value ; Driver program to test above function",
        "Category": "Binary Tree"
    },
    {
        "ID": "7490-7490",
        "Code": "def rearrangeString ( s1 , s2 ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT cnt [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT unique = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( cnt [ i ] != 0 ) : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT DEDENT if ( unique == 1 ) : NEW_LINE INDENT count_in_s2 = len ( s2 ) NEW_LINE count_in_s1 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ 0 ] ) : NEW_LINE INDENT count_in_s1 += 1 NEW_LINE DEDENT DEDENT if ( count_in_s1 < count_in_s2 ) : NEW_LINE INDENT print ( s1 , end = \" \" ) NEW_LINE return NEW_LINE DEDENT print ( - 1 , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT inc = 1 NEW_LINE for i in range ( len ( s2 ) - 1 ) : NEW_LINE INDENT if ( s2 [ i ] > s2 [ i + 1 ] ) : NEW_LINE INDENT inc = 0 NEW_LINE DEDENT DEDENT if ( inc == 1 ) : NEW_LINE INDENT s1 = sorted ( s1 ) [ : : - 1 ] NEW_LINE print ( \" \" . join ( s1 ) , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = sorted ( s1 ) NEW_LINE print ( \" \" . join ( s1 ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 , s2 = \" abcd \" , \" ab \" NEW_LINE rearrangeString ( s1 , s2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange a string S1 such that another given string S2 is not its subsequence | Function to rearrange characters in S1 such that S2 is not a subsequence of it ; Store the frequencies of characters of s2 ; Traverse the s2 ; Update the frequency ; Find the number of unique characters in s2 ; Increment unique by 1 if the condition satisfies ; Check if the number of unique characters in s2 is 1 ; Store the unique character frequency ; Store occurence of it in s1 ; Find count of that character in the s1 ; Increment count by 1 if that unique character is same as current character ; If count count_in_s1 is less than count_in_s2 , then prs1 and return ; Otherwise , there is no possible arrangement ; Checks if any character in s2 is less than its next character ; Iterate the string , s2 ; If s [ i ] is greater than the s [ i + 1 ] ; Set inc to 0 ; If inc = 1 , prs1 in decreasing order ; Otherwise , prs1 in increasing order ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7491-7491",
        "Code": "def minimumSwaps ( s , l , r , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE tot_ones , tot_zeros = 0 , 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT tot_ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot_zeros += 1 NEW_LINE DEDENT DEDENT ones , zeros , Sum = 0 , 0 , 0 NEW_LINE for i in range ( l - 1 , r ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE Sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT rem_ones = tot_ones - ones NEW_LINE rem_zeros = tot_zeros - zeros NEW_LINE if ( k >= Sum ) : NEW_LINE INDENT rem = k - Sum NEW_LINE if ( zeros >= rem and rem_ones >= rem ) : NEW_LINE INDENT return rem NEW_LINE DEDENT DEDENT elif ( k < Sum ) : NEW_LINE INDENT rem = Sum - k NEW_LINE if ( ones >= rem and rem_zeros >= rem ) : NEW_LINE INDENT return rem NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT S = \"110011111000101\" NEW_LINE L , R , K = 5 , 8 , 2 NEW_LINE print ( minimumSwaps ( S , L , R , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of swaps required such that a given substring consists of exactly K 1 s | Function to find the minimum number of swaps required such that the substring { s [ l ] , . . , s [ r ] } consists of exactly k 1 s ; Store the size of the string ; Store the total number of 1 s and 0 s in the entire string ; Traverse the string S to find the frequency of 1 and 0 ; Store the number of 1 s and 0 s in the substring s [ l , r ] ; Traverse the substring S [ l , r ] to find the frequency of 1 s and 0 s in it ; Store the count of 1 s and 0 s outside substring s [ l , r ] ; Check if the sum of the substring is at most K ; Store number of 1 s required ; Check if there are enough 1 s remaining to be swapped ; If the count of 1 s in the substring exceeds k ; Store the number of 0 s required ; Check if there are enough 0 s remaining to be swapped ; In all other cases , print - 1 ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "7492-7492",
        "Code": "def make_palindrome ( S1 , S2 , S3 ) : NEW_LINE INDENT maskA , maskC = 0 , 0 NEW_LINE for i in S1 : NEW_LINE INDENT maskA |= ( 1 << ( ord ( i ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT for i in S3 : NEW_LINE INDENT maskC |= ( 1 << ( ord ( i ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT if ( ( maskA & maskC ) > 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 , S2 , S3 = \" adcb \" , \" bcdb \" , \" abe \" NEW_LINE print ( make_palindrome ( S1 , S2 , S3 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if substrings from three given strings can be concatenated to form a palindrome | Function to check if substrings from three given strings can be concatenated to form a palindrome ; Mask for S1 and S2 ; Set ( i - ' a ' ) th bit in maskA ; Set ( i - ' a ' ) th bit in maskC ; If the bitwise AND is > 0 ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7494-7494",
        "Code": "SIZE = 26 NEW_LINE def longHelper ( freq1 , freq2 ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq1 [ i ] != freq2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def longCommomPrefixAnagram ( s1 , s2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 NEW_LINE freq2 = [ 0 ] * 26 NEW_LINE ans = 0 NEW_LINE mini_len = min ( n1 , n2 ) NEW_LINE for i in range ( mini_len ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE freq2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( longHelper ( freq1 , freq2 ) ) : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abaabcdezzwer \" NEW_LINE str2 = \" caaabbttyh \" NEW_LINE N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE longCommomPrefixAnagram ( str1 , str2 , N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of longest prefix anagram which are common in given two strings | Python3 program for the above approach ; Function to check if two arrays are identical or not ; Iterate over the range [ 0 , SIZE ] ; If frequency any character is not same in both the strings ; Otherwise ; Function to find the maximum length of the required string ; Store the count of characters in str1 ; Store the count of characters in str2 ; Stores the maximum length ; Minimum length of str1 and str2 ; Increment the count of characters of str1 [ i ] in freq1 [ ] by one ; Increment the count of characters of stord ( r2 [ i ] ) in freq2 [ ] by one ; Checks if prefixes are anagram or not ; Finally prthe ans ; Driver Code ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "7498-7498",
        "Code": "def findRank ( s ) : NEW_LINE INDENT N = len ( s ) ; NEW_LINE sb = \" \" ; NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sb += str ( '0' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sb += str ( '1' ) ; NEW_LINE DEDENT DEDENT bin = str ( sb ) ; NEW_LINE X = pow ( 2 , N ) ; NEW_LINE Y = int ( bin ) ; NEW_LINE ans = X + Y - 1 ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"001\" ; NEW_LINE findRank ( S ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographic rank of a Binary String | Function to find the rank of a string ; Store the length of the string ; Stores its equivalent decimal value ; Traverse the string ; Store the number of strings of length less than N occurring before the given string ; Store the decimal equivalent number of string bin ; Store the rank in answer ; Prthe answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7499-7499",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def checkPalindrome ( s ) : NEW_LINE INDENT low , high = 0 , len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def lexicographicallySmall ( root , s ) : NEW_LINE INDENT global finalAns NEW_LINE if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT s += root . data NEW_LINE if ( not root . left and not root . right ) : NEW_LINE INDENT if ( checkPalindrome ( s ) ) : NEW_LINE INDENT if ( finalAns == \" $ \" ) : NEW_LINE INDENT finalAns = s NEW_LINE DEDENT else : NEW_LINE INDENT finalAns = min ( finalAns , s ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT lexicographicallySmall ( root . left , s ) NEW_LINE lexicographicallySmall ( root . right , s ) NEW_LINE DEDENT def getPalindromePath ( root ) : NEW_LINE INDENT global finalAns NEW_LINE finalAns = \" $ \" NEW_LINE lexicographicallySmall ( root , \" \" ) NEW_LINE if ( finalAns == \" $ \" ) : NEW_LINE INDENT print ( \" No ▁ Palindromic ▁ Path ▁ exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( finalAns ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT finalAns = \" \" NEW_LINE root = Node ( ' a ' ) NEW_LINE root . left = Node ( ' c ' ) NEW_LINE root . left . left = Node ( ' a ' ) NEW_LINE root . left . right = Node ( ' g ' ) NEW_LINE root . right = Node ( ' b ' ) NEW_LINE root . right . left = Node ( ' b ' ) NEW_LINE root . right . right = Node ( ' x ' ) NEW_LINE root . right . left . right = Node ( ' a ' ) NEW_LINE getPalindromePath ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest Palindromic Path in a Binary Tree | Struct binary tree node ; Function to check if the is palindrome or not ; Function to find the lexicographically smallest palindromic path in the Binary Tree ; Base case ; Append current node 's  data to the string ; Check if a node is leaf or not ; Check for the 1 st Palindromic Path ; Store lexicographically the smallest palindromic path ; Recursively traverse left subtree ; Recursively traverse right subtree ; Function to get smallest lexographical palindromic path ; Variable which stores the final result ; Function call to compute lexicographically smallest palindromic Path ; Driver Code ; Construct binary tree",
        "Category": "Binary Tree"
    },
    {
        "ID": "75-75",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def constructTreeUtil ( pre , preLN , index_ptr , n ) : NEW_LINE INDENT index = index_ptr [ 0 ] NEW_LINE if index == n : NEW_LINE INDENT return None NEW_LINE DEDENT temp = newNode ( pre [ index ] ) NEW_LINE index_ptr [ 0 ] += 1 NEW_LINE if preLN [ index ] == ' N ' : NEW_LINE INDENT temp . left = constructTreeUtil ( pre , preLN , index_ptr , n ) NEW_LINE temp . right = constructTreeUtil ( pre , preLN , index_ptr , n ) NEW_LINE DEDENT return temp NEW_LINE DEDENT def constructTree ( pre , preLN , n ) : NEW_LINE INDENT index = [ 0 ] NEW_LINE return constructTreeUtil ( pre , preLN , index , n ) NEW_LINE DEDENT def printInorder ( node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE print ( node . data , end = \" ▁ \" ) NEW_LINE printInorder ( node . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE pre = [ 10 , 30 , 20 , 5 , 15 ] NEW_LINE preLN = [ ' N ' , ' N ' , ' L ' , ' L ' , ' L ' ] NEW_LINE n = len ( pre ) NEW_LINE root = constructTree ( pre , preLN , n ) NEW_LINE print ( \" Following ▁ is ▁ Inorder ▁ Traversal ▁ of \" , \" the ▁ Constructed ▁ Binary ▁ Tree : \" ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct a special tree from given preorder traversal | Utility function to create a new Binary Tree node ; A recursive function to create a Binary Tree from given pre [ ] preLN [ ] arrays . The function returns root of tree . index_ptr is used to update index values in recursive calls . index must be initially passed as 0 ; store the current value ; of index in pre [ ] Base Case : All nodes are constructed ; Allocate memory for this node and increment index for subsequent recursive calls ; If this is an internal node , construct left and right subtrees and link the subtrees ; A wrapper over constructTreeUtil ( ) ; Initialize index as 0. Value of index is used in recursion to maintain the current index in pre [ ] and preLN [ ] arrays . ; This function is used only for testing ; first recur on left child ; then print the data of node ; now recur on right child ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "750-750",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def floorCeilBSTHelper ( root , key ) : NEW_LINE INDENT global floor , ceil NEW_LINE while ( root ) : NEW_LINE INDENT if ( root . data == key ) : NEW_LINE INDENT ceil = root . data NEW_LINE floor = root . data NEW_LINE return NEW_LINE DEDENT if ( key > root . data ) : NEW_LINE INDENT floor = root . data NEW_LINE root = root . right NEW_LINE DEDENT else : NEW_LINE INDENT ceil = root . data NEW_LINE root = root . left NEW_LINE DEDENT DEDENT DEDENT def floorCeilBST ( root , key ) : NEW_LINE INDENT global floor , ceil NEW_LINE floor = - 1 NEW_LINE ceil = - 1 NEW_LINE floorCeilBSTHelper ( root , key ) NEW_LINE print ( key , floor , ceil ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT floor , ceil = - 1 , - 1 NEW_LINE root = Node ( 8 ) NEW_LINE root . left = Node ( 4 ) NEW_LINE root . right = Node ( 12 ) NEW_LINE root . left . left = Node ( 2 ) NEW_LINE root . left . right = Node ( 6 ) NEW_LINE root . right . left = Node ( 10 ) NEW_LINE root . right . right = Node ( 14 ) NEW_LINE for i in range ( 16 ) : NEW_LINE INDENT floorCeilBST ( root , i ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Floor and Ceil from a BST | A binary tree node has key , . left child and right child ; Helper function to find floor and ceil of a given key in BST ; Display the floor and ceil of a given key in BST . If key is less than the min key in BST , floor will be - 1 ; If key is more than the max key in BST , ceil will be - 1 ; ; Variables ' floor ' and ' ceil ' are passed by reference ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7503-7503",
        "Code": "def solution ( S ) : NEW_LINE INDENT vowels = [ ] NEW_LINE consonants = [ ] NEW_LINE for i in S : NEW_LINE INDENT if ( i == ' a ' or i == ' e ' or i == ' i ' or i == ' o ' or i == ' u ' ) : NEW_LINE INDENT vowels . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT consonants . append ( i ) NEW_LINE DEDENT DEDENT Nc = len ( consonants ) NEW_LINE Nv = len ( vowels ) NEW_LINE M = Nc // ( Nv - 1 ) NEW_LINE ans = \" \" NEW_LINE consonant_till = 0 NEW_LINE for i in vowels : NEW_LINE INDENT ans += i NEW_LINE temp = 0 NEW_LINE for j in range ( consonant_till , min ( Nc , consonant_till + M ) ) : NEW_LINE INDENT ans += consonants [ j ] NEW_LINE temp += 1 NEW_LINE DEDENT consonant_till += temp NEW_LINE DEDENT return ans NEW_LINE DEDENT S = \" aaaabbbcc \" NEW_LINE print ( solution ( S ) ) NEW_LINE",
        "Type": "py",
        "NL": "Rearrange a string to maximize the minimum distance between any pair of vowels | Function to rearrange the string such that the minimum distance between any of vowels is maximum . ; store vowels and consonants ; Iterate over the characters of string ; if current character is a vowel ; if current character is consonant ; store count of vowels and consonants respectively ; store the resultant string ; store count of consonants append into ans ; Append vowel to ans ; Append consonants ; Appendconsonant to ans ; update temp ; Remove the taken elements of consonant ; return final answer ; Driver code ; Function Call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7504-7504",
        "Code": "Ans = [ ] NEW_LINE def populateNumber ( ) : NEW_LINE INDENT Ans . append ( 2 ) NEW_LINE Ans . append ( 5 ) NEW_LINE x = 5 NEW_LINE while ( x < 1000000000001 ) : NEW_LINE INDENT x *= 2 NEW_LINE Ans . append ( x ) NEW_LINE x = x * 2 + 1 NEW_LINE Ans . append ( x ) NEW_LINE DEDENT DEDENT def checkString ( N ) : NEW_LINE INDENT populateNumber ( ) NEW_LINE for it in Ans : NEW_LINE INDENT if ( it == N ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT return \" No \" NEW_LINE DEDENT N = 5 NEW_LINE print ( checkString ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if given number contains only “ 01 ” and “ 10 ” as substring in its binary representation | Python3 program to implement the above approach ; Function to generate all numbers having \"01\" and \"10\" as a substring ; Insert 2 and 5 ; Iterate till x is 10 ^ 15 ; Multiply x by 2 ; Update x as x * 2 + 1 ; Function to check if binary representation of N contains only \"01\" and \"10\" as substring ; Function Call to generate all such numbers ; Check if a number N exists in Ans [ ] or not ; If the number exists ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7510-7510",
        "Code": "def GCD ( lena , lenb ) : NEW_LINE INDENT if ( lena == 0 ) : NEW_LINE INDENT return lenb NEW_LINE DEDENT if ( lenb == 0 ) : NEW_LINE INDENT return lena NEW_LINE DEDENT if ( lena == lenb ) : NEW_LINE INDENT return lena NEW_LINE DEDENT if ( lena > lenb ) : NEW_LINE INDENT return GCD ( lena - lenb , lenb ) NEW_LINE DEDENT return GCD ( lena , lenb - lena ) NEW_LINE DEDENT def StringGCD ( a , b ) : NEW_LINE INDENT gcd = GCD ( len ( a ) , len ( b ) ) NEW_LINE if a [ : gcd ] == b [ : gcd ] : NEW_LINE INDENT if a * ( len ( b ) // gcd ) == b * ( len ( a ) // gcd ) : NEW_LINE return a [ : gcd ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = ' geeksgeeks ' NEW_LINE b = ' geeks ' NEW_LINE print ( StringGCD ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the GCD of an array made up of numeric strings | Recursive function to return gcd of A and B ; Base case ; Length of A is greater ; Calculate GCD ; Store the GCD of the length of the strings ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "752-752",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . count = 1 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , \" ( \" , root . count , \" ) \" , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT k = newNode ( key ) NEW_LINE return k NEW_LINE DEDENT if key == node . key : NEW_LINE INDENT ( node . count ) += 1 NEW_LINE return node NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def minValueNode ( node ) : NEW_LINE INDENT current = node NEW_LINE while current . left != None : NEW_LINE INDENT current = current . left NEW_LINE DEDENT return current NEW_LINE DEDENT def deleteNode ( root , key ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return root NEW_LINE DEDENT if key < root . key : NEW_LINE INDENT root . left = deleteNode ( root . left , key ) NEW_LINE DEDENT elif key > root . key : NEW_LINE INDENT root . right = deleteNode ( root . right , key ) NEW_LINE DEDENT else : NEW_LINE INDENT if root . count > 1 : NEW_LINE INDENT root . count -= 1 NEW_LINE return root NEW_LINE DEDENT if root . left == None : NEW_LINE INDENT temp = root . right NEW_LINE return temp NEW_LINE DEDENT elif root . right == None : NEW_LINE INDENT temp = root . left NEW_LINE return temp NEW_LINE DEDENT temp = minValueNode ( root . right ) NEW_LINE root . key = temp . key NEW_LINE root . right = deleteNode ( root . right , temp . key ) NEW_LINE DEDENT return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 12 ) NEW_LINE root = insert ( root , 10 ) NEW_LINE root = insert ( root , 20 ) NEW_LINE root = insert ( root , 9 ) NEW_LINE root = insert ( root , 11 ) NEW_LINE root = insert ( root , 10 ) NEW_LINE root = insert ( root , 12 ) NEW_LINE root = insert ( root , 12 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE print ( ) NEW_LINE print ( \" Delete ▁ 20\" ) NEW_LINE root = deleteNode ( root , 20 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE print ( ) NEW_LINE print ( \" Delete ▁ 12\" ) NEW_LINE root = deleteNode ( root , 12 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE print ( ) NEW_LINE print ( \" Delete ▁ 9\" ) NEW_LINE root = deleteNode ( root , 9 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to handle duplicates in Binary Search Tree ? | A utility function to create a new BST node ; A utility function to do inorder traversal of BST ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; If key already exists in BST , increment count and return ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Given a binary search tree and a key , this function deletes a given key and returns root of modified tree ; base case ; If the key to be deleted is smaller than the root 's key, then it lies in left subtree ; If the key to be deleted is greater than the root 's key, then it lies in right subtree ; if key is same as root 's key ; If key is present more than once , simply decrement count and return ; ElSE , delete the node node with only one child or no child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's content  to this node ; Delete the inorder successor ; Driver Code ; Let us create following BST 12 ( 3 ) / \\ 10 ( 2 ) 20 ( 1 ) / \\ 9 ( 1 ) 11 ( 1 )",
        "Category": "Binary Tree"
    },
    {
        "ID": "7522-7522",
        "Code": "import sys NEW_LINE def update ( BIT , idx , i , val ) : NEW_LINE INDENT while ( i < 10005 ) : NEW_LINE BIT [ idx ] [ i ] += val NEW_LINE i = i + ( i & ( - i ) ) NEW_LINE DEDENT def query ( BIT , idx , i ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( i > 0 ) : NEW_LINE ans += BIT [ idx ] [ i ] NEW_LINE i = i - ( i & ( - i ) ) NEW_LINE return ans NEW_LINE DEDENT def maxDiffFreq ( s , queries ) : NEW_LINE INDENT BIT = [ [ 0 for i in range ( 10005 ) ] for j in range ( 26 ) ] NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE update ( BIT , ord ( s [ i ] ) - ord ( ' a ' ) , i + 1 , 1 ) NEW_LINE Q = len ( queries ) NEW_LINE for i in range ( Q ) : NEW_LINE mx = 0 NEW_LINE mn = sys . maxsize NEW_LINE l = queries [ i ] [ 0 ] NEW_LINE r = queries [ i ] [ 1 ] NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT p = query ( BIT , j , r ) NEW_LINE q = query ( BIT , j , l - 1 ) NEW_LINE mx = max ( mx , p - q ) NEW_LINE if ( p > 0 ) : NEW_LINE mn = min ( mn , p - q ) NEW_LINE DEDENT print ( mx - mn ) NEW_LINE DEDENT S = \" abaabac \" NEW_LINE queries = [ [ 2 , 6 ] , [ 1 , 7 ] ] NEW_LINE maxDiffFreq ( S , queries ) NEW_LINE",
        "Type": "py",
        "NL": "Queries to calculate difference between the frequencies of the most and least occurring characters in specified substring | Python3 program for the above approach ; Function to update frequency of a character in Fenwick tree ; Update frequency of ( idx + ' a ' ) ; Update i ; Function to find the frequency of a character ( idx + ' a ' ) in range [ 1 , i ] ; Stores frequency of character , ( idx + ' a ' ) in range [ 1 , i ] ; Update ans ; Update i ; Function to find difference between maximum and minimum frequency of a character in given range ; BIT [ i ] [ j ] : Stores frequency of ( i + ' a ' ) If j is a power of 2 , then it stores the frequency ( i + ' a ' ) of from [ 1 ] [ j ] ; Stores length of String ; Iterate over the characters of the String ; Update the frequency of s [ i ] in fenwick tree ; Stores count of queries ; Iterate over all the queries ; Stores maximum frequency of a character in range [ l , r ] ; Stores minimum frequency of a character in range [ l , r ] ; Iterate over all possible characters ; Stores frequency of ( j + ' a ' ) in range [ 1 , r ] ; Stores frequency of ( j + ' a ' ) in range [ 1 , l - 1 ] ; Update mx ; If a character ( i + ' a ' ) present in range [ l , r ] ; Update mn ; Print the difference between max and min freq ; Given String ; Given queries ; Function Call",
        "Category": "Fenwick Tree (Implicit in the implementation, but the dominant algorithmic technique is...)\n\n**Answer:** Binary Indexed Tree (Fenwick Tree)\n\nHowever, since \"Fenwick Tree\" is not in the provided category list and must choose from"
    },
    {
        "ID": "7526-7526",
        "Code": "def find_Winner ( arr , N ) : NEW_LINE INDENT Q = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT Q [ i ] = [ ] NEW_LINE DEDENT M = len ( arr ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT Len = len ( arr [ i ] ) NEW_LINE for j in range ( Len ) : NEW_LINE INDENT Q [ i ] . append ( ord ( arr [ i ] [ j ] ) - 1 ) NEW_LINE DEDENT DEDENT player = 0 NEW_LINE while ( len ( Q [ player ] ) > 0 ) : NEW_LINE INDENT nextPlayer = Q [ player ] [ 0 ] - ord ( '0' ) NEW_LINE del Q [ player ] [ 0 ] NEW_LINE player = nextPlayer NEW_LINE DEDENT print ( \" Player \" , ( player + 1 ) ) NEW_LINE DEDENT N = 3 NEW_LINE arr = [ \"323\" , \"2\" , \"2\" ] NEW_LINE find_Winner ( arr , N ) NEW_LINE",
        "Type": "py",
        "NL": "Find the winner of game of repeatedly removing the first character to empty given string | Function to find the winner of a game of repeatedly removing the first character to empty a string ; Store characters of each string of the array arr [ ] ; Stores count of strings in arr [ ] ; Traverse the array arr [ ] ; Stores length of current string ; Traverse the string ; Insert arr [ i ] [ j ] ; 1 st Player starts the game ; Stores the player number for the next turn ; Remove 1 st character of current string ; Update player number for the next turn ; Driver Code",
        "Category": "Game Theory"
    },
    {
        "ID": "7527-7527",
        "Code": "def longestSubstring ( s ) : NEW_LINE INDENT dp = [ 1024 for i in range ( 1024 ) ] NEW_LINE res , mask = 0 , 0 NEW_LINE dp [ 0 ] = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT mask ^= 1 << ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE res = max ( res , i - dp [ mask ] ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT res = max ( res , i - dp [ mask ^ ( 1 << j ) ] ) NEW_LINE DEDENT dp [ mask ] = min ( dp [ mask ] , i ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3242415\" NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Substring that can be made a palindrome by swapping of characters | Function to find the Longest substring that can be made a palindrome by swapping of characters ; Initialize dp array of size 1024 ; Initializing mask and res ; Traverse the string ; Find the mask of the current character ; Finding the length of the longest substring in s which is a palindrome for even count ; Finding the length of the longest substring in s which is a palindrome for one odd count ; Finding maximum length of substring having one odd count ; dp [ mask ] is minimum of current i and dp [ mask ] ; Return longest length of the substring which forms a palindrome with swaps ; Driver Code ; Input String ; Function Call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7528-7528",
        "Code": "def Validate ( M ) : NEW_LINE INDENT lenn = len ( M ) NEW_LINE temp = \" \" NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( M [ i ] . isdigit ( ) ) : NEW_LINE INDENT temp += M [ i ] NEW_LINE DEDENT DEDENT nwlenn = len ( temp ) NEW_LINE if ( nwlenn != 10 ) : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE return NEW_LINE DEDENT res = \" \" NEW_LINE x = temp [ 0 : 3 ] NEW_LINE res += \" ( \" + x + \" ) - \" NEW_LINE x = temp [ 3 : 3 + 3 ] NEW_LINE res += \" ( \" + x + \" ) - \" NEW_LINE x = temp [ 6 : 3 + 6 ] NEW_LINE res += \" ( \" + x + \" ) - \" NEW_LINE x = temp [ 9 : 1 + 9 ] NEW_LINE res += \" ( \" + x + \" ) \" NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = \"91 ▁ 234rt5%34*0 ▁ 3\" NEW_LINE Validate ( M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert given string to a valid mobile number | Function to print valid and formatted phone number ; Length of given ; Store digits in temp ; Iterate given M ; If any digit : append it to temp ; Find new length of ; If length is not equal to 10 ; Store final result ; Make groups of 3 digits and enclose them within ( ) and separate them with \" - \" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; Print final result ; Driver Code ; Given ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "7529-7529",
        "Code": "def countStrings ( S , list ) : NEW_LINE INDENT valid = { } NEW_LINE for x in S : NEW_LINE INDENT valid [ x ] = 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT j = 0 NEW_LINE while j < len ( list [ i ] ) : NEW_LINE INDENT if ( list [ i ] [ j ] in valid ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == len ( list [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" ab \" , \" aab \" , \" abaaaa \" , \" bbd \" ] NEW_LINE S , l = \" ab \" , [ ] NEW_LINE print ( countStrings ( S , arr ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count strings from given array having all characters appearing in a given string | Function to count the number of strings from an array having all characters appearing in the string S ; Initialize a set to store all distinct characters of S ; Traverse over S ; Insert characters into the Set ; Stores the required count ; Traverse the array ; Traverse over arr [ i ] ; Check if character in arr [ i ] [ j ] is present in the S or not ; Increment the count if all the characters of arr [ i ] are present in the S ; Finally , prthe count ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "753-753",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT else : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def minValueNode ( node ) : NEW_LINE INDENT current = node NEW_LINE while current . left != None : NEW_LINE INDENT current = current . left NEW_LINE DEDENT return current NEW_LINE DEDENT def deleteNode ( root , key ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return root NEW_LINE DEDENT if key < root . key : NEW_LINE INDENT root . left = deleteNode ( root . left , key ) NEW_LINE DEDENT elif key > root . key : NEW_LINE INDENT root . right = deleteNode ( root . right , key ) NEW_LINE DEDENT else : NEW_LINE INDENT if root . left == None : NEW_LINE INDENT temp = root . right NEW_LINE return temp NEW_LINE DEDENT elif root . right == None : NEW_LINE INDENT temp = root . left NEW_LINE return temp NEW_LINE DEDENT temp = minValueNode ( root . right ) NEW_LINE root . key = temp . key NEW_LINE root . right = deleteNode ( root . right , temp . key ) NEW_LINE DEDENT return root NEW_LINE DEDENT def changeKey ( root , oldVal , newVal ) : NEW_LINE INDENT root = deleteNode ( root , oldVal ) NEW_LINE root = insert ( root , newVal ) NEW_LINE return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 50 ) NEW_LINE root = insert ( root , 30 ) NEW_LINE root = insert ( root , 20 ) NEW_LINE root = insert ( root , 40 ) NEW_LINE root = insert ( root , 70 ) NEW_LINE root = insert ( root , 60 ) NEW_LINE root = insert ( root , 80 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE root = changeKey ( root , 40 , 10 ) NEW_LINE print ( ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree \" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "How to implement decrease key or change key in Binary Search Tree ? | A utility function to create a new BST node ; A utility function to do inorder traversal of BST ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Given a binary search tree and a key , this function deletes the key and returns the new root ; base case ; If the key to be deleted is smaller than the root 's key, then it lies in left subtree ; If the key to be deleted is greater than the root 's key, then it lies in right subtree ; if key is same as root 's key, then  this is the node to be deleted ; node with only one child or no child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's content  to this node ; Delete the inorder successor ; Function to decrease a key value in Binary Search Tree ; First delete old key value ; Then insert new key value ; Return new root ; Driver Code ; Let us create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 ; BST is modified to 50 / \\ 30 70 / / \\ 20 60 80 / 10",
        "Category": "Binary Tree"
    },
    {
        "ID": "7531-7531",
        "Code": "def minLength ( Str , N , K , M ) : NEW_LINE INDENT stackOfChar = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT stackOfChar . append ( Str [ i ] ) NEW_LINE if ( len ( stackOfChar ) >= M ) : NEW_LINE INDENT l = \" \" NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K [ j ] != stackOfChar [ - 1 ] ) : NEW_LINE INDENT f = 0 NEW_LINE while ( f != len ( l ) ) : NEW_LINE INDENT stackOfChar . append ( l [ f ] ) NEW_LINE f += 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l = stackOfChar [ - 1 ] + l NEW_LINE stackOfChar . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( stackOfChar ) NEW_LINE DEDENT S1 = \" fffoxoxoxfxo \" NEW_LINE S2 = \" fox \" NEW_LINE N = len ( S1 ) NEW_LINE M = len ( S2 ) NEW_LINE print ( minLength ( S1 , N , S2 , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize a string by removing all occurrences of another string | Function to find the minimum length to which string str can be reduced to by removing all occurrences of string K ; Initialize stack of characters ; Push character into the stack ; If stack size >= K . size ( ) ; Create empty string to store characters of stack ; Traverse the string K in reverse ; If any of the characters differ , it means that K is not present in the stack ; Push the elements back into the stack ; Store the string ; Remove top element ; Size of stack gives the minimized length of str ; Driver code ; Function Call",
        "Category": "Stack"
    },
    {
        "ID": "754-754",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def printCommon ( root1 , root2 ) : NEW_LINE INDENT s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE while 1 : NEW_LINE INDENT if root1 : NEW_LINE INDENT s1 . append ( root1 ) NEW_LINE root1 = root1 . left NEW_LINE DEDENT elif root2 : NEW_LINE INDENT s2 . append ( root2 ) NEW_LINE root2 = root2 . left NEW_LINE DEDENT elif len ( s1 ) != 0 and len ( s2 ) != 0 : NEW_LINE INDENT root1 = s1 [ - 1 ] NEW_LINE root2 = s2 [ - 1 ] NEW_LINE if root1 . key == root2 . key : NEW_LINE INDENT print ( root1 . key , end = \" ▁ \" ) NEW_LINE s1 . pop ( - 1 ) NEW_LINE s2 . pop ( - 1 ) NEW_LINE root1 = root1 . right NEW_LINE root2 = root2 . right NEW_LINE DEDENT elif root1 . key < root2 . key : NEW_LINE INDENT s1 . pop ( - 1 ) NEW_LINE root1 = root1 . right NEW_LINE root2 = None NEW_LINE DEDENT elif root1 . key > root2 . key : NEW_LINE INDENT s2 . pop ( - 1 ) NEW_LINE root2 = root2 . right NEW_LINE root1 = None NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( root . key , end = \" ▁ \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif key > node . key : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = None NEW_LINE root1 = insert ( root1 , 5 ) NEW_LINE root1 = insert ( root1 , 1 ) NEW_LINE root1 = insert ( root1 , 10 ) NEW_LINE root1 = insert ( root1 , 0 ) NEW_LINE root1 = insert ( root1 , 4 ) NEW_LINE root1 = insert ( root1 , 7 ) NEW_LINE root1 = insert ( root1 , 9 ) NEW_LINE root2 = None NEW_LINE root2 = insert ( root2 , 10 ) NEW_LINE root2 = insert ( root2 , 7 ) NEW_LINE root2 = insert ( root2 , 20 ) NEW_LINE root2 = insert ( root2 , 4 ) NEW_LINE root2 = insert ( root2 , 9 ) NEW_LINE print ( \" Tree ▁ 1 ▁ : ▁ \" ) NEW_LINE inorder ( root1 ) NEW_LINE print ( ) NEW_LINE print ( \" Tree ▁ 2 ▁ : ▁ \" ) NEW_LINE inorder ( root2 ) NEW_LINE print ( ) NEW_LINE print ( \" Common ▁ Nodes : ▁ \" ) NEW_LINE printCommon ( root1 , root2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print Common Nodes in Two Binary Search Trees | A utility function to create a new node ; Function two print common elements in given two trees ; Create two stacks for two inorder traversals ; append the Nodes of first tree in stack s1 ; append the Nodes of second tree in stack s2 ; Both root1 and root2 are NULL here ; If current keys in two trees are same ; move to the inorder successor ; If Node of first tree is smaller , than that of second tree , then its obvious that the inorder successors of current Node can have same value as that of the second tree Node . Thus , we pop from s2 ; root2 is set to NULL , because we need new Nodes of tree 1 ; Both roots and both stacks are empty ; A utility function to do inorder traversal ; A utility function to insert a new Node with given key in BST ; If the tree is empty , return a new Node ; Otherwise , recur down the tree ; return the ( unchanged ) Node pointer ; Driver Code ; Create first tree as shown in example ; Create second tree as shown in example",
        "Category": "Binary Tree"
    },
    {
        "ID": "7543-7543",
        "Code": "def findDisStr ( arr , N ) : NEW_LINE INDENT DistString = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] not in DistString ) : NEW_LINE INDENT DistString . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for string in DistString : NEW_LINE INDENT print ( string , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" Geeks \" , \" For \" , \" Geeks \" , \" Code \" , \" Coder \" ] NEW_LINE N = len ( arr ) NEW_LINE findDisStr ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all distinct strings from a given array | Function to find the distinct strings from the given array ; Stores distinct strings from the given array ; Traverse the array ; If current string not present into the set ; Insert current string into the set ; Traverse the set DistString ; Print distinct string ; Driver Code ; Stores length of the array",
        "Category": "Hash Table"
    },
    {
        "ID": "7546-7546",
        "Code": "def count_of_accident ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( n > m ) : NEW_LINE INDENT return ( m * ( m + 1 ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ) NEW_LINE DEDENT DEDENT def count_of_collision ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE answer = 0 NEW_LINE count_of_truck_in_lane_b = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( b [ i ] == ' T ' ) : NEW_LINE INDENT count_of_truck_in_lane_b += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i < m and i < n ) : NEW_LINE INDENT if ( a [ i ] == ' T ' ) : NEW_LINE INDENT answer += count_of_truck_in_lane_b NEW_LINE DEDENT if ( b [ i ] == ' T ' ) : NEW_LINE INDENT count_of_truck_in_lane_b -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT def findProbability ( a , b ) : NEW_LINE INDENT total_outcome = count_of_accident ( a , b ) ; NEW_LINE favourable_outcome = count_of_collision ( a , b ) ; NEW_LINE print ( favourable_outcome / total_outcome ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" TCCBCTTB \" NEW_LINE T = \" BTCCBBTT \" NEW_LINE findProbability ( S , T ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Probability of collision between two trucks | Function to calculate total number of accidents ; Function to calculate count of all possible collision ; Size of string ; Stores the count of collisions ; Total number of truck in lane b ; Count total number of collisions while traversing the string a ; Function to calculate the probability of collisions ; Evaluate total outcome that is all the possible accident ; Evaluate favourable outcome i . e . , count of collision of trucks ; Print desired probability ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7554-7554",
        "Code": "def uniqueMorseRep ( arr ) : NEW_LINE INDENT morseCode = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] ; NEW_LINE st = set ( ) ; NEW_LINE N = len ( arr ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE M = len ( arr [ i ] ) ; NEW_LINE for j in range ( M ) : NEW_LINE INDENT temp += morseCode [ ord ( arr [ i ] [ j ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT st . add ( temp ) ; NEW_LINE DEDENT return len ( st ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" gig \" , \" zeg \" , \" gin \" , \" msn \" ] ; NEW_LINE print ( uniqueMorseRep ( arr ) , \" \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count distinct strings possible by replacing each character by its Morse code | Function to count unique array elements by replacing each character by its Morse code ; Stores Morse code of all lowercase characters ; Stores distinct elements of String by replacing each character by Morse code ; Stores length of arr array ; Traverse the array ; Stores the Morse code of arr [ i ] ; Stores length of current String ; Update temp ; Insert temp into st ; Return count of elements in the set ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7555-7555",
        "Code": "def findFreq ( strr , N ) : NEW_LINE INDENT freq = [ 0 ] * 256 NEW_LINE max = 0 NEW_LINE charMax = '0' NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = ord ( strr [ i ] ) NEW_LINE freq [ ch ] += 1 NEW_LINE if ( freq [ ch ] >= max ) : NEW_LINE INDENT max = freq [ ch ] NEW_LINE charMax = ch NEW_LINE DEDENT print ( chr ( charMax ) , \" - > \" , max ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" abbc \" NEW_LINE N = len ( strr ) NEW_LINE findFreq ( strr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum repeating character for every index in given String | Function to print the maximum repeating character at each index of the string ; Stores frequency of each distinct character ; Stores frequency of maximum repeating character ; Stores the character having maximum frequency ; Traverse the string ; Stores current character ; Update the frequency of strr [ i ] ; If frequency of current character exceeds max ; Update max ; Update charMax ; Print the required output ; Driver Code ; Stores length of strr",
        "Category": "Hash Table"
    },
    {
        "ID": "7559-7559",
        "Code": "def checkValidDFA ( s ) : NEW_LINE INDENT initial_state = 0 NEW_LINE final_state = 0 NEW_LINE previous_state = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( s [ i ] == '0' and previous_state == 0 ) or ( s [ i ] == '1' and previous_state == 3 ) ) : NEW_LINE INDENT final_state = 1 NEW_LINE DEDENT elif ( ( s [ i ] == '0' and previous_state == 3 ) or ( s [ i ] == '1' and previous_state == 0 ) ) : NEW_LINE INDENT final_state = 2 NEW_LINE DEDENT elif ( ( s [ i ] == '0' and previous_state == 1 ) or ( s [ i ] == '1' and previous_state == 2 ) ) : NEW_LINE INDENT final_state = 0 NEW_LINE DEDENT elif ( ( s [ i ] == '0' and previous_state == 2 ) or ( s [ i ] == '1' and previous_state == 1 ) ) : NEW_LINE INDENT final_state = 3 NEW_LINE DEDENT previous_state = final_state NEW_LINE DEDENT if ( final_state == 3 ) : NEW_LINE INDENT print ( \" Accepted \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Accepted \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"010011\" NEW_LINE checkValidDFA ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to construct DFA accepting odd number of 0 s and odd number of 1 s | Function to check whether the given is accepted by DFA or not ; Stores initial state of DFA ; Stores final state of DFA ; Stores previous state of DFA ; Iterate through the string ; Checking for all combinations ; Update the previous_state ; If final state is reached ; Otherwise ; Driver Code ; Given string ; Function Call",
        "Category": "Graph Theory"
    },
    {
        "ID": "756-756",
        "Code": "def binarySearch ( inorder , l , r , d ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE if ( inorder [ mid ] == d ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( inorder [ mid ] > d ) : NEW_LINE INDENT return binarySearch ( inorder , l , mid - 1 , d ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( inorder , mid + 1 , r , d ) NEW_LINE DEDENT ind = [ 0 ] NEW_LINE DEDENT def leafNodesRec ( preorder , inorder , l , r , ind , n ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT print ( inorder [ l ] , end = \" ▁ \" ) NEW_LINE ind [ 0 ] = ind [ 0 ] + 1 NEW_LINE return NEW_LINE DEDENT if ( l < 0 or l > r or r >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT loc = binarySearch ( inorder , l , r , preorder [ ind [ 0 ] ] ) NEW_LINE ind [ 0 ] = ind [ 0 ] + 1 NEW_LINE leafNodesRec ( preorder , inorder , l , loc - 1 , ind , n ) NEW_LINE leafNodesRec ( preorder , inorder , loc + 1 , r , ind , n ) NEW_LINE DEDENT def leafNodes ( preorder , n ) : NEW_LINE INDENT inorder = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT inorder [ i ] = preorder [ i ] NEW_LINE DEDENT inorder . sort ( ) NEW_LINE ind = [ 0 ] NEW_LINE leafNodesRec ( preorder , inorder , 0 , n - 1 , ind , n ) NEW_LINE DEDENT preorder = [ 890 , 325 , 290 , 530 , 965 ] NEW_LINE n = len ( preorder ) NEW_LINE leafNodes ( preorder , n ) NEW_LINE",
        "Type": "py",
        "NL": "Leaf nodes from Preorder of a Binary Search Tree | Binary Search ; Poto the index in preorder . ; Function to prLeaf Nodes by doing preorder traversal of tree using preorder and inorder arrays . ; If l == r , therefore no right or left subtree . So , it must be leaf Node , print it . ; If array is out of bound , return . ; Finding the index of preorder element in inorder array using binary search . ; Incrementing the index . ; Finding on the left subtree . ; Finding on the right subtree . ; Finds leaf nodes from given preorder traversal . ; To store inorder traversal ; Copy the preorder into another array . ; Finding the inorder by sorting the array . ; Print the Leaf Nodes . ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7563-7563",
        "Code": "def minCost ( s , n ) : NEW_LINE INDENT minValue = 100000000 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT cnt += min ( abs ( i - ( ord ( s [ j ] ) - ord ( ' a ' ) ) ) , 26 - abs ( i - ( ord ( s [ j ] ) - ord ( ' a ' ) ) ) ) NEW_LINE DEDENT minValue = min ( minValue , cnt ) NEW_LINE DEDENT return minValue NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" geeksforgeeks \" NEW_LINE N = len ( st ) NEW_LINE print ( minCost ( st , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize replacements by previous or next alphabet required to make all characters of a string the same | Function to find the minimum count of operations to make all characters of the string same ; Set min to some large value ; Find minimum operations for each character ; Initialize cnt ; Add the value to cnt ; Update minValue ; Return minValue ; Driver Code ; Given string str ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7565-7565",
        "Code": "def max_len ( s , N , M ) : NEW_LINE INDENT set_str = { } NEW_LINE for i in s : NEW_LINE INDENT set_str [ i ] = 1 NEW_LINE DEDENT left_ans , right_ans = [ ] , [ ] NEW_LINE mid = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = s [ i ] NEW_LINE t = t [ : : - 1 ] NEW_LINE if ( t == s [ i ] ) : NEW_LINE INDENT mid = t NEW_LINE DEDENT elif ( t in set_str ) : NEW_LINE INDENT left_ans . append ( s [ i ] ) NEW_LINE right_ans . append ( t ) NEW_LINE del set_str [ s [ i ] ] NEW_LINE del set_str [ t ] NEW_LINE DEDENT DEDENT for x in left_ans : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT print ( mid , end = \" \" ) NEW_LINE right_ans = right_ans [ : : - 1 ] NEW_LINE for x in right_ans : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE s = [ \" omg \" , \" bbb \" , \" ffd \" , \" gmo \" ] NEW_LINE max_len ( s , N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest palindromic string possible by concatenating strings from a given array | Python3 program for the above approach ; Stores the distinct strings from the given array ; Insert the strings into set ; Stores the left and right substrings of the given string ; Stores the middle substring ; Traverse the array of strings ; Reverse the current string ; Checking if the is itself a palindrome or not ; Check if the reverse of the is present or not ; Append to the left substring ; Append to the right substring ; Erase both the strings from the set ; Print the left substring ; Print the middle substring ; Print the right substring ; Driver Code ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "7571-7571",
        "Code": "def util ( sub ) : NEW_LINE INDENT n = len ( sub ) NEW_LINE i = 0 NEW_LINE ret = \" \" NEW_LINE while i < n : NEW_LINE INDENT t = ( ord ( sub [ i ] ) - 97 ) + n - 1 - i NEW_LINE ch = chr ( t % 26 + 97 ) NEW_LINE ret = ret + ch NEW_LINE i = i + 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def manipulate ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE res = \" \" NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT res += util ( s [ j : j + i ] ) NEW_LINE res = res + \" ▁ \" NEW_LINE j = i + 1 NEW_LINE i = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT res = res + util ( s [ j : j + i ] ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" acm ▁ fkz \" NEW_LINE manipulate ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modify string by increasing each character by its distance from the end of the word | Function to transform and return the transformed word ; Stores resulting word ; Iterate over the word ; Add the position value to the letter ; Convert it back to character ; Add it to the string ; Function to transform the given string ; Size of string ; Stores resultant string ; Iterate over given string ; End of word is reached ; print ( s [ j : j + i ] ) Append the word ; For the last word ; Driver code ; Given string ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "7572-7572",
        "Code": "def ShortenString ( str1 ) : NEW_LINE INDENT st = [ ] NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT if len ( st ) == 0 or str1 [ i ] != st [ - 1 ] : NEW_LINE INDENT st . append ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if len ( st ) == 0 : NEW_LINE INDENT return ( \" Empty ▁ String \" ) NEW_LINE DEDENT else : NEW_LINE INDENT short_string = \" \" NEW_LINE for i in st : NEW_LINE INDENT short_string += str ( i ) NEW_LINE DEDENT return ( short_string ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" azzxzy \" NEW_LINE print ( ShortenString ( str1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove all duplicate adjacent characters from a string using Stack | Function to remove adjacent duplicate elements ; Store the string without duplicate elements ; Store the index of str ; Traverse the string str ; Checks if stack is empty or top of the stack is not equal to current character ; If top element of the stack is equal to the current character ; If stack is empty ; If stack is not Empty ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "7574-7574",
        "Code": "from math import log NEW_LINE def lenn ( A , B ) : NEW_LINE INDENT res = \" \" NEW_LINE logg = 0 NEW_LINE while True : NEW_LINE INDENT logg = log ( B ) // log ( 2 ) NEW_LINE if ( logg != 0 ) : NEW_LINE INDENT res += ( str ( A ) + \" < < \" + str ( int ( logg ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res += A NEW_LINE break NEW_LINE DEDENT B = B - pow ( 2 , logg ) NEW_LINE if ( B != 0 ) : NEW_LINE INDENT res += \" + \" NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT if logg == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def minimumString ( A , B ) : NEW_LINE INDENT res1 = lenn ( A , B ) NEW_LINE res2 = lenn ( B , A ) NEW_LINE if ( len ( res1 ) > len ( res2 ) ) : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 6 NEW_LINE B = 10 NEW_LINE minimumString ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest string without any multiplication sign that represents the product of two given numbers | Python3 program for the above approach ; Function to find the string which evaluates to the product of A and B ; Stores the result ; 2 ^ logg <= B && 2 ^ ( logg + 1 ) > B ; Update res to res += A X 2 ^ logg ; Update res to res += A X 2 ^ 0 ; Find the remainder ; If remainder is not equal to 0 ; Return the resultant string ; Function to find the minimum length representation of A * B ; Find representation of form A << k1 + A << k2 + ... + A << kn ; Find representation of form B << k1 + B << k2 + ... + B << kn ; Compare the length of the representations ; Driver Code ; Product A X B ; Function call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7578-7578",
        "Code": "def printResult ( result ) : NEW_LINE INDENT result = result [ : : - 1 ] NEW_LINE i = 0 NEW_LINE while ( i < len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def sumOfLargeNumbers ( v , k , N ) : NEW_LINE INDENT x = [ [ ] for i in range ( 1000 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT x [ i ] . append ( ord ( v [ i ] [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT carry = 0 NEW_LINE result = [ ] NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += x [ j ] [ i ] NEW_LINE DEDENT sum += carry NEW_LINE temp = sum NEW_LINE count = 0 NEW_LINE while ( temp > 9 ) : NEW_LINE INDENT temp = temp % 10 NEW_LINE count += 1 NEW_LINE DEDENT l = pow ( 10 , count ) NEW_LINE if ( l != 1 ) : NEW_LINE INDENT carry = sum / l NEW_LINE DEDENT sum = sum % 10 NEW_LINE result . append ( sum ) NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT a = carry % 10 NEW_LINE result . append ( a ) NEW_LINE carry = carry // 10 NEW_LINE DEDENT printResult ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 10 NEW_LINE N = 5 NEW_LINE arr = [ \"1111111111\" , \"1111111111\" , \"1111111111\" , \"1111111111\" , \"1111111111\" ] NEW_LINE sumOfLargeNumbers ( arr , N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of an array of large numbers | Function to prthe result of the summation of numbers having K - digit ; Reverse the array to obtain the result ; Print every digit of the answer ; Function to calculate the total sum ; Stores the array of large numbers in integer format ; Convert each element from character to integer ; Stores the carry ; Stores the result of summation ; Initialize the sum ; Calculate sum ; Update the sum by adding existing carry ; Store the number of digits ; Increase count of digits ; If the number exceeds 9 , Store the unit digit in carry ; Store the rest of the sum ; Append digit by digit into result array ; Append result until carry is 0 ; Print the result ; Driver Code ; Given N array of large numbers",
        "Category": "Array"
    },
    {
        "ID": "7579-7579",
        "Code": "def printRev ( strr ) : NEW_LINE INDENT strr = strr . split ( \" ▁ \" ) NEW_LINE st = [ ] NEW_LINE for i in strr : NEW_LINE INDENT st . append ( i ) NEW_LINE DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = \" ▁ \" ) NEW_LINE del st [ - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" geeks ▁ quiz ▁ practice ▁ code \" NEW_LINE printRev ( strr ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse words in a given string | Set 2 | Function to reverse the words of a given string ; Stack to store each word of the string ; Store the whole string in stream ; Push each word of the into the stack ; Print the in reverse order of the words ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "7583-7583",
        "Code": "def fact ( a ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , a + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT def permute ( n , r ) : NEW_LINE INDENT ans = 0 NEW_LINE ans = fact ( n ) // fact ( n - r ) NEW_LINE return ans NEW_LINE DEDENT def findPermutations ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT P = permute ( n , r ) NEW_LINE sum = sum + P NEW_LINE DEDENT return sum NEW_LINE DEDENT str = \" xz \" NEW_LINE n = len ( str ) NEW_LINE print ( findPermutations ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of distinct permutations of every possible length of given string | Function to find the factorial of a number ; Loop to find the factorial of the given number ; Function to find the number of permutations possible for a given string ; Function to find the total number of combinations possible ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7584-7584",
        "Code": "def charactersCount ( str , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur = str [ 0 ] ; NEW_LINE ind = 0 ; NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] < cur ) : NEW_LINE INDENT cur = str [ j ] ; NEW_LINE ind = j ; NEW_LINE DEDENT DEDENT str = str [ 0 : ind ] + str [ ind + 1 : ] ; NEW_LINE n -= 1 ; NEW_LINE count += ind + 1 ; NEW_LINE DEDENT print ( count ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" aabbc \" ; NEW_LINE n = 5 ; NEW_LINE charactersCount ( str , n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find value after N operations to remove N characters of string S with given constraints | Function to find the value after N operations to remove all the N characters of String S ; Iterate till N ; Remove character at ind and decrease n ( size of String ) ; Increase count by ind + 1 ; Driver Code ; Given String str ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "7586-7586",
        "Code": "def printMiddleCharacter ( str ) : NEW_LINE INDENT length = len ( str ) ; NEW_LINE middle = length // 2 ; NEW_LINE print ( str [ middle ] ) ; NEW_LINE DEDENT str = \" GeeksForGeeks \" ; NEW_LINE printMiddleCharacter ( str ) ; NEW_LINE",
        "Type": "py",
        "NL": "Print the middle character of a string | Function that prints the middle character of a string ; Finding string length ; Finding middle index of string ; Prthe middle character of the string ; Given string str ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "7588-7588",
        "Code": "def check ( s ) : NEW_LINE INDENT a = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if i in a : NEW_LINE INDENT return False NEW_LINE DEDENT a . add ( i ) NEW_LINE DEDENT return True NEW_LINE DEDENT def helper ( arr , ind ) : NEW_LINE INDENT if ( ind == len ( arr ) ) : NEW_LINE INDENT return [ \" \" ] NEW_LINE DEDENT tmp = helper ( arr , ind + 1 ) NEW_LINE ret = tmp NEW_LINE for i in tmp : NEW_LINE INDENT test = i + arr [ ind ] NEW_LINE if ( check ( test ) ) : NEW_LINE INDENT ret . append ( test ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT def maxLength ( arr ) : NEW_LINE INDENT tmp = helper ( arr , 0 ) NEW_LINE l = 0 NEW_LINE for i in tmp : NEW_LINE INDENT l = l if l > len ( i ) else len ( i ) NEW_LINE DEDENT return l NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( \" abcdefgh \" ) NEW_LINE print ( maxLength ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize length of the String by concatenating characters from an Array of Strings | Function to check if all the string characters are unique ; Check for repetition in characters ; Function to generate all possible strings from the given array ; Base case ; Consider every string as a starting substring and store the generated string ; Add current string to result of other strings and check if characters are unique or not ; Function to find the maximum possible length of a string ; Return max length possible ; Return the answer ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "759-759",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . key = item NEW_LINE self . left = self . right = None NEW_LINE self . parent = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print ( \" Node ▁ : \" , root . key , \" , ▁ \" , end = \" \" ) NEW_LINE if root . parent == None : NEW_LINE INDENT print ( \" Parent ▁ : ▁ NULL \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Parent ▁ : ▁ \" , root . parent . key ) NEW_LINE DEDENT inorder ( root . right ) NEW_LINE DEDENT DEDENT def insert ( node , key ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT lchild = insert ( node . left , key ) NEW_LINE node . left = lchild NEW_LINE lchild . parent = node NEW_LINE DEDENT elif key > node . key : NEW_LINE INDENT rchild = insert ( node . right , key ) NEW_LINE node . right = rchild NEW_LINE rchild . parent = node NEW_LINE DEDENT return node NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 50 ) NEW_LINE insert ( root , 30 ) NEW_LINE insert ( root , 20 ) NEW_LINE insert ( root , 40 ) NEW_LINE insert ( root , 70 ) NEW_LINE insert ( root , 60 ) NEW_LINE insert ( root , 80 ) NEW_LINE inorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Binary Search Tree insert with Parent Pointer | A utility function to create a new BST Node ; A utility function to do inorder traversal of BST ; A utility function to insert a new Node with given key in BST ; If the tree is empty , return a new Node ; Otherwise , recur down the tree ; Set parent of root of left subtree ; Set parent of root of right subtree ; return the ( unchanged ) Node pointer ; Driver Code ; Let us create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 ; print iNoder traversal of the BST",
        "Category": "Binary Tree"
    },
    {
        "ID": "7595-7595",
        "Code": "mod = 1000000007 NEW_LINE def binExp ( base , power ) : NEW_LINE INDENT x = 1 NEW_LINE while ( power ) : NEW_LINE INDENT if ( power % 2 == 1 ) : NEW_LINE INDENT x = ( ( ( x % mod ) * ( base % mod ) ) % mod ) NEW_LINE DEDENT base = ( ( ( base % mod ) * ( base % mod ) ) % mod ) NEW_LINE power = power // 2 NEW_LINE DEDENT return x NEW_LINE DEDENT def fact ( num ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT result = ( ( ( result % mod ) * ( i % mod ) ) % mod ) NEW_LINE DEDENT return result NEW_LINE DEDENT def calculate_nCi ( N , i ) : NEW_LINE INDENT nfact = fact ( N ) NEW_LINE ifact = fact ( i ) NEW_LINE dfact = fact ( N - i ) NEW_LINE inv_ifact = binExp ( ifact , mod - 2 ) NEW_LINE inv_dfact = binExp ( dfact , mod - 2 ) NEW_LINE denm = ( ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ) NEW_LINE answer = ( ( ( nfact % mod ) * ( denm % mod ) ) % mod ) NEW_LINE return answer NEW_LINE DEDENT def countSubstring ( N , s , k ) : NEW_LINE INDENT allWays = binExp ( 26 , N ) NEW_LINE noWays = 0 NEW_LINE for i in range ( s ) : NEW_LINE INDENT nCi = calculate_nCi ( N , i ) NEW_LINE remaining = binExp ( 25 , N - i ) NEW_LINE multiply = ( ( ( nCi % mod ) * ( remaining % mod ) ) % mod ) NEW_LINE noWays = ( ( ( noWays % mod ) + ( multiply % mod ) ) % mod ) NEW_LINE DEDENT answer = ( ( ( allWays % mod ) - ( noWays % mod ) ) % mod ) NEW_LINE if ( answer < 0 ) : NEW_LINE INDENT answer += mod NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" abc \" NEW_LINE k = 2 NEW_LINE s = len ( st ) NEW_LINE N = s + k NEW_LINE countSubstring ( N , s , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Distinct strings possible by inserting K characters in the original string | Python3 program for the above approach ; Function to calculate and return x ^ n in log ( n ) time using Binary Exponentiation ; Function to calculate the factorial of a number ; Function to calculate combination ; nCi = ( n ! ) / ( ( n - i ) ! * i ! ) ; Using Euler 's theorem of Modular  multiplicative inverse to find  the inverse of a number.  (1/a)%mod=a^(m?2)%mod ; Function to find the count of possible strings ; Number of ways to form all possible strings ; Number of ways to form strings that don 't contain the input  string as a subsequence ; Checking for all prefix length from 0 to | S | - 1. ; To calculate nCi ; Select the remaining characters 25 ^ ( N - i ) ; Add the answer for this prefix length to the final answer ; Answer is the difference of allWays and noWays ; Print the answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "7600-7600",
        "Code": "def count_minimum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n and ( s [ j ] == s [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT diff = j - i NEW_LINE ans += diff // 2 NEW_LINE i = j NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" caaab \" NEW_LINE count_minimum ( str ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum replacements in a string to make adjacent characters unequal | Function which counts the minimum number of required operations ; n stores the length of the string s ; ans will store the required ans ; i is the current index in the string ; Move j until characters s [ i ] & s [ j ] are equal or the end of the string is reached ; diff stores the length of the substring such that all the characters are equal in it ; We need atleast diff / 2 operations for this substring ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7602-7602",
        "Code": "def polynomialRollingHash ( str ) : NEW_LINE INDENT p = 31 NEW_LINE m = 1e9 + 9 NEW_LINE power_of_p = 1 NEW_LINE hash_val = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash_val = ( ( hash_val + ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) * power_of_p ) % m ) NEW_LINE power_of_p = ( power_of_p * p ) % m NEW_LINE DEDENT return int ( hash_val ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE print ( \" Hash ▁ of ▁ ' { } ' ▁ = ▁ { } \" . format ( str1 , polynomialRollingHash ( str1 ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "String hashing using Polynomial rolling hash function | Function to calculate the hash of a string ; P and M ; Loop to calculate the hash value by iterating over the elements of string ; Driver Code ; Given string",
        "Category": "Substring"
    },
    {
        "ID": "7603-7603",
        "Code": "def largestAnagramGrp ( arr ) : NEW_LINE INDENT prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 ] NEW_LINE max = - 1 NEW_LINE maxpdt = - 1 NEW_LINE W = { } NEW_LINE P = { } NEW_LINE for temp in arr : NEW_LINE INDENT c = [ i for i in temp ] NEW_LINE pdt = 1 NEW_LINE for t in c : NEW_LINE INDENT pdt *= prime [ ord ( t ) - ord ( ' a ' ) ] NEW_LINE DEDENT if ( pdt in P ) : NEW_LINE INDENT P [ pdt ] = P . get ( pdt , 0 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT W [ pdt ] = temp NEW_LINE P [ pdt ] = 1 NEW_LINE DEDENT DEDENT for e in P : NEW_LINE INDENT if ( max < P [ e ] ) : NEW_LINE INDENT max = P [ e ] NEW_LINE maxpdt = e NEW_LINE DEDENT DEDENT return W [ maxpdt ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" please ▁ be ▁ silent ▁ and ▁ listen ▁ to ▁ what ▁ the ▁ professor ▁ says \" NEW_LINE arr = S . split ( \" ▁ \" ) NEW_LINE print ( largestAnagramGrp ( arr ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the word with most anagrams in a given sentence | Function to find the word with maximum number of anagrams ; Primes assigned to 26 alphabets ; Stores the product and word mappings ; Stores the frequencies of products ; Calculate the product of primes assigned ; If product already exists ; Otherwise ; Fetch the most frequent product ; Return a string with that product ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "7608-7608",
        "Code": "def isPalindrome ( Str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( Str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def makeOddString ( Str ) : NEW_LINE INDENT odd = \" \" NEW_LINE for i in range ( 1 , len ( Str ) , 2 ) : NEW_LINE INDENT odd += Str [ i ] NEW_LINE DEDENT return odd NEW_LINE DEDENT def makeevenString ( Str ) : NEW_LINE INDENT even = \" \" NEW_LINE for i in range ( 0 , len ( Str ) , 2 ) : NEW_LINE INDENT even += Str [ i ] NEW_LINE DEDENT return even NEW_LINE DEDENT def checkevenOddPalindrome ( Str ) : NEW_LINE INDENT odd = makeOddString ( Str ) NEW_LINE even = makeevenString ( Str ) NEW_LINE if ( isPalindrome ( odd ) and isPalindrome ( even ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT Str = \" abzzab \" NEW_LINE checkevenOddPalindrome ( Str ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a given string is Even | Function to check if the string str is palindromic or not ; Pointers to iterate the string from both ends ; If characters are found to be distinct ; Return true if the string is palindromic ; Function to generate string from characters at odd indices ; Function to generate string from characters at even indices ; Functions to checks if string is Even - Odd Palindrome or not ; Generate odd indexed string ; Generate even indexed string ; Check for Palindrome ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "7610-7610",
        "Code": "def print_next_vovel_string ( st ) : NEW_LINE INDENT m = { } NEW_LINE m [ ' a ' ] = 0 NEW_LINE m [ ' e ' ] = 1 NEW_LINE m [ ' i ' ] = 2 NEW_LINE m [ ' o ' ] = 3 NEW_LINE m [ ' u ' ] = 4 NEW_LINE arr = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE N = len ( st ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT c = st [ i ] NEW_LINE if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT index = m [ st [ i ] ] + 1 NEW_LINE newindex = index % 5 NEW_LINE st = st . replace ( st [ i ] , arr [ newindex ] , 1 ) NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" geeksforgeeks \" NEW_LINE print ( print_next_vovel_string ( st ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Replace every vowels with lexicographically next vowel in a String | Function to replace every vowel with next vowel lexicographically ; Storing the vowels in the map with custom numbers showing their index ; Iterate over the string ; If the current character is a vowel Find the index in Hash and Replace it with next vowel from Hash ; Driver function",
        "Category": "Hash Table"
    },
    {
        "ID": "7612-7612",
        "Code": "def isPalindrome ( str ) : NEW_LINE INDENT l = 0 ; NEW_LINE h = len ( str ) - 1 ; NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True ; NEW_LINE DEDENT def makeOddString ( str ) : NEW_LINE INDENT odd = \" \" ; NEW_LINE for i in range ( 1 , len ( str ) , 2 ) : NEW_LINE INDENT odd += str [ i ] ; NEW_LINE DEDENT return odd ; NEW_LINE DEDENT def checkOddlyPalindrome ( str ) : NEW_LINE INDENT odd = makeOddString ( str ) ; NEW_LINE if ( isPalindrome ( odd ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT str = \" ddwfefwde \" ; NEW_LINE checkOddlyPalindrome ( str ) ; NEW_LINE",
        "Type": "py",
        "NL": "Check given string is oddly palindrome or not | Function to check if the string str is palindromic or not ; Iterate the string str from left and right pointers ; Keep comparing characters while they are same ; If they are not same then return false ; Return true if the string is palindromic ; Function to make string using odd indices of string str ; Functions checks if characters at odd index of the string forms palindrome or not ; Make odd indexed string ; Check for Palindrome ; Given string ; Function call",
        "Category": "Two Pointers"
    },
    {
        "ID": "7615-7615",
        "Code": "def decrypt ( Str , Start , End ) : NEW_LINE INDENT if ( Start > End ) : NEW_LINE INDENT return ; NEW_LINE DEDENT mid = ( Start + End ) >> 1 ; NEW_LINE print ( Str [ mid ] , end = \" \" ) ; NEW_LINE decrypt ( Str , mid + 1 , End ) ; NEW_LINE decrypt ( Str , Start , mid - 1 ) ; NEW_LINE DEDENT N = 4 ; NEW_LINE Str = \" abcd \" ; NEW_LINE decrypt ( Str , 0 , N - 1 ) ; NEW_LINE print ( ) ; NEW_LINE N = 6 ; NEW_LINE Str = \" gyuitp \" ; NEW_LINE decrypt ( Str , 0 , N - 1 ) ; NEW_LINE",
        "Type": "py",
        "NL": "String formed with middle character of every right substring followed by left sequentially | Function to decrypt and print the new string ; If the whole string has been traversed ; To calculate middle index of the string ; Print the character at middle index ; Recursively call for right - substring ; Recursive call for left - substring ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "762-762",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE self . leftSize = 0 NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return newNode ( data ) NEW_LINE DEDENT if data <= root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE root . leftSize += 1 NEW_LINE DEDENT else : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def getRank ( root , x ) : NEW_LINE INDENT if root . data == x : NEW_LINE INDENT return root . leftSize NEW_LINE DEDENT if x < root . data : NEW_LINE INDENT if root . left is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return getRank ( root . left , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if root . right is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT rightSize = getRank ( root . right , x ) NEW_LINE if rightSize == - 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return root . leftSize + 1 + rightSize NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 4 , 4 , 5 , 9 , 7 , 13 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE root = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE DEDENT print ( \" Rank ▁ of \" , x , \" in ▁ stream ▁ is : \" , getRank ( root , x ) ) NEW_LINE x = 13 NEW_LINE print ( \" Rank ▁ of \" , x , \" in ▁ stream ▁ is : \" , getRank ( root , x ) ) NEW_LINE x = 8 NEW_LINE print ( \" Rank ▁ of \" , x , \" in ▁ stream ▁ is : \" , getRank ( root , x ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rank of an element in a stream | Python3 program to find rank of an element in a stream . ; Inserting a new Node . ; Updating size of left subtree . ; Function to get Rank of a Node x . ; Step 1. ; Step 2. ; Step 3. ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7620-7620",
        "Code": "visited = set ( ) NEW_LINE ans = [ ] NEW_LINE def dfs ( curr , D ) : NEW_LINE INDENT for c in range ( D ) : NEW_LINE INDENT c = str ( c ) NEW_LINE neighbour = curr + c NEW_LINE if neighbour not in visited : NEW_LINE INDENT visited . add ( neighbour ) NEW_LINE dfs ( neighbour [ 1 : ] , D ) NEW_LINE ans . append ( c ) NEW_LINE DEDENT DEDENT DEDENT def reqString ( N , D ) : NEW_LINE INDENT if ( N == 1 and D == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT start = ' ' . join ( [ '0' ] * ( N - 1 ) ) NEW_LINE dfs ( start , D ) NEW_LINE ans . extend ( [ '0' ] * ( N - 1 ) ) NEW_LINE return ' ' . join ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , D = 2 , 2 NEW_LINE print ( reqString ( N , D ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest number containing all possible N length permutations using digits 0 to D | Initialize set to see if all the possible permutations are present in the min length string ; To keep min length string ; Generate the required string ; Iterate over all possible character ; Append to make a new string ; If the new string is not visited ; Add in set ; Call the dfs function on the last d characters ; Base case ; Append '0' n - 1 times ; Call the DFS Function ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "7627-7627",
        "Code": "def isvowel ( ch ) : NEW_LINE INDENT return ( ch in \" aeiou \" ) NEW_LINE DEDENT def CountTotal ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE n = len ( s ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isvowel ( s [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( cnt * ( cnt + 1 ) // 2 ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT if ( cnt != 0 ) : NEW_LINE INDENT ans += ( cnt * ( cnt + 1 ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE print ( CountTotal ( s ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of substrings consisting only of vowels | function to check vowel or not ; Function to Count all substrings in a string which contains only vowels ; if current character is vowel ; increment ; Count all possible substring of calculated length ; Reset the length ; Add remaining possible substrings consisting of vowels occupying last indices of the string ; Driver Program",
        "Category": "Substring"
    },
    {
        "ID": "7628-7628",
        "Code": "def getTotCount ( num ) : NEW_LINE INDENT totCount = 1 NEW_LINE firstCount = 1 NEW_LINE temp = 1 NEW_LINE while ( not ( num & temp ) ) : NEW_LINE INDENT temp = temp << 1 NEW_LINE totCount += 1 NEW_LINE DEDENT firstCount = totCount NEW_LINE temp = num >> totCount NEW_LINE while ( temp ) : NEW_LINE INDENT totCount += 1 NEW_LINE temp = temp >> 1 NEW_LINE DEDENT return totCount , firstCount NEW_LINE DEDENT def flipBitsFromRightMostSetBit ( num ) : NEW_LINE INDENT totbit , firstbit = getTotCount ( num ) NEW_LINE num1 = num ^ ( ( 1 << totbit ) - 1 ) NEW_LINE num1 = num1 ^ ( ( 1 << firstbit ) - 1 ) NEW_LINE return num1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE print ( flipBitsFromRightMostSetBit ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number formed by flipping all bits to the left of rightmost set bit | Function to get the total count ; Moving until we get the rightmost set bit ; To get total number of bits in a number ; Function to find the integer formed after flipping all bits to the left of the rightmost set bit ; Find the total count of bits and the rightmost set bit ; XOR given number with the number which has is made up of only totbits set ; To avoid flipping the bits to the right of the set bit , take XOR with the number made up of only set firstbits ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7629-7629",
        "Code": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def isValid ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return ( isVowel ( s [ 0 ] ) ) NEW_LINE DEDENT if ( isVowel ( s [ 0 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] or not isVowel ( s [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findMaxLen ( s ) : NEW_LINE INDENT maxLen = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp = temp + s [ j ] NEW_LINE if ( isValid ( temp ) ) : NEW_LINE INDENT maxLen = ( max ( maxLen , ( j - i + 1 ) ) ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Str = \" aeoibsddaeiouudb \" NEW_LINE print ( findMaxLen ( Str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest substring of vowels with no two adjacent alphabets same | Function to check a character is vowel or not ; Function to check a substring is valid or not ; If size is 1 then check only first character ; If 0 'th character is  not vowel then invalid ; If two adjacent characters are same or i 'th char is  not vowel then invalid ; Function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; Stores max length of valid substring ; For current substring ; Check if substring is valid ; Size of substring is ( j - i + 1 ) ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "763-763",
        "Code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 ] NEW_LINE key = 20 NEW_LINE arraySize = len ( a ) NEW_LINE count = 0 NEW_LINE for i in range ( arraySize ) : NEW_LINE INDENT if a [ i ] <= key : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( \" Rank ▁ of \" , key , \" in ▁ stream ▁ is : \" , count - 1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rank of an element in a stream | Driver code",
        "Category": "Array"
    },
    {
        "ID": "7633-7633",
        "Code": "def power ( base , pwr ) : NEW_LINE INDENT res = 1 NEW_LINE while ( pwr > 0 ) : NEW_LINE INDENT if ( pwr & 1 ) : NEW_LINE INDENT res = res * base NEW_LINE DEDENT base = base * base NEW_LINE pwr >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countNonPalindromicString ( n , m ) : NEW_LINE INDENT total = power ( n , m ) NEW_LINE palindrome = power ( n , m // 2 + m % 2 ) NEW_LINE count = total - palindrome NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 5 NEW_LINE print ( countNonPalindromicString ( n , m ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of non | Iterative Function to calculate base ^ pow in O ( log y ) ; Function to return the count of non palindromic strings ; Count of strings using n characters with repetitions allowed ; Count of palindromic strings ; Count of non - palindromic strings ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7634-7634",
        "Code": "def BalancedNumber ( s ) : NEW_LINE INDENT Leftsum = 0 NEW_LINE Rightsum = 0 NEW_LINE for i in range ( 0 , int ( len ( s ) / 2 ) ) : NEW_LINE INDENT Leftsum = Leftsum + int ( s [ i ] ) NEW_LINE Rightsum = ( Rightsum + int ( s [ len ( s ) - 1 - i ] ) ) NEW_LINE DEDENT if ( Leftsum == Rightsum ) : NEW_LINE INDENT print ( \" Balanced \" , end =   ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Balanced \" , end =   ' ' ) NEW_LINE DEDENT DEDENT s = \"12321\" NEW_LINE BalancedNumber ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Check if the number is balanced | Function to check whether N is Balanced Number or not ; Calculating the Leftsum and rightSum simultaneously ; Typecasting each character to integer and adding the digit to respective sums ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "7635-7635",
        "Code": "mod = 1e9 + 7 NEW_LINE def expo ( base , exponent ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( exponent != 0 ) : NEW_LINE INDENT if ( ( exponent & 1 ) == 1 ) : NEW_LINE INDENT ans = ans * base NEW_LINE ans = ans % mod NEW_LINE DEDENT base = base * base NEW_LINE base %= mod NEW_LINE exponent >>= 1 NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT def findCount ( N ) : NEW_LINE INDENT ans = ( ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ) NEW_LINE ans += mod NEW_LINE ans %= mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE print ( int ( findCount ( N ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of N size strings consisting of at least one vowel and one consonant | Python3 program to count all possible strings of length N consisting of atleast one vowel and one consonant ; Function to return base ^ exponent ; Function to count all possible strings ; All possible strings of length N ; vowels only ; consonants only ; Return the final result ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "7639-7639",
        "Code": "import sys NEW_LINE def decompose ( S ) : NEW_LINE INDENT s = [ ] NEW_LINE N = len ( S ) NEW_LINE ans = 0 NEW_LINE nix = sys . maxsize NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( S [ i ] ) NEW_LINE nix = S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( S [ i ] < s [ - 1 ] ) : NEW_LINE INDENT s . append ( S [ i ] ) NEW_LINE nix = min ( nix , S [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT val = S [ i ] NEW_LINE while ( len ( s ) != 0 and val >= s [ - 1 ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT nix = min ( nix , S [ i ] ) ; NEW_LINE s . append ( nix ) NEW_LINE DEDENT DEDENT ans += len ( s ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = [ 9 , 6 , 9 , 35 ] NEW_LINE print ( decompose ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of decomposition values of all suffixes of an Array | Python3 implementation to find the sum of Decomposition values of all suffixes of an array ; Function to find the decomposition values of the array ; Stack ; Variable to maintain min value in stack ; Loop to iterate over the array ; Condition to check if the stack is empty ; Condition to check if the top of the stack is greater than the current element ; Loop to pop the element out ; The size of the stack is the max no of subarrays for suffix till index i from the right ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "7644-7644",
        "Code": "def minDel ( s1 , s2 ) : NEW_LINE INDENT i = len ( s1 ) NEW_LINE j = len ( s2 ) NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return i + j NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" peeks \" NEW_LINE print ( minDel ( s1 , s2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum characters to be deleted from the beginning of two strings to make them equal | Function that finds minimum character required to be deleted ; Iterate in the strings ; Check if the characters are not equal ; Return the result ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7648-7648",
        "Code": "def isBalanced ( exp ) : NEW_LINE INDENT flag = True NEW_LINE count = 0 NEW_LINE for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count < 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT return flag NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp1 = \" ( ( ( ) ) ) ( ) ( ) \" NEW_LINE if ( isBalanced ( exp1 ) ) : NEW_LINE INDENT print ( \" Balanced \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Balanced \" ) NEW_LINE DEDENT exp2 = \" ( ) ) ( ( ( ) ) \" NEW_LINE if ( isBalanced ( exp2 ) ) : NEW_LINE INDENT print ( \" Balanced \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Balanced \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given Parentheses expression is balanced or not | Function to check if parenthesis are balanced ; Initialising Variables ; Traversing the Expression ; It is a closing parenthesis ; This means there are more closing parenthesis than opening ; If count is not zero , it means there are more opening parenthesis ; Driver code",
        "Category": "Stack"
    },
    {
        "ID": "7650-7650",
        "Code": "map = { } NEW_LINE def isScramble ( S1 : str , S2 : str ) : NEW_LINE INDENT if len ( S1 ) != len ( S2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = len ( S1 ) NEW_LINE if not n : NEW_LINE INDENT return True NEW_LINE DEDENT if S1 == S2 : NEW_LINE INDENT return True NEW_LINE DEDENT if sorted ( S1 ) != sorted ( S2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT / * make key of type string for search in map * / NEW_LINE INDENT if ( S1 + ' ▁ ' + S2 in map ) : NEW_LINE INDENT return map [ S1 + ' ▁ ' + S2 ] NEW_LINE DEDENT flag = False NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( isScramble ( S1 [ : i ] , S2 [ : i ] ) and isScramble ( S1 [ i : ] , S2 [ i : ] ) ) : NEW_LINE INDENT flag = True NEW_LINE return True NEW_LINE DEDENT if ( isScramble ( S1 [ - i : ] , S2 [ : i ] ) and isScramble ( S1 [ : - i ] , S2 [ i : ] ) ) : NEW_LINE INDENT flag = True NEW_LINE return True NEW_LINE DEDENT DEDENT map [ S1 + \" ▁ \" + S2 ] = flag NEW_LINE return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S1 = \" great \" NEW_LINE S2 = \" rgate \" NEW_LINE if ( isScramble ( S1 , S2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string is a scrambled form of another string | Declaring unordered map globally ; Python3 program to check if a given string is a scrambled form of another string ; Strings of non - equal length cant ' be scramble strings ; Empty strings are scramble strings ; Equal strings are scramble strings ; Check for the condition of anagram ;  ; Checking if both Substrings are in map or are already calculated or not ; Declaring a flag variable ; Check if S2 [ 0. . . i ] is a scrambled string of S1 [ 0. . . i ] and if S2 [ i + 1. . . n ] is a scrambled string of S1 [ i + 1. . . n ] ; Check if S2 [ 0. . . i ] is a scrambled string of S1 [ n - i ... n ] and S2 [ i + 1. . . n ] is a scramble string of S1 [ 0. . . n - i - 1 ] ; Storing calculated value to map ; If none of the above conditions are satisfied ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "7652-7652",
        "Code": "def LongestPalindromicPrefix ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE max_len = 0 NEW_LINE for length in range ( 0 , n + 1 ) : NEW_LINE INDENT temp = string [ 0 : length ] NEW_LINE temp2 = temp NEW_LINE temp3 = temp2 [ : : - 1 ] NEW_LINE if temp == temp3 : NEW_LINE INDENT max_len = length NEW_LINE DEDENT DEDENT print ( string [ 0 : max_len ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" abaac \" ; NEW_LINE LongestPalindromicPrefix ( string ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print the longest palindromic prefix of a given string | Function to find the longest prefix which is palindrome ; Find the length of the given string ; For storing the length of longest Prefix Palindrome ; Loop to check the substring of all length from 1 to n which is palindrome ; String of length i ; To store the value of temp ; Reversing the value of temp ; If string temp is palindromic then update the length ; Print the palindromic string of max_len ; Driver code ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "7655-7655",
        "Code": "def checkWord ( board , word , index , row , col ) : NEW_LINE INDENT if ( row < 0 or col < 0 or row >= len ( board ) or col >= len ( board [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( board [ row ] [ col ] != word [ index ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( index == len ( word ) - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = board [ row ] [ col ] NEW_LINE board [ row ] [ col ] = ' * ' NEW_LINE if ( checkWord ( board , word , index + 1 , row + 1 , col ) or checkWord ( board , word , index + 1 , row - 1 , col ) or checkWord ( board , word , index + 1 , row , col + 1 ) or checkWord ( board , word , index + 1 , row , col - 1 ) ) : NEW_LINE INDENT board [ row ] [ col ] = temp NEW_LINE return True NEW_LINE DEDENT board [ row ] [ col ] = temp NEW_LINE return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT board = [ [ ' A ' , ' B ' , ' C ' , ' E ' ] , [ ' S ' , ' F ' , ' C ' , ' S ' ] , [ ' A ' , ' D ' , ' E ' , ' E ' ] ] NEW_LINE word = \" CFDASABCESEE \" NEW_LINE f = 0 NEW_LINE for i in range ( len ( board ) ) : NEW_LINE INDENT for j in range ( len ( board [ 0 ] ) ) : NEW_LINE INDENT if ( board [ i ] [ j ] == word [ 0 ] and checkWord ( board , word , 0 , i , j ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f == 1 : NEW_LINE break NEW_LINE DEDENT if f == 0 : NEW_LINE print ( \" False \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given string can be formed using characters of adjacent cells of a Matrix | Function to check if the word exists ; If index exceeds board range ; If the current cell does not contain the required character ; If the cell contains the required character and is the last character of the word required to be matched ; Return true as word is found ; Mark cell visited ; Check Adjacent cells for the next character ; Restore cell value ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "7656-7656",
        "Code": "def count ( N , X , subStr , index , n ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = subStr + N [ index ] NEW_LINE b = 0 NEW_LINE if ( int ( a ) % X == 0 ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT m1 = count ( N , X , a , index + 1 , n ) NEW_LINE m2 = b + count ( N , X , \" \" , index + 1 , n ) NEW_LINE return max ( m1 , m2 ) NEW_LINE DEDENT N = \"00001242\" NEW_LINE K = 3 NEW_LINE l = len ( N ) NEW_LINE print ( count ( N , K , \" \" , 0 , l ) ) NEW_LINE",
        "Type": "py",
        "NL": "Split the number N by maximizing the count of subparts divisible by K | Function to count the subparts ; Total subStr till now ; If it can be divided , then this substring is one of the possible answer ; Convert string to long long and check if its divisible with X ; Consider there is no vertical cut between this index and the next one , hence take total carrying total substr a . ; If there is vertical cut between this index and next one , then we start again with subStr as \" \" and add b for the count of subStr upto now ; Return max of both the cases ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "7670-7670",
        "Code": "import re NEW_LINE def RemoveHTMLTags ( strr ) : NEW_LINE INDENT print ( re . compile ( r ' < [ ^ > ] + > ' ) . sub ( ' ' , strr ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = \" < div > < b > Geeks ▁ for ▁ Geeks < / b > < / div > \" NEW_LINE RemoveHTMLTags ( strr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to remove HTML tags from a given String | Python3 program for the above approach ; Function to remove the HTML tags from the given tags ; Print string after removing tags ; Driver code ; Given String ; Function call to print the HTML string after removing tags",
        "Category": "Substring"
    },
    {
        "ID": "7673-7673",
        "Code": "def removeRepeating ( s1 , s2 ) : NEW_LINE INDENT s3 = s1 + \" ▁ \" + s2 + \" ▁ \" NEW_LINE words = \" \" NEW_LINE i = 0 NEW_LINE for x in s3 : NEW_LINE INDENT if ( x == ' ▁ ' ) : NEW_LINE INDENT if ( words not in s1 or words not in s2 ) : NEW_LINE INDENT print ( words , end = \" \" ) NEW_LINE DEDENT words = \" ▁ \" NEW_LINE DEDENT else : NEW_LINE INDENT words = words + x NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" I ▁ have ▁ go ▁ a ▁ pen \" NEW_LINE s2 = \" I ▁ want ▁ to ▁ go ▁ park \" NEW_LINE removeRepeating ( s1 , s2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all the non | Function to print all the non - repeating words from the two given sentences ; Concatenate the two strings into one ; Iterating over the whole concatenated string ; Searching for the word in A . If while searching , we reach the end of the string , then the word is not present in the string ; Initialise word for the next iteration ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7674-7674",
        "Code": "def convert ( input ) : NEW_LINE INDENT Len = len ( input ) NEW_LINE i = 0 NEW_LINE while ( i < Len ) : NEW_LINE INDENT if ( input [ i ] == \" , \" ) : NEW_LINE INDENT input = input [ : i ] + input [ i + 1 : ] NEW_LINE Len -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT elif ( input [ i ] == \" ▁ \" ) : NEW_LINE INDENT input = input [ : i ] + input [ i + 1 : ] NEW_LINE Len -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT input = input [ : : - 1 ] NEW_LINE output = \" \" NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( i == 2 ) : NEW_LINE INDENT output += input [ i ] NEW_LINE output += \" ▁ , \" NEW_LINE DEDENT elif ( i > 2 and i % 2 == 0 and i + 1 < Len ) : NEW_LINE INDENT output += input [ i ] NEW_LINE output += \" ▁ , \" NEW_LINE DEDENT else : NEW_LINE INDENT output += input [ i ] NEW_LINE DEDENT DEDENT output = output [ : : - 1 ] NEW_LINE return output NEW_LINE DEDENT input1 = \"123 , ▁ 456 , ▁ 789\" NEW_LINE input2 = \"90 , ▁ 050 , ▁ 000 , ▁ 000\" NEW_LINE print ( convert ( input1 ) ) NEW_LINE print ( convert ( input2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Convert the number from International system to Indian system | Function to convert a number represented in International numeric system to Indian numeric system . ; Find the length of the input string ; Removing all the separators ( , ) from the input string ; Reverse the input string ; Declaring the output string ; Process the input string ; Add a separator ( , ) after the third number ; Then add a separator ( , ) after every second number ; Reverse the output string ; Return the output string back to the main function ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7675-7675",
        "Code": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sqt = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , sqt ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossibleSum ( N ) : NEW_LINE INDENT if ( isPrime ( N ) and isPrime ( N - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT return cnt == 2 NEW_LINE DEDENT def makeCypherString ( N ) : NEW_LINE INDENT semiPrime = \" \" NEW_LINE sumOfPrime = \" \" NEW_LINE st = str ( N ) NEW_LINE if ( checkSemiprime ( N ) ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT semiPrime += st [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT semiPrime += chr ( ord ( st [ i ] ) - ord ( '0' ) + 65 ) NEW_LINE DEDENT DEDENT DEDENT if ( isPossibleSum ( N ) ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sumOfPrime += chr ( ord ( st [ i ] ) - ord ( '0' ) + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT sumOfPrime += st [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( semiPrime + sumOfPrime == \" \" ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( semiPrime + sumOfPrime ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 1011243 NEW_LINE makeCypherString ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct the Cypher string based on the given conditions | Python3 program for the above approach ; Function to check whether a number is prime or not ; Function to check if a prime number can be expressed as sum of two Prime Numbers ; If the N && ( N - 2 ) is Prime ; Function to check semiPrime ; Loop from 2 to sqrt ( num ) ; Increment the count of prime numbers ; If num is greater than 1 , then add 1 to it ; Return '1' if count is 2 else return '0 ; Function to make the Cypher string ; Resultant string ; Make string for the number N ; Check for semiPrime ; Traverse to make Cypher string ; If index is odd add the current character ; Else current character is changed ; Check for sum of two primes ; Traverse to make Cypher string ; If index is odd then current character is changed ; Else add the current character ; If the resultant string is \" \" then print - 1 ; Else print the resultant string ; Driver Code ; Given number ; Function call",
        "Category": "Math"
    },
    {
        "ID": "7678-7678",
        "Code": "def findStr ( S ) : NEW_LINE INDENT S = list ( S ) NEW_LINE n = len ( S ) NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE DEDENT ' NEW_LINE INDENT if S [ i ] != ' a ' : NEW_LINE INDENT S [ i ] = ' a ' NEW_LINE return ( ' ' . join ( S ) ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT S [ n - 1 ] = ' b ' NEW_LINE if n < 2 : NEW_LINE INDENT return ' - 1' NEW_LINE DEDENT else : NEW_LINE INDENT return ( ' ' . join ( S ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = ' a ' NEW_LINE print ( findStr ( str1 ) ) NEW_LINE str2 = ' abccba ' NEW_LINE print ( findStr ( str2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Make the string lexicographically smallest and non palindromic by replacing exactly one character | Function to find the required string ; Length of the string ; Iterate till half of the string ; Replacing a non ' a ' char with 'a ; Check if there is no ' a ' in string we replace last char of string by 'b ; If the input is a single character ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7685-7685",
        "Code": "class TreeNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . parent = None NEW_LINE self . children = [ ] NEW_LINE DEDENT def addChild ( self , node ) : NEW_LINE INDENT self . children . append ( node ) ; NEW_LINE DEDENT def setParent ( self , node ) : NEW_LINE INDENT self . parent = node ; NEW_LINE DEDENT def getParent ( self ) : NEW_LINE INDENT return self . parent ; NEW_LINE DEDENT def computeScore ( self ) : NEW_LINE INDENT if ( len ( self . children ) == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT res = 0 ; NEW_LINE for curr in self . children : NEW_LINE INDENT res += curr . computeScore ( ) ; NEW_LINE DEDENT if ( self . parent == None ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * res ; NEW_LINE DEDENT DEDENT DEDENT def computeTree ( s ) : NEW_LINE INDENT current = TreeNode ( ) ; NEW_LINE root = current ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT child = TreeNode ( ) ; NEW_LINE child . setParent ( current ) ; NEW_LINE current . addChild ( child ) ; NEW_LINE current = child ; NEW_LINE DEDENT else : NEW_LINE INDENT current = current . getParent ( ) ; NEW_LINE DEDENT DEDENT return root ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ( ( ) ( ( ) ) ) \" ; NEW_LINE root = computeTree ( s ) ; NEW_LINE print ( root . computeScore ( ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Score of Parentheses using Tree | Customized tree class or struct , contains all required methods . ; Function to add a child into the list of children ; Function to change the parent pointer to the node passed ; Function to return the parent of the current node ; Function to compute the score recursively . ; Base case ; Adds scores of all children ; Function to create the tree structure ; Creating a node for every \" ( ) \" ; If we find \" ( \" we add a node as a child ; On finding \" ) \" which confirms that a pair is closed , we go back to the parent ; Driver code ; Generating the tree ; Computing the score",
        "Category": "Binary Tree"
    },
    {
        "ID": "7686-7686",
        "Code": "MAX = 500001 NEW_LINE parent = [ 0 ] * MAX NEW_LINE Rank = [ 0 ] * MAX NEW_LINE def find ( x ) : NEW_LINE INDENT if parent [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return find ( parent [ x ] ) NEW_LINE DEDENT DEDENT def merge ( r1 , r2 ) : NEW_LINE INDENT if ( r1 != r2 ) : NEW_LINE INDENT if ( Rank [ r1 ] > Rank [ r2 ] ) : NEW_LINE INDENT parent [ r2 ] = r1 NEW_LINE Rank [ r1 ] += Rank [ r2 ] NEW_LINE DEDENT else : NEW_LINE INDENT parent [ r1 ] = r2 NEW_LINE Rank [ r2 ] += Rank [ r1 ] NEW_LINE DEDENT DEDENT DEDENT def minimumOperations ( s1 , s2 ) : NEW_LINE INDENT for i in range ( 1 , 26 + 1 ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE Rank [ i ] = 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT if ( find ( ord ( s1 [ i ] ) - 96 ) != find ( ord ( s2 [ i ] ) - 96 ) ) : NEW_LINE INDENT x = find ( ord ( s1 [ i ] ) - 96 ) NEW_LINE y = find ( ord ( s2 [ i ] ) - 96 ) NEW_LINE merge ( x , y ) NEW_LINE ans . append ( [ s1 [ i ] , s2 [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i [ 0 ] , \" - > \" , i [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" abb \" NEW_LINE s2 = \" dad \" NEW_LINE minimumOperations ( s1 , s2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of operations required to make two strings equal | Python3 implementation to find the minimum number of operations to make two strings equal ; Function to find out parent of an alphabet ; Function to merge two different alphabets ; Merge a and b using rank compression ; Function to find the minimum number of operations required ; Initializing parent to i and rank ( size ) to 1 ; We will store our answerin this list ; Traversing strings ; If they have different parents ; Find their respective parents and merge them ; Store this in our Answer list ; Number of operations ; Driver code ; Two strings S1 and S2 ; Function Call",
        "Category": "Graph Theory"
    },
    {
        "ID": "7689-7689",
        "Code": "def GeberateDefangIP ( str ) : NEW_LINE INDENT defangIP = \" \" ; NEW_LINE for c in str : NEW_LINE INDENT if ( c == ' . ' ) : NEW_LINE INDENT defangIP += \" [ . ] \" NEW_LINE DEDENT else : NEW_LINE INDENT defangIP += c ; NEW_LINE DEDENT DEDENT return defangIP ; NEW_LINE DEDENT str = \"255.100.50.0\" ; NEW_LINE print ( GeberateDefangIP ( str ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Defanged Version of Internet Protocol Address | Function to generate a defanged version of IP address . ; Loop to iterate over the characters of the string ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "7696-7696",
        "Code": "def generateTheString ( n ) : NEW_LINE INDENT ans = \" \" NEW_LINE if ( n % 2 ) : NEW_LINE INDENT for i in range ( min ( n , 24 ) ) : NEW_LINE INDENT ans += chr ( ord ( ' b ' ) + i ) NEW_LINE DEDENT if ( n > 24 ) : NEW_LINE INDENT for i in range ( ( n - 24 ) ) : NEW_LINE INDENT ans += ' a ' NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( min ( n , 25 ) ) : NEW_LINE INDENT ans += chr ( ord ( ' b ' ) + i ) NEW_LINE DEDENT if ( n > 25 ) : NEW_LINE INDENT for i in range ( ( n - 25 ) ) : NEW_LINE INDENT ans += ' a ' NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 34 NEW_LINE print ( generateTheString ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate a string with maximum possible alphabets with odd frequencies | Function to generate a string of length n with maximum possible alphabets each occuring odd number of times . ; If n is odd ; Add all characters from b - y ; Append a to fill the remaining length ; If n is even ; Add all characters from b - z ; Append a to fill the remaining length ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7697-7697",
        "Code": "def moveAtEnd ( s , i , l ) : NEW_LINE INDENT if ( i >= l ) : NEW_LINE return NEW_LINE curr = s [ i ] NEW_LINE DEDENT ' NEW_LINE INDENT if ( curr != ' x ' ) : NEW_LINE INDENT print ( curr , end = \" \" ) NEW_LINE DEDENT moveAtEnd ( s , i + 1 , l ) NEW_LINE DEDENT ' NEW_LINE INDENT if ( curr == ' x ' ) : NEW_LINE INDENT print ( curr , end = \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geekxsforgexxeksxx \" NEW_LINE l = len ( s ) NEW_LINE moveAtEnd ( s , 0 , l ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Move all occurrence of letter ' x ' from the string s to the end using Recursion | Function to move all ' x ' in the end ; Store current character ; Check if current character is not 'x ; Recursive function call ; Check if current character is 'x ; Driver code",
        "Category": "Recursion"
    },
    {
        "ID": "7698-7698",
        "Code": "def rec ( a , i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT a . pop ( ) NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE return NEW_LINE DEDENT if ( a [ i ] == ' x ' ) : NEW_LINE j = i NEW_LINE while ( a [ j ] != ' \\0' and a [ j + 1 ] != ' \\0' ) : NEW_LINE INDENT ( a [ j ] , a [ j + 1 ] ) = ( a [ j + 1 ] , a [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT rec ( a , i - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ ' g ' , ' e ' , ' e ' , ' k ' , ' x ' , ' s ' , ' x ' , ' x ' , ' k ' , ' s ' , ' \\0' ] NEW_LINE n = 10 NEW_LINE rec ( a , n - 1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Move all occurrence of letter ' x ' from the string s to the end using Recursion | Recursive program to bring ' x ' to the end ; When the string is completed from reverse direction end of recursion ; If the character x is found ; Transverse the whole string ; Swap the x so that it moves to the last ; Call to the smaller problem now ; Driver code ; Size of a ; Call to rec",
        "Category": "Recursion"
    },
    {
        "ID": "7699-7699",
        "Code": "def String ( l , x , y ) : NEW_LINE INDENT p = 97 NEW_LINE for j in range ( l ) : NEW_LINE INDENT ans = chr ( p + j % y ) NEW_LINE print ( ans , end = \" \" ) NEW_LINE DEDENT DEDENT l = 6 NEW_LINE x = 5 NEW_LINE y = 3 NEW_LINE String ( l , x , y ) NEW_LINE",
        "Type": "py",
        "NL": "Construct a string of length L such that each substring of length X has exactly Y distinct letters | Python implementation to construct a string of length L such that each substring of length X has exactly Y distinct letters . ; Initialize p equal to the ASCII value of a ; Iterate till the length of the string ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7708-7708",
        "Code": "def removeDuplicates ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE s = set ( ) NEW_LINE res = \" \" NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] not in s ) : NEW_LINE INDENT res = res + str [ i ] NEW_LINE s . add ( str [ i ] ) NEW_LINE DEDENT DEDENT res = res [ : : - 1 ] NEW_LINE return res NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE print ( removeDuplicates ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Remove duplicates from string keeping the order according to last occurrences | Python3 program to remove duplicate character from character array and prin sorted order ; Used as index in the modified string ; Create an empty hash table ; Traverse through all characters from right to left ; If current character is not in ; Reverse the result string ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7711-7711",
        "Code": "max1 = 0 NEW_LINE def MaxLength ( v , i , m ) : NEW_LINE INDENT global max1 NEW_LINE if ( i >= m ) : NEW_LINE INDENT return m - 1 NEW_LINE DEDENT for k in range ( 26 ) : NEW_LINE INDENT c = chr ( ord ( ' a ' ) + k ) NEW_LINE v1 = [ ] NEW_LINE for j in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ j ] [ i ] == c ) : NEW_LINE INDENT v1 . append ( v [ j ] ) NEW_LINE DEDENT DEDENT if ( len ( v1 ) >= 2 ) : NEW_LINE INDENT max1 = max ( max1 , MaxLength ( v1 , i + 1 , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT max1 = max ( max1 , i - 1 ) NEW_LINE DEDENT DEDENT return max1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" abcde \" NEW_LINE s2 = \" abcsd \" NEW_LINE s3 = \" bcsdf \" NEW_LINE s4 = \" abcda \" NEW_LINE s5 = \" abced \" NEW_LINE v = [ ] NEW_LINE v . append ( s1 ) NEW_LINE v . append ( s2 ) NEW_LINE v . append ( s3 ) NEW_LINE v . append ( s4 ) NEW_LINE v . append ( s5 ) NEW_LINE m = len ( v [ 0 ] ) NEW_LINE print ( MaxLength ( v , 0 , m ) + 1 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest string which is prefix string of at least two strings | Python3 program to find longest string which is prefix string of at least two strings ; Function to find max length of the prefix ; Base case ; Iterating over all the alphabets ; Checking if char exists in current string or not ; If atleast 2 string have that character ; Recursive call to i + 1 ; Driver code ; Initialising strings ; Push strings into vectors .",
        "Category": "Substring"
    },
    {
        "ID": "7725-7725",
        "Code": "def printPalindrome ( left , mid , right ) : NEW_LINE INDENT for x in left : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT print ( mid , end = \" \" ) NEW_LINE right = right [ : : - 1 ] NEW_LINE for x in right : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT print ( ' ' , end = \" \" ) NEW_LINE DEDENT def findPalindrome ( S , N , M ) : NEW_LINE INDENT d = set ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT d . add ( S [ i ] ) NEW_LINE DEDENT left = [ ] NEW_LINE right = [ ] NEW_LINE mid = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = S [ i ] NEW_LINE t = t [ : : - 1 ] NEW_LINE if ( t == S [ i ] ) : NEW_LINE INDENT mid = t NEW_LINE DEDENT elif ( t in d ) : NEW_LINE INDENT left . append ( S [ i ] ) NEW_LINE right . append ( t ) NEW_LINE d . remove ( S [ i ] ) NEW_LINE d . remove ( t ) NEW_LINE DEDENT DEDENT printPalindrome ( left , mid , right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = [ \" tab \" , \" one \" , \" bat \" ] NEW_LINE M = 3 NEW_LINE N = len ( S ) NEW_LINE findPalindrome ( S , N , M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest palindrome formed by concatenating and reordering strings of equal length | Function to print the longest palindrome ; Printing every string in left vector ; Printing the palindromic string in the middle ; Printing the reverse of the right vector to make the final output palindromic ; Function to find and print the longest palindrome that can be formed ; Inserting each string in the set ; Vectors to add the strings in the left and right side ; To add the already present palindrome string in the middle of the solution ; Iterating through all the given strings ; If the string is a palindrome it is added in the middle ; Checking if the reverse of the string is already present in the set ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7729-7729",
        "Code": "def IsLexicographicallySmaller ( A , B ) : NEW_LINE INDENT if ( A < B ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = A NEW_LINE temp = ' ' . join ( sorted ( temp ) ) NEW_LINE index = - 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] != temp [ i ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == temp [ index ] ) : NEW_LINE INDENT j = i NEW_LINE DEDENT DEDENT A = list ( A ) NEW_LINE A [ index ] , A [ j ] = A [ j ] , A [ index ] NEW_LINE A = ' ' . join ( A ) NEW_LINE if ( A < B ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = \" AGAIN \" NEW_LINE B = \" ACTION \" NEW_LINE if ( IsLexicographicallySmaller ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smaller string by swapping at most one character pair | Function that finds whether is it possible to make string A lexicographically smaller than string B ; Condition if string A is already smaller than B ; Sorting temp string ; Condition for first changed character of string A and temp ; Condition if string A is already sorted ; Finding first changed character from last of string A ; Swap the two characters ; Condition if string A is smaller than B ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7737-7737",
        "Code": "def LexicoLesserStrings ( s ) : NEW_LINE INDENT count = 0 NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT count += ( ( ord ( s [ i ] ) - ord ( ' a ' ) ) * pow ( 26 , length - i - 1 ) ) NEW_LINE DEDENT return count NEW_LINE DEDENT def countString ( S1 , S2 ) : NEW_LINE INDENT countS1 = LexicoLesserStrings ( S1 ) NEW_LINE countS2 = LexicoLesserStrings ( S2 ) NEW_LINE totalString = countS2 - countS1 - 1 ; NEW_LINE return ( 0 if totalString < 0 else totalString ) NEW_LINE DEDENT S1 = \" cda \" ; NEW_LINE S2 = \" cef \" ; NEW_LINE print ( countString ( S1 , S2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of same length Strings that exists lexicographically in between two given Strings | Function to find the count of strings less than given string lexicographically ; Find length of string s ; Looping over the string characters and finding strings less than that character ; Function to find the count of same length Strings that exists lexicographically in between two given Strings ; Count string less than S1 ; Count string less than S2 ; Total strings between S1 and S2 would be difference between the counts - 1 ; If S1 is lexicographically greater than S2 then return 0 , otherwise return the value of totalString ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7740-7740",
        "Code": "def findString ( A , B ) : NEW_LINE INDENT dist = 0 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT dist += 1 ; NEW_LINE DEDENT DEDENT if ( dist & 1 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res = \" \" ; NEW_LINE K = dist // 2 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] and K > 0 ) : NEW_LINE INDENT res += B [ i ] ; NEW_LINE K -= 1 ; NEW_LINE DEDENT elif ( A [ i ] != B [ i ] ) : NEW_LINE INDENT res += A [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT res += A [ i ] ; NEW_LINE DEDENT DEDENT print ( res ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = \"1001010\" ; NEW_LINE B = \"0101010\" ; NEW_LINE findString ( A , B ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate string with Hamming Distance as half of the hamming distance between strings A and B | Function to find the required string ; Find the hamming distance between A and B ; If distance is odd , then resultant string is not possible ; Make the resultant string ; To store the final string ; Pick k characters from each string ; Pick K characters from string B ; Pick K characters from string A ; Append the res characters from string to the resultant string ; Print the resultant string ; Driver 's Code  ; Function to find the resultant string",
        "Category": "Math"
    },
    {
        "ID": "7745-7745",
        "Code": "def findLargest ( N ) : NEW_LINE INDENT largest = strings ( N , '7' ) ; NEW_LINE return largest ; NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT smallest = \"1\" + strings ( ( N - 1 ) , '0' ) ; NEW_LINE return smallest ; NEW_LINE DEDENT def strings ( N , c ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += c ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT def printLargestSmallest ( N ) : NEW_LINE INDENT print ( \" Largest : ▁ \" , findLargest ( N ) ) ; NEW_LINE print ( \" Smallest : ▁ \" , findSmallest ( N ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE printLargestSmallest ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest and Smallest N | Function to return the largest N - digit number in Octal Number System ; Append '7' N times ; Function to return the smallest N - digit number in Octal Number System ; Append '0' ( N - 1 ) times to 1 ; Function to print the largest and smallest N - digit Octal number ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "7748-7748",
        "Code": "def XorAscii ( str1 , len1 ) : NEW_LINE INDENT ans = ord ( str1 [ 0 ] ) NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT ans = ( ans ^ ( ord ( str1 [ i ] ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT str1 = \" geeksforgeeks \" NEW_LINE len1 = len ( str1 ) NEW_LINE print ( XorAscii ( str1 , len1 ) ) NEW_LINE str1 = \" GfG \" NEW_LINE len1 = len ( str1 ) NEW_LINE print ( XorAscii ( str1 , len1 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find the XOR of ASCII values of characters in a string | Function to find the XOR of ASCII value of characters in str1ing ; store value of first character ; Traverse str1ing to find the XOR ; Return the XOR ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7749-7749",
        "Code": "sticks = [ 6 , 7 , 4 , 6 , 5 , 4 , 6 , 5 , 2 , 4 , 4 , 3 , 6 , 6 , 6 , 5 , 7 , 6 , 5 , 3 , 5 , 4 , 6 , 4 , 3 , 4 ] ; NEW_LINE number = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; NEW_LINE def countSticks ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT cnt += sticks [ ord ( ch ) - ord ( ' A ' ) ] ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += number [ ord ( ch ) - ord ( '0' ) ] ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" ; NEW_LINE print ( countSticks ( string ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of sticks required to represent the given string | stick [ ] stores the count of matchsticks required to represent the alphabets ; number [ ] stores the count of matchsticks required to represent the numerals ; Function that return the count of sticks required to represent the given string ; For every char of the given string ; Add the count of sticks required to represent the current character ; Driver code ; Function call to find the count of matchsticks",
        "Category": "Array"
    },
    {
        "ID": "7750-7750",
        "Code": "def CamelCase ( words , pattern ) : NEW_LINE INDENT map = dict . fromkeys ( words , None ) ; NEW_LINE for i in range ( len ( words ) ) : NEW_LINE INDENT string = \" \" ; NEW_LINE l = len ( words [ i ] ) ; NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( words [ i ] [ j ] >= ' A ' and words [ i ] [ j ] <= ' Z ' ) : NEW_LINE INDENT string += words [ i ] [ j ] ; NEW_LINE if string not in map : NEW_LINE INDENT map [ string ] = [ words [ i ] ] NEW_LINE DEDENT elif map [ string ] is None : NEW_LINE INDENT map [ string ] = [ words [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT map [ string ] . append ( words [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT wordFound = False ; NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT if ( key == pattern ) : NEW_LINE INDENT wordFound = True ; NEW_LINE for itt in value : NEW_LINE INDENT print ( itt ) ; NEW_LINE DEDENT DEDENT DEDENT if ( not wordFound ) : NEW_LINE INDENT print ( \" No ▁ match ▁ found \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT words = [ \" Hi \" , \" Hello \" , \" HelloWorld \" , \" HiTech \" , \" HiGeek \" , \" HiTechWorld \" , \" HiTechCity \" , \" HiTechLab \" ] ; NEW_LINE pattern = \" HT \" ; NEW_LINE CamelCase ( words , pattern ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "CamelCase Pattern Matching | Function that prints the camel case pattern matching ; Map to store the hashing of each words with every uppercase letter found ; Traverse the words array that contains all the string ; Initialise str as empty ; length of string words [ i ] ; For every uppercase letter found map that uppercase to original words ; Traverse the map for pattern matching ; If pattern matches then print the corresponding mapped words ; If word not found print \" No ▁ match ▁ found \" ; Driver 's Code ; Pattern to be found ; Function call to find the words that match to the given pattern",
        "Category": "Hash Table"
    },
    {
        "ID": "7752-7752",
        "Code": "from math import ceil , floor , sqrt NEW_LINE def encryption ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE b = ceil ( sqrt ( l ) ) NEW_LINE a = floor ( sqrt ( l ) ) NEW_LINE encrypted = \" \" NEW_LINE if ( b * a < l ) : NEW_LINE INDENT if ( min ( b , a ) == b ) : NEW_LINE INDENT b = b + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT DEDENT arr = [ [ ' ▁ ' for i in range ( a ) ] for j in range ( b ) ] NEW_LINE k = 0 NEW_LINE for j in range ( a ) : NEW_LINE INDENT for i in range ( b ) : NEW_LINE INDENT if ( k < l ) : NEW_LINE INDENT arr [ j ] [ i ] = s [ k ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for j in range ( b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT encrypted = encrypted + arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return encrypted NEW_LINE DEDENT def decryption ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE b = ceil ( sqrt ( l ) ) NEW_LINE a = floor ( sqrt ( l ) ) NEW_LINE decrypted = \" \" NEW_LINE arr = [ [ ' ▁ ' for i in range ( a ) ] for j in range ( b ) ] NEW_LINE k = 0 NEW_LINE for j in range ( b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT if ( k < l ) : NEW_LINE INDENT arr [ j ] [ i ] = s [ k ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT for j in range ( a ) : NEW_LINE INDENT for i in range ( b ) : NEW_LINE INDENT decrypted = decrypted + arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return decrypted NEW_LINE DEDENT s = \" Geeks ▁ For ▁ Geeks \" NEW_LINE encrypted = \" \" NEW_LINE decrypted = \" \" NEW_LINE encrypted = encryption ( s ) NEW_LINE print ( encrypted ) NEW_LINE decrypted = decryption ( encrypted ) NEW_LINE print ( decrypted ) NEW_LINE",
        "Type": "py",
        "NL": "Encryption and Decryption of String according to given technique | Python3 implementation for Custom Encryption and Decryption of String ; Function to encrypt the ; Matrix to generate the Encrypted String ; Fill the matrix row - wise ; Loop to generate encrypted ; Function to decrypt the ; Matrix to generate the Encrypted String ; Fill the matrix column - wise ; Loop to generate decrypted ; Driver Code ; Encryption of String ; Decryption of String",
        "Category": "Matrix"
    },
    {
        "ID": "7754-7754",
        "Code": "def countSubstring ( S , L , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ( ord ( L [ i ] ) - ord ( ' a ' ) ) ] = 1 NEW_LINE DEDENT count , ans = 0 , 0 NEW_LINE for x in S : NEW_LINE INDENT if ( freq [ ord ( x ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT ans += ( count * count + count ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * count + count ) // 2 NEW_LINE return ans NEW_LINE DEDENT S = \" abcpxyz \" NEW_LINE L = [ ' a ' , ' p ' , ' q ' ] NEW_LINE n = len ( L ) NEW_LINE print ( countSubstring ( S , L , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of Substrings that can be formed without using the given list of Characters | Function to find the Number of sub - strings without using given character ; the freq array ; Count variable to store the count of the characters until a character from given L is encountered ; If a character from L is encountered , then the answer variable is incremented by the value obtained by using the mentioned formula and count is set to 0 ; For last remaining characters ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7755-7755",
        "Code": "def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 ; j = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] in str2 : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT print ( \" No . ▁ of ▁ matching ▁ characters ▁ are : ▁ \" , c ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" aabcddekll12 @ \" ; NEW_LINE str2 = \" bb2211@55k \" ; NEW_LINE count ( str1 , str2 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count the Number of matching characters in a pair of strings | Function to count the matching characters ; Traverse the string 1 char by char ; This will check if str1 [ i ] is present in str2 or not str2 . find ( str1 [ i ] ) returns - 1 if not found otherwise it returns the starting occurrence index of that character in str2 ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7757-7757",
        "Code": "def checkIfStartsWithCapital ( string ) : NEW_LINE INDENT if ( string [ 0 ] >= ' A ' and string [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( string ) ) : NEW_LINE INDENT print ( \" Accepted \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Accepted \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksforGeeks \" ; NEW_LINE check ( string ) ; NEW_LINE string = \" geeksforgeeks \" ; NEW_LINE check ( string ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to accept String starting with Capital letter | Function to check if first character is Capital ; Function to check ; Driver function",
        "Category": "Substring"
    },
    {
        "ID": "7759-7759",
        "Code": "def checkIfAllVowels ( string ) : NEW_LINE INDENT hash = [ 0 ] * 5 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' A ' or string [ i ] == ' a ' ) : NEW_LINE INDENT hash [ 0 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' E ' or string [ i ] == ' e ' ) : NEW_LINE INDENT hash [ 1 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' I ' or string [ i ] == ' i ' ) : NEW_LINE INDENT hash [ 2 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' O ' or string [ i ] == ' o ' ) : NEW_LINE INDENT hash [ 3 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' U ' or string [ i ] == ' u ' ) : NEW_LINE INDENT hash [ 4 ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 5 ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def checkIfAllVowelsArePresent ( string ) : NEW_LINE INDENT if ( checkIfAllVowels ( string ) ) : NEW_LINE INDENT print ( \" Not ▁ Accepted \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Accepted \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aeioubc \" ; NEW_LINE checkIfAllVowelsArePresent ( string ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to accept a Strings which contains all the Vowels | Function to to check that a string contains all vowels ; Hash Array of size 5 such that the index 0 , 1 , 2 , 3 and 4 represent the vowels a , e , i , o and u ; Loop the string to mark the vowels which are present ; Loop to check if there is any vowel which is not present in the string ; Function to to check that a string contains all vowels ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "7760-7760",
        "Code": "def countOfLetters ( string ) : NEW_LINE INDENT letter = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ( string [ i ] >= ' A ' and string [ i ] <= ' Z ' ) or ( string [ i ] >= ' a ' and string [ i ] <= ' z ' ) ) : NEW_LINE INDENT letter += 1 ; NEW_LINE DEDENT DEDENT return letter ; NEW_LINE DEDENT def countOfNumbers ( string ) : NEW_LINE INDENT number = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] >= '0' and string [ i ] <= '9' ) : NEW_LINE INDENT number += 1 ; NEW_LINE DEDENT DEDENT return number ; NEW_LINE DEDENT def check ( string ) : NEW_LINE INDENT if ( countOfLetters ( string ) == countOfNumbers ( string ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeKs01324\" ; NEW_LINE check ( string ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if count of Alphabets and count of Numbers are equal in the given String | Function to count the number of alphabets ; Counter to store the number of alphabets in the string ; Every character in the string is iterated ; To check if the character is an alphabet or not ; Function to count the number of numbers ; Counter to store the number of alphabets in the string ; Every character in the string is iterated ; To check if the character is a digit or not ; Function to check if the count of alphabets is equal to the count of numbers or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7768-7768",
        "Code": "def printValue ( digit ) : NEW_LINE INDENT if digit == '0' : NEW_LINE INDENT print ( \" Zero ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '1' : NEW_LINE INDENT print ( \" One ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '2' : NEW_LINE INDENT print ( \" Two ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '3' : NEW_LINE INDENT print ( \" Three \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '4' : NEW_LINE INDENT print ( \" Four ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '5' : NEW_LINE INDENT print ( \" Five ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '6' : NEW_LINE INDENT print ( \" Six ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '7' : NEW_LINE INDENT print ( \" Seven \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '8' : NEW_LINE INDENT print ( \" Eight \" , end = \" ▁ \" ) NEW_LINE DEDENT elif digit == '9' : NEW_LINE INDENT print ( \" Nine ▁ \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT def printWord ( N ) : NEW_LINE INDENT i = 0 NEW_LINE length = len ( N ) NEW_LINE while i < length : NEW_LINE INDENT printValue ( N [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT N = \"123\" NEW_LINE printWord ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Program to print the given digit in words | Function to return the word of the corresponding digit ; For digit 0 ; For digit 1 ; For digit 2 ; For digit 3 ; For digit 4 ; For digit 5 ; For digit 6 ; For digit 7 ; For digit 8 ; For digit 9 ; Function to iterate through every digit in the given number ; Finding each digit of the number ; Print the digit in words ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7789-7789",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , _val ) : NEW_LINE INDENT self . data = _val NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def addinBT ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT root = Node ( data ) NEW_LINE DEDENT else : NEW_LINE INDENT Q = [ ] NEW_LINE Q . append ( root ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT temp = Q [ - 1 ] NEW_LINE Q . pop ( ) NEW_LINE if ( temp . left == None ) : NEW_LINE INDENT temp . left = Node ( data ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT Q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right == None ) : NEW_LINE INDENT temp . right = Node ( data ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT Q . append ( temp . right ) NEW_LINE DEDENT DEDENT DEDENT return root NEW_LINE DEDENT def print_ ( root ) : NEW_LINE INDENT Q = [ ] NEW_LINE Q . append ( root ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT temp = Q [ - 1 ] NEW_LINE Q . pop ( ) NEW_LINE print ( temp . data , end = \" ▁ \" ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT Q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT Q . append ( temp . right ) NEW_LINE DEDENT DEDENT DEDENT def checkvowel ( ch ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def removevowels ( root ) : NEW_LINE INDENT Q = [ ] NEW_LINE Q . append ( root ) NEW_LINE root1 = None NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT temp = Q [ - 1 ] NEW_LINE Q . pop ( ) NEW_LINE if ( not checkvowel ( temp . data ) ) : NEW_LINE INDENT root1 = addinBT ( root1 , temp . data ) NEW_LINE DEDENT if ( temp . left != None ) : NEW_LINE INDENT Q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT Q . append ( temp . right ) NEW_LINE DEDENT DEDENT return root1 NEW_LINE DEDENT s = \" geeks \" NEW_LINE root = None NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT root = addinBT ( root , s [ i ] ) NEW_LINE DEDENT root = removevowels ( root ) NEW_LINE print_ ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Remove vowels from a string stored in a Binary Tree | Structure Representing the Node in the Binary tree ; Function to perform a level order insertion of a Node in the Binary tree ; If the root is empty , make it point to the Node ; In case there are elements in the Binary tree , perform a level order traversal using a Queue ; If the left child does not exist , insert the Node as the left child ; In case the right child does not exist , insert the Node as the right child ; Function to print the level order traversal of the Binary tree ; Function to check if the character is a vowel or not . ; Function to remove the vowels in the Binary tree ; Declaring the root of the tree ; If the given character is not a vowel , add it to the Binary tree ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "7791-7791",
        "Code": "import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def concat ( m , n ) : NEW_LINE INDENT k = int ( math . log2 ( m ) ) + 1 NEW_LINE l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , k ) ] NEW_LINE b = [ 0 for i in range ( 0 , l ) ] NEW_LINE c = [ 0 for i in range ( 0 , k + l ) ] NEW_LINE decBinary ( a , m ) ; NEW_LINE decBinary ( b , n ) ; NEW_LINE iin = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT c [ iin ] = a [ i ] NEW_LINE iin = iin + 1 NEW_LINE DEDENT for i in range ( 0 , l ) : NEW_LINE INDENT c [ iin ] = b [ i ] NEW_LINE iin = iin + 1 NEW_LINE DEDENT return ( binaryDec ( c , k + l ) ) NEW_LINE DEDENT m = 4 NEW_LINE n = 5 NEW_LINE print ( concat ( m , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number obtained after concatenation of binary representation of M and N | Python3 implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr [ ] ; Funtion to convert the number represented as a binary array arr [ ] its decimal equivalent ; Function to concatenate the binary numbers and return the decimal result ; Number of bits in both the numbers ; Convert the bits in both the gers to the arrays a [ ] and b [ ] ; c [ ] will be the binary array for the result ; Update the c [ ] array ; Return the decimal equivalent of the result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7792-7792",
        "Code": "def getBinaryLength ( n ) : NEW_LINE INDENT length = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT length += 1 NEW_LINE n //= 2 NEW_LINE DEDENT return length NEW_LINE DEDENT def concat ( m , n ) : NEW_LINE INDENT length = getBinaryLength ( n ) NEW_LINE return ( m << length ) + n NEW_LINE DEDENT m , n = 4 , 5 NEW_LINE print ( concat ( m , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the number obtained after concatenation of binary representation of M and N | Utility function to calculate binary length of a number . ; Function to concatenate the binary numbers and return the decimal result ; find binary length of n ; left binary shift m and then add n ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7796-7796",
        "Code": "def largestSubStr ( s ) : NEW_LINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT s = s [ : len ( s ) - 1 ] ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return \" - 1\" ; NEW_LINE DEDENT else : NEW_LINE INDENT return s ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"11001\" ; NEW_LINE print ( largestSubStr ( s ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest sub | Function to return the largest substring divisible by 2 ; While the last character of the string is '1' , pop it ; If the original string had no '0 ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7811-7811",
        "Code": "class node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT data = None NEW_LINE next = None NEW_LINE DEDENT DEDENT def add ( data ) : NEW_LINE INDENT newnode = node ( ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def string_to_SLL ( text , head ) : NEW_LINE INDENT head = add ( text [ 0 ] ) NEW_LINE curr = head NEW_LINE for i in range ( len ( text ) - 1 ) : NEW_LINE INDENT curr . next = add ( text [ i + 1 ] ) NEW_LINE curr = curr . next NEW_LINE DEDENT return head NEW_LINE DEDENT def print_ ( head ) : NEW_LINE INDENT curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( ( curr . data ) , end = \" ▁ - ▁ > ▁ \" ) NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT text = \" GEEKS \" NEW_LINE head = None NEW_LINE head = string_to_SLL ( text , head ) NEW_LINE print_ ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Convert a String to a Singly Linked List | Structure for a Singly Linked List ; Function to add a node to the Linked List ; Function to convert the string to Linked List . ; curr pointer points to the current node where the insertion should take place ; Function to print the data present in all the nodes ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "7812-7812",
        "Code": "def minLength ( string , l ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( string [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ - 1 ] ; NEW_LINE if ( c != string [ i ] and c . upper ( ) == string [ i ] . upper ( ) ) : NEW_LINE INDENT s . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( string [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ASbBsd \" ; NEW_LINE l = len ( string ) ; NEW_LINE print ( minLength ( string , l ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reduce the string to minimum length with the given operation | Function to return the minimum possible length str can be reduced to with the given operation ; Stack to store the characters of the given string ; For every character of the string ; If the stack is empty then push the current character in the stack ; Get the top character ; If the top element is not equal to the current element and it only differs in the case ; Pop the top element from stack ; Else push the current element ; Driver code",
        "Category": "Stack"
    },
    {
        "ID": "7814-7814",
        "Code": "CHARS = \"0123456789ABCDEF \" ; NEW_LINE DIGITS = 16 ; NEW_LINE def isDivisible ( s , m ) : NEW_LINE INDENT mp = dict . fromkeys ( CHARS , 0 ) ; NEW_LINE for i in range ( DIGITS ) : NEW_LINE INDENT mp [ CHARS [ i ] ] = i ; NEW_LINE DEDENT r = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT r = ( r * 16 + mp [ s [ i ] ] ) % m ; NEW_LINE DEDENT if ( not r ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10\" ; NEW_LINE m = 3 ; NEW_LINE if ( isDivisible ( s , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check the divisibility of Hexadecimal numbers | Python3 implementation of the approach ; Function that returns true if s is divisible by m ; Map to map characters to real value ; To store the remainder at any stage ; Find the remainder ; Check the value of remainder ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7818-7818",
        "Code": "def anagram_pairs ( s , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp_str = \" \" . join ( sorted ( s [ i ] ) ) NEW_LINE if temp_str in mp : NEW_LINE INDENT mp [ temp_str ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ temp_str ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for k in mp . values ( ) : NEW_LINE INDENT ans += ( k * ( k - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = [ \" aaab \" , \" aaba \" , \" baaa \" , \" cde \" , \" dec \" ] NEW_LINE n = len ( s ) NEW_LINE print ( anagram_pairs ( s , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of index pairs such that s [ i ] and s [ j ] are anagrams | Function to find number of pairs of integers i , j such that s [ i ] is an anagram of s [ j ] . ; To store the count of sorted strings ; Traverse all strings and store in the map ; Sort the string ; If string exists in map , increment count Else create key value pair with count = 1 ; To store the number of pairs ; Traverse through the map ; Count the pairs for each string ; Return the required answer ; Driver code ; Function call",
        "Category": "Hash Table"
    },
    {
        "ID": "7833-7833",
        "Code": "def maxNumber ( string , n ) : NEW_LINE INDENT freq = [ 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' z ' ) : NEW_LINE INDENT freq [ 0 ] += 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' n ' ) : NEW_LINE INDENT freq [ 1 ] += 1 ; NEW_LINE DEDENT DEDENT num = \" \" ; NEW_LINE for i in range ( freq [ 1 ] ) : NEW_LINE INDENT num += '1' ; NEW_LINE DEDENT for i in range ( freq [ 0 ] ) : NEW_LINE INDENT num += '0' ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" roenenzooe \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( maxNumber ( string , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the maximum possible Binary Number from given string | Function to return maximum number that can be formed from the string ; To store the frequency of ' z ' and ' n ' in the given string ; Number of zeroes ; Number of ones ; To store the required number ; Add all the ones ; Add all the zeroes ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "7834-7834",
        "Code": "def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the number of strings formed using distinct characters of a given string | Function to return the factorial of n ; Function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; To store the distinct characters of the string str ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "7837-7837",
        "Code": "def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 for i in range ( 32 ) ] NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT binary = \" \" NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += str ( binaryNum [ j ] ) NEW_LINE DEDENT return binary NEW_LINE DEDENT def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findOccurrence ( arr , n , pattern ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) NEW_LINE print ( countFreq ( pattern , binary ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 5 , 106 , 7 , 8 ] NEW_LINE pattern = \"10\" NEW_LINE n = len ( arr ) NEW_LINE findOccurrence ( arr , n , pattern ) NEW_LINE",
        "Type": "py",
        "NL": "Find the occurrence of the given binary pattern in the binary representation of the array elements | Function to return the binary representation of n ; Array to store binary representation ; Counter for binary array ; Storing remainder in binary array ; To store the binary representation as a string ; Function to return the frequency of pat in the given txt ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; If pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Function to find the occurrence of the given pattern in the binary representation of elements of arr [ ] ; For every element of the array ; Find its binary representation ; Print the occurrence of the given pattern in its binary representation ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7839-7839",
        "Code": "def z_function ( s ) : NEW_LINE INDENT global z , n NEW_LINE n = len ( s ) NEW_LINE z = [ 0 ] * n NEW_LINE l , r = 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i <= r : NEW_LINE INDENT z [ i ] = min ( r - i + 1 , z [ i - 1 ] ) NEW_LINE DEDENT while ( i + z [ i ] < n and s [ z [ i ] ] == s [ i + z [ i ] ] ) : NEW_LINE INDENT z [ i ] += 1 NEW_LINE DEDENT if ( i + z [ i ] - 1 > r ) : NEW_LINE INDENT l = i NEW_LINE r = i + z [ i ] - 1 NEW_LINE DEDENT DEDENT return z NEW_LINE DEDENT def update ( idx , val ) : NEW_LINE INDENT global bit NEW_LINE if idx == 0 : NEW_LINE INDENT return NEW_LINE DEDENT while idx <= n : NEW_LINE INDENT bit [ idx ] += val NEW_LINE idx += ( idx & - idx ) NEW_LINE DEDENT DEDENT def pref ( idx ) : NEW_LINE INDENT global bit NEW_LINE ans = 0 NEW_LINE while idx > 0 : NEW_LINE INDENT ans += bit [ idx ] NEW_LINE idx -= ( idx & - idx ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 0 NEW_LINE length = 0 NEW_LINE bit = [ 0 ] * 1000005 NEW_LINE z = [ ] NEW_LINE m = dict ( ) NEW_LINE s = \" geeksisforgeeksinplatformgeeks \" NEW_LINE z = z_function ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT update ( z [ i ] , 1 ) NEW_LINE DEDENT for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT if z [ i ] != n - i : NEW_LINE INDENT continue NEW_LINE DEDENT if ( pref ( n ) - pref ( z [ i ] - 1 ) ) >= 2 : NEW_LINE INDENT length = max ( length , z [ i ] ) NEW_LINE DEDENT DEDENT if not length : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ : length ] ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find the longest sub | Z - algorithm function ; bit update function which updates values from index \" idx \" to last by value \" val \" ; Query function in bit ; Driver Code ; BIT array ; Making the z array ; update in the bit array from index z [ i ] by increment of 1 ; if the value in z [ i ] is not equal to ( n - i ) then no need to move further ; queryng for the maximum length substring from bit array",
        "Category": "Substring"
    },
    {
        "ID": "7849-7849",
        "Code": "def expandString ( strin ) : NEW_LINE INDENT temp = \" \" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( strin ) ) : NEW_LINE INDENT if ( strin [ i ] >= \"0\" ) : NEW_LINE INDENT num = ord ( strin [ i ] ) - ord ( \"0\" ) NEW_LINE if ( strin [ i + 1 ] == ' ( ' ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( strin [ j ] != ' ) ' ) : NEW_LINE INDENT if ( ( strin [ j ] >= ' a ' and strin [ j ] <= ' z ' ) or ( strin [ j ] >= ' A ' and strin [ j ] <= ' Z ' ) ) : NEW_LINE INDENT temp += strin [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for k in range ( 1 , num + 1 ) : NEW_LINE INDENT print ( temp , end = \" \" ) NEW_LINE DEDENT num = 0 NEW_LINE temp = \" \" NEW_LINE if ( j < len ( strin ) ) : NEW_LINE INDENT i = j NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT strin = \"3 ( ab ) 4 ( cd ) \" NEW_LINE expandString ( strin ) NEW_LINE",
        "Type": "py",
        "NL": "Expand the string according to the given conditions | Function to expand and print the given string ; Subtract '0' to convert char to int ; Characters within brackets ; Expanding ; Reset the variables ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7850-7850",
        "Code": "import operator NEW_LINE def findPrefix ( str1 , str2 ) : NEW_LINE INDENT pos = False ; NEW_LINE while ( len ( str1 ) != 0 ) : NEW_LINE INDENT if operator . contains ( str2 , str1 ) != True : NEW_LINE INDENT str1 = str1 [ 0 : len ( str1 ) - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT pos = operator . contains ( str2 , str1 ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pos == False ) : NEW_LINE INDENT return \" - 1\" ; NEW_LINE DEDENT return str1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" geeksfor \" ; NEW_LINE str2 = \" forgeeks \" ; NEW_LINE print ( findPrefix ( str1 , str2 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Largest substring of str2 which is a prefix of str1 | Python3 implementation of the approach ; Function to return the largest substring in str2 which is a prefix of str1 ; To store the index in str2 which matches the prefix in str1 ; While there are characters left in str1 ; If the prefix is not found in str2 ; Remove the last character ; Prefix found ; No substring found in str2 that matches the prefix of str1 ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7852-7852",
        "Code": "def encrypt ( input_arr ) : NEW_LINE INDENT evenPos = ' @ ' ; oddPos = ' ! ' ; NEW_LINE for i in range ( len ( input_arr ) ) : NEW_LINE INDENT ascii = ord ( input_arr [ i ] ) ; NEW_LINE repeat = ( ascii - 96 ) if ascii >= 97 else ( ascii - 64 ) ; NEW_LINE for j in range ( repeat ) : NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( oddPos , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( evenPos , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT input_arr = [ ' A ' , ' b ' , ' C ' , ' d ' ] ; NEW_LINE encrypt ( input_arr ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to Encrypt a String using ! and @ | Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print '@ ; Driver code ; Encrypt the String",
        "Category": "String"
    },
    {
        "ID": "7853-7853",
        "Code": "def IsRedundantBraces ( A ) : NEW_LINE INDENT a , b = 0 , 0 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == ' ( ' and A [ i + 2 ] == ' ) ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( A [ i ] == ' * ' or A [ i ] == ' + ' or A [ i ] == ' - ' or A [ i ] == ' / ' ) : NEW_LINE INDENT a += 1 ; NEW_LINE DEDENT if ( A [ i ] == ' ( ' ) : NEW_LINE INDENT b += 1 ; NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" ( ( ( a + b ) ▁ + ▁ c ) ▁ + ▁ d ) \" ; NEW_LINE if ( IsRedundantBraces ( A ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if expression contains redundant bracket or not | Set 2 | Function to check for redundant braces ; count of no of signs ; Driver Code",
        "Category": "Stack"
    },
    {
        "ID": "7865-7865",
        "Code": "def endingWith ( str , suff ) : NEW_LINE INDENT c = 0 NEW_LINE wrd = str . split ( \" ▁ \" ) NEW_LINE for l in wrd : NEW_LINE INDENT if l . endswith ( suff ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT str = \" GeeksForGeeks ▁ is ▁ a ▁ computer ▁ science ▁ portal ▁ for ▁ geeks \" NEW_LINE suff = \" ks \" NEW_LINE print ( endingWith ( str , suff ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of words ending at the given suffix in Java | Function declared to return the count of words in the given sentence that end with the given suffix ; Variable to store count ; split function used to extract words from sentence in form of list ; using for loop with ' in ' to extract elements of list ; returning the count ; Driver Code ; printing the final cde",
        "Category": "Substring"
    },
    {
        "ID": "7872-7872",
        "Code": "MAX = 256 NEW_LINE def smallestStr ( str , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE chk = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT chk [ i ] = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( chk [ ord ( str [ i ] ) ] == - 1 ) : NEW_LINE INDENT chk [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( ord ( str [ i ] ) ) : NEW_LINE INDENT if ( chk [ j ] > chk [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT ch1 = ( str [ i ] ) NEW_LINE ch2 = chr ( j ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ch1 ) : NEW_LINE INDENT str [ i ] = ch2 NEW_LINE DEDENT elif ( str [ i ] == ch2 ) : NEW_LINE INDENT str [ i ] = ch1 NEW_LINE DEDENT DEDENT DEDENT return \" \" . join ( str ) NEW_LINE DEDENT st = \" ccad \" NEW_LINE str = [ i for i in st ] NEW_LINE n = len ( str ) NEW_LINE print ( smallestStr ( str , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Swap all occurrences of two characters to get lexicographically smallest string | python3 implementation of the approach ; Function to return the lexicographically smallest after swapping all the occurrences of any two characters ; To store the first index of every character of str ; Store the first occurring index every character ; If current character is appearing for the first time in str ; Starting from the leftmost character ; For every character smaller than ord ( str [ i ] ) ; If there is a character in str which is smaller than ord ( str [ i ] ) and appears after it ; If the required character pair is found ; If swapping is possible ; Characters to be swapped ; For every character ; Replace every ch1 with ch2 and every ch2 with ch1 ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7878-7878",
        "Code": "MAX = 26 NEW_LINE def canBeMapped ( s1 , l1 , s2 , l2 ) : NEW_LINE INDENT if ( l1 != l2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT freq1 = [ 0 for i in range ( MAX ) ] NEW_LINE freq2 = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT freq2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT found = False NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == freq2 [ j ] ) : NEW_LINE INDENT freq2 [ j ] = - 1 NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" axx \" NEW_LINE s2 = \" cbc \" NEW_LINE l1 = len ( s1 ) NEW_LINE l2 = len ( s2 ) NEW_LINE if ( canBeMapped ( s1 , l1 , s2 , l2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Map every character of one string to another such that all occurrences are mapped to the same character | Python 3 implementation of the approach ; Function that returns true if the mapping is possible ; Both the strings are of un - equal lengths ; To store the frequencies of the characters in both the string ; Update frequencies of the characters ; For every character of s1 ; If current character is not present in s1 ; Find a character in s2 that has frequency equal to the current character 's  frequency in s1 ; If such character is found ; Set the frequency to - 1 so that it doesn 't get picked again ; Set found to true ; If there is no character in s2 that could be mapped to the current character in s1 ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "7879-7879",
        "Code": "stringSet = dict ( ) NEW_LINE def find_permutation ( str1 , str2 , len1 , len2 , i , j , res ) : NEW_LINE INDENT if ( len ( res ) == len1 + len2 ) : NEW_LINE INDENT stringSet [ res ] = 1 NEW_LINE return NEW_LINE DEDENT if ( i < len1 ) : NEW_LINE INDENT find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) NEW_LINE DEDENT if ( j < len2 ) : NEW_LINE INDENT find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) NEW_LINE DEDENT DEDENT def print_set ( ) : NEW_LINE INDENT for i in stringSet : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT str1 = \" aa \" NEW_LINE str2 = \" ab \" NEW_LINE len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE find_permutation ( str1 , str2 , len1 , len2 , 0 , 0 , \" \" ) NEW_LINE print_set ( ) NEW_LINE",
        "Type": "py",
        "NL": "Distinct strings such that they contains given strings as sub | Set to store strings and aduplicates ; Recursive function to generate the required strings ; If currentis part of the result ; Insert it into the set ; If character from str1 can be chosen ; If character from str2 can be chosen ; Function to print the generated strings from the set ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "7893-7893",
        "Code": "def reverse ( s ) : NEW_LINE INDENT stc = [ ] NEW_LINE temp = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE stc . append ( temp ) NEW_LINE temp = \" \" NEW_LINE else : NEW_LINE temp = temp + s [ i ] NEW_LINE DEDENT stc . append ( temp ) NEW_LINE while len ( stc ) != 0 : NEW_LINE INDENT temp = stc [ len ( stc ) - 1 ] NEW_LINE print ( temp , end = \" ▁ \" ) NEW_LINE stc . pop ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT s = \" I ▁ Love ▁ To ▁ Code \" NEW_LINE reverse ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Reverse the Words of a String using Stack | function to reverse the words of the given string without using strtok ( ) . ; create an empty string stack ; create an empty temporary string ; traversing the entire string ; push the temporary variable into the stack ; assigning temporary variable as empty ; for the last word of the string ; Get the words in reverse order ; Driver code",
        "Category": "Stack"
    },
    {
        "ID": "7894-7894",
        "Code": "def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE token = k . split ( ) NEW_LINE for word in token : NEW_LINE INDENT s . append ( word ) ; NEW_LINE DEDENT while ( len ( s ) ) : NEW_LINE INDENT print ( s . pop ( ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = \" geeks ▁ for ▁ geeks \" ; NEW_LINE reverse ( k ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse the Words of a String using Stack | Function to reverse the words of the given sentence ; Create an empty character array stack ; Push words into the stack ; Get the words in reverse order ; Driver code",
        "Category": "Stack"
    },
    {
        "ID": "7897-7897",
        "Code": "def isPossible ( l , m , x , y ) : NEW_LINE INDENT if ( l * m == x + y ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 3 ; m = 2 ; x = 4 ; y = 2 ; NEW_LINE if ( isPossible ( l , m , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find if it is possible to make a binary string which contanins given number of \"0\" , \"1\" , \"01\" and \"10\" as sub sequences | Function that returns true if it is possible to make a binary string consisting of l 0 ' s , ▁ m ▁ 1' s , x \"01\" sub - sequences and y \"10\" sub - sequences ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "79-79",
        "Code": "def buildTree ( inorder , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return None NEW_LINE DEDENT i = Max ( inorder , start , end ) NEW_LINE root = newNode ( inorder [ i ] ) NEW_LINE if start == end : NEW_LINE INDENT return root NEW_LINE DEDENT root . left = buildTree ( inorder , start , i - 1 ) NEW_LINE root . right = buildTree ( inorder , i + 1 , end ) NEW_LINE return root NEW_LINE DEDENT def Max ( arr , strt , end ) : NEW_LINE INDENT i , Max = 0 , arr [ strt ] NEW_LINE maxind = strt NEW_LINE for i in range ( strt + 1 , end + 1 ) : NEW_LINE INDENT if arr [ i ] > Max : NEW_LINE INDENT Max = arr [ i ] NEW_LINE maxind = i NEW_LINE DEDENT DEDENT return maxind NEW_LINE DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printInorder ( node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE print ( node . data , end = \" ▁ \" ) NEW_LINE printInorder ( node . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inorder = [ 5 , 10 , 40 , 30 , 28 ] NEW_LINE Len = len ( inorder ) NEW_LINE root = buildTree ( inorder , 0 , Len - 1 ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the \" , \" constructed ▁ tree ▁ is ▁ \" ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct Special Binary Tree from given Inorder traversal | Recursive function to construct binary of size len from Inorder traversal inorder [ ] . Initial values of start and end should be 0 and len - 1. ; Find index of the maximum element from Binary Tree ; Pick the maximum value and make it root ; If this is the only element in inorder [ start . . end ] , then return it ; Using index in Inorder traversal , construct left and right subtress ; Function to find index of the maximum value in arr [ start ... end ] ; Helper class that allocates a new node with the given data and None left and right pointers . ; This funtcion is here just to test buildTree ( ) ; first recur on left child ; then print the data of node ; now recur on right child ; Driver Code ; Assume that inorder traversal of following tree is given 40 / \\ 10 30 / \\ 5 28 ; Let us test the built tree by printing Insorder traversal",
        "Category": "Binary Tree"
    },
    {
        "ID": "7900-7900",
        "Code": "def isPalin ( i , j , k , l , p , q , s ) : NEW_LINE INDENT start = i ; end = q ; NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( s [ start ] != s [ end ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT start += 1 ; NEW_LINE if ( start == j + 1 ) : NEW_LINE INDENT start = k ; NEW_LINE DEDENT end -= 1 ; NEW_LINE if ( end == p - 1 ) : NEW_LINE INDENT end = l ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def countSubStr ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k , n - 1 ) : NEW_LINE INDENT for p in range ( l + 1 , n ) : NEW_LINE INDENT for q in range ( p , n ) : NEW_LINE INDENT if ( isPalin ( i , j , k , l , p , q , s ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abca \" ; NEW_LINE print ( countSubStr ( s ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of three non | Function that returns true if s [ i ... j ] + s [ k ... l ] + s [ p ... q ] is a palindrome ; Function to return the count of valid sub - strings ; To store the count of required sub - strings ; For choosing the first sub - string ; For choosing the second sub - string ; For choosing the third sub - string ; Check if the concatenation is a palindrome ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "7907-7907",
        "Code": "def isValid ( s ) : NEW_LINE INDENT p = \" \" NEW_LINE p = s . find ( \" geek \" ) NEW_LINE if ( s . find ( \" keeg \" , p + 4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geekeekeeg \" NEW_LINE if ( isValid ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string contains two non overlapping sub | Function that returns true if s contains two non overlapping sub strings \" geek \" and \" keeg \" ; If \" geek \" and \" keeg \" are both present in s without over - lapping and \" keeg \" starts after \" geek \" ends ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7912-7912",
        "Code": "NUM = 31 NEW_LINE def positions ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ( ord ( i ) & NUM ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT str = \" Geeks \" NEW_LINE positions ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Find letter 's position in Alphabet using Bit operation | Python3 implementation of the approach ; Function to calculate the position of characters ; Performing AND operation with number 31 ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7913-7913",
        "Code": "def permute ( str , l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT if \" AB \" not in ' ' . join ( str ) : NEW_LINE INDENT print ( ' ' . join ( str ) , end = \" ▁ \" ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT str [ l ] , str [ i ] = str [ i ] , str [ l ] NEW_LINE permute ( str , l + 1 , r ) NEW_LINE str [ l ] , str [ i ] = str [ i ] , str [ l ] NEW_LINE DEDENT DEDENT str = \" ABC \" NEW_LINE permute ( list ( str ) , 0 , len ( str ) - 1 ) NEW_LINE",
        "Type": "py",
        "NL": "Generate all permutations of a string that follow given constraints | Simple Python program to print all permutations of a string that follow given constraint ; Check if current permutation is valid ; Recursively generate all permutation ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "7916-7916",
        "Code": "def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE length += 1 NEW_LINE DEDENT DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" synapse \" NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the longest substring that do not contain any palindrome | Function to find the length of the longest substring ; initializing the variables ; checking palindrome of size 2 example : aa ; checking palindrome of size 3 example : aba ; else : incrementing length of substring ; If there exits single character then it is always palindrome ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "7934-7934",
        "Code": "def isValid ( str1 , n ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ 0 ] ) >= ord ( ' a ' ) and ord ( str1 [ 0 ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ 0 ] ) >= ord ( ' A ' ) and ord ( str1 [ 0 ] ) <= ord ( ' Z ' ) ) or ord ( str1 [ 0 ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( str1 ) ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ i ] ) >= ord ( ' a ' ) and ord ( str1 [ i ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( ' A ' ) and ord ( str1 [ i ] ) <= ord ( ' Z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( '0' ) and ord ( str1 [ i ] ) <= ord ( '9' ) ) or ord ( str1 [ i ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = \" _ geeks123\" NEW_LINE n = len ( str1 ) NEW_LINE if ( isValid ( str1 , n ) ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether the given string is a valid identifier | Function that returns true if str1 is a valid identifier ; If first character is invalid ; Traverse the for the rest of the characters ; is a valid identifier ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7935-7935",
        "Code": "def countSubStr ( string , n ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE return ( length - n + 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = 5 ; NEW_LINE print ( countSubStr ( string , n ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of sub | Function to return the count of possible sub - strings of length n ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7942-7942",
        "Code": "def FirstAndLast ( string ) : NEW_LINE INDENT ch = list ( string ) ; NEW_LINE i = 0 ; NEW_LINE while i < len ( ch ) : NEW_LINE INDENT k = i ; NEW_LINE while ( i < len ( ch ) and ch [ i ] != ' ▁ ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( ord ( ch [ k ] ) >= 97 and ord ( ch [ k ] ) <= 122 ) : NEW_LINE INDENT ch [ k ] = chr ( ord ( ch [ k ] ) - 32 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ch [ k ] = ch [ k ] NEW_LINE DEDENT if ( ord ( ch [ i - 1 ] ) >= 90 and ord ( ch [ i - 1 ] ) <= 122 ) : NEW_LINE INDENT ch [ i - 1 ] = chr ( ord ( ch [ i - 1 ] ) - 32 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i - 1 ] = ch [ i - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return \" \" . join ( ch ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Geeks ▁ for ▁ Geeks \" ; NEW_LINE print ( string ) ; NEW_LINE print ( FirstAndLast ( string ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Capitalize the first and last character of each word in a string | Python3 program to capitalise the first and last character of each word in a string . ; Create an equivalent char array of given string ; k stores index of first character and i is going to store index of last character . ; Check if the character is a small letter If yes , then Capitalise ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "7945-7945",
        "Code": "def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ Len ] ) : NEW_LINE INDENT Len += 1 NEW_LINE lps [ i ] = Len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( Len != 0 ) : NEW_LINE INDENT Len = lps [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT s = \" fixprefixsuffix \" NEW_LINE Longestsubstring ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Find the longest sub | Function to find longest prefix suffix ; To store longest prefix suffix ; Length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; Loop calculates lps [ i ] for i = 1 to n - 1 ; ( pat [ i ] != pat [ Len ] ) ; If Len = 0 ; Function to find the longest substring which is prefix as well as a sub - of s [ 1. . . n - 2 ] ; Find longest prefix suffix ; If lps of n - 1 is zero ; At any position lps [ i ] equals to lps [ n - 1 ] ; If answer is not possible ; Driver code ; function call",
        "Category": "Substring"
    },
    {
        "ID": "7946-7946",
        "Code": "MAX = 64 NEW_LINE def getBitmask ( s ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ j ] == ' s ' ) : NEW_LINE INDENT temp = temp | 1 NEW_LINE DEDENT elif ( s [ j ] == ' t ' ) : NEW_LINE INDENT temp = temp | 2 NEW_LINE DEDENT elif ( s [ j ] == ' r ' ) : NEW_LINE INDENT temp = temp | 4 NEW_LINE DEDENT elif ( s [ j ] == ' i ' ) : NEW_LINE INDENT temp = temp | 8 NEW_LINE DEDENT elif ( s [ j ] == ' n ' ) : NEW_LINE INDENT temp = temp | 16 NEW_LINE DEDENT elif ( s [ j ] == ' g ' ) : NEW_LINE INDENT temp = temp | 32 NEW_LINE DEDENT DEDENT return temp NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT bitMask = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT bitMask [ getBitmask ( arr [ i ] ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i , MAX ) : NEW_LINE INDENT if ( ( i j ) == ( MAX - 1 ) ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( bitMask [ i ] * bitMask [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ \" strrr \" , \" string \" , \" gstrin \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Pairs of strings which on concatenating contains each character of \" string \" | Python3 implementation of the approach ; Function to return the bitmask for the string ; Function to return the count of pairs ; bitMask [ i ] will store the count of strings from the array whose bitmask is i ; To store the count of pairs ; MAX - 1 = 63 i . e . 111111 in binary ; arr [ i ] cannot make s pair with itself i . e . ( arr [ i ] , arr [ i ] ) ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "7948-7948",
        "Code": "def printBinStr ( string , length ) : NEW_LINE INDENT for i in range ( 0 , length ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateBinStr ( string , length , currlen , occur , nextbit ) : NEW_LINE INDENT if currlen == length : NEW_LINE INDENT if occur == 2 and nextbit == 0 : NEW_LINE INDENT printBinStr ( string , length ) NEW_LINE DEDENT return NEW_LINE DEDENT if currlen == 0 : NEW_LINE INDENT string [ 0 ] = nextbit NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 0 ) NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if occur < 2 : NEW_LINE INDENT string [ currlen ] = nextbit NEW_LINE if string [ currlen - 1 ] == 0 and nextbit == 1 : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT generateBinStr ( string , length , currlen + 1 , occur , 0 ) NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if string [ currlen - 1 ] == 0 and nextbit == 1 : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT string [ currlen ] = nextbit NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 0 ) NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE if n < 4 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT string = [ None ] * n NEW_LINE generateBinStr ( string , n , 0 , 0 , 0 ) NEW_LINE generateBinStr ( string , n , 0 , 0 , 1 ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Generate all binary strings of length n with sub | Utility function to print the given binary string ; This function will be called recursively to generate the next bit for given binary string according to its current state ; Base - case : if the generated binary string meets the required length and the pattern \"01\" appears twice ; nextbit needs to be 0 because each time we call the function recursively , we call 2 times for 2 cases : next bit is 0 or 1 The is to assure that the binary string is printed one time only ; Generate the next bit for str and call recursive ; Assign first bit ; The next generated bit will either be 0 or 1 ; If pattern \"01\" occurrence is < 2 ; Set next bit ; If pattern \"01\" appears then increase the occurrence of pattern ; Else pattern \"01\" occurrence equals 2 ; If previous bit is 0 then next bit cannot be 1 ; Otherwise ; Driver code ; Length of the resulting strings must be at least 4 ; Generate all binary strings of length n with sub - string \"01\" appearing twice",
        "Category": "Backtracking"
    },
    {
        "ID": "7954-7954",
        "Code": "def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the kth character after decrypting a string | Function to print kth character of String s after decrypting it ; Get the length of string ; Initialise pointer to character of input string to zero ; Total length of resultant string ; Traverse the string from starting and check if each character is alphabet then increment total_len ; If total_leg equal to k then return string else increment i ; Parse the number ; Update next_total_len ; Get the position of kth character ; Position not found then update position with total_len ; Recursively find the kth position ; Else update total_len by next_total_len ; Return - 1 if character not found ; Driver code",
        "Category": "Recursion"
    },
    {
        "ID": "7955-7955",
        "Code": "from math import floor NEW_LINE def check_char ( st , ch ) : NEW_LINE INDENT l = len ( st ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( st [ i ] == ch ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def find_avg ( st ) : NEW_LINE INDENT sm = 0 NEW_LINE l = len ( st ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT ch = st [ i ] NEW_LINE sm = sm + ord ( ch ) NEW_LINE DEDENT avg = int ( floor ( sm / l ) ) NEW_LINE return ( chr ( avg ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = \" ag23sdfa \" NEW_LINE ch = find_avg ( st ) NEW_LINE print ( ch ) NEW_LINE if ( check_char ( st , ch ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether the Average Character of the String is present or not | Python 3 program to check if the average character is present in the string or not ; Checks if the character is present ; Get the length of string ; Iterate from i = 0 to the length of the string to check if the character is present in the string ; Finds the average character of the string ; Calculate the sum of ASCII values of each character ; Calculate average of ascii values ; Convert the ASCII value to character and return it ; Driver code ; Get the average character ; Check if the average character is present in string or not",
        "Category": "Array"
    },
    {
        "ID": "7972-7972",
        "Code": "def groupCharacters ( s , l ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT temp = temp + s [ i ] NEW_LINE DEDENT DEDENT l = len ( temp ) NEW_LINE ans = \" \" NEW_LINE i = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( ord ( temp [ i ] ) >= ord ( ' A ' ) and ord ( temp [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT while ( i < l and ord ( temp [ i ] ) >= ord ( ' A ' ) and ord ( temp [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT ans = ans + temp [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = ans + \" ▁ \" NEW_LINE DEDENT elif ( ord ( temp [ i ] ) >= ord ( '0' ) and ord ( temp [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT while ( i < l and ord ( temp [ i ] ) >= ord ( '0' ) and ord ( temp [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT ans = ans + temp [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = ans + \" ▁ \" NEW_LINE DEDENT else : NEW_LINE INDENT while ( i < l and ord ( temp [ i ] ) >= ord ( ' * ' ) and ord ( temp [ i ] ) <= ord ( ' / ' ) ) : NEW_LINE INDENT ans = ans + temp [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = ans + \" ▁ \" NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"34FTG234 + ▁ + - ▁ * \" NEW_LINE l = len ( s ) NEW_LINE print ( groupCharacters ( s , l ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Group consecutive characters of same type in a string | Function to return the modified string ; Store original string ; Remove all white spaces ; To store the resultant string ; Traverse the string ; Group upper case characters ; Group numeric characters ; Group arithmetic operators ; Return the resultant string ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "7973-7973",
        "Code": "def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 NEW_LINE close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : open1 += 1 continue if s [ i ] == ' ) ' : NEW_LINE INDENT close1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' { ' : NEW_LINE INDENT open2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' } ' : NEW_LINE INDENT close2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' [ ' : NEW_LINE INDENT open3 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' ] ' : NEW_LINE INDENT close3 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT maxLen = ( 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ) NEW_LINE return maxLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : s = \" ) ) [ ] ] ( ( \" NEW_LINE INDENT print ( maxBalancedStr ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum length of balanced string after swapping and removal of characters | Function to return the length of the longest balanced sub - string ; To store the count of parentheses ; Traversing the string ; Check type of parentheses and incrementing count for it ; Sum all pair of balanced parentheses ; Driven code",
        "Category": "Substring"
    },
    {
        "ID": "7984-7984",
        "Code": "def leastLexiString ( s ) : NEW_LINE INDENT if ( len ( s ) & 1 != 0 ) : NEW_LINE INDENT return s NEW_LINE DEDENT x = leastLexiString ( s [ 0 : int ( len ( s ) / 2 ) ] ) NEW_LINE y = leastLexiString ( s [ int ( len ( s ) / 2 ) : len ( s ) ] ) NEW_LINE return min ( x + y , y + x ) NEW_LINE DEDENT def areEquivalent ( a , b ) : NEW_LINE INDENT return ( leastLexiString ( a ) == leastLexiString ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" aaba \" NEW_LINE b = \" abaa \" NEW_LINE if ( areEquivalent ( a , b ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT a = \" aabb \" NEW_LINE b = \" abab \" NEW_LINE if ( areEquivalent ( a , b ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether two strings are equivalent or not according to given condition | This function returns the least lexicogr aphical string obtained from its two halves ; Base Case - If string size is 1 ; Divide the string into its two halves ; Form least lexicographical string ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "7987-7987",
        "Code": "def generateString ( A , B ) : NEW_LINE INDENT rt = \" \" NEW_LINE while ( 0 < A or 0 < B ) : NEW_LINE INDENT if ( A < B ) : NEW_LINE INDENT if ( 0 < B ) : NEW_LINE INDENT rt = rt + ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT DEDENT elif ( B < A ) : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( rt ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 NEW_LINE B = 6 NEW_LINE generateString ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate a string consisting of characters ' a ' and ' b ' that satisfy the given conditions | Function to generate and print the required string ; More ' b ' , append \" bba \" ; More ' a ' , append \" aab \" ; Equal number of ' a ' and ' b ' append \" ab \" ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "7990-7990",
        "Code": "def count_acronym ( n , arr ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( arr [ i ] [ 0 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT st = arr [ i ] NEW_LINE num = [ 0 ] * 26 NEW_LINE for j in range ( len ( st ) ) : NEW_LINE INDENT num [ ord ( st [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for j in range ( 1 , 26 ) : NEW_LINE INDENT if num [ j ] > freq [ j ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT x = ord ( st [ 0 ] ) - ord ( ' a ' ) NEW_LINE if freq [ x ] - 1 < num [ x ] : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" abc \" , \" bcad \" , \" cabd \" , \" cba \" , \" dzzz \" ] NEW_LINE n = 5 NEW_LINE print ( count_acronym ( n , arr ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Acronym words | Function to return the number of strings that can be an acronym for other strings ; Frequency array to store the frequency of the first character of every string in the array ; To store the count of required strings ; Current word ; Frequency array to store the frequency of each of the character of the current string ; Check if the frequency of every character in the current string is <= its value in freq [ ] ; First character of the current string ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "7994-7994",
        "Code": "def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct = ct + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = \" xaxa \" NEW_LINE b = \" xaxaxaxa \" NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count the number of common divisors of the given strings | Function that returns true if sub - string s [ 0. . . k ] is repeated a number of times to generate String s ; Function to return the count of common divisors ; If the length of the sub - string divides length of both the strings ; If prefixes match in both the strings ; If both the strings can be generated ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "80-80",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def createNode ( parent , i , created , root ) : NEW_LINE INDENT if created [ i ] is not None : NEW_LINE INDENT return NEW_LINE DEDENT created [ i ] = Node ( i ) NEW_LINE if parent [ i ] == - 1 : NEW_LINE INDENT root [ 0 ] = created [ i ] NEW_LINE return NEW_LINE DEDENT if created [ parent [ i ] ] is None : NEW_LINE INDENT createNode ( parent , parent [ i ] , created , root ) NEW_LINE DEDENT p = created [ parent [ i ] ] NEW_LINE if p . left is None : NEW_LINE INDENT p . left = created [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT p . right = created [ i ] NEW_LINE DEDENT DEDENT def createTree ( parent ) : NEW_LINE INDENT n = len ( parent ) NEW_LINE created = [ None for i in range ( n + 1 ) ] NEW_LINE root = [ None ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT createNode ( parent , i , created , root ) NEW_LINE DEDENT return root [ 0 ] NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print root . key , NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT parent = [ - 1 , 0 , 0 , 1 , 1 , 3 , 5 ] NEW_LINE root = createTree ( parent ) NEW_LINE print \" Inorder ▁ Traversal ▁ of ▁ constructed ▁ tree \" NEW_LINE inorder ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Construct Binary Tree from given Parent Array representation | A node structure ; Creates a node with key as ' i ' . If i is root , then it changes root . If parent of i is not created , then it creates parent first ; If this node is already created ; Create a new node and set created [ i ] ; If ' i ' is root , change root pointer and return ; If parent is not created , then create parent first ; Find parent pointer ; If this is first child of parent ; If second child ; Creates tree from parent [ 0. . n - 1 ] and returns root of the created tree ; Create and array created [ ] to keep track of created nodes , initialize all entries as None ; Inorder traversal of tree ; Driver Method",
        "Category": "Binary Tree"
    },
    {
        "ID": "8006-8006",
        "Code": "def printString ( Str1 , n ) : NEW_LINE INDENT ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT used = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '2' and used == False ) : NEW_LINE INDENT used = 1 NEW_LINE for j in range ( ones ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) NEW_LINE DEDENT DEDENT if ( Str1 [ i ] != '1' ) : NEW_LINE INDENT print ( Str1 [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT for j in range ( ones ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT Str1 = \"100210\" NEW_LINE n = len ( Str1 ) NEW_LINE printString ( Str1 , n ) NEW_LINE",
        "Type": "py",
        "NL": "Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If Str1 [ i ] = 0 or Str1 [ i ] = 2 ; If 1 s are not printed yet ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "8008-8008",
        "Code": "def reverse ( str1 , x ) : NEW_LINE INDENT n = ( len ( str1 ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str1 [ i ] , end = \" \" ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = \" \" ) NEW_LINE DEDENT for i in range ( n + x , len ( str1 ) ) : NEW_LINE INDENT print ( str1 [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT str1 = \" geeksforgeeks \" NEW_LINE x = 3 NEW_LINE reverse ( str1 , x ) NEW_LINE",
        "Type": "py",
        "NL": "Reverse Middle X Characters | Function to reverse the middle x characters in a str1ing ; Find the position from where the characters have to be reversed ; Print the first n characters ; Print the middle x characters in reverse ; Print the last n characters ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8010-8010",
        "Code": "def getSteps ( str , i , j , n ) : NEW_LINE INDENT k = i + 1 NEW_LINE steps = 0 NEW_LINE ch = str [ i ] NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( str [ k ] != ch ) : NEW_LINE INDENT steps = steps + 1 NEW_LINE ch = str [ k ] NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT def getMinSteps ( str , i , j , n ) : NEW_LINE INDENT if ( j < i ) : NEW_LINE INDENT temp = i NEW_LINE i = j NEW_LINE j = temp NEW_LINE DEDENT stepsToRight = getSteps ( str , i , j , n ) NEW_LINE stepsToLeft = getSteps ( str , 0 , i , n ) + getSteps ( str , j , n - 1 , n ) NEW_LINE if ( str [ 0 ] != str [ n - 1 ] ) : NEW_LINE INDENT stepsToLeft = stepsToLeft + 1 NEW_LINE DEDENT return min ( stepsToLeft , stepsToRight ) NEW_LINE DEDENT str = \" SSNSS \" NEW_LINE n = len ( str ) NEW_LINE i = 0 NEW_LINE j = 3 NEW_LINE print ( getMinSteps ( str , i , j , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum moves to reach from i to j in a cyclic string | Function to return the count of steps required to move from i to j ; Starting from i + 1 ; Count of steps ; Current character ; If current character is different from previous ; Increment steps ; Update current character ; Return total steps ; Function to return the minimum number of steps required to reach j from i ; Swap the values so that i <= j ; Steps to go from i to j ( left to right ) ; While going from i to j ( right to left ) First go from i to 0 then from ( n - 1 ) to j ; If first and last character is different then it 'll add a step to stepsToLeft ; Return the minimum of two paths ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8016-8016",
        "Code": "import math as mt NEW_LINE def findPermutation ( string , k ) : NEW_LINE INDENT has = [ False for i in range ( 26 ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( has [ ord ( string [ i ] ) - ord ( ' a ' ) ] == False ) : NEW_LINE INDENT cnt += 1 NEW_LINE has [ ord ( string [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , cnt + 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT for i in range ( cnt - k , 1 , - 1 ) : NEW_LINE INDENT ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT string = \" geeksforgeeks \" NEW_LINE k = 4 NEW_LINE print ( findPermutation ( string , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "K length words that can be formed from given characters without repetition | Python3 implementation of the approach ; Function to return the required count ; To store the count of distinct characters in str ; Traverse str character by character ; If current character is appearing for the first time in str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! / ( n - r ) ! ; Return the answer ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8017-8017",
        "Code": "MAX_CHAR = 256 NEW_LINE def countSubStrings ( s , anotherStr , k ) : NEW_LINE INDENT illegal = [ False ] * MAX_CHAR NEW_LINE for i in range ( len ( anotherStr ) ) : NEW_LINE INDENT illegal [ ord ( anotherStr [ i ] ) ] = True NEW_LINE DEDENT us = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ss = \" \" NEW_LINE count = 0 NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT if ( illegal [ ord ( s [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ss = ss + s [ j ] NEW_LINE if ( count <= k ) : NEW_LINE INDENT us . add ( ss ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( us ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" acbacbacaa \" NEW_LINE anotherStr = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE k = 2 NEW_LINE print ( countSubStrings ( string , anotherStr , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count distinct substrings that contain some characters at most k times | Python3 implementation of the approach ; Function to return the count of valid sub - strings ; Store all characters of anotherStr in a direct index table for quick lookup . ; To store distinct output substrings ; Traverse through the given string and one by one generate substrings beginning from s [ i ] . ; One by one generate substrings ending with s [ j ] ; If character is illegal ; If current substring is valid ; If current substring is invalid , adding more characters would not help . ; Return the count of distinct sub - strings ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8019-8019",
        "Code": "def extractSecretMessage ( Str , Sub ) : NEW_LINE INDENT Str = Str . replace ( Sub , \" ▁ \" ) NEW_LINE return Str . strip ( ) NEW_LINE DEDENT Str = \" LIELIEILIEAMLIECOOL \" NEW_LINE Sub = \" LIE \" NEW_LINE print ( extractSecretMessage ( Str , Sub ) ) NEW_LINE",
        "Type": "py",
        "NL": "Replace all occurrences of a string with space | Function to extract the secret message ; Replacing all occurrences of Sub in Str by empty spaces ; Removing unwanted spaces in the start and end of the string ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8027-8027",
        "Code": "def pangramCost ( arr , string ) : NEW_LINE INDENT cost = 0 NEW_LINE occurred = [ False ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT occurred [ ord ( string [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( not occurred [ i ] ) : NEW_LINE INDENT cost += arr [ i ] NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 ] NEW_LINE string = \" abcdefghijklmopqrstuvwz \" NEW_LINE print ( pangramCost ( arr , string ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Cost to make a string Panagram | Function to return the total cost required to make the string Pangram ; Mark all the alphabets that occurred in the string ; Calculate the total cost for the missing alphabets ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8032-8032",
        "Code": "def check ( s , K ) : NEW_LINE INDENT for ch in range ( 0 , 26 ) : NEW_LINE INDENT c = chr ( 97 + ch ) NEW_LINE last = - 1 NEW_LINE found = True NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT last = i NEW_LINE DEDENT DEDENT if last == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( K , len ( s ) ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT last = i NEW_LINE DEDENT if last <= ( i - K ) : NEW_LINE INDENT found = False NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def binarySearch ( s ) : NEW_LINE INDENT low , high , ans = 1 , len ( s ) , None NEW_LINE while low <= high : NEW_LINE INDENT mid = ( high + low ) >> 1 NEW_LINE if check ( s , mid ) : NEW_LINE INDENT ans , high = mid , mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcde \" NEW_LINE print ( binarySearch ( s ) ) NEW_LINE s = \" aaaa \" NEW_LINE print ( binarySearch ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum K such that every substring of length atleast K contains a character c | This function checks if there exists some character which appears in all K length substrings ; Iterate over all possible characters ; stores the last occurrence ; set answer as true ; No occurrence found of current character in first substring of length K ; Check for every last substring of length K where last occurr - ence exists in substring ; If last occ is not present in substring ; current character is K amazing ; This function performs binary search over the answer to minimise it ; Check if answer is found try to minimise it ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "8034-8034",
        "Code": "def prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isVowel ( c ) : NEW_LINE INDENT c = c . lower ( ) NEW_LINE if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isValidString ( word ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT if ( isVowel ( word [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( prime ( cnt ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE if ( isValidString ( s ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if the string satisfies the given condition | Function that returns true if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if c is a vowel ; Function that returns true if the count of vowels in word is prime ; If count of vowels is prime ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8035-8035",
        "Code": "def subStringsStartingHere ( string , n , startIndex ) : NEW_LINE INDENT count = 0 NEW_LINE i = startIndex + 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if string . startswith ( string [ startIndex : i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSubStrings ( string , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if string [ i ] == string [ 0 ] : NEW_LINE INDENT count += subStringsStartingHere ( string , n , i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ababc \" NEW_LINE n = len ( string ) NEW_LINE print ( countSubStrings ( string , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sub | Function to return the count of sub - strings starting from startIndex that are also the prefixes of string ; Function to return the count of all possible sub - strings of string that are also the prefixes of string ; If current character is equal to the starting character of str ; Driver Code ; Function Call",
        "Category": "Substring"
    },
    {
        "ID": "804-804",
        "Code": "def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ row ▁ = ▁ \" , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( \" Sum ▁ of ▁ middle ▁ column ▁ = ▁ \" , col_sum ) NEW_LINE DEDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of middle row and column in Matrix | Python program to find sum of middle row and column in matrix ; loop for sum of row ; loop for sum of column ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "8040-8040",
        "Code": "def binarySearch ( arr , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE res = ( x == arr [ m ] ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT return m - 1 NEW_LINE DEDENT if ( res > 0 ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" contribute \" , \" geeks \" , \" ide \" , \" practice \" ] ; NEW_LINE x = \" ide \" NEW_LINE result = binarySearch ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element ▁ not ▁ present \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element ▁ found ▁ at ▁ index \" , result ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Binary Search a String | Returns index of x if it is present in arr [ ] , else return - 1 ; Check if x is present at mid ; If x greater , ignore left half ; If x is smaller , ignore right half ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "8041-8041",
        "Code": "def printExpansion ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , len ( str ) ) : NEW_LINE INDENT print ( str [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT str = \" geeks \" NEW_LINE printExpansion ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Concatenate suffixes of a String | Function to print the expansion of the string ; Take sub - string from i to n - 1 ; Print the sub - string ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8043-8043",
        "Code": "from math import sqrt NEW_LINE max_val = 257 NEW_LINE def PrimeCharacters ( s ) : NEW_LINE INDENT prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( prime [ ord ( s [ i ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" geeksforgeeks \" ; NEW_LINE print ( PrimeCharacters ( S ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count characters in a string whose ASCII values are prime | Python3 implementation of above approach ; Function to find prime characters in the string ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a Boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; 0 and 1 are not primes ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Traverse all the characters ; Driver program ; print required answer",
        "Category": "Math"
    },
    {
        "ID": "805-805",
        "Code": "MAX = 1000 NEW_LINE from time import clock NEW_LINE arr = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def rowMajor ( ) : NEW_LINE INDENT global arr NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT arr [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def colMajor ( ) : NEW_LINE INDENT global arr NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT arr [ j ] [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT t = clock ( ) NEW_LINE rowMajor ( ) ; NEW_LINE t = clock ( ) - t NEW_LINE print ( \" Row ▁ major ▁ access ▁ time ▁ : { : .2f } ▁ s \" . format ( t ) ) NEW_LINE t = clock ( ) NEW_LINE colMajor ( ) NEW_LINE t = clock ( ) - t NEW_LINE print ( \" Column ▁ major ▁ access ▁ time ▁ : { : .2f } ▁ s \" . format ( t ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Row | taking MAX 10000 so that time difference can be shown ; accessing element row wise ; accessing element column wise ; Driver code ; Time taken by row major order ; Time taken by column major order",
        "Category": "Array"
    },
    {
        "ID": "8050-8050",
        "Code": "ALL_CHARS = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( ALL_CHARS ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * ALL_CHARS NEW_LINE countTW = [ 0 ] * ALL_CHARS NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if compare ( countP , countTW ) : NEW_LINE INDENT return True NEW_LINE DEDENT countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i - M ] ) ] -= 1 NEW_LINE DEDENT if compare ( countP , countTW ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def calculateSubString ( s1 , s2 , n ) : NEW_LINE INDENT count , j , x = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for length in range ( 1 , n - i + 1 ) : NEW_LINE INDENT if search ( s1 [ i : i + length ] , s2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" PLEASEHELPIMTRAPPED \" NEW_LINE str2 = \" INAKICKSTARTFACTORY \" NEW_LINE length = len ( str1 ) NEW_LINE print ( calculateSubString ( str1 , str2 , length ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of sub | Python3 program to find the number of sub - strings of s1 which are anagram of any sub - string of s2 ; This function returns true if contents of arr1 [ ] and arr2 [ ] are same , otherwise false . ; This function search for all permutations of string pat [ ] in string txt [ ] ; countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text ; Traverse through remaining characters of pattern ; Compare counts of current window of text with counts of pattern [ ] ; cout << pat << \" ▁ \" << txt << \" ▁ \" ; ; Add current character to current window ; Remove the first character of previous window ; Check for the last window in text ; Function to return the number of sub - strings of s1 that are anagrams of any sub - string of s2 ; initializing variables ; outer loop for picking starting point ; loop for different length of substrings ; If s2 has any substring which is anagram of s1 . substr ( i , len ) ; increment the count ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "8052-8052",
        "Code": "import math as mt NEW_LINE def logicalExpressionEvaluation ( string ) : NEW_LINE INDENT arr = list ( ) NEW_LINE n = len ( string ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( string [ i ] == \" [ \" ) : NEW_LINE INDENT s = list ( ) NEW_LINE while ( arr [ - 1 ] != \" ] \" ) : NEW_LINE INDENT s . append ( arr [ - 1 ] ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT arr . pop ( ) NEW_LINE if ( len ( s ) == 3 ) : NEW_LINE INDENT if s [ 2 ] == \"1\" : NEW_LINE INDENT arr . append ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( \"1\" ) NEW_LINE DEDENT DEDENT elif ( len ( s ) == 5 ) : NEW_LINE INDENT a = int ( s [ 0 ] ) - 48 NEW_LINE b = int ( s [ 4 ] ) - 48 NEW_LINE c = 0 NEW_LINE if s [ 2 ] == \" & \" : NEW_LINE INDENT c = a & b NEW_LINE DEDENT else : NEW_LINE INDENT c = a | b NEW_LINE DEDENT arr . append ( ( c ) + 48 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr . append ( string [ i ] ) NEW_LINE DEDENT DEDENT return arr [ - 1 ] NEW_LINE DEDENT string = \" [ | , [ & ,1 , [ ! , 0 ] ] , [ ! , [ | , [ ▁ , 1,0 ] , [ ! ,1 ] ] ] ] \" NEW_LINE print ( logicalExpressionEvaluation ( string ) ) NEW_LINE",
        "Type": "py",
        "NL": "Solve the Logical Expression given by string | Python3 program to solve the logical expression . ; Function to evaluate the logical expression ; traversing string from the end . ; for NOT operation ; for AND and OR operation ; Driver code",
        "Category": "Stack"
    },
    {
        "ID": "806-806",
        "Code": "M = 3 NEW_LINE N = 3 NEW_LINE matrix = [ [ 12 , 23 , 34 ] , [ 45 , 56 , 67 ] , [ 78 , 89 , 91 ] ] NEW_LINE def rotateMatrix ( k ) : NEW_LINE INDENT global M , N , matrix NEW_LINE temp = [ 0 ] * M NEW_LINE k = k % M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for t in range ( 0 , M - k ) : NEW_LINE INDENT temp [ t ] = matrix [ i ] [ t ] NEW_LINE DEDENT for j in range ( M - k , M ) : NEW_LINE INDENT matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] NEW_LINE DEDENT for j in range ( k , M ) : NEW_LINE INDENT matrix [ i ] [ j ] = temp [ j - k ] NEW_LINE DEDENT DEDENT DEDENT def displayMatrix ( ) : NEW_LINE INDENT global M , N , matrix NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT print ( \" { } ▁ \" . format ( matrix [ i ] [ j ] ) , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT k = 2 NEW_LINE rotateMatrix ( k ) NEW_LINE displayMatrix ( ) NEW_LINE",
        "Type": "py",
        "NL": "Rotate the matrix right by K times | size of matrix ; function to rotate matrix by k times ; temporary array of size M ; within the size of matrix ; copy first M - k elements to temporary array ; copy the elements from k to end to starting ; copy elements from temporary array to end ; function to display the matrix ; Driver code ; rotate matrix by k ; display rotated matrix",
        "Category": "Matrix"
    },
    {
        "ID": "807-807",
        "Code": "N = 3 ; NEW_LINE def multiply ( mat , res ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] = 0 ; NEW_LINE for k in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT def InvolutoryMatrix ( mat ) : NEW_LINE INDENT res = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] ; NEW_LINE res = multiply ( mat , res ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j and res [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( i != j and res [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 ] , [ 0 , - 1 , 0 ] , [ 0 , 0 , - 1 ] ] ; NEW_LINE if ( InvolutoryMatrix ( mat ) ) : NEW_LINE INDENT print ( \" Involutory ▁ Matrix \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Involutory ▁ Matrix \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check Involutory Matrix | Program to implement involutory matrix . ; Function for matrix multiplication . ; Function to check involutory matrix . ; multiply function call . ; Driver Code ; Function call . If function return true then if part will execute otherwise else part will execute .",
        "Category": "Matrix"
    },
    {
        "ID": "8075-8075",
        "Code": "def CountWords ( str , k ) : NEW_LINE INDENT sum = 0 NEW_LINE NumberOfWords = 0 NEW_LINE counter = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT if ( sum < k ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT sum = 0 NEW_LINE NumberOfWords += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += ord ( str [ i ] ) NEW_LINE DEDENT DEDENT NumberOfWords += 1 NEW_LINE if ( sum < k ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT print ( \" Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII \" , \" values ▁ less ▁ than ▁ k ▁ = \" , counter ) NEW_LINE print ( \" Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII ▁ values \" , \" greater ▁ than ▁ or ▁ equal ▁ to ▁ k ▁ = \" , NumberOfWords - counter ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" Learn ▁ how ▁ to ▁ code \" NEW_LINE k = 400 NEW_LINE CountWords ( str , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count the number of words having sum of ASCII values less than and greater than k | Function to count the words ; Sum of ascii values ; Number of words having sum of ascii less than k ; If character is a space ; Add the ascii value to sum ; Handling the Last word separately ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8077-8077",
        "Code": "from sys import maxsize NEW_LINE def sameCharAdj ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE st = set ( ) NEW_LINE st . add ( string [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if string [ i ] in st : NEW_LINE INDENT return False NEW_LINE DEDENT st . add ( string [ i ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT def minSwaps ( string , l , r , cnt , minm ) : NEW_LINE INDENT if l == r : NEW_LINE INDENT if sameCharAdj ( string ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT else : NEW_LINE INDENT return maxsize NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 , 1 ) : NEW_LINE INDENT string [ i ] , string [ l ] = string [ l ] , string [ i ] NEW_LINE cnt += 1 NEW_LINE x = minSwaps ( string , l + 1 , r , cnt , minm ) NEW_LINE string [ i ] , string [ l ] = string [ l ] , string [ i ] NEW_LINE cnt -= 1 NEW_LINE y = minSwaps ( string , l + 1 , r , cnt , minm ) NEW_LINE minm = min ( minm , min ( x , y ) ) NEW_LINE DEDENT return minm NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abbaacb \" NEW_LINE string = list ( string ) NEW_LINE n = len ( string ) NEW_LINE cnt = 0 NEW_LINE minm = maxsize NEW_LINE print ( minSwaps ( string , 0 , n - 1 , cnt , minm ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum swaps to group similar characters side by side ? | checks whether a string has similar characters side by side ; If similar chars side by side , continue ; If we have found a char equal to current char and does not exist side to it , return false ; counts min swap operations to convert a string that has similar characters side by side ; Base case ; considering swapping of i and l chars ; Backtrack ; not considering swapping of i and l chars ; taking min of above two ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8079-8079",
        "Code": "def separateChar ( str__ ) : NEW_LINE INDENT n = len ( str__ ) NEW_LINE digitSum = 0 NEW_LINE alphabetSum = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( str__ [ i ] ) >= 48 and ord ( str__ [ i ] ) <= 56 ) : NEW_LINE INDENT digitSum += ord ( str__ [ i ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT alphabetSum += ord ( str__ [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE alphabetSum %= 26 NEW_LINE DEDENT DEDENT sumStr = str ( digitSum ) NEW_LINE alphabetStr = chr ( alphabetSum + ord ( ' a ' ) - 1 ) NEW_LINE sumStr += alphabetStr NEW_LINE return sumStr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str__ = \"3652adyz3423\" NEW_LINE print ( separateChar ( str__ ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange a string in the form of integer sum followed by the minimized character | function to return maximum volume ; separate digits and alphabets ; change digit sum to string ; change alphabet sum to string ; concatenate sum to alphabets string ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8098-8098",
        "Code": "import math NEW_LINE def fact ( n ) : NEW_LINE INDENT f = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f = f * i ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT def npr ( n , r ) : NEW_LINE INDENT return fact ( n ) / fact ( n - r ) ; NEW_LINE DEDENT def countPermutations ( str ) : NEW_LINE INDENT even = math . floor ( len ( str ) / 2 ) ; NEW_LINE odd = len ( str ) - even ; NEW_LINE ways = 0 ; NEW_LINE freq = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT nvowels = ( freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ) ; NEW_LINE nconsonants = len ( str ) - nvowels ; NEW_LINE ways = ( npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ) ; NEW_LINE return int ( ways ) ; NEW_LINE DEDENT str = \" geeks \" ; NEW_LINE print ( countPermutations ( str ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Arrangement of the characters of a word such that all vowels are at odd places | Python3 program to find the number of ways in which the characters of the word can be arranged such that the vowels occupy only the odd positions ; Function to return the factorial of a number ; calculating nPr ; Function to find the number of ways in which the characters of the word can be arranged such that the vowels occupy only the odd positions ; Get total even positions ; Get total odd positions ; Store frequency of each character of the string ; Count total number of vowels ; Count total number of consonants ; Calculate the total number of ways ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8101-8101",
        "Code": "def replacingConsonants ( s ) : NEW_LINE INDENT nVowel = \" aaaeeeeiiiiioooooouuuuuuuu \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT s = s . replace ( s [ i ] , nVowel [ ord ( s [ i ] ) - 97 ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT s = \" geeksforgeeks \" ; NEW_LINE print ( replacingConsonants ( s ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Replace all consonants with nearest vowels in a string | Function to replace consonant with nearest vowels ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8115-8115",
        "Code": "def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically largest string formed from the characters in range L and R | Function to return the lexicographically largest string ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans string ; iterate in frequency array ; add til all characters are added ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8118-8118",
        "Code": "def max_length_substring ( st , n , k ) : NEW_LINE INDENT max_len = 0 NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '0' ) : NEW_LINE INDENT len = len + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT len = 0 NEW_LINE DEDENT max_len = max ( max_len , len ) NEW_LINE DEDENT if ( max_len == n ) : NEW_LINE INDENT return n * k NEW_LINE DEDENT pref = 0 NEW_LINE suff = 0 NEW_LINE i = 0 NEW_LINE while ( st [ i ] == '0' ) : NEW_LINE INDENT i = i + 1 NEW_LINE pref = pref + 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while ( st [ i ] == '0' ) : NEW_LINE INDENT i = i - 1 NEW_LINE suff = suff + 1 NEW_LINE DEDENT if ( k > 1 ) : NEW_LINE INDENT max_len = max ( max_len , pref + suff ) NEW_LINE DEDENT return max_len NEW_LINE DEDENT n = 6 NEW_LINE k = 3 NEW_LINE st = \"110010\" NEW_LINE ans = max_length_substring ( st , n , k ) NEW_LINE print ( ans ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum Consecutive Zeroes in Concatenated Binary String | returns the maximum size of a substring consisting only of zeroes after k concatenation ; stores the maximum length of the required substring ; if the current character is 0 ; stores maximum length of current substrings with zeroes ; if the whole is filled with zero ; computes the length of the maximal prefix which contains only zeroes ; computes the length of the maximal suffix which contains only zeroes ; if more than 1 concatenations are to be made ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8121-8121",
        "Code": "def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT S = \"2222\" ; NEW_LINE X = 97 ; NEW_LINE print ( countSubStr ( S , X ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count number of substrings with numeric value greater than X | Function that counts valid sub - strings ; Only take those numbers that do not start with '0' . ; converting the sub - string starting from index ' i ' and having length ' len ' to int and checking if it is greater than X or not ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8122-8122",
        "Code": "' NEW_LINE def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = \" \" NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isBinary ( a [ i ] ) == True : NEW_LINE INDENT s += str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT cout <<   \" - 1 NEW_LINE DEDENT DEDENT \" NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether a binary string can be formed by concatenating given N numbers sequentially | Function that returns false if the number passed as argument contains digit ( s ) other than '0' or '1 ; Function that checks whether the binary string can be formed or not ; Empty string for storing the binary number ; check if a [ i ] can be a part of the binary string ; Conversion of int into string ; if a [ i ] can 't be a part  then break the loop ; possible to create binary string ; impossible to create binary string ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8127-8127",
        "Code": "def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aaaabbbccdddd \" NEW_LINE k = 4 NEW_LINE solve ( s , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sub | Function that counts all the sub - strings of length ' k ' which have all identical characters ; count of sub - strings , length , initial position of sliding window ; dictionary to store the frequency of the characters of sub - string ; increase the frequency of the character and length of the sub - string ; if the length of the sub - string is greater than K ; remove the character from the beginning of sub - string ; if the length of the sub string is equal to k and frequency of one of its characters is equal to the length of the sub - string i . e . all the characters are same increase the count ; display the number of valid sub - strings ; Driver code",
        "Category": "Sliding Window"
    },
    {
        "ID": "8131-8131",
        "Code": "def fact ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result *= i NEW_LINE DEDENT return result NEW_LINE DEDENT def getResult ( string , ch ) : NEW_LINE INDENT has = [ 0 ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT has [ ord ( string [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT particular = has [ ord ( ch ) - ord ( ' A ' ) ] NEW_LINE if particular == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT has [ ord ( ch ) - ord ( ' A ' ) ] = 0 NEW_LINE total = len ( string ) NEW_LINE total = total - particular + 1 NEW_LINE result = fact ( total ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if has [ i ] > 1 : NEW_LINE INDENT result /= fact ( has [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" MISSISSIPPI \" NEW_LINE print ( getResult ( string , ' S ' ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of permutations of a string in which all the occurrences of a given character occurs together | Function to return factorial of the number passed as argument ; Function to get the total permutations which satisfy the given condition ; Create has to store count of each character ; Store character occurrences ; Count number of times Particular character comes ; If particular character isn 't  present in the string then return 0 ; Remove count of particular character ; Total length of the string ; Assume all occurrences of particular character as a single character . ; Compute factorial of the length ; Divide by the factorials of the no . of occurrences of all the characters . ; return the result ; Driver code ; Assuming the string and the character are all in uppercase",
        "Category": "Hash Table"
    },
    {
        "ID": "8132-8132",
        "Code": "def isPalindrome ( r ) : NEW_LINE INDENT p = r [ : : - 1 ] NEW_LINE return r == p NEW_LINE DEDENT def CheckStr ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE for i in range ( 2 , l + 1 ) : NEW_LINE INDENT if isPalindrome ( s [ 0 : i ] ) == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == ( l + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , l + 1 ) : NEW_LINE INDENT if isPalindrome ( s [ l - i : l ] ) == True : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abccbarfgdbd \" NEW_LINE if CheckStr ( s ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if suffix and prefix of a string are palindromes | Function to check whether the string is a palindrome ; Reverse the string and assign it to new variable for comparison ; check if both are same ; Function to check whether the string has prefix and suffix substrings of length greater than 1 which are palindromes . ; check all prefix substrings ; check if the prefix substring is a palindrome ; If we did not find any palindrome prefix of length greater than 1. ; check all suffix substrings , as the string is reversed now ; check if the suffix substring is a palindrome ; If we did not find a suffix ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8138-8138",
        "Code": "def isPalindrome ( s ) : NEW_LINE INDENT s1 = \" \" NEW_LINE N = len ( s ) NEW_LINE i = ( N - 1 ) NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE i = i - 1 NEW_LINE DEDENT if ( s == s1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createString ( N ) : NEW_LINE INDENT s2 = \" \" NEW_LINE s = str ( N ) NEW_LINE letters = \" abcdefghij \" NEW_LINE sum = 0 NEW_LINE substr = \" \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT digit = int ( s [ i ] ) NEW_LINE substr += letters [ digit ] NEW_LINE sum += digit NEW_LINE DEDENT while ( len ( s2 ) <= sum ) : NEW_LINE INDENT s2 += substr NEW_LINE DEDENT s2 = s2 [ : sum ] NEW_LINE return isPalindrome ( s2 ) NEW_LINE DEDENT N = 61 ; NEW_LINE flag = createString ( N ) NEW_LINE if ( flag ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to create a palindrome string from given N | Function to check if a string is palindrome or not ; String that stores characters of s in reverse order ; Length of the string s ; String used to form substring using N ; Variable to store sum of digits of N ; Forming the substring by traversing N ; Appending the substr to str till it 's length becomes equal to sum ; Trimming the string str so that it 's length becomes equal to sum ; Driver code ; Calling function isPalindrome to check if str is Palindrome or not",
        "Category": "Substring"
    },
    {
        "ID": "8146-8146",
        "Code": "def count_carry ( a , b ) : NEW_LINE INDENT carry = 0 ; NEW_LINE count = 0 ; NEW_LINE len_a = len ( a ) ; NEW_LINE len_b = len ( b ) ; NEW_LINE while ( len_a != 0 or len_b != 0 ) : NEW_LINE INDENT x = 0 ; NEW_LINE y = 0 ; NEW_LINE if ( len_a > 0 ) : NEW_LINE INDENT x = int ( a [ len_a - 1 ] ) + int ( '0' ) ; NEW_LINE len_a -= 1 ; NEW_LINE DEDENT if ( len_b > 0 ) : NEW_LINE INDENT y = int ( b [ len_b - 1 ] ) + int ( '0' ) ; NEW_LINE len_b -= 1 ; NEW_LINE DEDENT sum = x + y + carry ; NEW_LINE if ( sum >= 10 ) : NEW_LINE INDENT carry = 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT a = \"9555\" ; NEW_LINE b = \"555\" ; NEW_LINE count = count_carry ( a , b ) ; NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( \"0\" ) ; NEW_LINE DEDENT elif ( count == 1 ) : NEW_LINE INDENT print ( \"1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count the number of carry operations required to add two numbers | Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers / digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8155-8155",
        "Code": "def balancedString ( str ) : NEW_LINE INDENT count , i = 0 , 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE count += 1 NEW_LINE DEDENT elif ( str [ i ] == ' ) ' and count != 0 ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE count -= 1 NEW_LINE DEDENT elif ( str [ i ] != ' ) ' ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT for i in range ( count ) : NEW_LINE INDENT print ( \" ) \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : str = \" gau ) ra ) v ( ku ( mar ( rajput ) ) \" NEW_LINE INDENT balancedString ( str ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Balance a string after removing extra brackets | Print balanced and remove extra brackets from string ; Maintain a count for opening brackets Traversing string ; check if opening bracket ; print str [ i ] and increment count by 1 ; check if closing bracket and count != 0 ; decrement count by 1 ; if str [ i ] not a closing brackets print it ; balanced brackets if opening brackets are more then closing brackets ; print remaining closing brackets ; Driver code",
        "Category": "String"
    },
    {
        "ID": "8158-8158",
        "Code": "MAX = 256 NEW_LINE def minimumOperation ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE first_occ = [ - 1 ] * MAX NEW_LINE res = float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x = s [ i ] NEW_LINE if first_occ [ ord ( x ) ] == - 1 : NEW_LINE INDENT first_occ [ ord ( x ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT last_occ = n - i - 1 NEW_LINE res = min ( res , first_occ [ ord ( x ) ] + last_occ ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" bacdefghipalop \" NEW_LINE print ( minimumOperation ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum operation require to make first and last character same | Python3 program to find minimum operation require to make first and last character same ; Return the minimum operation require to make string first and last character same . ; Store indexes of first occurrences of characters . ; Initialize result ; Traverse through all characters ; Find first occurrence ; Update result for subsequent occurrences ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8161-8161",
        "Code": "def removeDuplicatesFromString ( str2 ) : NEW_LINE INDENT counter = 0 ; NEW_LINE i = 0 ; NEW_LINE size = len ( str2 ) ; NEW_LINE str1 = list ( str2 ) ; NEW_LINE x = 0 ; NEW_LINE length = 0 ; NEW_LINE while ( i < size ) : NEW_LINE INDENT x = ord ( str1 [ i ] ) - 97 ; NEW_LINE if ( ( counter & ( 1 << x ) ) == 0 ) : NEW_LINE INDENT str1 [ length ] = chr ( 97 + x ) ; NEW_LINE counter = counter | ( 1 << x ) ; NEW_LINE length += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT str2 = ' ' . join ( str1 ) ; NEW_LINE return str2 [ 0 : length ] ; NEW_LINE DEDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( removeDuplicatesFromString ( str1 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Remove duplicates from a string in O ( 1 ) extra space | Function to remove duplicates ; keeps track of visited characters ; gets character value ; keeps track of length of resultant string ; check if Xth bit of counter is unset ; mark current character as visited ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8162-8162",
        "Code": "def removeDuplicatesFromString ( string ) : NEW_LINE INDENT table = [ 0 for i in range ( 256 ) ] NEW_LINE endIndex = 0 NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( table [ ord ( string [ i ] ) ] == 0 ) : NEW_LINE INDENT table [ ord ( string [ i ] ) ] = - 1 NEW_LINE string [ endIndex ] = string [ i ] NEW_LINE endIndex += 1 NEW_LINE DEDENT DEDENT ans = \" \" NEW_LINE for i in range ( endIndex ) : NEW_LINE ans += string [ i ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT temp = \" geeksforgeeks \" NEW_LINE print ( removeDuplicatesFromString ( temp ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove duplicates from a string in O ( 1 ) extra space | Method to remove duplicates ; Table to keep track of visited characters ; To keep track of end index of resultant string ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8163-8163",
        "Code": "def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if ( lexMax < currStr ) : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if ( lexMin > currStr ) : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" GeeksForGeeks \" NEW_LINE k = 3 NEW_LINE getSmallestAndLargest ( str1 , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest and largest substring of size k | Python 3 program to find lexicographically largest and smallest substrings of size k . ; Initialize min and max as first substring of size k ; Consider all remaining substrings . We consider every substring ending with index i . ; Print result . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8164-8164",
        "Code": "def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' ▁ ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + \" . ▁ \" , end = \" \" ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ishita ▁ bhuiya \" NEW_LINE printInitials ( string ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to print the initials of a name with the surname | Python program to print the initials of a name with the surname ; to remove any leading or trailing spaces ; to store extracted words ; forming the word ; when space is encountered it means the name is completed and thereby extracted ; printing the first letter of the name in capital letters ; for the surname , we have to print the entire surname and not just the initial string \" t \" has the surname now ; first letter of surname in capital letter ; rest of the letters in small ; printing surname ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8173-8173",
        "Code": "def isInGivenBase ( Str , base ) : NEW_LINE INDENT if ( base > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( base <= 10 ) : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) or ( ord ( Str [ i ] ) >= ord ( ' A ' ) and ord ( Str [ i ] ) < ( ord ( ' A ' ) + base - 10 ) ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT Str = \" AF87\" NEW_LINE if ( isInGivenBase ( Str , 16 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a number is in given base or not | Python3 program to check if given number is in given base or not . ; Allowed bases are till 16 ( Hexadecimal ) ; If base is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from 'A ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8176-8176",
        "Code": "def frequency ( fre , s , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT string = s [ i ] NEW_LINE for j in range ( 0 , len ( string ) ) : NEW_LINE INDENT fre [ i ] [ ord ( string [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT DEDENT def LongestSequence ( fre , n ) : NEW_LINE INDENT for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT mi = fre [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT mi = min ( fre [ j ] [ i ] , mi ) NEW_LINE DEDENT while mi : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE mi -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = [ \" loo \" , \" lol \" , \" olive \" ] NEW_LINE n = len ( s ) NEW_LINE MAX_CHAR = 26 NEW_LINE fre = [ [ 0 for i in range ( 26 ) ] for j in range ( n ) ] NEW_LINE frequency ( fre , s , n ) NEW_LINE LongestSequence ( fre , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest common anagram subsequence from N strings | Function to store frequency of each character in each string ; Function to Find longest possible sequence of N strings which is anagram to each other ; to get lexicographical largest sequence . ; find minimum of that character ; print that character minimum number of times ; Driver code ; to store frequency of each character in each string ; To get frequency of each character ; Function call",
        "Category": "Hash Table"
    },
    {
        "ID": "8177-8177",
        "Code": "def printIndex ( str , s ) : NEW_LINE INDENT flag = False ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i : i + len ( s ) ] == s ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) ; NEW_LINE flag = True ; NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( \" NONE \" ) ; NEW_LINE DEDENT DEDENT str1 = \" GeeksforGeeks \" ; NEW_LINE str2 = \" Geeks \" ; NEW_LINE printIndex ( str1 , str2 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find indices of all occurrence of one string in other | Python program to find indices of all occurrences of one String in other . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8178-8178",
        "Code": "def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = \" ▁ \" . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = \" ▁ \" . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" test \" NEW_LINE str2 = \" ttew \" NEW_LINE if ( arePermutation ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if two strings are permutation of each other | function to check whether two strings are Permutation of each other ; Get lengths of both strings ; If length of both strings is not same , then they cannot be Permutation ; Sort both strings ; Compare sorted strings ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8182-8182",
        "Code": "def merge ( s1 , s2 ) : NEW_LINE INDENT result = \" \" NEW_LINE i = 0 NEW_LINE while ( i < len ( s1 ) ) or ( i < len ( s2 ) ) : NEW_LINE INDENT if ( i < len ( s1 ) ) : NEW_LINE INDENT result += s1 [ i ] NEW_LINE DEDENT if ( i < len ( s2 ) ) : NEW_LINE INDENT result += s2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT s1 = \" geeks \" NEW_LINE s2 = \" forgeeks \" NEW_LINE print ( merge ( s1 , s2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Alternatively Merge two Strings in Java | Function for alternatively merging two strings ; To store the final string ; For every index in the strings ; First choose the ith character of the first string if it exists ; Then choose the ith character of the second string if it exists ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8192-8192",
        "Code": "def getMaxOccurringChar ( str ) : NEW_LINE INDENT freq = [ 0 for i in range ( 100 ) ] NEW_LINE max = - 1 NEW_LINE len__ = len ( str ) NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( 0 , len__ , 1 ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( max < freq [ i ] ) : NEW_LINE INDENT max = freq [ i ] NEW_LINE result = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" sample ▁ program \" NEW_LINE print ( \" Maximum ▁ occurring ▁ character ▁ = \" , getMaxOccurringChar ( str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum occurring character in an input string | Set | function to find the maximum occurring character in an input string which is lexicographically first ; freq [ ] used as hash table ; to store maximum frequency ; length of str ; get frequency of each character of 'str ; for each character , where character is obtained by ( i + ' a ' ) check whether it is the maximum character so far and accodingly update 'result ; maximum occurring character ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8194-8194",
        "Code": "def predictWinner ( score , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 2 ) ] NEW_LINE for i in range ( 0 , len ( score ) , 1 ) : NEW_LINE INDENT index = ord ( score [ i ] ) - ord ( '0' ) NEW_LINE count [ index ] += 1 NEW_LINE if ( count [ 0 ] == n and count [ 1 ] < n - 1 ) : NEW_LINE INDENT print ( \" GEEKS ▁ lost \" , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( count [ 1 ] == n and count [ 0 ] < n - 1 ) : NEW_LINE INDENT print ( \" GEEKS ▁ won \" , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( count [ 0 ] == n - 1 and count [ 1 ] == n - 1 ) : NEW_LINE INDENT count [ 0 ] = 0 NEW_LINE count [ 1 ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE for i in range ( i , len ( score ) , 1 ) : NEW_LINE INDENT index = ord ( score [ i ] ) - ord ( '0' ) NEW_LINE count [ index ] += 1 NEW_LINE if ( abs ( count [ 0 ] - count [ 1 ] ) == 2 ) : NEW_LINE INDENT if ( count [ 0 ] > count [ 1 ] ) : NEW_LINE INDENT print ( \" GEEKS ▁ lost \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" GEEKS ▁ won \" , end = \" ▁ \" ) ; NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT score = \"1001010101111011101111\" NEW_LINE n = 15 NEW_LINE predictWinner ( score , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the winner of a game where scores are given as a binary string | function for winner prediction ; increase count ; check losing condition ; check winning condition ; check tie on n - 1 point ; increase count ; check for 2 point lead ; condition of lost ; condition of win ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8195-8195",
        "Code": "def isPalindrome ( str , l , r ) : NEW_LINE INDENT while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def CyclicShifts ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE str = str + str NEW_LINE cnt = 0 NEW_LINE while ( right < 2 * n - 1 ) : NEW_LINE INDENT if ( isPalindrome ( str , left , right ) ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt += 1 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" bccbbaab \" ; NEW_LINE print ( CyclicShifts ( str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of Counterclockwise shifts to make a string palindrome | Function to check if given string is palindrome or not . ; Function to find counter clockwise shifts to make string palindrome . ; Pointer to starting of current shifted string . ; Pointer to ending of current shifted string . ; Concatenate string with itself ; To store counterclockwise shifts ; Move left and right pointers one step at a time . ; Check if current shifted string is palindrome or not ; If string is not palindrome then increase count of number of shifts by 1. ; Driver code .",
        "Category": "Two Pointers"
    },
    {
        "ID": "8197-8197",
        "Code": "def printString ( n , str ) : NEW_LINE INDENT str2 = \" \" NEW_LINE extraChar = n % 26 NEW_LINE if ( extraChar >= 1 ) : NEW_LINE INDENT for i in range ( 26 - ( extraChar + 1 ) , 26 ) : NEW_LINE INDENT str2 += str [ i ] NEW_LINE DEDENT DEDENT countOfStr = n // 26 NEW_LINE for i in range ( 1 , countOfStr + 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT str2 += str [ j ] NEW_LINE DEDENT DEDENT return str2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 30 NEW_LINE str = \" zyxwvutsrqponmlkjihgfedcba \" NEW_LINE print ( printString ( n , str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find a string such that every character is lexicographically greater than its immediate next character | Function that prints the required string ; Find modulus with 26 ; Print extra characters required ; Print the given reverse string countOfStr times ; Driver Code ; Initialize a string in reverse order",
        "Category": "Substring"
    },
    {
        "ID": "8198-8198",
        "Code": "def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = \" \" NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Common Prefix Matching | Set | A Utility Function to find the common prefix between first and last strings ; Compare str1 and str2 ; A Function that returns the longest common prefix from the array of strings ; sorts the N set of strings ; prints the common prefix of the first and the last string of the set of strings ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8199-8199",
        "Code": "def newString ( s , k ) : NEW_LINE INDENT X = \" \" NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < k and i < len ( s ) ) : NEW_LINE INDENT if ( s [ i ] < temp ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT X = X + temp NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( s [ i ] == temp ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return X NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" gaurang \" NEW_LINE k = 3 NEW_LINE print ( newString ( s , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically smallest string formed by appending a character from the first K characters of a given string | Function to find the new string thus formed by removing characters ; new string ; Remove characters until the string is empty ; Traverse to find the smallest character in the first k characters ; append the smallest character ; removing the lexicographically smallest character from the string ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "820-820",
        "Code": "N = 3 NEW_LINE def isMagicSquare ( mat ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s = s + mat [ i ] [ i ] NEW_LINE DEDENT s2 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s2 = s2 + mat [ i ] [ N - i - 1 ] NEW_LINE DEDENT if ( s != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT rowSum = 0 ; NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT rowSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( rowSum != s ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT colSum = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT colSum += mat [ j ] [ i ] NEW_LINE DEDENT if ( s != colSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 2 , 7 , 6 ] , [ 9 , 5 , 1 ] , [ 4 , 3 , 8 ] ] NEW_LINE if ( isMagicSquare ( mat ) ) : NEW_LINE INDENT print ( \" Magic ▁ Square \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ magic ▁ Square \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check given matrix is magic square or not | Python3 program to check whether a given matrix is magic matrix or not ; Returns true if mat [ ] [ ] is magic square , else returns false . ; calculate the sum of the prime diagonal ; the secondary diagonal ; For sums of Rows ; check if every row sum is equal to prime diagonal sum ; For sums of Columns ; check if every column sum is equal to prime diagonal sum ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "8206-8206",
        "Code": "from typing import List NEW_LINE def generateSubsequences ( input : str , output : str , idx : int , ans : List [ str ] ) -> None : NEW_LINE INDENT if idx == len ( input ) : NEW_LINE INDENT if ( len ( output ) ) : NEW_LINE INDENT ans . append ( output ) NEW_LINE DEDENT return NEW_LINE DEDENT generateSubsequences ( input , output , idx + 1 , ans ) NEW_LINE output += input [ idx ] NEW_LINE generateSubsequences ( input , output , idx + 1 , ans ) NEW_LINE output = output [ : - 1 ] NEW_LINE upper = input [ idx ] NEW_LINE upper = upper . upper ( ) NEW_LINE output += upper NEW_LINE generateSubsequences ( input , output , idx + 1 , ans ) NEW_LINE DEDENT def printSubsequences ( S : str ) -> None : NEW_LINE INDENT output = \" \" NEW_LINE ans = [ ] NEW_LINE generateSubsequences ( S , output , 0 , ans ) NEW_LINE ans . sort ( ) NEW_LINE for string in ans : NEW_LINE INDENT print ( string , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" ab \" NEW_LINE printSubsequences ( S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sudo Placement | Special Subsequences | Python3 program to find all special subsequences of the given type ; Function to generate the required subsequences ; If the index pointer has reached the end of input string ; Skip empty ( \" ▁ \" ) subsequence ; Exclude current character in output string ; Include current character in output string ; Remove the current included character and and include it in its uppercase form ; Function to print the required subsequences ; Output String to store every subsequence ; Set of strings that will store all special subsequences in lexicographical sorted order ; Sort the strings to print in sorted order ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8214-8214",
        "Code": "def nextGreatestAlphabet ( alphabets , K ) : NEW_LINE INDENT n = len ( alphabets ) NEW_LINE if ( K >= alphabets [ n - 1 ] ) : NEW_LINE return alphabets [ 0 ] NEW_LINE l = 0 NEW_LINE r = len ( alphabets ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE if ( alphabets [ mid ] > K ) : NEW_LINE INDENT r = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT if ( alphabets [ ans ] < K ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return alphabets [ ans ] NEW_LINE DEDENT DEDENT letters = [ ' A ' , ' r ' , ' z ' ] NEW_LINE K = ' z ' NEW_LINE result = nextGreatestAlphabet ( letters , K ) NEW_LINE print ( result ) NEW_LINE",
        "Type": "py",
        "NL": "Smallest alphabet greater than a given character | Returns the smallest character from the given set of letters that is greater than K ; Take the first element as l and the rightmost element as r ; if this while condition does not satisfy simply return the first element . ; Return the smallest element ; Driver Code ; Function call",
        "Category": "Binary Search"
    },
    {
        "ID": "8216-8216",
        "Code": "def isGreaterThanEqualTo ( s1 , s2 ) : NEW_LINE INDENT if len ( s1 ) > len ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return s1 == s2 NEW_LINE DEDENT def multiply ( s1 , s2 ) : NEW_LINE INDENT n , m = len ( s1 ) , len ( s2 ) NEW_LINE result = [ 0 ] * ( n + m ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT result [ i + j + 1 ] += ( int ( s1 [ i ] ) * int ( s2 [ j ] ) ) NEW_LINE DEDENT DEDENT size = len ( result ) NEW_LINE for i in range ( size - 1 , 0 , - 1 ) : NEW_LINE INDENT if result [ i ] >= 10 : NEW_LINE INDENT result [ i - 1 ] += result [ i ] // 10 NEW_LINE result [ i ] = result [ i ] % 10 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < size and result [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == size : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT temp = \" \" NEW_LINE while i < size : NEW_LINE INDENT temp += str ( result [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return temp NEW_LINE DEDENT def removeLeadingZeores ( s ) : NEW_LINE INDENT n , i = len ( s ) , 0 NEW_LINE while i < n and s [ i ] == '0' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT temp = \" \" NEW_LINE while i < n : NEW_LINE INDENT temp += s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return temp NEW_LINE DEDENT def isPower ( s1 , s2 ) : NEW_LINE INDENT s1 = removeLeadingZeores ( s1 ) NEW_LINE s2 = removeLeadingZeores ( s2 ) NEW_LINE if s1 == \"0\" or s2 == \"0\" : NEW_LINE INDENT return False NEW_LINE DEDENT if s1 == \"1\" and s2 == \"1\" : NEW_LINE INDENT return True NEW_LINE DEDENT if s1 == \"1\" and s2 == \"1\" : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( s1 ) > len ( s2 ) : NEW_LINE INDENT return isPower ( s2 , s1 ) NEW_LINE DEDENT temp = s1 NEW_LINE while not isGreaterThanEqualTo ( s1 , s2 ) : NEW_LINE INDENT s1 = multiply ( s1 , temp ) NEW_LINE DEDENT return s1 == s2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 , s2 = \"374747\" , \"52627712618930723\" NEW_LINE if isPower ( s1 , s2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT s1 , s2 = \"4099\" , \"2\" NEW_LINE if isPower ( s1 , s2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Given two numbers as strings , find if one is a power of other | Python3 program to check if one number is a power of other ; Multiply the numbers . It multiplies each digit of second string to each digit of first and stores the result . ; If the digit exceeds 9 , add the cumulative carry to previous digit . ; If all zeroes , return \"0\" . ; Remove starting zeroes . ; Removes Extra zeroes from front of a string . ; Make sure there are no leading zeroes in the string . ; Making sure that s1 is smaller . If it is greater , we recur we reversed parameters . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8218-8218",
        "Code": "def reverse ( string , start , end ) : NEW_LINE INDENT temp = ' ' NEW_LINE while start <= end : NEW_LINE INDENT temp = string [ start ] NEW_LINE string [ start ] = string [ end ] NEW_LINE string [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT def reverseletter ( string , start , end ) : NEW_LINE INDENT wstart , wend = start , start NEW_LINE while wend < end : NEW_LINE INDENT if string [ wend ] == \" ▁ \" : NEW_LINE INDENT wend += 1 NEW_LINE continue NEW_LINE DEDENT while wend <= end and string [ wend ] != \" ▁ \" : NEW_LINE INDENT wend += 1 NEW_LINE DEDENT wend -= 1 NEW_LINE reverse ( string , wstart , wend ) NEW_LINE wend += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Ashish ▁ Yadav ▁ Abhishek ▁ Rajput ▁ Sunil ▁ Pundir \" NEW_LINE string = list ( string ) NEW_LINE reverseletter ( string , 0 , len ( string ) - 1 ) NEW_LINE print ( ' ' . join ( string ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse String according to the number of words | Reverse the letters of the word ; Temporary variable to store character ; Swapping the first and last character ; This function forms the required string ; Checking the number of words present in string to reverse ; Reverse the letter of the words ; Driver Code",
        "Category": "Two Pointers"
    },
    {
        "ID": "8221-8221",
        "Code": "def minimumFlip ( s , x , y ) : NEW_LINE INDENT s = s + s NEW_LINE isOpposite = False NEW_LINE if ( x > y ) : NEW_LINE INDENT temp = y NEW_LINE y = x ; NEW_LINE x = temp NEW_LINE isOpposite = True NEW_LINE DEDENT valClockwise = 0 NEW_LINE cur = s [ x ] NEW_LINE for i in range ( x , y + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valClockwise += 1 NEW_LINE DEDENT DEDENT valAnticlockwise = 0 NEW_LINE cur = s [ y ] NEW_LINE x += len ( s ) - 1 NEW_LINE for i in range ( y , x + 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] != cur ) : NEW_LINE INDENT cur = s [ i ] NEW_LINE valAnticlockwise += 1 NEW_LINE DEDENT DEDENT if ( valClockwise <= valAnticlockwise ) : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isOpposite == False ) : NEW_LINE INDENT print ( \" Anti - clockwise \" , valAnticlockwise ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Clockwise \" , valClockwise ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 0 NEW_LINE y = 8 NEW_LINE s = \"000110\" NEW_LINE minimumFlip ( s , x , y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum bit changes in Binary Circular array to reach a index | finding which path have minimum flip bit and the minimum flip bits ; concatenating given string to itself , to make it circular ; check x is greater than y . marking if output need to be opposite . ; iterate Clockwise ; if current bit is not equal to next index bit . ; iterate Anti - Clockwise ; if current bit is not equal to next index bit . ; Finding whether Clockwise or Anti - clockwise path take minimum flip . ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8226-8226",
        "Code": "def subzero ( str , k ) : NEW_LINE INDENT ans = 0 NEW_LINE curr = 0 NEW_LINE n = len ( str ) NEW_LINE for i in str : NEW_LINE INDENT if ( i == '0' ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr = 0 NEW_LINE DEDENT ans = max ( ans , curr ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( ans == n ) : NEW_LINE INDENT print ( n * k ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT pre = suff = 0 NEW_LINE for i in str : NEW_LINE INDENT if ( i == '0' ) : NEW_LINE INDENT pre += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT suff += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( k > 1 ) : NEW_LINE INDENT ans = max ( ans , pre + suff ) NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT k = 5 NEW_LINE str = '00100110' NEW_LINE subzero ( str , k ) NEW_LINE",
        "Type": "py",
        "NL": "Longest substring of 0 s in a string formed by k concatenations | Function to calculate maximum length of substring containing only zero ; loop to calculate longest substring in string containing 0 's ; if all elements in string a are '0 ; Else , find prefix and suffix containing only zeroes ; Calculate length of the prefix containing only zeroes ; Calculate length of the suffix containing only zeroes ; if k <= 1 , no need to take suffix + prefix into account ; Driver program to test above function",
        "Category": "Substring"
    },
    {
        "ID": "8227-8227",
        "Code": "def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE str = \"01110\" NEW_LINE print ( possibleToSort ( arr , n , str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sorting array with conditional swapping | Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8232-8232",
        "Code": "N = 20 NEW_LINE def countPair ( st , n ) : NEW_LINE INDENT cnt = [ 0 ] * ( 1 << 10 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = 0 NEW_LINE for j in range ( len ( st [ i ] ) ) : NEW_LINE INDENT mask |= ( 1 << ( ord ( st [ i ] [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT cnt [ mask ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for m1 in range ( 1024 ) : NEW_LINE INDENT for m2 in range ( 1024 ) : NEW_LINE INDENT if ( ( m1 m2 ) == 1023 ) : NEW_LINE INDENT if ( m1 == m2 ) : NEW_LINE INDENT ans += ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( cnt [ m1 ] * cnt [ m2 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans // 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE st = [ \"129300455\" , \"5559948277\" , \"012334556\" , \"56789\" , \"123456879\" ] NEW_LINE print ( countPair ( st , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Pairs whose concatenation contain all digits | Python3 Program to find number of pairs whose concatenation contains all digits from 0 to 9. ; Function to return number of pairs whose concatenation contain all digits from 0 to 9 ; Making the mask for each of the number . ; for each of the possible pair which can make OR value equal to 1023 ; Finding the count of pair from the given numbers . ; Driven Program",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8235-8235",
        "Code": "mod = 1000000007 NEW_LINE Max = 1001 NEW_LINE nCr = [ [ 0 for _ in range ( 1003 ) ] for i in range ( 1003 ) ] NEW_LINE def preComputeCoeff ( ) : NEW_LINE INDENT for i in range ( Max ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT nCr [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT nCr [ i ] [ j ] = ( nCr [ i - 1 ] [ j - 1 ] + nCr [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT DEDENT DEDENT DEDENT def computeStringCount ( N ) : NEW_LINE INDENT n = N // 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT ans = ( ans + ( ( nCr [ n ] [ i ] * nCr [ n ] [ i // 2 ] ) % mod ) ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT preComputeCoeff ( ) NEW_LINE N = 3 NEW_LINE print ( computeStringCount ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count binary strings with twice zeros in first half | pre define some constant ; global values for pre computation ; function to print number of required string ; calculate answer using proposed algorithm ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "8236-8236",
        "Code": "MAX = 100 NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" GFGFG \" NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of ' GFG ' Subsequences in the given string | Python 3 Program to find the \" GFG \" subsequence in the given string ; Print the count of \" GFG \" subsequence in the string ; Traversing the given string ; If the character is ' G ' , increment the count of ' G ' , increase the result and update the array . ; If the character is ' F ' , increment the count of ' F ' and update the array . ; Ignore other character . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8237-8237",
        "Code": "def cipher ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isalpha ( ) == 0 and str [ i ] != \" ▁ \" : NEW_LINE INDENT print ( \" Enter ▁ only ▁ alphabets ▁ and ▁ space \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" Encrypted ▁ Code ▁ using ▁ Latin ▁ Alphabet \" ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] >= \" A \" and str [ i ] <= \" Z \" : NEW_LINE INDENT print ( ord ( str [ i ] ) - ord ( \" A \" ) + 1 , end = \" ▁ \" ) NEW_LINE DEDENT elif str [ i ] >= \" a \" and str [ i ] <= ' z ' : NEW_LINE INDENT print ( ord ( str [ i ] ) - ord ( \" a \" ) + 1 , end = \" ▁ \" ) NEW_LINE DEDENT if str [ i ] == \" ▁ \" : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE cipher ( str ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Latin alphabet cipher | function for calculating the encryption ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8239-8239",
        "Code": "def LexicographicalMaxString ( str ) : NEW_LINE INDENT mx = \" \" NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mx = max ( mx , str [ i : ] ) NEW_LINE DEDENT return mx NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" ababaa \" NEW_LINE print ( LexicographicalMaxString ( str ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographical Maximum substring of string | Python 3 program to find the lexicographically maximum substring . ; loop to find the max leicographic substring in the substring array ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "824-824",
        "Code": "import math NEW_LINE def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE k = 7 NEW_LINE freq = find ( n , k ) NEW_LINE if ( freq < 0 ) : NEW_LINE INDENT print ( \" ▁ element ▁ not ▁ exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ▁ Frequency ▁ of ▁ \" , k , \" ▁ is ▁ \" , freq ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count frequency of k in a matrix of size n where matrix ( i , j ) = i + j | Python program to find the frequency of k in matrix where m ( i , j ) = i + j ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8244-8244",
        "Code": "def checkPalin ( word ) : NEW_LINE INDENT n = len ( word ) NEW_LINE word = word . lower ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( word [ i ] != word [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def longestPalin ( str ) : NEW_LINE INDENT str = str + \" ▁ \" NEW_LINE longestword = \" \" NEW_LINE word = \" \" NEW_LINE length1 = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch != ' ▁ ' ) : NEW_LINE INDENT word = word + ch NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( word ) NEW_LINE if ( checkPalin ( word ) and length > length1 ) : NEW_LINE INDENT length1 = length NEW_LINE longestword = word NEW_LINE DEDENT word = \" \" NEW_LINE DEDENT DEDENT return longestword NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" My ▁ name ▁ is ▁ ava ▁ and ▁ i ▁ love ▁ Geeksforgeeks \" NEW_LINE if ( longestPalin ( s ) == \" \" ) : NEW_LINE INDENT print ( \" No ▁ Palindrome ▁ Word \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( longestPalin ( s ) ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Print longest palindrome word in a sentence | Function to check if a word is palindrome ; making the check case case insensitive ; loop to check palindrome ; Function to find longest palindrome word ; to check last word for palindrome ; to store each word ; extracting each word ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8246-8246",
        "Code": "def isCommonBase ( base , s1 , s2 ) : NEW_LINE ' NEW_LINE INDENT for j in range ( len ( s1 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonBases ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , min ( n1 , n2 ) + 1 ) : NEW_LINE INDENT base = s1 [ 0 : i ] NEW_LINE if ( isCommonBase ( base , s1 , s2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" pqrspqrs \" NEW_LINE s2 = \" pqrspqrspqrspqrs \" NEW_LINE print ( countCommonBases ( s1 , s2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of common base strings for two strings | function for finding common divisor . ; Checking if ' base ' is base string of 's1 ; Checking if ' base ' is base string of 's2 ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8249-8249",
        "Code": "def countWays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 ; NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] = ( count [ ord ( x ) - ord ( ' a ' ) ] ) + 1 ; NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE ans = 1 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" acbbcc \" ; NEW_LINE print ( countWays ( s ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Ways to split string such that each partition starts with distinct character | Returns the number of we can split the string ; Finding the frequency of each character . ; making frequency of first character of string equal to 1. ; Finding the product of frequency of occurrence of each character . ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "825-825",
        "Code": "def ZigZag ( rows , columns , numbers ) : NEW_LINE INDENT k = 0 NEW_LINE arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] NEW_LINE for i in range ( rows ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < columns and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT j = columns - 1 NEW_LINE while j >= 0 and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT for i in arr : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows = 4 ; NEW_LINE columns = 5 ; NEW_LINE Numbers = [ 3 , 4 , 2 , 2 , 3 , 1 , 5 ] NEW_LINE ZigZag ( rows , columns , Numbers ) NEW_LINE",
        "Type": "py",
        "NL": "Given 1 ' s , ▁ 2' s , 3 ' s ▁ . . . . . . k ' s print them in zig zag way . | function that prints given number of 1 ' s , ▁ 2' s , 3 ' s ▁ . . . . k ' s in zig - zag way . ; two - dimensional array to store numbers . ; for even row . ; for each column . ; storing element . ; decrement element at kth index . ; if array contains zero then increment index to make this next index ; for odd row . ; for each column . ; storing element . ; decrement element at kth index . ; if array contains zero then increment index to make this next index . ; printing the stored elements . ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "8253-8253",
        "Code": "def checkPalin ( word ) : NEW_LINE INDENT if word . lower ( ) == word . lower ( ) [ : : - 1 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def countPalin ( str ) : NEW_LINE INDENT count = 0 NEW_LINE listOfWords = str . split ( \" ▁ \" ) NEW_LINE for elements in listOfWords : NEW_LINE INDENT if ( checkPalin ( elements ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT countPalin ( \" Madam ▁ Arora ▁ teaches ▁ malayalam \" ) NEW_LINE countPalin ( \" Nitin ▁ speaks ▁ malayalam \" ) NEW_LINE",
        "Type": "py",
        "NL": "Count palindrome words in a sentence | Function to check if a word is palindrome ; Function to count palindrome words ; splitting each word as spaces as delimiter and storing it into a list ; Iterating every element from list and checking if it is a palindrome . ; if the word is a palindrome increment the count . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8260-8260",
        "Code": "def is_vow ( c ) : NEW_LINE ' NEW_LINE INDENT return ( ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] , end = \" \" ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( is_vow ( str [ i - 1 ] ) != True ) or ( is_vow ( str [ i ] ) != True ) ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT str = \" ▁ geeks ▁ for ▁ geeks \" ; NEW_LINE removeVowels ( str ) ; NEW_LINE",
        "Type": "py",
        "NL": "Remove consecutive vowels from string | function which returns True or False for occurrence of a vowel ; this compares vowel with character 'c ; function to print resultant string ; print 1 st character ; loop to check for each character ; comparison of consecutive characters ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8264-8264",
        "Code": "def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find one extra character in a string | Python3 program to find extra character in one string ; store string values in map ; store second string in map with frequency ; store first string in map with frequency ; if the frequency is 1 then this character is which is added extra ; Driver Code ; given string ; find Extra Character",
        "Category": "Hash Table"
    },
    {
        "ID": "8265-8265",
        "Code": "def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( strA ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strA [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( strB ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strB [ i ] ) NEW_LINE DEDENT return ( ( chr ) ( res ) ) ; NEW_LINE DEDENT strA = \" abcd \" NEW_LINE strB = \" cbdad \" NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find one extra character in a string | Python 3 program to find extra character in one string ; result store the result ; traverse string A till end and xor with res ; xor with res ; traverse string B till end and xor with res ; xor with res ; print result at the end ; given string",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8266-8266",
        "Code": "def findExtraCharacter ( s1 , s2 ) : NEW_LINE INDENT smallStr = \" \" NEW_LINE largeStr = \" \" NEW_LINE if ( len ( s1 ) > len ( s2 ) ) : NEW_LINE INDENT smallStr = s2 NEW_LINE largeStr = s1 NEW_LINE DEDENT else : NEW_LINE INDENT smallStr = s1 NEW_LINE largeStr = s2 NEW_LINE DEDENT smallStrCodeTotal = 0 NEW_LINE largeStrCodeTotal = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( smallStr ) ) : NEW_LINE INDENT smallStrCodeTotal += ord ( smallStr [ i ] ) NEW_LINE largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT largeStrCodeTotal += ord ( largeStr [ i ] ) NEW_LINE intChar = largeStrCodeTotal - smallStrCodeTotal NEW_LINE return chr ( intChar ) NEW_LINE DEDENT s1 = \" abcd \" NEW_LINE s2 = \" cbdae \" NEW_LINE extraChar = findExtraCharacter ( s1 , s2 ) NEW_LINE print ( \" Extra ▁ Character : \" , extraChar ) NEW_LINE",
        "Type": "py",
        "NL": "Find one extra character in a string | Python Program to find extra character in one string ; Determine string with extra character ; Add Character codes of both the strings ; Add last character code of large string ; Minus the character code of smaller string from the character code of large string The result will be the extra character code ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8267-8267",
        "Code": "def transformString ( s ) : NEW_LINE ' NEW_LINE INDENT ch = ' a ' NEW_LINE if ( len ( s ) < 26 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( ord ( ch ) > ord ( ' z ' ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ i ] <= ch ) : NEW_LINE INDENT s [ i ] = ch NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT if ( ch <= ' z ' ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT print ( \" \" . join ( s ) ) NEW_LINE DEDENT s = list ( \" aaaaaaaaaaaaaaaaaaaaaaaaaa \" ) NEW_LINE transformString ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Transform a string such that it has abcd . . z as a subsequence | function to transform string with string passed as reference ; initializing the variable ch to 'a ; if the length of string is less than 26 , we can 't obtain the required  subsequence ; if ch has reached ' z ' , it means we have transformed our string such that required subsequence can be obtained ; current character is not greater than ch , then replace it with ch and increment ch ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8268-8268",
        "Code": "def isPanDigital ( s ) : NEW_LINE INDENT digits = [ False ] * 10 ; NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT digits [ int ( s [ i ] ) - int ( '0' ) ] = True NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( digits [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPandigitalPairs ( v ) : NEW_LINE INDENT pairs = 0 NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( v ) ) : NEW_LINE INDENT if ( isPanDigital ( v [ i ] + v [ j ] ) ) : NEW_LINE INDENT pairs = pairs + 1 NEW_LINE DEDENT DEDENT DEDENT return pairs NEW_LINE DEDENT v = [ \"123567\" , \"098234\" , \"14765\" , \"19804\" ] NEW_LINE print ( countPandigitalPairs ( v ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of pairs with Pandigital Concatenation | Checks if a given is Pandigital ; digit i is not present thus not pandigital ; Returns number of pairs of strings resulting in Pandigital Concatenations ; iterate over all pair of strings ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8270-8270",
        "Code": "MAX = 256 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def countPalinPermutations ( str ) : NEW_LINE INDENT global MAX NEW_LINE n = len ( str ) NEW_LINE freq = [ 0 ] * MAX ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] = freq [ ord ( str [ i ] ) ] + 1 ; NEW_LINE DEDENT res = fact ( int ( n / 2 ) ) NEW_LINE oddFreq = False NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT half = int ( freq [ i ] / 2 ) NEW_LINE if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( oddFreq == True ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT oddFreq = True NEW_LINE DEDENT res = int ( res / fact ( half ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT str = \" gffg \" NEW_LINE print ( countPalinPermutations ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of palindromic permutations | Set 1 | Python3 program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n / 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8272-8272",
        "Code": "def copy_str ( x , y ) : NEW_LINE INDENT if len ( y ) == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT c = copy_str ( x , ( y ) [ 1 : - 1 ] ) NEW_LINE return c NEW_LINE DEDENT DEDENT x = input ( ) NEW_LINE y = input ( ) NEW_LINE print ( copy_str ( x , y ) ) NEW_LINE",
        "Type": "py",
        "NL": "Function to copy string ( Iterative and Recursive ) | Function to copy one string to other ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8276-8276",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , next = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def newNode ( c ) : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . c = c NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def reverse_word ( str ) : NEW_LINE INDENT s = \" \" NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT s = str [ i ] + s NEW_LINE i = i + 1 NEW_LINE DEDENT return s NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT ptr = head NEW_LINE while ( ptr != None ) : NEW_LINE INDENT ptr . c = reverse_word ( ptr . c ) NEW_LINE ptr = ptr . next NEW_LINE DEDENT return head NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . c , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT head = newNode ( \" Geeksforgeeks \" ) NEW_LINE head . next = newNode ( \" a \" ) NEW_LINE head . next . next = newNode ( \" computer \" ) NEW_LINE head . next . next . next = newNode ( \" science \" ) NEW_LINE head . next . next . next . next = newNode ( \" portal \" ) NEW_LINE head . next . next . next . next . next = newNode ( \" for \" ) NEW_LINE head . next . next . next . next . next . next = newNode ( \" geeks \" ) NEW_LINE print ( \" List ▁ before ▁ reverse : ▁ \" ) NEW_LINE printList ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print (   \" List after reverse :   \" ) NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Reverse each word in a linked list node | Node of a linked list ; Function to create newNode in a linked list ; reverse each node data ; iterate each node and call reverse_word for each node data ; printing linked list ; Driver program",
        "Category": "Linked List"
    },
    {
        "ID": "8284-8284",
        "Code": "def LargestString ( na ) : NEW_LINE INDENT N = len ( na ) NEW_LINE c = [ 0 ] * N NEW_LINE m = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT character = [ False ] * 26 NEW_LINE for k in range ( len ( na [ j ] ) ) : NEW_LINE INDENT x = ord ( na [ j ] [ k ] ) - ord ( ' A ' ) NEW_LINE if ( ( na [ j ] [ k ] != ' ▁ ' ) and ( character [ x ] == False ) ) : NEW_LINE INDENT c [ j ] += 1 NEW_LINE character [ x ] = True NEW_LINE DEDENT if ( c [ j ] > c [ m ] ) : NEW_LINE INDENT m = j NEW_LINE DEDENT DEDENT DEDENT print ( na [ m ] ) NEW_LINE DEDENT na = [ \" BOB \" , \" A ▁ AB ▁ C ▁ JOHNSON \" , \" ANJALI \" , \" ASKRIT \" , \" ARMAN ▁ MALLIK \" ] NEW_LINE LargestString ( na ) NEW_LINE",
        "Type": "py",
        "NL": "String with maximum number of unique characters | Function to find string with maximum number of unique characters . ; Index of string with maximum unique characters ; Iterate through all strings ; Array indicating any alphabet included or not included ; count number of unique alphabets in each string ; keep track of maximum number of alphabets ; print result ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8286-8286",
        "Code": "def longestWordLength ( string ) : NEW_LINE INDENT length = 0 NEW_LINE for word in string . split ( ) : NEW_LINE INDENT if ( len ( word ) > length ) : NEW_LINE INDENT length = len ( word ) NEW_LINE DEDENT DEDENT return length NEW_LINE DEDENT string = \" I ▁ am ▁ an ▁ intern ▁ at ▁ geeksforgeeks \" NEW_LINE print ( longestWordLength ( string ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for length of the longest word in a sentence | Python program to find the number of characters in the longest word in the sentence . ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8287-8287",
        "Code": "def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE corner = \" geeks \" NEW_LINE if ( isCornerPresent ( str , corner ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if a string starts and ends with another given string | Python program to find if a given corner string is present at corners . ; If length of corner string is more , it cannot be present at corners . ; Return true if corner string is present at both corners of given string . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8290-8290",
        "Code": "def morseEncode ( x ) : NEW_LINE INDENT if x is ' a ' : NEW_LINE INDENT return \" . - \" NEW_LINE DEDENT elif x is ' b ' : NEW_LINE INDENT return \" - . . . \" NEW_LINE DEDENT elif x is ' c ' : NEW_LINE INDENT return \" - . - . \" NEW_LINE DEDENT elif x is ' d ' : NEW_LINE INDENT return \" - . . \" NEW_LINE DEDENT elif x is ' e ' : NEW_LINE INDENT return \" . \" NEW_LINE DEDENT elif x is ' f ' : NEW_LINE INDENT return \" . . - . \" NEW_LINE DEDENT elif x is ' g ' : NEW_LINE INDENT return \" - - . \" NEW_LINE DEDENT elif x is ' h ' : NEW_LINE INDENT return \" . . . . \" NEW_LINE DEDENT elif x is ' i ' : NEW_LINE INDENT return \" . . \" NEW_LINE DEDENT elif x is ' j ' : NEW_LINE INDENT return \" . - - - \" NEW_LINE DEDENT elif x is ' k ' : NEW_LINE INDENT return \" - . - \" NEW_LINE DEDENT elif x is ' l ' : NEW_LINE INDENT return \" . - . . \" NEW_LINE DEDENT elif x is ' m ' : NEW_LINE INDENT return \" - - \" NEW_LINE DEDENT elif x is ' n ' : NEW_LINE INDENT return \" - . \" NEW_LINE DEDENT elif x is ' o ' : NEW_LINE INDENT return \" - - - \" NEW_LINE DEDENT elif x is ' p ' : NEW_LINE INDENT return \" . - - . \" NEW_LINE DEDENT elif x is ' q ' : NEW_LINE INDENT return \" - - . - \" NEW_LINE DEDENT elif x is ' r ' : NEW_LINE INDENT return \" . - . \" NEW_LINE DEDENT elif x is ' s ' : NEW_LINE INDENT return \" . . . \" NEW_LINE DEDENT elif x is ' t ' : NEW_LINE INDENT return \" - \" NEW_LINE DEDENT elif x is ' u ' : NEW_LINE INDENT return \" . . - \" NEW_LINE DEDENT elif x is ' v ' : NEW_LINE INDENT return \" . . . - \" NEW_LINE DEDENT elif x is ' w ' : NEW_LINE INDENT return \" . - - \" NEW_LINE DEDENT elif x is ' x ' : NEW_LINE INDENT return \" - . . - \" NEW_LINE DEDENT elif x is ' y ' : NEW_LINE INDENT return \" - . - - \" NEW_LINE DEDENT elif x is ' z ' : NEW_LINE INDENT return \" - - . . \" NEW_LINE DEDENT elif x is '1' : NEW_LINE INDENT return \" . - - - - \" ; NEW_LINE DEDENT elif x is '2' : NEW_LINE INDENT return \" . . - - - \" ; NEW_LINE DEDENT elif x is '3' : NEW_LINE INDENT return \" . . . - - \" ; NEW_LINE DEDENT elif x is '4' : NEW_LINE INDENT return \" . . . . - \" ; NEW_LINE DEDENT elif x is '5' : NEW_LINE INDENT return \" . . . . . \" ; NEW_LINE DEDENT elif x is '6' : NEW_LINE INDENT return \" - . . . . \" ; NEW_LINE DEDENT elif x is '7' : NEW_LINE INDENT return \" - - . . . \" ; NEW_LINE DEDENT elif x is '8' : NEW_LINE INDENT return \" - - - . . \" ; NEW_LINE DEDENT elif x is '9' : NEW_LINE INDENT return \" - - - - . \" ; NEW_LINE DEDENT elif x is '0' : NEW_LINE INDENT return \" - - - - - \" ; NEW_LINE DEDENT DEDENT def morseCode ( s ) : NEW_LINE INDENT for character in s : NEW_LINE INDENT print ( morseEncode ( character ) , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE morseCode ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Morse Code Implementation | function to encode a alphabet as Morse code ; refer to the Morse table image attached in the article ; for space ; character by character print Morse code ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8291-8291",
        "Code": "def polybiusCipher ( s ) : NEW_LINE INDENT for char in s : NEW_LINE INDENT row = int ( ( ord ( char ) - ord ( ' a ' ) ) / 5 ) + 1 NEW_LINE col = ( ( ord ( char ) - ord ( ' a ' ) ) % 5 ) + 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if char == ' k ' : NEW_LINE INDENT row = row - 1 NEW_LINE col = 5 - col + 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT elif ord ( char ) >= ord ( ' j ' ) : NEW_LINE INDENT if col == 1 : NEW_LINE INDENT col = 6 NEW_LINE row = row - 1 NEW_LINE DEDENT col = col - 1 NEW_LINE DEDENT print ( row , col , end = ' ' , sep = ' ' ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE polybiusCipher ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Polybius Square Cipher | function to display polybius cipher text ; convert each character to its encrypted code ; finding row of the table ; finding column of the table ; if character is 'k ; if character is greater than 'j ; Driver 's Code ; print the cipher of \" geeksforgeeks \"",
        "Category": "Math"
    },
    {
        "ID": "8293-8293",
        "Code": "def minRemoval ( strr ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for char in strr : NEW_LINE INDENT hash [ ord ( char ) - ord ( ' a ' ) ] = hash [ ord ( char ) - ord ( ' a ' ) ] + 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if hash [ i ] % 2 : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return 0 if count == 0 else count - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strr = \" geeksforgeeks \" ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum removal to make palindrome permutation | function to find minimum removal of characters ; hash to store frequency of each character to set hash array to zeros ; count frequency of each character ; count the odd frequency characters ; if count is 0 , return 0 otherwise return count ; Driver 's Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8295-8295",
        "Code": "def findMaxSegment ( s , k ) : NEW_LINE INDENT seg_len = len ( s ) - k NEW_LINE res = 0 NEW_LINE for i in range ( seg_len ) : NEW_LINE INDENT res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT seg_len_pow = pow ( 10 , seg_len - 1 ) NEW_LINE curr_val = res NEW_LINE for i in range ( 1 , len ( s ) - seg_len ) : NEW_LINE INDENT curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow NEW_LINE curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) NEW_LINE res = max ( res , curr_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"8754\" NEW_LINE k = 2 NEW_LINE print ( \" Maximum ▁ number ▁ = ▁ \" , findMaxSegment ( s , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum segment value after putting k breakpoints in a number | Function to Find Maximum Number ; Maximum segment length ; Find value of first segment of seg_len ; Find value of remaining segments using sliding window ; To find value of current segment , first remove leading digit from previous value ; Then add trailing digit ; Driver Code",
        "Category": "Sliding Window"
    },
    {
        "ID": "8298-8298",
        "Code": "from collections import defaultdict NEW_LINE def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT def calculateTotal ( temp , n ) : NEW_LINE INDENT f = factorial ( n ) NEW_LINE hm = defaultdict ( int ) NEW_LINE for i in range ( len ( temp ) ) : NEW_LINE INDENT hm [ temp [ i ] ] += 1 NEW_LINE DEDENT for e in hm : NEW_LINE INDENT x = hm [ e ] NEW_LINE if ( x > 1 ) : NEW_LINE INDENT temp5 = factorial ( x ) NEW_LINE f //= temp5 NEW_LINE DEDENT return f NEW_LINE DEDENT DEDENT def nextPermutation ( temp ) : NEW_LINE INDENT for i in range ( len ( temp ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( temp [ i ] > temp [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT min = i NEW_LINE x = temp [ i - 1 ] NEW_LINE for j in range ( i + 1 , len ( temp ) ) : NEW_LINE INDENT if ( ( temp [ j ] < temp [ min ] ) and ( temp [ j ] > x ) ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT temp [ i - 1 ] , temp [ min ] = ( temp [ min ] , temp [ i - 1 ] ) NEW_LINE temp [ i : ] . sort ( ) NEW_LINE print ( ' ' . join ( temp ) ) NEW_LINE DEDENT def printAllPermutations ( s ) : NEW_LINE INDENT temp = list ( s ) NEW_LINE temp . sort ( ) NEW_LINE print ( ' ' . join ( temp ) ) NEW_LINE total = calculateTotal ( temp , len ( temp ) ) NEW_LINE for i in range ( 1 , total ) : NEW_LINE INDENT nextPermutation ( temp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" AAB \" NEW_LINE printAllPermutations ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print distinct sorted permutations with duplicates allowed in input | Python3 program to print all permutations of a string in sorted order . ; Calculating factorial of a number ; Method to find total number of permutations ; Building Map to store frequencies of all characters . ; Traversing map and finding duplicate elements . ; Start traversing from the end and find position ' i - 1' of the first character which is greater than its successor ; Finding smallest character after ' i - 1' and greater than temp [ i - 1 ] ; Swapping the above found characters . ; Sort all digits from position next to ' i - 1' to end of the string ; Print the String ; Sorting String ; Print first permutation ; Finding the total permutations ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8302-8302",
        "Code": "def printSequence ( arr , input ) : NEW_LINE INDENT n = len ( input ) NEW_LINE output = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + \"0\" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT str = [ \"2\" , \"22\" , \"222\" , \"3\" , \"33\" , \"333\" , \"4\" , \"44\" , \"444\" , \"5\" , \"55\" , \"555\" , \"6\" , \"66\" , \"666\" , \"7\" , \"77\" , \"777\" , \"7777\" , \"8\" , \"88\" , \"888\" , \"9\" , \"99\" , \"999\" , \"9999\" ] NEW_LINE input = \" GEEKSFORGEEKS \" ; NEW_LINE print ( printSequence ( str , input ) ) NEW_LINE",
        "Type": "py",
        "NL": "Convert a sentence into its equivalent mobile numeric keypad sequence | Function which computes the sequence ; length of input string ; checking for space ; calculating index for each character ; output sequence ; storing the sequence in array",
        "Category": "Array"
    },
    {
        "ID": "8305-8305",
        "Code": "def isConvertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT commonLength = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT commonLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" geek \" NEW_LINE str2 = \" geek \" NEW_LINE k = 7 NEW_LINE if ( isConvertible ( str1 , str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT str1 = \" geeks \" NEW_LINE str2 = \" geek \" NEW_LINE k = 5 NEW_LINE if ( isConvertible ( str1 , str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Converting one string to other using append and delete last operations | Returns true if it is possible to convert str1 to str2 using k operations . ; Case A ( i ) ; finding common length of both string ; Case A ( ii ) - ; Case B - ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8311-8311",
        "Code": "MAX_LEN , MAX_CHAR = 1005 , 26 NEW_LINE cnt = [ [ 0 for i in range ( MAX_CHAR ) ] for j in range ( MAX_LEN ) ] NEW_LINE def preProcess ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt [ i ] [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT cnt [ i ] [ j ] += cnt [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def findCharFreq ( l , r , c ) : NEW_LINE INDENT return ( cnt [ r ] [ ord ( c ) - 97 ] - cnt [ l - 1 ] [ ord ( c ) - 97 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE Q = 4 NEW_LINE preProcess ( s ) NEW_LINE print ( findCharFreq ( 0 , 5 , ' e ' ) ) NEW_LINE print ( findCharFreq ( 2 , 6 , ' f ' ) ) NEW_LINE print ( findCharFreq ( 4 , 7 , ' m ' ) ) NEW_LINE print ( findCharFreq ( 0 , 12 , ' e ' ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries for frequencies of characters in substrings | Python3 program to find occurrence of character in substring l to r ; To store count of all character ; To pre - process string from 0 to size of string ; Store occurrence of character i ; Store occurrence o all character upto i ; To return occurrence of character in range l to r ; Return occurrence of character from 0 to r minus its occurrence from 0 to l ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8313-8313",
        "Code": "import math NEW_LINE def findLUSlength ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT a = \" abcdabcd \" NEW_LINE b = \" abcabc \" NEW_LINE print ( findLUSlength ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Longest Uncommon Subsequence | Python program to find longest uncommon subsequence using naive method ; function to calculate length of longest uncommon subsequence ; Case 1 : If strings are equal ; for case 2 and case 3 ; input strings",
        "Category": "Substring"
    },
    {
        "ID": "8323-8323",
        "Code": "def solve ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE x = l // 2 NEW_LINE y = l NEW_LINE p = \" \" NEW_LINE while ( x > 0 and y > l / 2 ) : NEW_LINE INDENT p = p + s [ x - 1 ] NEW_LINE x = x - 1 NEW_LINE p = p + s [ y - 1 ] NEW_LINE y = y - 1 NEW_LINE DEDENT if ( y > l // 2 ) : NEW_LINE INDENT p = p + s [ y - 1 ] NEW_LINE y = y - 1 NEW_LINE DEDENT print ( p ) NEW_LINE DEDENT s = \" sunshine \" NEW_LINE solve ( s ) NEW_LINE",
        "Type": "py",
        "NL": "Create a new string by alternately combining the characters of two halves of the string in reverse | Function performing calculations ; Calculating the two halves of string s as first and second . The final string p ; It joins the characters to final string in reverse order ; It joins the characters to final string in reverse order ; Driver code ; Calling function",
        "Category": "Substring"
    },
    {
        "ID": "8324-8324",
        "Code": "def swapTwoHalves ( a , b ) : NEW_LINE INDENT la = len ( a ) NEW_LINE lb = len ( b ) NEW_LINE c = a [ 0 : la // 2 ] + b [ lb // 2 : lb ] NEW_LINE d = b [ 0 : lb // 2 ] + a [ la // 2 : la ] NEW_LINE print ( c ,   \" \" , d ) NEW_LINE DEDENT a = \" remuneration \" NEW_LINE b = \" day \" NEW_LINE / * Calling function * / NEW_LINE swapTwoHalves ( a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Interchanging first and second halves of strings | Function to concatenate two different halves of given strings ; Creating new strings by exchanging the first half of a and b . Please refer below for details of substr . https : www . geeksforgeeks . org / stdsubstr - in - ccpp / ; Driver function ;",
        "Category": "Substring"
    },
    {
        "ID": "8327-8327",
        "Code": "str = \" GeeksforGeeks \" NEW_LINE def string_length ( str ) : NEW_LINE INDENT if str == ' ' : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + string_length ( str [ 1 : ] ) NEW_LINE DEDENT DEDENT print ( string_length ( str ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for length of a string using recursion | Python program to calculate length of a string using recursion ; Function to calculate length ; if we reach at the end of the string ; Driver Code",
        "Category": "Recursion is used here to calculate the length of a string by reducing the problem size with each recursive call. However, since \"Recursion\" is not one of the allowed categories and the primary intent is to measure the length of a string by processing"
    },
    {
        "ID": "8333-8333",
        "Code": "MAX = 26 NEW_LINE def Swap ( s , t , n ) : NEW_LINE INDENT dp = [ [ - 1 for x in range ( MAX ) ] for y in range ( MAX ) ] NEW_LINE tot = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != t [ i ] ) : NEW_LINE INDENT tot += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE b = ord ( t [ i ] ) - ord ( ' a ' ) NEW_LINE if ( a == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT print ( i + 1 , \" ▁ \" , dp [ a ] [ b ] + 1 ) NEW_LINE return NEW_LINE DEDENT dp [ b ] [ a ] = i NEW_LINE DEDENT A = [ - 1 ] * MAX NEW_LINE B = [ - 1 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE b = ord ( t [ i ] ) - ord ( ' a ' ) NEW_LINE if ( a == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( A [ b ] != - 1 ) : NEW_LINE INDENT print ( i + 1 , A [ b ] + 1 ) NEW_LINE return NEW_LINE DEDENT if ( B [ a ] != - 1 ) : NEW_LINE INDENT print ( i + 1 , B [ a ] + 1 ) NEW_LINE return NEW_LINE DEDENT A [ a ] = i NEW_LINE B [ b ] = i NEW_LINE DEDENT print ( \" - 1\" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" permanent \" NEW_LINE T = \" pergament \" NEW_LINE n = len ( S ) NEW_LINE if ( S == \" \" or T == \" \" ) : NEW_LINE INDENT print ( \" Required ▁ string ▁ is ▁ empty . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT Swap ( S , T , n ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Reduce Hamming distance by swapping two characters | Python 3 code to decrease hamming distance using swap . ; Function to return the swapped indexes to get minimum hamming distance . ; Find the initial hamming distance ; Case - I : To decrease distance by two ; ASCII values of present character . ; If two same letters appear in different positions print their indexes ; Store the index of letters which is in wrong position ; Case : II ; If misplaced letter is found , print its original index and its new index ; Store the index of letters in wrong position ; Case - III ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8335-8335",
        "Code": "pre = [ False ] * 100 NEW_LINE s = [ None ] * 110 NEW_LINE def verify ( position , index ) : NEW_LINE INDENT l = len ( w ) NEW_LINE k = len ( s [ index ] ) NEW_LINE if ( position + k > l ) : NEW_LINE INDENT return NEW_LINE DEDENT same = True NEW_LINE for i in range ( position , position + k ) : NEW_LINE INDENT ch = w [ i ] NEW_LINE ch1 = s [ index ] [ i - position ] NEW_LINE if ( ch >= ' a ' and ch <= ' z ' ) : NEW_LINE INDENT n = ord ( ch ) - ord ( ' a ' ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ord ( ch ) - ord ( ' A ' ) NEW_LINE DEDENT if ( ch1 >= ' a ' and ch1 <= ' z ' ) : NEW_LINE INDENT n1 = ord ( ch1 ) - ord ( ' a ' ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = ord ( ch1 ) - ord ( ' A ' ) NEW_LINE DEDENT if ( n != n1 ) : NEW_LINE INDENT same = False NEW_LINE DEDENT DEDENT if ( same == True ) : NEW_LINE INDENT for i in range ( position , position + k ) : NEW_LINE INDENT pre [ i ] = True NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT l = len ( w ) NEW_LINE p = ord ( letter ) - ord ( ' a ' ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT verify ( i , j ) NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT if ( pre [ i ] == True ) : NEW_LINE INDENT if ( w [ i ] == letter ) : NEW_LINE INDENT w [ i ] = ' b ' if ( letter == ' a ' ) else ' a ' NEW_LINE DEDENT elif ( w [ i ] == str ( ord ( ' A ' ) + p ) ) : NEW_LINE INDENT w [ i ] = ' B ' if ( letter == ' a ' ) else ' A ' NEW_LINE DEDENT elif ( w [ i ] >= ' a ' and w [ i ] <= ' z ' ) : NEW_LINE INDENT w [ i ] = letter NEW_LINE DEDENT elif ( w [ i ] >= ' A ' and w [ i ] <= ' Z ' ) : NEW_LINE INDENT w [ i ] = chr ( ord ( ' A ' ) + p ) NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( w ) ) NEW_LINE DEDENT n = 3 NEW_LINE s [ 0 ] = \" etr \" NEW_LINE s [ 1 ] = \" ed \" NEW_LINE s [ 2 ] = \" ied \" NEW_LINE w = \" PEtrUnited \" NEW_LINE w = list ( w ) NEW_LINE letter = ' d ' NEW_LINE solve ( ) NEW_LINE",
        "Type": "py",
        "NL": "Remove the forbidden strings | pre [ ] keeps record of the characters of w that need to be changed ; stores the forbidden strings ; Function to check if the particula r substring is present in w at position ; If length of substring from this position is greater than length of w then return ; n and n1 are used to check for substring without considering the case of the letters in w by comparing the difference of ASCII values ; If same == true then it means a substring was found starting at position therefore all characters from position to length of substring found need to be changed therefore they needs to be marked ; Function implementing logic ; To verify if any substring is starting from index i ; Modifying the string w according to th rules ; This condition checks if w [ i ] = upper ( letter ) ; This condition checks if w [ i ] is any lowercase letter apart from letter . If true replace it with letter ; This condition checks if w [ i ] is any uppercase letter apart from letter . If true then replace it with upper ( letter ) . ; number of forbidden strings ; given string ; letter to replace and occur max number of times ; Calling function",
        "Category": "Substring"
    },
    {
        "ID": "834-834",
        "Code": "MAX = 100 NEW_LINE def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" ▁ Frequency ▁ of ▁ odd ▁ number ▁ = \" , odd ) NEW_LINE print ( \" ▁ Frequency ▁ of ▁ even ▁ number ▁ = \" , even ) NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE array = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE freq ( array , m , n ) NEW_LINE",
        "Type": "py",
        "NL": "Frequencies of even and odd numbers in a matrix | Python Program to Find the frequency of even and odd numbers in a matrix ; Function for calculating frequency ; modulo by 2 to check even and odd ; print Frequency of numbers ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "8345-8345",
        "Code": "def calSumUtil ( a , b , n , m ) : NEW_LINE INDENT sum = [ 0 ] * n NEW_LINE i = n - 1 NEW_LINE j = m - 1 NEW_LINE k = n - 1 NEW_LINE carry = 0 NEW_LINE s = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT s = a [ i ] + b [ j ] + carry NEW_LINE sum [ k ] = ( s % 10 ) NEW_LINE carry = s // 10 NEW_LINE k -= 1 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT s = a [ i ] + carry NEW_LINE sum [ k ] = ( s % 10 ) NEW_LINE carry = s // 10 NEW_LINE i -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT ans = 0 NEW_LINE if carry : NEW_LINE INDENT ans = 10 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += sum [ i ] NEW_LINE ans *= 10 NEW_LINE DEDENT return ans // 10 NEW_LINE DEDENT def calSum ( a , b , n , m ) : NEW_LINE INDENT if n >= m : NEW_LINE INDENT return calSumUtil ( a , b , n , m ) NEW_LINE DEDENT else : NEW_LINE INDENT return calSumUtil ( b , a , m , n ) NEW_LINE DEDENT DEDENT a = [ 9 , 3 , 9 ] NEW_LINE b = [ 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( calSum ( a , b , n , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Add two numbers represented by two arrays | Return sum of two number represented by the arrays . Size of a [ ] is greater than b [ ] . It is made sure be the wrapper function ; array to store sum . ; Until we reach beginning of array . we are comparing only for second array because we have already compare the size of array in wrapper function . ; find sum of corresponding element of both array . ; Finding carry for next sum . ; If second array size is less the first array size . ; Add carry to first array elements . ; If there is carry on adding 0 index elements . append 1 to total sum . ; Converting array into number . ; Wrapper Function ; Making first array which have greater number of element ; Driven Code",
        "Category": "Array"
    },
    {
        "ID": "8346-8346",
        "Code": "SIZE = 26 NEW_LINE def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE l = 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( SIZE ) : NEW_LINE INDENT l += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return l NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" abdacp \" NEW_LINE str2 = \" ckamb \" NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE print ( \" Length ▁ = ▁ \" , longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Common Anagram Subsequence | Python 3 implementation to find the length of the longest common anagram subsequence ; function to find the length of the longest common anagram subsequence ; List for storing frequencies of each character ; calculate frequency of each character of 'str1[] ; calculate frequency of each character of 'str2[] ; for each character add its minimum frequency out of the two strings in 'len ; required length ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8347-8347",
        "Code": "def isPanalphabeticWindow ( s , n ) : NEW_LINE INDENT ch = ' a ' NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT if ( ch == ' z ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = \" abujm ▁ zvcd ▁ acefc ▁ deghf ▁ gijkle ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap \" NEW_LINE n = len ( s ) NEW_LINE if ( isPanalphabeticWindow ( s , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Panalphabetic window in a string | Return if given string contain panalphabetic window . ; traversing the string ; if character of string is equal to ch , increment ch . ; if all characters are found , return true . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "835-835",
        "Code": "MAX = 100 NEW_LINE def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ [ 2 , 9 , 1 , 4 , - 2 ] , [ 6 , 7 , 2 , 11 , 4 ] , [ 4 , 2 , 9 , 2 , 4 ] , [ 1 , 9 , 2 , 4 , 4 ] , [ 0 , 2 , 4 , 2 , 5 ] ] NEW_LINE print ( \" Yes \" ) if ( HalfDiagonalSums ( a , 5 ) ) else print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Center element of matrix equals sums of half diagonals | Python 3 Program to check if the center element is equal to the individual sum of all the half diagonals ; Function to Check center element is equal to the individual sum of all the half diagonals ; Find sums of half diagonals ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "8351-8351",
        "Code": "def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" the ▁ big ▁ dwarf ▁ only ▁ jumps \" NEW_LINE n = len ( s ) NEW_LINE print ( \" YES \" if isHeterogram ( s , n ) else \" NO \" ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether a given string is Heterogram or not | Python3 code to check whether the given string is Heterogram or not . ; traversing the string . ; ignore the space ; if already encountered ; else return false . ; Driven Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8352-8352",
        "Code": "def ASCIISentence ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ord ( i ) , end = ' ' ) NEW_LINE DEDENT print ( ' ' , ▁ end ▁ = ▁ ' ' ) NEW_LINE DEDENT str = \" GeeksforGeeks \" NEW_LINE print ( \" ASCII ▁ Sentence : \" ) NEW_LINE ASCIISentence ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Print given sentence into its equivalent ASCII form | Function to compute the ASCII value of each character one by one ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8353-8353",
        "Code": "fwd = [ 0 ] * 100 NEW_LINE bwd = [ 0 ] * 100 NEW_LINE def preProcess ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE j = 0 NEW_LINE for i in range ( 1 , len ( a ) + 1 ) : NEW_LINE INDENT if j < len ( b ) and a [ i - 1 ] == b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT fwd [ i ] = j NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( len ( a ) , 0 , - 1 ) : NEW_LINE INDENT if ( j < len ( b ) and a [ i - 1 ] == b [ len ( b ) - j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT bwd [ i ] = j NEW_LINE DEDENT DEDENT def query ( a , b , x , y ) : NEW_LINE INDENT if ( x - 1 + len ( a ) - y ) < len ( b ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT if ( fwd [ x - 1 ] + bwd [ y + 1 ] ) >= len ( b ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" abcabcxy \" NEW_LINE b = \" acy \" NEW_LINE preProcess ( a , b ) NEW_LINE x = 2 NEW_LINE y = 5 NEW_LINE query ( a , b , x , y ) NEW_LINE x = 3 NEW_LINE y = 6 NEW_LINE query ( a , b , x , y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Subsequence queries after removing substrings | arrays to store results of preprocessing ; function to preprocess the strings ; initialize it as 0. ; store subsequence count in forward direction ; store number of matches till now ; store subsequence count in backward direction ; store number of matches till now ; function that gives the output ; length of remaining String A is less than B 's length ; Driver Code ; two queries",
        "Category": "Substring"
    },
    {
        "ID": "8357-8357",
        "Code": "def isEven ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE dotSeen = False NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' and dotSeen == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' . ' ) : NEW_LINE INDENT dotSeen = True NEW_LINE continue NEW_LINE DEDENT if ( ( int ) ( s [ i ] ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT s = \"100.70\" NEW_LINE if ( isEven ( s ) ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether given floating point number is even or odd | Function to check even or odd . ; Loop to traverse number from LSB ; We ignore trailing 0 s after dot ; If it is ' . ' we will check next digit and it means decimal part is traversed . ; If digit is divisible by 2 means even number . ; Driver Function",
        "Category": "Math"
    },
    {
        "ID": "8359-8359",
        "Code": "def largestAnagramSet ( arr , n ) : NEW_LINE INDENT maxSize = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ' ' . join ( sorted ( arr [ i ] ) ) NEW_LINE if arr [ i ] in count : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT maxSize = max ( maxSize , count [ arr [ i ] ] ) NEW_LINE DEDENT return maxSize NEW_LINE DEDENT arr = [ \" ant \" , \" magenta \" , \" magnate \" , \" tan \" , \" gnamate \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( largestAnagramSet ( arr , n ) ) NEW_LINE arr1 = [ \" cars \" , \" bikes \" , \" arcs \" , \" steer \" ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( largestAnagramSet ( arr1 , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the size of largest subset of anagram words | Utility function to find size of largest subset of anagram ; sort the string ; Increment the count of string ; Compute the maximum size of string ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8362-8362",
        "Code": "def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( \" Vowels : \" , vowels ) NEW_LINE print ( \" Consonant : \" , consonant ) NEW_LINE print ( \" Digit : \" , digit ) NEW_LINE print ( \" Special ▁ Character : \" , specialChar ) NEW_LINE DEDENT str = \" geeks ▁ for ▁ geeks121\" NEW_LINE countCharacterType ( str ) NEW_LINE",
        "Type": "py",
        "NL": "Program to count vowels , consonant , digits and special characters in string . | Function to count number of vowels , consonant , digits and special character in a string . ; Declare the variable vowels , consonant , digit and special characters ; str . length ( ) function to count number of character in given string . ; To handle upper case letters ; Driver function .",
        "Category": "Substring"
    },
    {
        "ID": "8368-8368",
        "Code": "def finalPosition ( move ) : NEW_LINE INDENT l = len ( move ) NEW_LINE countUp , countDown = 0 , 0 NEW_LINE countLeft , countRight = 0 , 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT if ( move [ i ] == ' U ' ) : NEW_LINE INDENT countUp += 1 NEW_LINE DEDENT elif ( move [ i ] == ' D ' ) : NEW_LINE INDENT countDown += 1 NEW_LINE DEDENT elif ( move [ i ] == ' L ' ) : NEW_LINE INDENT countLeft += 1 NEW_LINE DEDENT elif ( move [ i ] == ' R ' ) : NEW_LINE INDENT countRight += 1 NEW_LINE DEDENT DEDENT print ( \" Final ▁ Position : ▁ ( \" , ( countRight - countLeft ) , \" , ▁ \" , ( countUp - countDown ) , \" ) \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT move = \" UDDLLRUUUDUURUDDUULLDRRRR \" NEW_LINE finalPosition ( move ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Position of robot after given movements | function to find final position of robot after the complete movement ; traverse the instruction string 'move ; for each movement increment its respective counter ; required final position of robot ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8373-8373",
        "Code": "def fibWord ( n ) : NEW_LINE INDENT Sn_1 = \"0\" NEW_LINE Sn = \"01\" NEW_LINE tmp = \" \" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp = Sn NEW_LINE Sn += Sn_1 NEW_LINE Sn_1 = tmp NEW_LINE DEDENT return Sn NEW_LINE DEDENT n = 6 NEW_LINE print ( fibWord ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Fibonacci Word | Returns n - th Fibonacci word ; driver program",
        "Category": "Substring"
    },
    {
        "ID": "8375-8375",
        "Code": "def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( \" Total ▁ cost ▁ to ▁ construct \" , s , \" is \" , minCost ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum cost to construct a string | Python 3 Program to find minimum cost to construct a string ; Initially all characters are un - seen ; Marking seen characters ; Count total seen character , and that is the cost ; Driver Code ; s is the string that needs to be constructed",
        "Category": "Hash Table"
    },
    {
        "ID": "8384-8384",
        "Code": "def numberOfDifferentSubstrings ( s , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE ls = len ( s ) NEW_LINE la = len ( a ) NEW_LINE lb = len ( b ) NEW_LINE x = [ 0 ] * ls NEW_LINE y = [ 0 ] * ls NEW_LINE for i in range ( ls ) : NEW_LINE INDENT if ( s [ i : la + i ] == a ) : NEW_LINE INDENT x [ i ] = 1 NEW_LINE DEDENT if ( s [ i : lb + i ] == b ) : NEW_LINE INDENT y [ i ] = 1 NEW_LINE DEDENT DEDENT hash = [ ] NEW_LINE curr_substr = \" \" NEW_LINE for i in range ( ls ) : NEW_LINE INDENT if ( x [ i ] ) : NEW_LINE INDENT for j in range ( i , ls ) : NEW_LINE INDENT if ( not y [ j ] ) : NEW_LINE INDENT curr_substr += s [ j ] NEW_LINE DEDENT if ( y [ j ] ) : NEW_LINE INDENT curr_substr += s [ j : lb + j ] NEW_LINE if curr_substr not in hash : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT hash . append ( curr_substr ) NEW_LINE DEDENT DEDENT curr_substr = \" \" NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" codecppforfood \" NEW_LINE begin = \" c \" NEW_LINE end = \" d \" NEW_LINE print ( numberOfDifferentSubstrings ( s , begin , end ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Different substrings in a string that start and end with given strings | function to return number of different sub - strings ; initially our answer is zero . ; find the length of given strings ; currently make array and initially put zero . ; find occurrence of \" a \" and \" b \" in string \" s \" ; We use a hash to make sure that same substring is not counted twice . ; go through all the positions to find occurrence of \" a \" first . ; if we found occurrence of \" a \" . ; then go through all the positions to find occurrence of \" b \" . ; if we do found \" b \" at index j then add it to already existed substring . ; if we found occurrence of \" b \" . ; now add string \" b \" to already existed substring . ; If current substring is not included already . ; put any non negative integer to make this string as already existed . ; make substring null . ; return answer . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8387-8387",
        "Code": "max = 100 NEW_LINE def carveCross ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Not ▁ possible . ▁ Please ▁ enter ▁ \" ,   \" odd length string . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] NEW_LINE m = n // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = ' X ' NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" PICTURE \" NEW_LINE carveCross ( str ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Printing string in plus ‘ + ’ pattern in the matrix | Python 3 program to print the string in ' plus ' pattern ; Function to make a cross in the matrix ; As , it is not possible to make the cross exactly in the middle of the matrix with an even length string . ; declaring a 2D array i . e a matrix ; Now , we will fill all the elements of the array with 'X ; Now , we will place the characters of the string in the matrix , such that a cross is formed in it . ; here the characters of the string will be added in the middle column of our array . ; here the characters of the string will be added in the middle row of our array . ; Now finally , we will print the array ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "8389-8389",
        "Code": "def generateString ( n ) : NEW_LINE INDENT s = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i & 2 ) > 1 ) : NEW_LINE INDENT s += ' b ' ; NEW_LINE DEDENT else : NEW_LINE INDENT s += ' a ' ; NEW_LINE DEDENT DEDENT print ( s ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE generateString ( n ) ; NEW_LINE n = 8 ; NEW_LINE generateString ( n ) ; NEW_LINE n = 10 ; NEW_LINE generateString ( n ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Binary String of given length that without a palindrome of size 3 | Python3 program find a binary String of given length that doesn 't contain a palindrome of size 3. ; Printing the character according to i ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "839-839",
        "Code": "def modPower ( a , t ) : NEW_LINE INDENT now = a ; NEW_LINE ret = 1 ; NEW_LINE mod = 100000007 ; NEW_LINE while ( t ) : NEW_LINE INDENT if ( t & 1 ) : NEW_LINE INDENT ret = now * ( ret % mod ) ; NEW_LINE DEDENT now = now * ( now % mod ) ; NEW_LINE t >>= 1 ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT def countWays ( n , m , k ) : NEW_LINE INDENT mod = 100000007 ; NEW_LINE if ( k == - 1 and ( ( n + m ) % 2 == 1 ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 or m == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( modPower ( modPower ( 2 , n - 1 ) , m - 1 ) % mod ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE m = 7 ; NEW_LINE k = 1 ; NEW_LINE print ( countWays ( n , m , k ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Ways of filling matrix such that product of all rows and all columns are equal to unity | Returns a raised power t under modulo mod ; Counting number of ways of filling the matrix ; Function calculating the answer ; if sum of numbers of rows and columns is odd i . e ( n + m ) % 2 == 1 and k = - 1 then there are 0 ways of filiing the matrix . ; If there is one row or one column then there is only one way of filling the matrix ; If the above cases are not followed then we find ways to fill the n - 1 rows and m - 1 columns which is 2 ^ ( ( m - 1 ) * ( n - 1 ) ) . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8398-8398",
        "Code": "def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_1 = [ 0 for i in range ( n + 1 ) ] NEW_LINE post_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"000011100000\" NEW_LINE print ( longestSubseq ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest subsequence of the form 0 * 1 * 0 * in a binary string | Returns length of the longest subsequence of the form 0 * 1 * 0 * ; Precomputing values in three arrays pre_count_0 [ i ] is going to store count of 0 s in prefix str [ 0. . i - 1 ] pre_count_1 [ i ] is going to store count of 1 s in prefix str [ 0. . i - 1 ] post_count_0 [ i ] is going to store count of 0 s in suffix str [ i - 1. . n - 1 ] ; string is made up of all 0 s or all 1 s ; Compute result using precomputed values ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "8413-8413",
        "Code": "def findString ( n , k ) : NEW_LINE INDENT res = \" \" NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findString ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "String with k distinct characters and no same characters adjacent | Function to find a string of length n with k distinct characters . ; Initialize result with first k Latin letters ; Fill remaining n - k letters by repeating k letters again and again . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8414-8414",
        "Code": "def isValid ( p ) : NEW_LINE INDENT n = len ( p ) NEW_LINE c1 = 0 NEW_LINE c0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] == '0' ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if ( p [ i ] == '1' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( c0 == c1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def longestSub ( s ) : NEW_LINE INDENT max_len = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( isValid ( s [ i : j - i + 1 ] ) and max_len < j - i + 1 ) : NEW_LINE INDENT max_len = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"101001000\" NEW_LINE print ( longestSub ( s ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the longest substring with equal 1 s and 0 s | Function to check if a contains equal number of one and zeros or not ; Function to find the length of the longest balanced substring ; Driver code ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "8422-8422",
        "Code": "MAX_CHAR = 26 NEW_LINE def commonCharacters ( strings , n ) : NEW_LINE INDENT prim = [ True ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_CHAR NEW_LINE for j in range ( len ( strings [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT prim [ i ] = sec [ i ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( \" % c ▁ \" % ( i + ord ( ' a ' ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT strings = [ \" geeksforgeeks \" , \" gemkstones \" , \" acknowledges \" , \" aguelikes \" ] NEW_LINE n = len ( strings ) NEW_LINE commonCharacters ( strings , n ) NEW_LINE",
        "Type": "py",
        "NL": "Common characters in n strings | Python3 Program to find all the common characters in n strings ; primary array for common characters we assume all characters are seen before . ; for each strings ; secondary array for common characters Initially marked false ; for every character of ith strings ; if character is present in all strings before , mark it . ; copy whole secondary array into primary ; displaying common characters ; Driver 's Code",
        "Category": "Array"
    },
    {
        "ID": "8426-8426",
        "Code": "def makeAndCheckString ( words , str ) : NEW_LINE INDENT n = len ( words ) NEW_LINE first = second = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if words [ i ] == str : NEW_LINE INDENT return True NEW_LINE DEDENT if str [ 0 ] == words [ i ] [ 1 ] : NEW_LINE INDENT first = True NEW_LINE DEDENT if str [ 1 ] == words [ i ] [ 0 ] : NEW_LINE INDENT second = True NEW_LINE DEDENT if first and second : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = ' ya ' NEW_LINE words = [ ' ah ' , ' oy ' , ' to ' , ' ha ' ] NEW_LINE if makeAndCheckString ( words , str ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a two character string can be made using given words | Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8428-8428",
        "Code": "MAX_CHAR = 256 NEW_LINE def printDuo ( string ) : NEW_LINE INDENT countChar = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE n = len ( string ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countChar [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str1 = \" \" NEW_LINE str2 = \" \" NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( countChar [ i ] > 1 ) : NEW_LINE INDENT str2 = str2 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT elif ( countChar [ i ] == 1 ) : NEW_LINE INDENT str1 = str1 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT print ( \" String ▁ with ▁ characters ▁ occurring ▁ once : \" ,   \" \" , str1 ) NEW_LINE print ( \" String ▁ with ▁ characters ▁ occurring \" , \" multiple ▁ times : \" ,   \" \" , str2 ) NEW_LINE DEDENT string = \" lovetocode \" NEW_LINE printDuo ( string ) NEW_LINE",
        "Type": "py",
        "NL": "Generate two output strings depending upon occurrence of character in input string . | Python3 program to print two strings made of character occurring once and multiple times ; function to print two strings generated from single string one with characters occurring onces other with character occurring multiple of times ; initialize hashtable with zero entry ; perform hashing for input string ; generate string ( str1 ) consisting char occurring once and string ( str2 ) consisting char occurring multiple times ; print both strings ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8430-8430",
        "Code": "' NEW_LINE def reverse ( num , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = num [ i ] NEW_LINE num [ i ] = num [ j ] NEW_LINE num [ j ] = temp NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT def nextPalin ( num , n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT print \" Not ▁ Possible \" NEW_LINE return NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT mid = n / 2 - 1 NEW_LINE i = mid - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT print \" Not ▁ Possible \" NEW_LINE return NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT smallest = i + 1 NEW_LINE j = i + 2 NEW_LINE while j <= mid : NEW_LINE INDENT if ( num [ j ] > num [ i ] and num [ j ] < num [ smallest ] ) : NEW_LINE INDENT smallest = j NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT temp = num [ i ] NEW_LINE num [ i ] = num [ smallest ] NEW_LINE num [ smallest ] = temp NEW_LINE DEDENT ' NEW_LINE INDENT temp = num [ n - i - 1 ] NEW_LINE num [ n - i - 1 ] = num [ n - smallest - 1 ] NEW_LINE num [ n - smallest - 1 ] = temp NEW_LINE reverse ( num , i + 1 , mid ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT reverse ( num , mid + 1 , n - i - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT reverse ( num , mid + 2 , n - i - 2 ) NEW_LINE DEDENT result = ' ' . join ( num ) NEW_LINE print \" Next ▁ Palindrome : ▁ \" , result NEW_LINE DEDENT st = \"4697557964\" NEW_LINE num = list ( st ) NEW_LINE n = len ( st ) NEW_LINE nextPalin ( num , n ) NEW_LINE",
        "Type": "py",
        "NL": "Next higher palindromic number using the same set of digits | function to reverse the digits in the range i to j in 'num ; function to find next higher palindromic number using the same set of digits ; if length of number is less than '3' then no higher palindromic number can be formed ; find the index of last digit in the 1 st half of 'num ; Start from the ( mid - 1 ) th digit and find the first digit that is smaller than the digit next to it . ; If no such digit is found , then all digits are in descending order which means there cannot be a greater palindromic number with same set of digits ; Find the smallest digit on right side of ith digit which is greater than num [ i ] up to index 'mid ; swap num [ i ] with num [ smallest ] ; as the number is a palindrome , the same swap of digits should be performed in the 2 nd half of 'num ; reverse digits in the range ( i + 1 ) to mid ; if n is even , then reverse digits in the range mid + 1 to n - i - 2 ; else if n is odd , then reverse digits in the range mid + 2 to n - i - 2 ; required next higher palindromic number ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "8432-8432",
        "Code": "def getBinaryRep ( N , num_of_bits ) : NEW_LINE INDENT r = \" \" ; NEW_LINE num_of_bits -= 1 NEW_LINE while ( num_of_bits >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << num_of_bits ) ) : NEW_LINE INDENT r += ( \"1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT r += ( \"0\" ) ; NEW_LINE DEDENT num_of_bits -= 1 NEW_LINE DEDENT return r ; NEW_LINE DEDENT def NBitBinary ( N ) : NEW_LINE INDENT r = [ ] NEW_LINE first = 1 << ( N - 1 ) ; NEW_LINE last = first * 2 ; NEW_LINE for i in range ( last - 1 , first - 1 , - 1 ) : NEW_LINE INDENT zero_cnt = 0 ; NEW_LINE one_cnt = 0 ; NEW_LINE t = i ; NEW_LINE num_of_bits = 0 ; NEW_LINE while ( t ) : NEW_LINE INDENT if ( t & 1 ) : NEW_LINE INDENT one_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT num_of_bits += 1 NEW_LINE t = t >> 1 ; NEW_LINE DEDENT if ( one_cnt >= zero_cnt ) : NEW_LINE INDENT all_prefix_match = True ; NEW_LINE msk = ( 1 << num_of_bits ) - 2 ; NEW_LINE prefix_shift = 1 ; NEW_LINE while ( msk ) : NEW_LINE INDENT prefix = ( ( msk & i ) >> prefix_shift ) ; NEW_LINE prefix_one_cnt = 0 ; NEW_LINE prefix_zero_cnt = 0 ; NEW_LINE while ( prefix ) : NEW_LINE INDENT if ( prefix & 1 ) : NEW_LINE INDENT prefix_one_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix_zero_cnt += 1 NEW_LINE DEDENT prefix = prefix >> 1 ; NEW_LINE DEDENT if ( prefix_zero_cnt > prefix_one_cnt ) : NEW_LINE INDENT all_prefix_match = False ; NEW_LINE break ; NEW_LINE DEDENT prefix_shift += 1 NEW_LINE msk = msk & ( msk << 1 ) ; NEW_LINE DEDENT if ( all_prefix_match ) : NEW_LINE INDENT r . append ( getBinaryRep ( i , num_of_bits ) ) ; NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE results = NBitBinary ( n ) ; NEW_LINE for i in range ( len ( results ) ) : NEW_LINE INDENT print ( results [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print N | Function to get the binary representation of the number N ; loop for each bit ; generate numbers in the range of ( 2 ^ N ) - 1 to 2 ^ ( N - 1 ) inclusive ; longest prefix check ; if counts of 1 is greater than counts of zero ; do sub - prefixes check ; Driver code ; Function call",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8433-8433",
        "Code": "def findstem ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE s = arr [ 0 ] NEW_LINE l = len ( s ) NEW_LINE res = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i + 1 , l + 1 ) : NEW_LINE INDENT stem = s [ i : j ] NEW_LINE k = 1 NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT if stem not in arr [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( k + 1 == n and len ( res ) < len ( stem ) ) : NEW_LINE INDENT res = stem NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" grace \" , \" graceful \" , \" disgraceful \" , \" gracefully \" ] NEW_LINE stems = findstem ( arr ) NEW_LINE print ( stems ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Longest Common Substring in an Array of Strings | function to find the stem ( longestcommon substring ) from the string array ; Determine size of the array ; Take first word from array as reference ; generating all possible substrings of our reference string arr [ 0 ] i . e s ; Check if the generated stem is common to all words ; If current substring is present in all strings and its length is greater than current result ; Driver Code ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "8436-8436",
        "Code": "from collections import defaultdict NEW_LINE def findWinner ( votes ) : NEW_LINE INDENT mapObj = defaultdict ( int ) NEW_LINE for st in votes : NEW_LINE INDENT mapObj [ st ] += 1 NEW_LINE DEDENT maxValueInMap = 0 NEW_LINE winner = \" \" NEW_LINE for entry in mapObj : NEW_LINE INDENT key = entry NEW_LINE val = mapObj [ entry ] NEW_LINE if ( val > maxValueInMap ) : NEW_LINE INDENT maxValueInMap = val NEW_LINE winner = key NEW_LINE DEDENT elif ( val == maxValueInMap and winner > key ) : NEW_LINE INDENT winner = key NEW_LINE DEDENT DEDENT print ( winner ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT votes = [ \" john \" , \" johnny \" , \" jackie \" , \" johnny \" , \" john \" , \" jackie \" , \" jamie \" , \" jamie \" , \" john \" , \" johnny \" , \" jamie \" , \" johnny \" , \" john \" ] NEW_LINE findWinner ( votes ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find winner of an election where votes are represented as candidate names | Python3 program to find winner in an election . ; We have four Candidates with name as ' John ' , ' Johnny ' , ' jamie ' , ' jackie ' . The votes in String array are as per the votes casted . Print the name of candidates received Max vote . ; Insert all votes in a hashmap ; Traverse through map to find the candidate with maximum votes . ; If there is a tie , pick lexicographically smaller . ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8440-8440",
        "Code": "def checkLuhn ( cardNo ) : NEW_LINE INDENT nDigits = len ( cardNo ) NEW_LINE nSum = 0 NEW_LINE isSecond = False NEW_LINE for i in range ( nDigits - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = ord ( cardNo [ i ] ) - ord ( '0' ) NEW_LINE if ( isSecond == True ) : NEW_LINE INDENT d = d * 2 NEW_LINE DEDENT nSum += d // 10 NEW_LINE nSum += d % 10 NEW_LINE isSecond = not isSecond NEW_LINE DEDENT if ( nSum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cardNo = \"79927398713\" NEW_LINE if ( checkLuhn ( cardNo ) ) : NEW_LINE INDENT print ( \" This ▁ is ▁ a ▁ valid ▁ card \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" This ▁ is ▁ not ▁ a ▁ valid ▁ card \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Luhn algorithm | Returns true if given card number is valid ; We add two digits to handle cases that make two digits after doubling ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8444-8444",
        "Code": "def nextHighUsingAtMostOneSwap ( st ) : NEW_LINE INDENT num = list ( st ) NEW_LINE l = len ( num ) NEW_LINE posRMax = l - 1 NEW_LINE index = - 1 NEW_LINE i = l - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( num [ i ] >= num [ posRMax ] ) : NEW_LINE INDENT posRMax = i NEW_LINE DEDENT else : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT if ( index == - 1 ) : NEW_LINE INDENT return \" Not ▁ Possible \" NEW_LINE DEDENT greatSmallDgt = - 1 NEW_LINE i = l - 1 NEW_LINE while i > index : NEW_LINE INDENT if ( num [ i ] > num [ index ] ) : NEW_LINE INDENT if ( greatSmallDgt == - 1 ) : NEW_LINE INDENT greatSmallDgt = i NEW_LINE DEDENT elif ( num [ i ] <= num [ greatSmallDgt ] ) : NEW_LINE INDENT greatSmallDgt = i NEW_LINE DEDENT DEDENT i = i - 1 NEW_LINE DEDENT temp = num [ index ] NEW_LINE num [ index ] = num [ greatSmallDgt ] ; NEW_LINE num [ greatSmallDgt ] = temp ; NEW_LINE return ' ' . join ( num ) NEW_LINE DEDENT num = \"218765\" NEW_LINE print \" Original ▁ number : ▁ \" , num NEW_LINE print \" Next ▁ higher ▁ number : ▁ \" , nextHighUsingAtMostOneSwap ( num ) NEW_LINE",
        "Type": "py",
        "NL": "Next higher number using atmost one swap operation | function to find the next higher number using atmost one swap operation ; to store the index of the largest digit encountered so far from the right ; to store the index of rightmost digit which has a digit greater to it on its right side ; finding the ' index ' of rightmost digit which has a digit greater to it on its right side ; required digit found , store its ' index ' and break ; if no such digit is found which has a larger digit on its right side ; to store the index of the smallest digit greater than the digit at ' index ' and right to it ; finding the index of the smallest digit greater than the digit at ' index ' and right to it ; swapping the digits ; required number ; Driver program to test above",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "8450-8450",
        "Code": "MAX_CHAR = 26 NEW_LINE def check ( freq , k ) : NEW_LINE INDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] and freq [ i ] != k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def substrings ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT index = ord ( s [ j ] ) - ord ( ' a ' ) NEW_LINE freq [ index ] += 1 NEW_LINE if ( freq [ index ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( freq [ index ] == k and check ( freq , k ) == True ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbcc \" NEW_LINE k = 2 NEW_LINE print ( substrings ( s , k ) ) NEW_LINE s = \" aabbc \" ; NEW_LINE k = 2 ; NEW_LINE print ( substrings ( s , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of substrings with count of each character as k | Python3 program to count number of substrings with counts of distinct characters as k . ; Returns true if all values in freq [ ] are either 0 or k . ; Returns count of substrings where frequency of every present character is k ; Pick a starting point ; Initialize all frequencies as 0 for this starting point ; One by one pick ending points ; Increment frequency of current char ; If frequency becomes more than k , we can 't have more substrings  starting with i ; If frequency becomes k , then check other frequencies as well ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8461-8461",
        "Code": "def generate ( st , s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if s not in st : NEW_LINE INDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = list ( s ) . copy ( ) NEW_LINE t . remove ( s [ i ] ) NEW_LINE t = ' ' . join ( t ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" xyz \" NEW_LINE st = set ( ) NEW_LINE generate ( st , s ) NEW_LINE for i in st : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Generating distinct subsequences of a given string in lexicographic order | Finds and stores result in st for a given string s . ; If current string is not already present . ; Traverse current string , one by one remove every character and recur . ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8469-8469",
        "Code": "def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if char_count [ i ] != 0 : NEW_LINE INDENT count += abs ( char_count [ i ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" ddcf \" NEW_LINE s2 = \" cedk \" NEW_LINE print ( countManipulations ( s1 , s2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum Number of Manipulations required to make two Strings Anagram Without Deletion of Character | Counts the no of manipulations required ; store the count of character ; iterate though the first String and update count ; iterate through the second string update char_count . if character is not found in char_count then increase count ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8473-8473",
        "Code": "MAX_CHAR = 26 NEW_LINE def stringPalindrome ( A , B ) : NEW_LINE INDENT countA = [ 0 ] * MAX_CHAR NEW_LINE countB = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( A ) NEW_LINE l2 = len ( B ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT countA [ ord ( A [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT countB [ ord ( B [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( ( countA [ i ] > 1 and countB [ i ] == 0 ) ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT DEDENT return ' B ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" abcdea \" NEW_LINE b = \" bcdesg \" NEW_LINE print ( stringPalindrome ( a , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Given two strings check which string makes a palindrome first | Given two strings , check which string makes palindrome first . ; returns winner of two strings ; Count frequencies of characters in both given strings ; Check if there is a character that appears more than once in A and does not appear in B ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8477-8477",
        "Code": "def check ( list , s ) : NEW_LINE INDENT n = len ( list ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( len ( list [ i ] ) != len ( s ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT diff = False NEW_LINE for j in range ( 0 , len ( list [ i ] ) , 1 ) : NEW_LINE INDENT if ( list [ i ] [ j ] != s [ j ] ) : NEW_LINE INDENT if ( diff == False ) : NEW_LINE INDENT diff = True NEW_LINE DEDENT else : NEW_LINE INDENT diff = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( diff ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( \" bana \" ) NEW_LINE s . append ( \" apple \" ) NEW_LINE s . append ( \" banacb \" ) NEW_LINE s . append ( \" bonanza \" ) NEW_LINE s . append ( \" banamf \" ) NEW_LINE print ( int ( check ( s , \" banana \" ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if an array contains a string with one mismatch | Python 3 program to find if given string is present with one mismatch . ; If the array is empty ; If sizes are same ; If first mismatch ; Second mismatch ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8484-8484",
        "Code": "MAX_CHAR = 26 NEW_LINE MAX_FACT = 20 NEW_LINE fact = [ None ] * ( MAX_FACT ) NEW_LINE def precomputeFactorials ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX_FACT ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT def nPermute ( string , n ) : NEW_LINE INDENT precomputeFactorials ( ) NEW_LINE length = len ( string ) NEW_LINE freq = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT out = [ None ] * ( MAX_CHAR ) NEW_LINE Sum , k = 0 , 0 NEW_LINE while Sum != n : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT freq [ i ] -= 1 NEW_LINE xsum = fact [ length - 1 - k ] NEW_LINE for j in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT xsum = xsum // fact [ freq [ j ] ] NEW_LINE DEDENT Sum += xsum NEW_LINE if Sum >= n : NEW_LINE INDENT out [ k ] = chr ( i + ord ( ' a ' ) ) NEW_LINE n -= Sum - xsum NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT if Sum < n : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT i = MAX_CHAR - 1 NEW_LINE while k < length and i >= 0 : NEW_LINE INDENT if freq [ i ] : NEW_LINE INDENT out [ k ] = chr ( i + ord ( ' a ' ) ) NEW_LINE freq [ i ] -= 1 NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ' ' . join ( out [ : k ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE string = \" geeksquiz \" NEW_LINE nPermute ( string , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find n | Python3 program to print n - th permutation ; Utility for calculating factorials ; Function for nth permutation ; length of given string ; Count frequencies of all characters ; out string for output string ; iterate till sum equals n ; We update both n and sum in this loop . ; check for characters present in freq [ ] ; Remove character ; calculate sum after fixing a particular char ; if sum > n fix that char as present char and update sum and required nth after fixing char at that position ; if sum < n , add character back ; if sum == n means this char will provide its greatest permutation as nth permutation ; print result ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8487-8487",
        "Code": "def sentencePalindrome ( s ) : NEW_LINE INDENT l , h = 0 , len ( s ) - 1 NEW_LINE s = s . lower ( ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT if ( not ( s [ l ] >= ' a ' and s [ l ] <= ' z ' ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( not ( s [ h ] >= ' a ' and s [ h ] <= ' z ' ) ) : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT elif ( s [ l ] == s [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" Too ▁ hot ▁ to ▁ hoot . \" NEW_LINE if ( sentencePalindrome ( s ) ) : NEW_LINE INDENT print \" Sentence ▁ is ▁ palindrome . \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Sentence ▁ is ▁ not ▁ palindrome . \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver program to test sentencePalindrome ( )",
        "Category": "Two Pointers"
    },
    {
        "ID": "8488-8488",
        "Code": "import math NEW_LINE def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] ; NEW_LINE sum , counter = 0 , 0 ; NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT s = \"12212\" ; NEW_LINE b , k = 3 , 3 ; NEW_LINE substringConversions ( s , b , k ) ; NEW_LINE",
        "Type": "py",
        "NL": "Convert all substrings of length ' k ' from base ' b ' to decimal | Simple Python3 program to convert all substrings from decimal to given base . ; Saving substring in sub ; Evaluating decimal for current substring and printing it . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8492-8492",
        "Code": "alphabets = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE def panLipogramChecker ( s ) : NEW_LINE / * convert string to lower case * / NEW_LINE INDENT s . lower ( ) NEW_LINE counter = 0 NEW_LINE for ch in alphabets : NEW_LINE INDENT if ( s . find ( ch ) < 0 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT if ( counter == 0 ) : NEW_LINE INDENT result = \" Pangram \" NEW_LINE DEDENT elif ( counter == 1 ) : NEW_LINE INDENT result = \" Pangrammatic ▁ Lipogram \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" Not ▁ a ▁ pangram ▁ but ▁ might ▁ a ▁ lipogram \" NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( panLipogramChecker ( \" The ▁ quick ▁ brown ▁ fox ▁ \\ ▁ jumped ▁ over ▁ the ▁ lazy ▁ dog \" ) ) NEW_LINE print ( panLipogramChecker ( \" The ▁ quick ▁ brown ▁ fox ▁ \\ ▁ jumps ▁ over ▁ the ▁ lazy ▁ dog \" ) ) NEW_LINE print ( panLipogramChecker ( \" The ▁ quick ▁ brown ▁ fox ▁ jum\\ ▁ over ▁ the ▁ lazy ▁ dog \" ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a string is Pangrammatic Lipogram | collection of letters ; function to check for a Pangrammatic Lipogram ;  ; variable to keep count of all the letters not found in the string ; traverses the string for every letter of the alphabet ; character not found in string then increment count ; Driver program to test above function",
        "Category": "Substring"
    },
    {
        "ID": "8499-8499",
        "Code": "def findFlips ( str , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"00011110001110\" NEW_LINE n = len ( str ) NEW_LINE print ( findFlips ( str , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Min flips of continuous characters to make all characters same in a string | To find min number of flips in binary string ; If last character is not equal to str [ i ] increase res ; To return min flips ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "85-85",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . Next = self . child = None NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def addSibling ( n , data ) : NEW_LINE INDENT if ( n == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT while ( n . Next ) : NEW_LINE INDENT n = n . Next NEW_LINE DEDENT n . Next = newNode ( data ) NEW_LINE return n . Next NEW_LINE DEDENT def addChild ( n , data ) : NEW_LINE INDENT if ( n == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( n . child ) : NEW_LINE INDENT return addSibling ( n . child , data ) NEW_LINE DEDENT else : NEW_LINE INDENT n . child = newNode ( data ) NEW_LINE return n . child NEW_LINE DEDENT DEDENT def traverseTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT while ( root ) : NEW_LINE INDENT print ( root . data , end = \" ▁ \" ) NEW_LINE if ( root . child ) : NEW_LINE INDENT traverseTree ( root . child ) NEW_LINE DEDENT root = root . Next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE n1 = addChild ( root , 2 ) NEW_LINE n2 = addChild ( root , 3 ) NEW_LINE n3 = addChild ( root , 4 ) NEW_LINE n4 = addChild ( n3 , 6 ) NEW_LINE n5 = addChild ( root , 5 ) NEW_LINE n6 = addChild ( n5 , 7 ) NEW_LINE n7 = addChild ( n5 , 8 ) NEW_LINE n8 = addChild ( n5 , 9 ) NEW_LINE traverseTree ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Creating a tree with Left | Creating new Node ; Adds a sibling to a list with starting with n ; Add child Node to a Node ; Check if child list is not empty . ; Traverses tree in depth first order ; Driver code",
        "Category": "Linked List"
    },
    {
        "ID": "8509-8509",
        "Code": "def nPermute ( string , n ) : NEW_LINE INDENT string = list ( string ) NEW_LINE new_string = [ ] NEW_LINE string . sort ( ) NEW_LINE j = 2 NEW_LINE while next_permutation ( string ) : NEW_LINE INDENT new_string = string NEW_LINE if j == n : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( ' ' . join ( new_string ) ) NEW_LINE DEDENT def next_permutation ( L ) : NEW_LINE INDENT n = len ( L ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 and L [ i ] >= L [ i + 1 ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT j = i + 1 NEW_LINE while j < n and L [ j ] > L [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT j -= 1 NEW_LINE L [ i ] , L [ j ] = L [ j ] , L [ i ] NEW_LINE left = i + 1 NEW_LINE right = n - 1 NEW_LINE while left < right : NEW_LINE INDENT L [ left ] , L [ right ] = L [ right ] , L [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" NEW_LINE n = 100 NEW_LINE nPermute ( string , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lexicographically n | Function to print nth permutation using next_permute ( ) ; Sort the string in lexicographically ascending order ; Keep iterating until we reach nth position ; check for nth iteration ; print string after nth iteration ; next_permutation method implementation ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8511-8511",
        "Code": "import math as mt NEW_LINE def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT n = \"10\" NEW_LINE print ( evenlength ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Nth Even length Palindrome | Python3 program to find n = th even length string . ; Function to find nth even length Palindrome ; string r to store resultant palindrome . Initialize same as s ; In this loop string r stores reverse of string s after the string s in consecutive manner . ; Driver code ; Function call",
        "Category": "Substring"
    },
    {
        "ID": "852-852",
        "Code": "R = 5 NEW_LINE C = 5 NEW_LINE def diagonalOrder ( arr , n , m ) : NEW_LINE INDENT ans = [ [ ] for i in range ( n + m - 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans [ i + j ] . append ( arr [ j ] [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT for j in range ( len ( ans [ i ] ) ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 4 NEW_LINE arr = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] , [ 17 , 18 , 19 , 20 ] ] NEW_LINE diagonalOrder ( arr , n , m ) NEW_LINE",
        "Type": "py",
        "NL": "Zigzag ( or diagonal ) traversal of Matrix |  ; we will use a 2D vector to store the diagonals of our array the 2D vector will have ( n + m - 1 ) rows that is equal to the number of diagnols ; Driver Code ; Function call",
        "Category": "Matrix"
    },
    {
        "ID": "8523-8523",
        "Code": "def checkString ( s ) : NEW_LINE INDENT Len = len ( s ) NEW_LINE first = len ( s ) + 1 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT last = 0 NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( first , last + 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"00011111111100000\" NEW_LINE if ( checkString ( s ) ) : NEW_LINE INDENT print ( \" VALID \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NOT ▁ VALID \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a binary string has a 0 between 1 s or not | Set 1 ( General approach ) | Function returns 1 when string is valid else returns 0 ; Find first occurrence of 1 in s [ ] ; Find last occurrence of 1 in s [ ] ; Check if there is any 0 in range ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8524-8524",
        "Code": "MAX_CHAR = 26 NEW_LINE def arrangeString ( string ) : NEW_LINE INDENT char_count = [ 0 ] * MAX_CHAR NEW_LINE s = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= \" A \" and string [ i ] <= \" Z \" : NEW_LINE INDENT char_count [ ord ( string [ i ] ) - ord ( \" A \" ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += ord ( string [ i ] ) - ord ( \"0\" ) NEW_LINE DEDENT DEDENT res = \" \" NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = chr ( ord ( \" A \" ) + i ) NEW_LINE while char_count [ i ] : NEW_LINE INDENT res += ch NEW_LINE char_count [ i ] -= 1 NEW_LINE DEDENT DEDENT if s > 0 : NEW_LINE INDENT res += str ( s ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ACCBA10D2EW30\" NEW_LINE print ( arrangeString ( string ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Rearrange a string in sorted order followed by the integer sum | Python3 program for above implementation ; Function to return string in lexicographic order followed by integers sum ; Traverse the string ; Count occurrence of uppercase alphabets ; Store sum of integers ; Traverse for all characters A to Z ; Append the current character in the string no . of times it occurs in the given string ; Append the sum of integers ; return resultant string ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "853-853",
        "Code": "n = 4 NEW_LINE def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT q = mat [ i ] [ j ] // n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT mat = [ [ 4 , 7 , 0 , 3 ] , [ 8 , 5 , 6 , 1 ] , [ 9 , 11 , 10 , 2 ] , [ 15 , 13 , 14 , 12 ] ] NEW_LINE print ( \" Total ▁ energy ▁ required ▁ = ▁ \" , calculateEnergy ( mat , n ) , \" units \" ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum cost to sort a matrix of numbers from 0 to n ^ 2 | implementation to find the total energy required to rearrange the numbers ; function to find the total energy required to rearrange the numbers ; nested loops to access the elements of the given matrix ; store quotient ; final destination location ( i_des , j_des ) of the element mat [ i ] [ j ] is being calculated ; energy required for the movement of the element mat [ i ] [ j ] is calculated and then accumulated in the 'tot_energy   ; required total energy ; Driver Program",
        "Category": "Math"
    },
    {
        "ID": "8536-8536",
        "Code": "def printAllSubstrings ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT DEDENT s = \" Geeky \" NEW_LINE printAllSubstrings ( s , len ( s ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to print all substrings of a given string | * Function to print all ( n * ( n + 1 ) ) / 2 * substrings of a given string s of length n . ; Fix start index in outer loop . Reveal new character in inner loop till end of string . Prtill - now - formed string . ; Driver program to test above function",
        "Category": "Substring"
    },
    {
        "ID": "8540-8540",
        "Code": "def reverses ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE result = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == ' ▁ ' ) : NEW_LINE INDENT result [ i ] = ' ▁ ' NEW_LINE DEDENT DEDENT j = n - 1 NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( st [ i ] != ' ▁ ' ) : NEW_LINE INDENT if ( result [ j ] == ' ▁ ' ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT result [ j ] = st [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( result ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" internship ▁ at ▁ geeks ▁ for ▁ geeks \" NEW_LINE print ( reverses ( st ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Reverse a string preserving space positions | Function to reverse the string and preserve the space position ; Mark spaces in result ; Traverse input string from beginning and put characters in result from end ; Ignore spaces in input string ; Ignore spaces in result . ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8541-8541",
        "Code": "def preserveSpace ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE Str = list ( Str ) NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( Str [ start ] == ' ▁ ' ) : NEW_LINE INDENT start += 1 NEW_LINE continue NEW_LINE DEDENT elif ( Str [ end ] == ' ▁ ' ) : NEW_LINE INDENT end -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT Str [ start ] , Str [ end ] = ( Str [ end ] , Str [ start ] ) NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( Str ) ) NEW_LINE DEDENT Str = \" internship ▁ at ▁ geeks ▁ for ▁ geeks \" NEW_LINE preserveSpace ( Str ) ; NEW_LINE",
        "Type": "py",
        "NL": "Reverse a string preserving space positions | Python3 program to implement the above approach ; Initialize two pointers as two corners ; Move both pointers toward each other ; If character at start or end is space , ignore it ; If both are not spaces , do swap ; Driver code",
        "Category": "Two Pointers"
    },
    {
        "ID": "8543-8543",
        "Code": "def amendSentence ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" BruceWayneIsBatman \" NEW_LINE amendSentence ( string ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Put spaces between words starting with capital letters | Function to amend the sentence ; Traverse the string ; Convert to lowercase if its an uppercase character ; Print space before it if its an uppercase character ; Print the character ; if lowercase character then just print ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8550-8550",
        "Code": "def lengthOfLastWord ( a ) : NEW_LINE INDENT l = 0 NEW_LINE x = a . strip ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == \" ▁ \" : NEW_LINE INDENT l = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inp = \" Geeks ▁ For ▁ Geeks ▁ \" NEW_LINE print ( \" The ▁ length ▁ of ▁ last ▁ word ▁ is \" , lengthOfLastWord ( inp ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length Of Last Word in a String | Python3 program for implementation of simple approach to find length of last word ; String a is ' final ' -- can not be modified So , create a copy and trim the spaces from both sides ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8555-8555",
        "Code": "x = 32 ; NEW_LINE def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT str = \" CheRrY \" ; NEW_LINE print ( \" Toggle ▁ case : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE print ( \" Original ▁ string : ▁ \" , end = \" \" ) ; NEW_LINE str = toggleCase ( str ) ; NEW_LINE print ( str ) ; NEW_LINE",
        "Type": "py",
        "NL": "Toggle case of a string using Bitwise Operators | Python3 program to get toggle case of a string ; tOGGLE cASE = swaps CAPS to lower case and lower case to CAPS ; Bitwise EXOR with 32 ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8557-8557",
        "Code": "MAX_CHAR = 26 NEW_LINE def factorial ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE DEDENT return fact NEW_LINE DEDENT def countDistinctPermutations ( st ) : NEW_LINE INDENT length = len ( st ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( st [ i ] >= ' a ' ) : NEW_LINE INDENT freq [ ( ord ) ( st [ i ] ) - 97 ] = freq [ ( ord ) ( st [ i ] ) - 97 ] + 1 ; NEW_LINE DEDENT DEDENT fact = 1 NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT fact = fact * factorial ( freq [ i ] ) NEW_LINE DEDENT return factorial ( length ) / fact NEW_LINE DEDENT st = \" fvvfhvgv \" NEW_LINE print ( countDistinctPermutations ( st ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of distinct permutation a String can have | Python program to find number of distinct permutations of a string . ; Utility function to find factorial of n . ; Returns count of distinct permutations of str . ; finding frequency of all the lower case alphabet and storing them in array of integer ; finding factorial of number of appearances and multiplying them since they are repeating alphabets ; finding factorial of size of string and dividing it by factorial found after multiplying ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8563-8563",
        "Code": "def uniqueCharacters ( str ) : NEW_LINE INDENT setstring = set ( str ) NEW_LINE if ( len ( setstring ) == len ( str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = \" GeeksforGeeks \" NEW_LINE if ( uniqueCharacters ( input ) ) : NEW_LINE INDENT print ( \" The ▁ String ▁ \" + input + \" ▁ has ▁ all ▁ unique ▁ characters \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ String ▁ \" + input + \" ▁ has ▁ duplicate ▁ characters \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Determine if a string has all Unique Characters | Python3 program to illustrate String with unique characters ; Converting string to set ; If length of set is equal to len of string then it will have unique characters ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8564-8564",
        "Code": "def concatenate ( a , b , c , n1 , n2 ) : NEW_LINE INDENT i = - 1 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT c [ i ] = a [ i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT c [ i ] = b [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" Hi ▁ This ▁ is ▁ geeksforgeeks . ▁ \" NEW_LINE n1 = len ( a ) NEW_LINE b = \" You ▁ are ▁ welcome ▁ here . \" NEW_LINE n2 = len ( b ) NEW_LINE a = list ( a ) NEW_LINE b = list ( b ) NEW_LINE c = [ 0 ] * ( n1 + n2 - 1 ) NEW_LINE concatenate ( a , b , c , n1 , n2 ) NEW_LINE for i in c : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Ropes Data Structure ( Fast String Concatenation ) | Function that concatenates strings a [ 0. . n1 - 1 ] and b [ 0. . n2 - 1 ] and stores the result in c [ ] ; Copy characters of A [ ] to C [ ] ; Copy characters of B [ ] ; Driver Code ; Concatenate a [ ] and b [ ] and store result in c [ ]",
        "Category": "Array"
    },
    {
        "ID": "8571-8571",
        "Code": "def nextGreaterWithSameDigits ( bnum ) : NEW_LINE INDENT l = len ( bnum ) NEW_LINE bnum = list ( bnum ) NEW_LINE for i in range ( l - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( bnum [ i ] == '0' and bnum [ i + 1 ] == '1' ) : NEW_LINE INDENT ch = bnum [ i ] NEW_LINE bnum [ i ] = bnum [ i + 1 ] NEW_LINE bnum [ i + 1 ] = ch NEW_LINE break NEW_LINE DEDENT DEDENT if ( i == 0 ) : NEW_LINE INDENT return \" no ▁ greater ▁ number \" NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT j = i + 2 NEW_LINE k = l - 1 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( bnum [ j ] == '1' and bnum [ k ] == '0' ) : NEW_LINE INDENT ch = bnum [ j ] NEW_LINE bnum [ j ] = bnum [ k ] NEW_LINE bnum [ k ] = ch NEW_LINE j += 1 NEW_LINE k -= 1 NEW_LINE DEDENT elif ( bnum [ i ] == '0' ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return bnum NEW_LINE DEDENT bnum = \"10010\" NEW_LINE print ( \" Binary ▁ representation ▁ of ▁ next ▁ greater ▁ number ▁ = ▁ \" , * nextGreaterWithSameDigits ( bnum ) , sep = \" \" ) NEW_LINE",
        "Type": "py",
        "NL": "Binary representation of next greater number with same number of 1 ' s ▁ and ▁ 0' s | Function to find the next greater number with same number of 1 ' s ▁ and ▁ 0' s ; locate first ' i ' from end such that bnum [ i ] == '0' and bnum [ i + 1 ] == '1' swap these value and break ; if no swapping performed ; Since we want the smallest next value , shift all 1 ' s ▁ at ▁ the ▁ end ▁ in ▁ the ▁ binary ▁ ▁ substring ▁ starting ▁ from ▁ index ▁ ' i + 2 ; special case while swapping if '0' occurs then break ; required next greater number ; Driver code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8581-8581",
        "Code": "def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE if ( Len == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT ptr1 = 0 NEW_LINE ptr2 = Len - 1 NEW_LINE while ( ptr2 > ptr1 ) : NEW_LINE INDENT if ( Str [ ptr1 ] != Str [ ptr2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT ptr1 += 1 NEW_LINE ptr2 -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def noOfAppends ( s ) : NEW_LINE INDENT if ( isPalindrome ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT del s [ 0 ] NEW_LINE return 1 + noOfAppends ( s ) NEW_LINE DEDENT se = \" abede \" NEW_LINE s = [ i for i in se ] NEW_LINE print ( noOfAppends ( s ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of Appends needed to make a string palindrome | Checking if the String is palindrome or not ; single character is always palindrome ; pointing to first character ; pointing to last character ; Recursive function to count number of appends ; Removing first character of String by incrementing base address pointer . ; Driver Code",
        "Category": "Two Pointers"
    },
    {
        "ID": "8583-8583",
        "Code": "def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = s [ 0 : i ] NEW_LINE s2 = s [ i : j - i ] NEW_LINE s3 = s [ j : k - j ] NEW_LINE s4 = s [ k : len ( s ) - k ] NEW_LINE if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" aaabb \" NEW_LINE print ( \" Yes \" ) if ( check ( str ) ) else print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if given string can be split into four distinct strings | Return if the given string can be split or not . ; We can always break a of size 10 or more into four distinct strings . ; Brute Force ; Making 4 from the given ; Checking if they are distinct or not . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8586-8586",
        "Code": "def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) ; NEW_LINE str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT s = \" GeeksforGeeks \" ; NEW_LINE print ( reversingString ( s , 0 , 12 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Reverse string without using any temporary variable | Function to reverse string and return reversed string ; Iterate loop upto start not equal to end ; XOR for swapping the variable ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8587-8587",
        "Code": "str = \" geeksforgeeks \" ; NEW_LINE str = \" \" . join ( reversed ( str ) ) NEW_LINE print ( str ) ; NEW_LINE",
        "Type": "py",
        "NL": "Reverse string without using any temporary variable | Reversing a string using reverse ( ) ; Reverse str [ beign . . end ]",
        "Category": "Substring"
    },
    {
        "ID": "8588-8588",
        "Code": "def isPalRec ( st , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( st [ s ] != st [ e ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s < e + 1 ) : NEW_LINE INDENT return isPalRec ( st , s + 1 , e - 1 ) ; NEW_LINE DEDENT return True NEW_LINE DEDENT def isPalindrome ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPalRec ( st , 0 , n - 1 ) ; NEW_LINE DEDENT st = \" geeg \" NEW_LINE if ( isPalindrome ( st ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Recursive function to check if a string is palindrome | A recursive function that check a str [ s . . e ] is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "859-859",
        "Code": "MAX = 100 ; NEW_LINE def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT n = 4 ; NEW_LINE m = 4 ; NEW_LINE M = [ [ 1 , 2 , 3 , 4 ] , [ 9 , 5 , 3 , 1 ] , [ 0 , 3 , 5 , 6 ] , [ 0 , 4 , 5 , 6 ] ] NEW_LINE print ( areSumSame ( M , n , m ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if sums of i | Python3 program to check the if sum of a row is same as corresponding column ; Function to check the if sum of a row is same as corresponding column ; number of rows ; number of columns",
        "Category": "Matrix"
    },
    {
        "ID": "8597-8597",
        "Code": "M = 26 NEW_LINE def getIdx ( ch ) : NEW_LINE INDENT return ( ord ( ch ) - ord ( ' a ' ) ) NEW_LINE DEDENT def allSame ( freq , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT same = freq [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( freq [ j ] > 0 and freq [ j ] != same ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def possibleSameCharFreqByOneRemoval ( str1 ) : NEW_LINE INDENT l = len ( str1 ) NEW_LINE freq = [ 0 ] * M NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT freq [ getIdx ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT if ( allSame ( freq , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE if ( allSame ( freq , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT freq [ i ] += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" xyyzz \" NEW_LINE if ( possibleSameCharFreqByOneRemoval ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if frequency of all characters can become same by one removal | Python3 program to get same frequency character string by removal of at most one char ; Utility method to get index of character ch in lower alphabet characters ; Returns true if all non - zero elements values are same ; get first non - zero element ; check equality of each element with variable same ; Returns true if we can make all character frequencies same ; fill frequency array ; if all frequencies are same , then return true ; Try decreasing frequency of all character by one and then check all equality of all non - zero frequencies ; Check character only if it occurs in str ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "86-86",
        "Code": "from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE self . child = None NEW_LINE DEDENT DEDENT def addSibling ( n , data ) : NEW_LINE INDENT if ( n == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT while ( n . next ) : NEW_LINE INDENT n = n . next NEW_LINE DEDENT n . next = Node ( data ) NEW_LINE return n NEW_LINE DEDENT def addChild ( n , data ) : NEW_LINE INDENT if ( n == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( n . child ) : NEW_LINE INDENT return addSibling ( n . child , data ) NEW_LINE DEDENT else : NEW_LINE INDENT n . child = Node ( data ) NEW_LINE return n NEW_LINE DEDENT DEDENT def traverseTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( root . data , end = \" ▁ \" ) NEW_LINE if ( root . child == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = deque ( ) NEW_LINE curr = root . child NEW_LINE q . append ( curr ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( curr . data , end = \" ▁ \" ) NEW_LINE if ( curr . child != None ) : NEW_LINE INDENT q . append ( curr . child ) NEW_LINE DEDENT curr = curr . next NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 10 ) NEW_LINE n1 = addChild ( root , 2 ) NEW_LINE n2 = addChild ( root , 3 ) NEW_LINE n3 = addChild ( root , 4 ) NEW_LINE n4 = addChild ( n3 , 6 ) NEW_LINE n5 = addChild ( root , 5 ) NEW_LINE n6 = addChild ( n5 , 7 ) NEW_LINE n7 = addChild ( n5 , 8 ) NEW_LINE n8 = addChild ( n5 , 9 ) NEW_LINE traverseTree ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Creating a tree with Left | Python3 program to create a tree with left child right sibling representation ; Creating new Node ; Adds a sibling to a list with starting with n ; Add child Node to a Node ; Check if child list is not empty ; Traverses tree in level order ; Corner cases ; Create a queue and enque root ; Take out an item from the queue ; Print next level of taken out item and enque next level 's children ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "8600-8600",
        "Code": "def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral //= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert decimal fraction to binary number | Function to convert decimal to binary upto k - precision after decimal point ; Fetch the integral part of decimal number ; Fetch the fractional part decimal number ; Conversion of integral part to binary equivalent ; Append 0 in binary ; Reverse string to get original binary equivalent ; Append point before conversion of fractional part ; Conversion of fractional part to binary equivalent ; Find next bit in fraction ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8601-8601",
        "Code": "MAX_CHAR = 26 ; NEW_LINE ' NEW_LINE def countFreq ( str1 , freq , len1 ) : NEW_LINE INDENT for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len1 ) : NEW_LINE INDENT count_odd = 0 ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT DEDENT if ( len1 % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = \" \" ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 ; NEW_LINE odd_str += chr ( i + ord ( ' a ' ) ) ; NEW_LINE return odd_str ; NEW_LINE DEDENT DEDENT return odd_str ; NEW_LINE DEDENT def findPalindromicString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) ; NEW_LINE freq = [ 0 ] * MAX_CHAR ; NEW_LINE countFreq ( str1 , freq , len1 ) ; NEW_LINE if ( canMakePalindrome ( freq , len1 ) == False ) : NEW_LINE INDENT return \" No ▁ Palindromic ▁ String \" ; NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) ; NEW_LINE front_str = \" \" ; NEW_LINE rear_str = \" ▁ \" ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = \" \" ; NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) ; NEW_LINE for j in range ( 1 , int ( freq [ i ] / 2 ) + 1 ) : NEW_LINE INDENT temp += ch ; NEW_LINE DEDENT front_str += temp ; NEW_LINE rear_str = temp + rear_str ; NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) ; NEW_LINE DEDENT str1 = \" malayalam \" ; NEW_LINE print ( findPalindromicString ( str1 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Lexicographically first palindromic string | Python3 program to find first palindromic permutation of given string ; Function to count frequency of each char in the string . freq [ 0 ] for ' a ' , ... . , freq [ 25 ] for 'z ; Cases to check whether a palindr0mic string can be formed or not ; count_odd to count no of chars with odd frequency ; For even length string no odd freq character ; For odd length string one odd freq character ; Function to find odd freq char and reducing its freq by 1 returns \" \" if odd freq char is not present ; To find lexicographically first palindromic string . ; Assigning odd freq character if present else empty string . ; Traverse characters in increasing order ; Divide all occurrences into two halves . Note that odd character is removed by findOddAndRemoveItsFreq ( ) ; creating front string ; creating rear string ; Final palindromic string which is lexicographically first ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8614-8614",
        "Code": "def isSubSequence ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) ; NEW_LINE n = len ( str2 ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return ( j == m ) ; NEW_LINE DEDENT def findLongestString ( dict1 , str1 ) : NEW_LINE INDENT result = \" \" ; NEW_LINE length = 0 ; NEW_LINE for word in dict1 : NEW_LINE INDENT if ( length < len ( word ) and isSubSequence ( word , str1 ) ) : NEW_LINE INDENT result = word ; NEW_LINE length = len ( word ) ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT dict1 = [ \" ale \" , \" apple \" , \" monkey \" , \" plea \" ] ; NEW_LINE str1 = \" abpcplea \" ; NEW_LINE print ( findLongestString ( dict1 , str1 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find largest word in dictionary by deleting some characters of given string | Returns true if str1 [ ] is a subsequence of str2 [ ] . m is length of str1 and n is length of str2 ; Traverse str2 and str1 , and compare current character of str2 with first unmatched char of str1 , if matched then move ahead in str1 ; If all characters of str1 were found in str2 ; Returns the longest string in dictionary which is a subsequence of str . ; Traverse through all words of dictionary ; If current word is subsequence of str and is largest such word so far . ; Return longest string ; Driver program to test above function",
        "Category": "Substring"
    },
    {
        "ID": "8626-8626",
        "Code": "def replaceDig ( x , from1 , to ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT reminder = x % 10 NEW_LINE if ( reminder == from1 ) : NEW_LINE INDENT result = result + to * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + reminder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return result NEW_LINE DEDENT def calculateMinMaxSum ( x1 , x2 ) : NEW_LINE INDENT minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) NEW_LINE maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) NEW_LINE print ( \" Minimum ▁ sum ▁ = \" , minSum ) NEW_LINE print ( \" Maximum ▁ sum ▁ = \" , maxSum , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 5466 NEW_LINE x2 = 4555 NEW_LINE calculateMinMaxSum ( x1 , x2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum and minimum sums from two numbers with digit replacements | Find new value of x after replacing digit \" from \" to \" to \" ; Required digit found , replace it ; Returns maximum and minimum possible sums of x1 and x2 if digit replacements are allowed . ; We always get minimum sum if we replace 6 with 5. ; We always get maximum sum if we replace 5 with 6. ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8629-8629",
        "Code": "def qType1 ( l , x , str1 ) : NEW_LINE INDENT str1 [ l - 1 ] = x NEW_LINE DEDENT def qType2 ( l , r , str1 ) : NEW_LINE INDENT freq = [ 0 for i in range ( 27 ) ] NEW_LINE for i in range ( l - 1 , r ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( freq [ j ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count <= 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT str1 = \" geeksforgeeks \" NEW_LINE str2 = [ i for i in str1 ] NEW_LINE n = len ( str2 ) NEW_LINE qType1 ( 4 , ' g ' , str2 ) NEW_LINE qType2 ( 1 , 4 , str2 ) NEW_LINE qType2 ( 2 , 3 , str2 ) NEW_LINE qType1 ( 10 , ' t ' , str2 ) NEW_LINE qType2 ( 10 , 11 , str2 ) NEW_LINE",
        "Type": "py",
        "NL": "Queries on substring palindrome formation | Query type 1 : update str1ing position i with character x . ; Pr \" Yes \" if range [ L . . R ] can form palindrome , else pr \" No \" . ; Find the frequency of each character in S [ L ... R ] . ; Checking if more than one character have frequency greater than 1. ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8630-8630",
        "Code": "max = 1000 ; NEW_LINE def getFrequency ( tree , idx , i ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( idx > 0 ) : NEW_LINE INDENT sum += tree [ idx ] [ i ] ; NEW_LINE idx -= ( idx & - idx ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def update ( tree , idx , val , i ) : NEW_LINE INDENT while ( idx <= max ) : NEW_LINE INDENT tree [ idx ] [ i ] += val ; NEW_LINE idx += ( idx & - idx ) ; NEW_LINE DEDENT DEDENT def qType1 ( tree , l , x , str1 ) : NEW_LINE INDENT update ( tree , l , - 1 , ord ( str1 [ l - 1 ] ) - 97 + 1 ) ; NEW_LINE list1 = list ( str1 ) NEW_LINE list1 [ l - 1 ] = x ; NEW_LINE str1 = ' ' . join ( list1 ) ; NEW_LINE update ( tree , l , 1 , ord ( str1 [ l - 1 ] ) - 97 + 1 ) ; NEW_LINE DEDENT def qType2 ( tree , l , r , str1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , 27 ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT if ( getFrequency ( tree , r , i ) % 2 == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( \" Yes \" ) if ( count <= 1 ) else print ( \" No \" ) ; NEW_LINE DEDENT def buildBIT ( tree , str1 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT update ( tree , i + 1 , 1 , ord ( str1 [ i ] ) - 97 + 1 ) ; NEW_LINE DEDENT DEDENT str1 = \" geeksforgeeks \" ; NEW_LINE n = len ( str1 ) ; NEW_LINE tree = [ [ 0 for x in range ( 27 ) ] for y in range ( max ) ] ; NEW_LINE buildBIT ( tree , str1 , n ) ; NEW_LINE qType1 ( tree , 4 , ' g ' , str1 ) ; NEW_LINE qType2 ( tree , 1 , 4 , str1 ) ; NEW_LINE qType2 ( tree , 2 , 3 , str1 ) ; NEW_LINE qType1 ( tree , 10 , ' t ' , str1 ) ; NEW_LINE qType2 ( tree , 10 , 11 , str1 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Queries on substring palindrome formation | Python3 program to Queries on substr1ing palindrome formation . ; Return the frequency of the character in the i - th prefix . ; Updating the BIT ; Query to update the character in the str1ing . ; Adding - 1 at L position ; Updating the character ; Adding + 1 at R position ; Query to find if rearrangement of character in range L ... R can form palindrome ; Checking on the first character of the str1ing S . ; Checking if frequency of character is even or odd . ; Creating the Binary Index Tree of all aphabet ; Driver code",
        "Category": "Binary Tree"
    },
    {
        "ID": "8631-8631",
        "Code": "def findDivision ( str , a , b ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE DEDENT ' NEW_LINE INDENT lr = [ 0 ] * ( lenn + 1 ) NEW_LINE lr [ 0 ] = ( int ( str [ 0 ] ) ) % a NEW_LINE for i in range ( 1 , lenn ) : NEW_LINE INDENT lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + int ( str [ i ] ) ) % a NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT rl = [ 0 ] * ( lenn + 1 ) NEW_LINE rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b NEW_LINE power10 = 10 NEW_LINE for i in range ( lenn - 2 , - 1 , - 1 ) : NEW_LINE INDENT rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b NEW_LINE power10 = ( power10 * 10 ) % b NEW_LINE DEDENT for i in range ( 0 , lenn - 1 ) : NEW_LINE INDENT if ( lr [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( rl [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for k in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( str [ k ] , end = \" \" ) NEW_LINE DEDENT print ( \" , \" , end = \" ▁ \" ) NEW_LINE for i in range ( i + 1 , lenn ) : NEW_LINE INDENT print ( str [ k ] , end = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" NO \" ) NEW_LINE DEDENT str = \"123\" NEW_LINE a , b = 12 , 3 NEW_LINE findDivision ( str , a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Partition a number into two divisible parts | Finds if it is possible to partition str into two parts such that first part is divisible by a and second part is divisible by b . ; Create an array of size lenn + 1 and initialize it with 0. Store remainders from left to right when divided by 'a ; Compute remainders from right to left when divided by 'b ; Find a pothat can partition a number ; If split is not possible at this point ; We can split at i if one of the following two is true . a ) All characters after str [ i ] are 0 b ) after str [ i ] is divisible by b , i . e . , str [ i + 1. . n - 1 ] is divisible by b . ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8632-8632",
        "Code": "MAX = 10000 NEW_LINE CHAR_SIZE = 26 NEW_LINE def precompute ( mat , str , Len ) : NEW_LINE INDENT for i in range ( CHAR_SIZE ) : NEW_LINE INDENT mat [ Len ] [ i ] = Len NEW_LINE DEDENT for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( CHAR_SIZE ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i + 1 ] [ j ] NEW_LINE DEDENT mat [ i ] [ ord ( str [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT DEDENT def query ( mat , str , Len ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( mat [ pos ] [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= Len ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT pos = mat [ pos ] [ ord ( str [ i ] ) - ord ( ' a ' ) ] + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT S = \" geeksforgeeks \" NEW_LINE Len = len ( S ) NEW_LINE mat = [ [ 0 for i in range ( CHAR_SIZE ) ] for j in range ( MAX ) ] NEW_LINE precompute ( mat , S , Len ) NEW_LINE get = \" No \" NEW_LINE if ( query ( mat , \" gg \" , Len ) ) : NEW_LINE INDENT get = \" Yes \" NEW_LINE DEDENT print ( get ) NEW_LINE get = \" No \" NEW_LINE if ( query ( mat , \" gro \" , Len ) ) : NEW_LINE INDENT get = \" Yes \" NEW_LINE DEDENT print ( get ) NEW_LINE get = \" No \" NEW_LINE if ( query ( mat , \" gfg \" , Len ) ) : NEW_LINE INDENT get = \" Yes \" NEW_LINE DEDENT print ( get ) NEW_LINE get = \" No \" NEW_LINE if ( query ( mat , \" orf \" , Len ) ) : NEW_LINE INDENT get = \" Yes \" NEW_LINE DEDENT print ( get ) NEW_LINE",
        "Type": "py",
        "NL": "Queries on subsequence of string | Python3 program to answer subsequence queries for a given string . ; Precompute the position of each character from each position of String S ; Computing position of each character from each position of String S ; Print \" Yes \" if T is subsequence of S , else \" No \" ; Traversing the string T ; If next position is greater than length of S set flag to false . ; Setting position of next character ; Driven code",
        "Category": "Array"
    },
    {
        "ID": "8633-8633",
        "Code": "def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( \" Yes \" ) if s [ i ] == s [ j ] else print ( \" No \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" geeksforgeeks \" NEW_LINE query ( X , 0 , 8 ) NEW_LINE query ( X , 8 , 13 ) NEW_LINE query ( X , 6 , 15 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries for characters in a repeated string | Print whether index i and j have same element or not . ; Finding relative position of index i , j . ; Checking is element are same at index i , j . ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8638-8638",
        "Code": "MAX_CHAR = 26 NEW_LINE def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" anagram \" NEW_LINE str2 = \" grammar \" NEW_LINE k = 2 NEW_LINE if ( arekAnagrams ( str1 , str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if two strings are k | Python3 program to check if two strings are k anagram or not . ; Function to check that is k - anagram or not ; If both strings are not of equal length then return false ; Store the occurrence of all characters in a hash_array ; Count number of characters that are different in both strings ; Return true if count is less than or equal to k ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8640-8640",
        "Code": "import sys NEW_LINE def kAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT flag = 0 NEW_LINE list1 = [ ] NEW_LINE if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT sys . exit ( ) NEW_LINE DEDENT arr1 = list ( str1 ) NEW_LINE arr2 = list ( str2 ) NEW_LINE arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT list1 . append ( arr2 [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( list1 ) <= k ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" fodr \" NEW_LINE str2 = \" gork \" NEW_LINE k = 2 NEW_LINE kAnagrams ( str1 , str2 , k ) NEW_LINE if ( kAnagrams ( str1 , str2 , k ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if two strings are k | Python 3 program for the above approach ; Function to check k anagram of two strings ; First Condition : If both the strings have different length , then they cannot form anagram ; Converting str1 to Character Array arr1 ; Converting str2 to Character Array arr2 ; Sort arr1 in increasing order ; Sort arr2 in increasing order ; Iterate till str1 . length ( ) ; Condition if arr1 [ i ] is not equal to arr2 [ i ] then add it to list ; Condition to check if strings for K - anagram or not ; Driver Code ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "8653-8653",
        "Code": "def isPalindrome ( string : str , low : int , high : int ) -> bool : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def possiblepalinByRemovingOneChar ( string : str ) -> int : NEW_LINE INDENT low = 0 NEW_LINE high = len ( string ) - 1 NEW_LINE while low < high : NEW_LINE INDENT if string [ low ] == string [ high ] : NEW_LINE INDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if isPalindrome ( string , low + 1 , high ) : NEW_LINE INDENT return low NEW_LINE DEDENT if isPalindrome ( string , low , high - 1 ) : NEW_LINE INDENT return high NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT return - 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abecbea \" NEW_LINE idx = possiblepalinByRemovingOneChar ( string ) NEW_LINE if idx == - 1 : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT elif idx == - 2 : NEW_LINE INDENT print ( \" Possible ▁ without ▁ removing ▁ any ▁ character \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Possible ▁ by ▁ removing ▁ character ▁ at ▁ index \" , idx ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Remove a character from a string to make it a palindrome | Utility method to check if substring from low to high is palindrome or not . ; This method returns - 1 if it is not possible to make string a palindrome . It returns - 2 if string is already a palindrome . Otherwise it returns index of character whose removal can make the whole string palindrome . ; Initialize low and right by both the ends of the string ; loop until low and high cross each other ; If both characters are equal then move both pointer towards end ; If removing str [ low ] makes the whole string palindrome . We basically check if substring str [ low + 1. . high ] is palindrome or not . ; If removing str [ high ] makes the whole string palindrome We basically check if substring str [ low + 1. . high ] is palindrome or not ; We reach here when complete string will be palindrome if complete string is palindrome then return mid character ; Driver Code",
        "Category": "Two Pointers"
    },
    {
        "ID": "8654-8654",
        "Code": "MAX_CHAR = 26 NEW_LINE def sortByPattern ( str , pat ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT index = 0 ; NEW_LINE str = \" \" NEW_LINE for i in range ( 0 , len ( pat ) ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < count [ ord ( pat [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT str += pat [ i ] NEW_LINE j = j + 1 NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT pat = \" bca \" NEW_LINE str = \" abc \" NEW_LINE print ( sortByPattern ( str , pat ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sort a string according to the order defined by another string | Python3 program to sort a string according to the order defined by a pattern string ; Sort str according to the order defined by pattern . ; Create a count array store count of characters in str . ; Count number of occurrences of each character in str . ; Traverse the pattern and print every characters same number of times as it appears in str . This loop takes O ( m + n ) time where m is length of pattern and n is length of str . ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8657-8657",
        "Code": "def encryptDecrypt ( inpString ) : NEW_LINE INDENT xorKey = ' P ' ; NEW_LINE length = len ( inpString ) ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT inpString = ( inpString [ : i ] + chr ( ord ( inpString [ i ] ) ^ ord ( xorKey ) ) + inpString [ i + 1 : ] ) ; NEW_LINE print ( inpString [ i ] , end = \" \" ) ; NEW_LINE DEDENT return inpString ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sampleString = \" GeeksforGeeks \" ; NEW_LINE print ( \" Encrypted ▁ String : ▁ \" , end = \" \" ) ; NEW_LINE sampleString = encryptDecrypt ( sampleString ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" Decrypted ▁ String : ▁ \" , end = \" \" ) ; NEW_LINE encryptDecrypt ( sampleString ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "XOR Cipher | The same function is used to encrypt and decrypt ; Define XOR key Any character value will work ; calculate length of input string ; perform XOR operation of key with every character in string ; Driver Code ; Encrypt the string ; Decrypt the string",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8661-8661",
        "Code": "def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] ; NEW_LINE series_index = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 ; NEW_LINE result += digit * series [ series_index ] ; NEW_LINE series_index = ( series_index + 1 ) % 6 ; NEW_LINE result %= 7 ; NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT str = \"12345\" ; NEW_LINE print ( \" Remainder ▁ with ▁ 7 ▁ is \" , remainderWith7 ( str ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Remainder with 7 for large numbers | Function which return Remainder after dividing the number by 7 ; This series is used to find remainder with 7 ; Index of next element in series ; Initialize result ; Traverse num from end ; Find current digit of num ; Add next term to result ; Move to next term in series ; Make sure that result never goes beyond 7. ; Make sure that remainder is positive ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8662-8662",
        "Code": "def canBecomeEmpty ( string , sub_str ) : NEW_LINE INDENT while len ( string ) > 0 : NEW_LINE INDENT idx = string . find ( sub_str ) NEW_LINE if idx == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT string = string . replace ( sub_str , \" \" , 1 ) NEW_LINE DEDENT return ( len ( string ) == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEGEEKSKS \" NEW_LINE sub_str = \" GEEKS \" NEW_LINE if canBecomeEmpty ( string , sub_str ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a string can become empty by recursively deleting a given sub | Returns true if str can be made empty by recursively removing sub_str . ; idx : to store starting index of sub - string found in the original string ; Erasing the found sub - string from the original string ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8674-8674",
        "Code": "def encodedChar ( str , k ) : NEW_LINE INDENT expand = \" \" NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( ' a ' ) and ord ( str [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 , 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" ab4c12ed3\" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( str , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find k 'th character of decrypted string | Set 1 | Function to find K 'th character in Encoded String ; expand string variable is used to store final string after decompressing string str ; Current substring freq = 0 Count of current substring ; read characters until you find a number or end of string ; push character in temp ; read number for how many times string temp will be repeated in decompressed string ; generating frequency of temp ; now append string temp into expand equal to its frequency ; this condition is to handle the case when string str is ended with alphabets not with numeric value ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8682-8682",
        "Code": "def intToRoman ( num ) : NEW_LINE INDENT m = [ \" \" , \" M \" , \" MM \" , \" MMM \" ] NEW_LINE c = [ \" \" , \" C \" , \" CC \" , \" CCC \" , \" CD \" , \" D \" , \" DC \" , \" DCC \" , \" DCCC \" , \" CM ▁ \" ] NEW_LINE x = [ \" \" , \" X \" , \" XX \" , \" XXX \" , \" XL \" , \" L \" , \" LX \" , \" LXX \" , \" LXXX \" , \" XC \" ] NEW_LINE i = [ \" \" , \" I \" , \" II \" , \" III \" , \" IV \" , \" V \" , \" VI \" , \" VII \" , \" VIII \" , \" IX \" ] NEW_LINE thousands = m [ num // 1000 ] NEW_LINE hundereds = c [ ( num % 1000 ) // 100 ] NEW_LINE tens = x [ ( num % 100 ) // 10 ] NEW_LINE ones = i [ num % 10 ] NEW_LINE ans = ( thousands + hundereds + tens + ones ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT number = 3549 NEW_LINE print ( intToRoman ( number ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Converting Decimal Number lying between 1 to 3999 to Roman Numerals | Function to calculate roman equivalent ; Storing roman values of digits from 0 - 9 when placed at different places ; Converting to roman ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8683-8683",
        "Code": "def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" abcbaa \" NEW_LINE k = 3 NEW_LINE print ( \" Total ▁ substrings ▁ with ▁ exactly \" , k , \" distinct ▁ characters ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count number of substrings with exactly k distinct characters | Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Initializing array with 0 ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8693-8693",
        "Code": "MAX_CHAR = 256 NEW_LINE def isPalindrome ( Str , l , h ) : NEW_LINE INDENT while ( h > l ) : NEW_LINE INDENT if ( Str [ l ] != Str [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( Str [ i ] ) ] += 1 NEW_LINE if ( freq [ ord ( Str [ i ] ) ] > 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( Str [ i ] ) ] > 1 ) : NEW_LINE INDENT Str [ k ] = Str [ i ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT Str [ k ] = ' \\0' NEW_LINE if ( isPalindrome ( Str , 0 , k - 1 ) ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT return Str [ k // 2 ] == Str [ k // 2 - 1 ] NEW_LINE DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT S = \" ABCABD \" NEW_LINE Str = [ i for i in S ] NEW_LINE if ( check ( Str ) ) : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Repeated ▁ Subsequence ▁ Doesn ' t ▁ Exists \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Repeated subsequence of length 2 or more | Python3 program to check if any repeated subsequence exists in the String ; A function to check if a String Str is palindrome ; l and h are leftmost and rightmost corners of Str Keep comparing characters while they are same ; The main function that checks if repeated subsequence exists in the String ; Find length of input String ; Create an array to store all characters and their frequencies in Str [ ] ; Traverse the input String and store frequencies of all characters in freq [ ] array . ; If the character count is more than 2 we found a repetition ; In - place remove non - repeating characters from the String ; check if the resultant String is palindrome ; special case - if length is odd return true if the middle character is same as previous one ; return false if String is a palindrome ; return true if String is not a palindrome ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "8697-8697",
        "Code": "def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT str = list ( str ) NEW_LINE temp = str [ i - 1 ] NEW_LINE str [ i - 1 ] = str [ j ] NEW_LINE str [ j ] = temp NEW_LINE str = ' ' . join ( str ) NEW_LINE str [ : : - 1 ] NEW_LINE return True , str NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"4321\" NEW_LINE b , str = prevPermutation ( str ) NEW_LINE if ( b == True ) : NEW_LINE INDENT print ( \" Previous ▁ permutation ▁ is \" , str ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Previous ▁ permutation ▁ doesn ' t ▁ exist \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "How to find Lexicographically previous permutation ? | Function to compute the previous permutation ; Find index of the last element of the string ; Find largest index i such that str [ i - 1 ] > str [ i ] ; if string is sorted in ascending order we 're at the last permutation ; Note - str [ i . . n ] is sorted in ascending order . Find rightmost element 's index  that is less than str[i - 1] ; Swap character at i - 1 with j ; Reverse the substring [ i . . n ] ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "87-87",
        "Code": "def printTreeEdges ( prufer , m ) : NEW_LINE INDENT vertices = m + 2 NEW_LINE vertex_set = [ 0 ] * vertices NEW_LINE for i in range ( vertices - 2 ) : NEW_LINE INDENT vertex_set [ prufer [ i ] - 1 ] += 1 NEW_LINE DEDENT print ( \" The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : \" ) NEW_LINE j = 0 NEW_LINE for i in range ( vertices - 2 ) : NEW_LINE INDENT for j in range ( vertices ) : NEW_LINE INDENT if ( vertex_set [ j ] == 0 ) : NEW_LINE INDENT vertex_set [ j ] = - 1 NEW_LINE print ( \" ( \" , ( j + 1 ) , \" , ▁ \" , prufer [ i ] , \" ) ▁ \" , sep = \" \" , end = \" \" ) NEW_LINE vertex_set [ prufer [ i ] - 1 ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for i in range ( vertices ) : NEW_LINE INDENT if ( vertex_set [ i ] == 0 and j == 0 ) : NEW_LINE INDENT print ( \" ( \" , ( i + 1 ) , \" , ▁ \" , sep = \" \" , end = \" \" ) NEW_LINE j += 1 NEW_LINE DEDENT elif ( vertex_set [ i ] == 0 and j == 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , \" ) \" ) NEW_LINE DEDENT DEDENT DEDENT prufer = [ 4 , 1 , 3 , 4 ] NEW_LINE n = len ( prufer ) NEW_LINE printTreeEdges ( prufer , n ) NEW_LINE",
        "Type": "py",
        "NL": "Prufer Code to Tree Creation | Prints edges of tree represented by give Prufer code ; Initialize the array of vertices ; Number of occurrences of vertex in code ; Find the smallest label not present in prufer . ; If j + 1 is not present in prufer set ; Remove from Prufer set and print pair . ; For the last element ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "8700-8700",
        "Code": "def _print ( string , index ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT print ( ' ' . join ( string ) ) NEW_LINE return NEW_LINE DEDENT if string [ index ] == \" ? \" : NEW_LINE INDENT string [ index ] = '0' NEW_LINE _print ( string , index + 1 ) NEW_LINE string [ index ] = '1' NEW_LINE _print ( string , index + 1 ) NEW_LINE string [ index ] = ' ? ' NEW_LINE DEDENT else : NEW_LINE INDENT _print ( string , index + 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"1 ? ? 0?101\" NEW_LINE string = list ( string ) NEW_LINE _print ( string , 0 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate all binary strings from given pattern | Recursive function to generate all binary strings formed by replacing each wildcard character by 0 or 1 ; replace ' ? ' by '0' and recurse ; replace ' ? ' by '1' and recurse ; NOTE : Need to backtrack as string is passed by reference to the function ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "8706-8706",
        "Code": "' NEW_LINE def flip ( c ) : NEW_LINE INDENT return '1' if ( c == '0' ) else '0' NEW_LINE DEDENT def printOneAndTwosComplement ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE ones = \" \" NEW_LINE twos = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT ones += flip ( bin [ i ] ) NEW_LINE DEDENT ones = list ( ones . strip ( \" \" ) ) NEW_LINE twos = list ( ones ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( ones [ i ] == '1' ) : NEW_LINE INDENT twos [ i ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT twos [ i ] = '1' NEW_LINE break NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE if ( i == - 1 ) : NEW_LINE INDENT twos . insert ( 0 , '1' ) NEW_LINE DEDENT print ( \"1 ' s ▁ complement : ▁ \" , * ones , sep = \" \" ) NEW_LINE print ( \"2 ' s ▁ complement : ▁ \" , * twos , sep = \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT bin = \"1100\" NEW_LINE printOneAndTwosComplement ( bin . strip ( \" \" ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "1 ' s ▁ and ▁ 2' s complement of a Binary Number | Returns '0' for '1' and '1' for '0 ; Print 1 ' s ▁ and ▁ 2' s complement of binary number represented by \" bin \" ; for ones complement flip every bit ; for two 's complement go from right  to left in ones complement and if  we get 1 make, we make them 0 and  keep going left when we get first  0, make that 1 and go out of loop ; If No break : all are 1 as in 111 or 11111 in such case , add extra 1 at beginning ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "8711-8711",
        "Code": "def removeRecurringDigits ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE ( i , j ) = ( 0 , 0 ) NEW_LINE str = ' ' NEW_LINE while i < l : NEW_LINE INDENT str += num [ i ] NEW_LINE j += 1 NEW_LINE while ( i + 1 < l and num [ i ] == num [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = '1299888833' NEW_LINE print ( ' Modified ▁ number ▁ is ▁ { } ' . format ( removeRecurringDigits ( num ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove recurring digits in a given number | Removes recurring digits in num [ ] ; Index in modified string ; Traverse digits of given number one by one ; Copy the first occurrence of new digit ; Remove repeating occurrences of digit ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "8720-8720",
        "Code": "def isPalin ( str , st , end ) : NEW_LINE INDENT while ( st < end ) : NEW_LINE INDENT if ( str [ st ] != str [ end ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT st += 1 NEW_LINE end - - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def findMinInsert ( str , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalin ( str , 0 , i ) ) : NEW_LINE INDENT return ( n - i - 1 ) NEW_LINE DEDENT DEDENT DEDENT Input = \" JAVA \" NEW_LINE print ( findMinInsert ( Input , len ( Input ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum insertions to form shortest palindrome | Returns true if a string str [ st . . end ] is palindrome ; Returns count of insertions on left side to make str [ ] a palindrome ; Find the largest prefix of given string that is palindrome . ; Characters after the palindromic prefix must be added at the beginning also to make the complete string palindrome ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "8727-8727",
        "Code": "def removeRecur ( n ) : NEW_LINE INDENT prev_digit = n % 10 NEW_LINE pow = 10 NEW_LINE res = prev_digit NEW_LINE while ( n ) : NEW_LINE INDENT curr_digit = n % 10 NEW_LINE if ( curr_digit != prev_digit ) : NEW_LINE INDENT res += curr_digit * pow NEW_LINE prev_digit = curr_digit NEW_LINE pow *= 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12224 NEW_LINE print ( removeRecur ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Remove repeated digits in a given number | Python 3 program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "8728-8728",
        "Code": "def removeSpaces ( string ) : NEW_LINE INDENT count = 0 NEW_LINE list = [ ] NEW_LINE DEDENT ' NEW_LINE INDENT for i in xrange ( len ( string ) ) : NEW_LINE INDENT if string [ i ] != ' ▁ ' : NEW_LINE INDENT list . append ( string [ i ] ) NEW_LINE DEDENT DEDENT return toString ( list ) NEW_LINE DEDENT def toString ( List ) : NEW_LINE INDENT return ' ' . join ( List ) NEW_LINE DEDENT string = \" g ▁ eeks ▁ for ▁ ge ▁ eeks ▁ \" NEW_LINE print removeSpaces ( string ) NEW_LINE",
        "Type": "py",
        "NL": "Remove spaces from a given string | Function to remove all spaces from a given string ; To keep track of non - space character count ; Traverse the given string . If current character is not space , then place it at index 'count++ ; Utility Function ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "8729-8729",
        "Code": "def removeSpaces ( string ) : NEW_LINE INDENT string = string . replace ( ' ▁ ' , ' ' ) NEW_LINE return string NEW_LINE DEDENT string = \" g ▁ eeks ▁ for ▁ ge ▁ eeks ▁ \" NEW_LINE print ( removeSpaces ( string ) ) NEW_LINE",
        "Type": "py",
        "NL": "Remove spaces from a given string | Function to remove all spaces from a given string ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "8734-8734",
        "Code": "MAX_CHARS = 26 NEW_LINE def isValid ( count , k ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( MAX_CHARS ) : NEW_LINE INDENT if count [ i ] > 0 : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT return ( k >= val ) NEW_LINE DEDENT def kUniques ( s , k ) : NEW_LINE INDENT count = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT u += 1 NEW_LINE DEDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if u < k : NEW_LINE INDENT print ( \" Not ▁ enough ▁ unique ▁ characters \" ) NEW_LINE return NEW_LINE DEDENT curr_start = 0 NEW_LINE curr_end = 0 NEW_LINE max_window_size = 1 NEW_LINE max_window_start = 0 NEW_LINE count = [ 0 ] * len ( count ) NEW_LINE count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE curr_end += 1 NEW_LINE while not isValid ( count , k ) : NEW_LINE INDENT count [ ord ( s [ curr_start ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE curr_start += 1 NEW_LINE DEDENT if curr_end - curr_start + 1 > max_window_size : NEW_LINE INDENT max_window_size = curr_end - curr_start + 1 NEW_LINE max_window_start = curr_start NEW_LINE DEDENT DEDENT print ( \" Max ▁ substring ▁ is ▁ : ▁ \" + s [ max_window_start : max_window_start + max_window_size ] + \" ▁ with ▁ length ▁ \" + str ( max_window_size ) ) NEW_LINE DEDENT s = \" aabacbebebe \" NEW_LINE k = 3 NEW_LINE kUniques ( s , k ) NEW_LINE",
        "Type": "py",
        "NL": "Find the longest substring with k unique characters in a given string | Python program to find the longest substring with k unique characters in a given string ; This function calculates number of unique characters using a associative array count [ ] . Returns true if no . of characters are less than required else returns false . ; Return true if k is greater than or equal to val ; Finds the maximum substring with exactly k unique characters ; Associative array to store the count ; Tranverse the string , fills the associative array count [ ] and count number of unique characters ; If there are not enough unique characters , show an error message . ; Otherwise take a window with first element in it . start and end variables . ; Also initialize values for result longest window ; Initialize associative array count [ ] with zero ; put the first character ; Start from the second character and add characters in window according to above explanation ; Add the character ' s [ i ] ' to current window ; If there are more than k unique characters in current window , remove from left side ; Update the max window size if required ; Driver function",
        "Category": "Sliding Window"
    },
    {
        "ID": "8740-8740",
        "Code": "NO_OF_CHARS = 256 NEW_LINE def canFormPalindrome ( st ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if ( canFormPalindrome ( \" geeksforgeeks \" ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT if ( canFormPalindrome ( \" geeksogeeks \" ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if characters of a given string can be rearranged to form a palindrome | Python3 implementation to check if characters of a given string can be rearranged to form a palindrome ; function to check whether characters of a string can form a palindrome ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; Count odd occurring characters ; Return true if odd count is 0 or 1 , ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8743-8743",
        "Code": "NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 : str , str2 : str ) -> bool : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def findAllAnagrams ( arr : list , n : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if areAnagram ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" is ▁ anagram ▁ of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksquiz \" , \" geeksforgeeks \" , \" abcd \" , \" forgeeksgeeks \" , \" zuiqkeegs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all pairs of anagrams in a given array of strings | Python3 program to find best meeting point in 2D array ; function to check whether two strings are anagram of each other ; Create two count arrays and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like \" aaca \" and \" aca \" ; See if there is any non - zero value in count array ; This function prints all anagram pairs in a given array of strings ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "8755-8755",
        "Code": "def toList ( string ) : NEW_LINE INDENT l = [ ] NEW_LINE for x in string : NEW_LINE INDENT l . append ( x ) NEW_LINE DEDENT return l NEW_LINE DEDENT def toString ( l ) : NEW_LINE INDENT return ' ' . join ( l ) NEW_LINE DEDENT def stringFilter ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE i = - 1 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if j < n - 1 and string [ j ] == ' a ' and string [ j + 1 ] == ' c ' : NEW_LINE INDENT j += 2 NEW_LINE DEDENT elif string [ j ] == ' b ' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif i >= 0 and string [ j ] == ' c ' and string [ i ] == ' a ' : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE string [ i ] = string [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE return toString ( string [ : i ] ) NEW_LINE DEDENT string1 = \" ad \" NEW_LINE print \" Input ▁ = > ▁ \" + string1 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string1 ) ) +   \" NEW_LINE \" NEW_LINE string2 = \" acbac \" NEW_LINE print \" Input ▁ = > ▁ \" + string2 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string2 ) ) +   \" NEW_LINE \" NEW_LINE string3 = \" aaac \" NEW_LINE print \" Input ▁ = > ▁ \" + string3 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string3 ) ) +   \" NEW_LINE \" NEW_LINE string4 = \" react \" NEW_LINE print \" Input ▁ = > ▁ \" + string4 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string4 ) ) +   \" NEW_LINE \" NEW_LINE string5 = \" aa \" NEW_LINE print \" Input ▁ = > ▁ \" + string5 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string5 ) ) +   \" NEW_LINE \" NEW_LINE string6 = \" ababaac \" NEW_LINE print \" Input ▁ = > ▁ \" + string6 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string6 ) ) +   \" NEW_LINE \" NEW_LINE string7 = \" abc \" NEW_LINE print \" Input ▁ = > ▁ \" + string7 +   \" NEW_LINE Output = >   \" , NEW_LINE print stringFilter ( toList ( string7 ) ) +   \" NEW_LINE \" NEW_LINE",
        "Type": "py",
        "NL": "Remove \" b \" and \" ac \" from a given string | Utility function to convert string to list ; Utility function to convert list to string ; length of string ; Check if current and next character forms ac ; If current character is b ; if current char is ' c ▁ & & ▁ last ▁ char ▁ in ▁ output ▁ ▁ is ▁ ' a ' so delete both ; Else copy curr char to output string ; Driver program",
        "Category": "Substring"
    },
    {
        "ID": "8760-8760",
        "Code": "import sys NEW_LINE def myAtoi ( Str ) : NEW_LINE INDENT sign , base , i = 1 , 0 , 0 NEW_LINE while ( Str [ i ] == ' ▁ ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( Str [ i ] == ' - ' or Str [ i ] == ' + ' ) : NEW_LINE INDENT sign = 1 - 2 * ( Str [ i ] == ' - ' ) NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( Str ) and Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT if ( base > ( sys . maxsize // 10 ) or ( base == ( sys . maxsize // 10 ) and ( Str [ i ] - '0' ) > 7 ) ) : NEW_LINE INDENT if ( sign == 1 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT else : NEW_LINE INDENT return - ( sys . maxsize ) NEW_LINE DEDENT DEDENT base = 10 * base + ( ord ( Str [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT return base * sign NEW_LINE DEDENT Str = list ( \" ▁ - 123\" ) NEW_LINE val = myAtoi ( Str ) NEW_LINE print ( val ) NEW_LINE",
        "Type": "py",
        "NL": "Write your own atoi ( ) | A simple Python3 program for implementation of atoi ; If whitespaces then ignore . ; Sign of number ; Checking for valid input ; Handling overflow test case ; Driver Code ; Functional Code",
        "Category": "Math"
    },
    {
        "ID": "8762-8762",
        "Code": "def generateGray ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ \"0\" ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return [ \"0\" , \"1\" ] NEW_LINE DEDENT recAns = generateGray ( n - 1 ) NEW_LINE mainAns = [ ] NEW_LINE for i in range ( len ( recAns ) ) : NEW_LINE INDENT s = recAns [ i ] NEW_LINE mainAns . append ( \"0\" + s ) NEW_LINE DEDENT for i in range ( len ( recAns ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT s = recAns [ i ] NEW_LINE mainAns . append ( \"1\" + s ) NEW_LINE DEDENT return mainAns NEW_LINE DEDENT def generateGrayarr ( n ) : NEW_LINE INDENT arr = generateGray ( n ) NEW_LINE print ( * arr , sep =   \" \" ) NEW_LINE DEDENT generateGrayarr ( 3 ) NEW_LINE",
        "Type": "py",
        "NL": "Generate n | This function generates all n bit Gray codes and prints the generated codes ; Base case ; Recursive case ; Append 0 to the first half ; Append 1 to the second half ; Function to generate the Gray code of N bits ; Print contents of arr ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8789-8789",
        "Code": "NO_OF_CHARS = 256 NEW_LINE def printList ( list , word , list_size ) : NEW_LINE INDENT map = [ 0 ] * NO_OF_CHARS NEW_LINE for i in word : NEW_LINE INDENT map [ ord ( i ) ] = 1 NEW_LINE DEDENT word_size = len ( word ) NEW_LINE for i in list : NEW_LINE INDENT count = 0 NEW_LINE for j in i : NEW_LINE INDENT if map [ ord ( j ) ] : NEW_LINE INDENT count += 1 NEW_LINE map [ ord ( j ) ] = 0 NEW_LINE DEDENT DEDENT if count == word_size : NEW_LINE INDENT print i NEW_LINE DEDENT for j in xrange ( len ( word ) ) : NEW_LINE INDENT map [ ord ( word [ j ] ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT string = \" sun \" NEW_LINE list = [ \" geeksforgeeks \" , \" unsorted \" , \" sunday \" , \" just \" , \" sss \" ] NEW_LINE printList ( list , string , 5 ) NEW_LINE",
        "Type": "py",
        "NL": "Print list items containing all characters of a given word | Python program to print the list items containing all characters of a given word ; Prints list items having all characters of word ; Set the values in map ; Get the length of given word ; Check each item of list if has all characters of words ; unset the bit so that strings like sss not printed ; Set the values in map for next item ; Driver program to test the above function",
        "Category": "Substring"
    },
    {
        "ID": "8793-8793",
        "Code": "def divideString ( string , n ) : NEW_LINE INDENT str_size = len ( string ) NEW_LINE if str_size % n != 0 : NEW_LINE INDENT print \" Invalid ▁ Input : ▁ String ▁ size ▁ is ▁ not ▁ divisible ▁ by ▁ n \" NEW_LINE return NEW_LINE DEDENT part_size = str_size / n NEW_LINE k = 0 NEW_LINE for i in string : NEW_LINE INDENT if k % part_size == 0 : NEW_LINE INDENT print   \" NEW_LINE DEDENT DEDENT DEDENT \" , NEW_LINE INDENT print i , NEW_LINE k += 1 NEW_LINE DEDENT string = \" a _ simple _ divide _ string _ quest \" NEW_LINE / * length od string is 28 * / NEW_LINE divideString ( string , 4 ) NEW_LINE",
        "Type": "py",
        "NL": "Divide a string in N equal parts | Function to print n equal parts of string ; Check if string can be divided in n equal parts ; Calculate the size of parts to find the division points ; Driver program to test the above function Length of string is 28 ;  ; Print 4 equal parts of the string",
        "Category": "Substring"
    },
    {
        "ID": "88-88",
        "Code": "from math import ceil , log NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . key = value NEW_LINE self . child = [ ] NEW_LINE DEDENT DEDENT def BuildkaryTree ( A , n , k , h , ind ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return None NEW_LINE DEDENT nNode = newNode ( A [ ind [ 0 ] ] ) NEW_LINE if ( nNode == None ) : NEW_LINE INDENT print ( \" Memory ▁ error \" ) NEW_LINE return None NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( ind [ 0 ] < n - 1 and h > 1 ) : NEW_LINE INDENT ind [ 0 ] += 1 NEW_LINE nNode . child . append ( BuildkaryTree ( A , n , k , h - 1 , ind ) ) NEW_LINE DEDENT else : NEW_LINE INDENT nNode . child . append ( None ) NEW_LINE DEDENT DEDENT return nNode NEW_LINE DEDENT def BuildKaryTree ( A , n , k , ind ) : NEW_LINE INDENT height = int ( ceil ( log ( float ( n ) * ( k - 1 ) + 1 ) / log ( float ( k ) ) ) ) NEW_LINE return BuildkaryTree ( A , n , k , height , ind ) NEW_LINE DEDENT def postord ( root , k ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT postord ( root . child [ i ] , k ) NEW_LINE DEDENT print ( root . key , end = \" ▁ \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ind = [ 0 ] NEW_LINE k = 3 NEW_LINE n = 10 NEW_LINE preorder = [ 1 , 2 , 5 , 6 , 7 , 3 , 8 , 9 , 10 , 4 ] NEW_LINE root = BuildKaryTree ( preorder , n , k , ind ) NEW_LINE print ( \" Postorder ▁ traversal ▁ of ▁ constructed \" , \" full ▁ k - ary ▁ tree ▁ is : ▁ \" ) NEW_LINE postord ( root , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct the full k | Python3 program to build full k - ary tree from its preorder traversal and to print the postorder traversal of the tree . ; Utility function to create a new tree node with k children ; Function to build full k - ary tree ; For None tree ; For adding k children to a node ; Check if ind is in range of array Check if height of the tree is greater than 1 ; Recursively add each child ; Function to find the height of the tree ; Function to prpostorder traversal of the tree ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "8801-8801",
        "Code": "def removeDuplicate ( str , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in str : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT st = \" \" NEW_LINE for i in s : NEW_LINE INDENT st = st + i NEW_LINE DEDENT return st NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE print ( removeDuplicate ( list ( str ) , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Remove duplicates from a given string | Python program to remove duplicate character from character array and print in sorted order ; Create a set using String characters ; Print content of the set ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "8817-8817",
        "Code": "import math NEW_LINE def TowerOfHanoi ( N ) : NEW_LINE INDENT for x in range ( 1 , int ( math . pow ( 2 , N ) ) ) : NEW_LINE INDENT print ( \" Move ▁ from ▁ Rod ▁ \" , ( ( x & x - 1 ) % 3 + 1 ) , \" ▁ to ▁ Rod ▁ \" , ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) ) NEW_LINE DEDENT DEDENT N = 3 NEW_LINE TowerOfHanoi ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Tower of Hanoi | Set 2 | Python program for the above approach ; Function to print order of movement of N disks across three rods to place all disks on the third rod from the first - rod using binary representation ; Iterate over the range [ 0 , 2 ^ N - 1 ] ; Print the movement of the current rod ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8827-8827",
        "Code": "def solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) : NEW_LINE INDENT if ( N == 0 or ( QuitP1 and QuitP2 ) ) : NEW_LINE INDENT print ( \" Number ▁ of ▁ pens ▁ remaining ▁ in ▁ the ▁ box : ▁ \" , N ) NEW_LINE print ( \" Number ▁ of ▁ pens ▁ collected ▁ by ▁ P1 : ▁ \" , P1 ) NEW_LINE print ( \" Number ▁ of ▁ pens ▁ collected ▁ by ▁ P2 : ▁ \" , P2 ) NEW_LINE return NEW_LINE DEDENT if ( Move == 0 and QuitP1 == False ) : NEW_LINE INDENT req_P1 = int ( pow ( 2 , X ) ) NEW_LINE if ( req_P1 <= N ) : NEW_LINE INDENT P1 += req_P1 NEW_LINE N -= req_P1 NEW_LINE DEDENT else : NEW_LINE INDENT QuitP1 = True NEW_LINE DEDENT DEDENT elif ( Move == 1 and QuitP2 == False ) : NEW_LINE INDENT req_P2 = int ( pow ( 3 , X ) ) NEW_LINE if ( req_P2 <= N ) : NEW_LINE INDENT P2 += req_P2 NEW_LINE N -= req_P2 NEW_LINE DEDENT else : NEW_LINE INDENT QuitP2 = True NEW_LINE DEDENT DEDENT X += 1 NEW_LINE if ( Move == 1 ) : NEW_LINE INDENT Move = 0 NEW_LINE DEDENT else : NEW_LINE INDENT Move = 1 NEW_LINE DEDENT solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) NEW_LINE DEDENT def PenGame ( N ) : NEW_LINE INDENT P1 = 0 NEW_LINE P2 = 0 NEW_LINE X = 0 NEW_LINE Move = False NEW_LINE QuitP1 = False NEW_LINE QuitP2 = False NEW_LINE solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) NEW_LINE DEDENT N = 22 NEW_LINE PenGame ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Pen Distribution Problem | Recursive function to play Game ; Box is empty , Game Over ! or Both have quit , Game Over ! ; P1 moves ; P2 moves ; Increment X ; Switch moves between P1 and P2 ; Function to find the number of pens remaining in the box and calculate score for each player ; Score of P1 ; Score of P2 ; Initialized to zero ; Move = 0 , P1 ' s ▁ turn ▁ ▁ Move ▁ = ▁ 1 , ▁ P2' s turn ; Has P1 quit ; Has P2 quit ; Recursively continue the game ; Driver Code",
        "Category": "Recursion"
    },
    {
        "ID": "8841-8841",
        "Code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( key ) NEW_LINE return temp NEW_LINE DEDENT def find_x ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT num = math . log10 ( n ) NEW_LINE x , no = 0 , 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT den = math . log10 ( i ) NEW_LINE p = num / den NEW_LINE no = int ( pow ( i , int ( p ) ) ) NEW_LINE if abs ( no - n ) < 1e-6 : NEW_LINE INDENT x = i NEW_LINE break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT def is_key ( n , x ) : NEW_LINE INDENT p = math . log10 ( n ) / math . log10 ( x ) NEW_LINE no = int ( pow ( x , int ( p ) ) ) NEW_LINE if n == no : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def evenPaths ( node , count , x ) : NEW_LINE INDENT if node == None or not is_key ( node . key , x ) : NEW_LINE INDENT return count NEW_LINE DEDENT if node . left == None and node . right == None : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = evenPaths ( node . left , count , x ) NEW_LINE return evenPaths ( node . right , count , x ) NEW_LINE DEDENT def countExpPaths ( node , x ) : NEW_LINE INDENT return evenPaths ( node , 0 , x ) NEW_LINE DEDENT root = newNode ( 27 ) NEW_LINE root . left = newNode ( 9 ) NEW_LINE root . right = newNode ( 81 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 10 ) NEW_LINE root . right . left = newNode ( 70 ) NEW_LINE root . right . right = newNode ( 243 ) NEW_LINE root . right . right . left = newNode ( 81 ) NEW_LINE root . right . right . right = newNode ( 909 ) NEW_LINE x = find_x ( root . key ) NEW_LINE print ( countExpPaths ( root , x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of exponential paths in a Binary Tree | Python3 program to find the count exponential paths in Binary Tree ; Structure of a Tree node ; Function to create a new node ; Function to find x ; Take log10 of n ; Log ( n ) with base i ; Raising i to the power p ; Function to check whether the given node equals to x ^ y for some y > 0 ; Take logx ( n ) with base x ; Utility function to count the exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to count exponential paths ; Create Tree ; Retrieve the value of x ; Function call",
        "Category": "Binary Tree"
    },
    {
        "ID": "8846-8846",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . key = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenPaths ( node , count ) : NEW_LINE INDENT if ( node == None or ( node . key % 2 != 0 ) ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( not node . left and not node . right ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = evenPaths ( node . left , count ) NEW_LINE return evenPaths ( node . right , count ) NEW_LINE DEDENT def countEvenPaths ( node ) : NEW_LINE INDENT return evenPaths ( node , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 12 ) NEW_LINE root . left = Node ( 13 ) NEW_LINE root . right = Node ( 12 ) NEW_LINE root . right . left = Node ( 14 ) NEW_LINE root . right . right = Node ( 16 ) NEW_LINE root . right . left . left = Node ( 21 ) NEW_LINE root . right . left . right = Node ( 22 ) NEW_LINE root . right . right . left = Node ( 22 ) NEW_LINE root . right . right . right = Node ( 24 ) NEW_LINE root . right . right . right . left = Node ( 8 ) NEW_LINE print ( countEvenPaths ( root ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count even paths in Binary Tree | A Tree node ; Utility function to count the even path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is odd ; Increment count when encounter leaf node with all node value even ; Left recursive call , and save the value of count ; Right recursive call , and return value of count ; Function to count the even paths in a given Binary tree ; Function call with count = 0 ; Driver Code ; Tree ; Function call",
        "Category": "Binary Tree"
    },
    {
        "ID": "8854-8854",
        "Code": "V = 4 NEW_LINE answer = [ ] NEW_LINE def tsp ( graph , v , currPos , n , count , cost ) : NEW_LINE INDENT if ( count == n and graph [ currPos ] [ 0 ] ) : NEW_LINE INDENT answer . append ( cost + graph [ currPos ] [ 0 ] ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] == False and graph [ currPos ] [ i ] ) : NEW_LINE INDENT v [ i ] = True NEW_LINE tsp ( graph , v , i , n , count + 1 , cost + graph [ currPos ] [ i ] ) NEW_LINE v [ i ] = False NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE graph = [ [ 0 , 10 , 15 , 20 ] , [ 10 , 0 , 35 , 25 ] , [ 15 , 35 , 0 , 30 ] , [ 20 , 25 , 30 , 0 ] ] NEW_LINE v = [ False for i in range ( n ) ] NEW_LINE v [ 0 ] = True NEW_LINE tsp ( graph , v , 0 , n , 1 , 0 ) NEW_LINE print ( min ( answer ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Travelling Salesman Problem implementation using BackTracking | Python3 implementation of the approach ; Function to find the minimum weight Hamiltonian Cycle ; If last node is reached and it has a link to the starting node i . e the source then keep the minimum value out of the total cost of traversal and \" ans \" Finally return to check for more possible values ; BACKTRACKING STEP Loop to traverse the adjacency list of currPos node and increasing the count by 1 and cost by graph [ currPos ] [ i ] value ; Mark as visited ; Mark ith node as unvisited ; n is the number of nodes i . e . V ; Boolean array to check if a node has been visited or not ; Mark 0 th node as visited ; Find the minimum weight Hamiltonian Cycle ; ans is the minimum weight Hamiltonian Cycle",
        "Category": "Backtracking"
    },
    {
        "ID": "886-886",
        "Code": "ROW = 3 NEW_LINE COL = 3 NEW_LINE def transpose ( transpose_matrix , matrix ) : NEW_LINE INDENT for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT transpose_matrix [ j ] [ i ] = matrix [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def check ( transpose_matrix , matrix ) : NEW_LINE INDENT for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] != - transpose_matrix [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def printMatrix ( matrix ) : NEW_LINE INDENT for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT print ( matrix [ i ] [ j ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT matrix = [ [ 0 , 5 , - 4 ] , [ - 5 , 0 , 1 ] , [ 4 , - 1 , 0 ] , ] NEW_LINE transpose_matrix = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE transpose ( transpose_matrix , matrix ) NEW_LINE print ( \" Transpose ▁ matrix : \" ) NEW_LINE printMatrix ( transpose_matrix ) NEW_LINE if ( check ( transpose_matrix , matrix ) ) : NEW_LINE INDENT print ( \" Skew ▁ Symmetric ▁ Matrix \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Skew ▁ Symmetric ▁ Matrix \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "C Program To Check whether Matrix is Skew Symmetric or not | Python 3 program to check whether given matrix is skew - symmetric or not ; Utility function to create transpose matrix ; Utility function to check skew - symmetric matrix condition ; Utility function to print a matrix ; Driver program to test above functions ; Function create transpose matrix ; Check whether matrix is skew - symmetric or not",
        "Category": "Matrix"
    },
    {
        "ID": "8866-8866",
        "Code": "class GfG : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 10 NEW_LINE self . arr = [ 0 ] * self . MAX NEW_LINE self . no = 0 NEW_LINE DEDENT def breakLine ( self ) : NEW_LINE INDENT print ( \" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \" ) NEW_LINE DEDENT def canPlace ( self , k , i ) : NEW_LINE INDENT for j in range ( 1 , k ) : NEW_LINE INDENT if ( self . arr [ j ] == i or ( abs ( self . arr [ j ] - i ) == abs ( j - k ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def display ( self , n ) : NEW_LINE INDENT self . breakLine ( ) NEW_LINE self . no += 1 NEW_LINE print ( \" Arrangement ▁ No . \" , self . no , end = \" ▁ \" ) NEW_LINE self . breakLine ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if self . arr [ i ] != j : NEW_LINE INDENT print ( \" TABSYMBOL _ \" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" TABSYMBOL Q \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT self . breakLine ( ) NEW_LINE DEDENT def nQueens ( self , k , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if self . canPlace ( k , i ) : NEW_LINE INDENT self . arr [ k ] = i NEW_LINE if k == n : NEW_LINE INDENT self . display ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT self . nQueens ( k + 1 , n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE obj = GfG ( ) NEW_LINE obj . nQueens ( 1 , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "N Queen in O ( n ) space | Python code to for n Queen placement ; Helper Function to check if queen can be placed ; Function to display placed queen ; Function to check queens placement ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "8875-8875",
        "Code": "def isParenthesis ( c ) : NEW_LINE INDENT return ( ( c == ' ( ' ) or ( c == ' ) ' ) ) NEW_LINE DEDENT def isValidString ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( str [ i ] == ' ) ' ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT if ( cnt < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( cnt == 0 ) NEW_LINE DEDENT def removeInvalidParenthesis ( str ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT visit = set ( ) NEW_LINE q = [ ] NEW_LINE temp = 0 NEW_LINE level = 0 NEW_LINE q . append ( str ) NEW_LINE visit . add ( str ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT str = q [ 0 ] NEW_LINE q . pop ( ) NEW_LINE if ( isValidString ( str ) ) : NEW_LINE INDENT print ( str ) NEW_LINE level = True NEW_LINE DEDENT if ( level ) : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( not isParenthesis ( str [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = str [ 0 : i ] + str [ i + 1 : ] NEW_LINE if temp not in visit : NEW_LINE INDENT q . append ( temp ) NEW_LINE visit . add ( temp ) NEW_LINE DEDENT DEDENT DEDENT DEDENT expression = \" ( ) ( ) ) ( ) \" NEW_LINE removeInvalidParenthesis ( expression ) NEW_LINE expression = \" ( ) v ) \" NEW_LINE removeInvalidParenthesis ( expression ) NEW_LINE",
        "Type": "py",
        "NL": "Remove Invalid Parentheses | Method checks if character is parenthesis ( openor closed ) ; method returns true if contains valid parenthesis ; method to remove invalid parenthesis ; visit set to ignore already visited ; queue to maintain BFS ; pushing given as starting node into queu ; If answer is found , make level true so that valid of only that level are processed . ; Removing parenthesis from str and pushing into queue , if not visited already ; Driver Code",
        "Category": "BFS / Graph Theory"
    },
    {
        "ID": "8885-8885",
        "Code": "allPaths = [ ] NEW_LINE def findPaths ( maze , m , n ) : NEW_LINE INDENT path = [ 0 for d in range ( m + n - 1 ) ] NEW_LINE findPathsUtil ( maze , m , n , 0 , 0 , path , 0 ) NEW_LINE DEDENT def findPathsUtil ( maze , m , n , i , j , path , indx ) : NEW_LINE INDENT global allPaths NEW_LINE if i == m - 1 : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT path [ indx + k - j ] = maze [ i ] [ k ] NEW_LINE DEDENT print ( path ) NEW_LINE allPaths . append ( path ) NEW_LINE return NEW_LINE DEDENT if j == n - 1 : NEW_LINE INDENT for k in range ( i , m ) : NEW_LINE INDENT path [ indx + k - i ] = maze [ k ] [ j ] NEW_LINE DEDENT print ( path ) NEW_LINE allPaths . append ( path ) NEW_LINE return NEW_LINE DEDENT path [ indx ] = maze [ i ] [ j ] NEW_LINE findPathsUtil ( maze , m , n , i + 1 , j , path , indx + 1 ) NEW_LINE findPathsUtil ( maze , m , n , i , j + 1 , path , indx + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maze = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE findPaths ( maze , 3 , 3 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print all possible paths from top left to bottom right of a mXn matrix | Python3 program to Print all possible paths from top left to bottom right of a mXn matrix ; if we reach the bottom of maze , we can only move right ; path . append ( maze [ i ] [ k ] ) ; if we hit this block , it means one path is completed . Add it to paths list and print ; if we reach to the right most corner , we can only move down ; path . append ( maze [ j ] [ k ] ) if we hit this block , it means one path is completed . Add it to paths list and print ; add current element to the path list path . append ( maze [ i ] [ j ] ) ; move down in y direction and call findPathsUtil recursively ; move down in y direction and call findPathsUtil recursively ; Driver code",
        "Category": "Backtracking"
    },
    {
        "ID": "8886-8886",
        "Code": "N = 9 NEW_LINE def printing ( arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def isSafe ( grid , row , col , num ) : NEW_LINE INDENT for x in range ( 9 ) : NEW_LINE INDENT if grid [ row ] [ x ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for x in range ( 9 ) : NEW_LINE INDENT if grid [ x ] [ col ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT startRow = row - row % 3 NEW_LINE startCol = col - col % 3 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if grid [ i + startRow ] [ j + startCol ] == num : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def solveSuduko ( grid , row , col ) : NEW_LINE INDENT if ( row == N - 1 and col == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT if col == N : NEW_LINE INDENT row += 1 NEW_LINE col = 0 NEW_LINE DEDENT if grid [ row ] [ col ] > 0 : NEW_LINE INDENT return solveSuduko ( grid , row , col + 1 ) NEW_LINE DEDENT for num in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if isSafe ( grid , row , col , num ) : NEW_LINE INDENT grid [ row ] [ col ] = num NEW_LINE if solveSuduko ( grid , row , col + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT grid [ row ] [ col ] = 0 NEW_LINE DEDENT return False NEW_LINE DEDENT grid = [ [ 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 ] , [ 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 ] , [ 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 ] , [ 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 ] , [ 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 ] , [ 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 ] , [ 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 ] ] NEW_LINE if ( solveSuduko ( grid , 0 , 0 ) ) : NEW_LINE INDENT printing ( grid ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no ▁ solution ▁ exists ▁ \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sudoku | Backtracking | N is the size of the 2D matrix N * N ; A utility function to print grid ; Checks whether it will be legal to assign num to the given row , col ; Check if we find the same num in the similar row , we return false ; Check if we find the same num in the similar column , we return false ; Check if we find the same num in the particular 3 * 3 matrix , we return false ; Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes ) ; Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking ; Check if column value becomes 9 , we move to next row and column start from 0 ; Check if the current position of the grid already contains value > 0 , we iterate for next column ; Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column ; Assigning the num in the current ( row , col ) position of the grid and assuming our assigned num in the position is correct ; Checking for next possibility with next column ; Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value ; 0 means unassigned cells",
        "Category": "Backtracking"
    },
    {
        "ID": "89-89",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def preOrder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( node . data , end = \" ▁ \" ) NEW_LINE preOrder ( node . left ) NEW_LINE preOrder ( node . right ) NEW_LINE DEDENT def findIndex ( Str , si , ei ) : NEW_LINE INDENT if ( si > ei ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( si , ei + 1 ) : NEW_LINE INDENT if ( Str [ i ] == ' ( ' ) : NEW_LINE INDENT s . append ( Str [ i ] ) NEW_LINE DEDENT elif ( Str [ i ] == ' ) ' ) : NEW_LINE INDENT if ( s [ - 1 ] == ' ( ' ) : NEW_LINE INDENT s . pop ( - 1 ) NEW_LINE if len ( s ) == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def treeFromString ( Str , si , ei ) : NEW_LINE INDENT if ( si > ei ) : NEW_LINE INDENT return None NEW_LINE DEDENT root = newNode ( ord ( Str [ si ] ) - ord ( '0' ) ) NEW_LINE index = - 1 NEW_LINE if ( si + 1 <= ei and Str [ si + 1 ] == ' ( ' ) : NEW_LINE INDENT index = findIndex ( Str , si + 1 , ei ) NEW_LINE DEDENT if ( index != - 1 ) : NEW_LINE INDENT root . left = treeFromString ( Str , si + 2 , index - 1 ) NEW_LINE root . right = treeFromString ( Str , index + 2 , ei - 1 ) NEW_LINE DEDENT return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = \"4(2(3 ) ( 1 ) ) (6(5 ) ) \" NEW_LINE root = treeFromString ( Str , 0 , len ( Str ) - 1 ) NEW_LINE preOrder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Construct Binary Tree from String with bracket representation | Helper class that allocates a new node ; This funtcion is here just to test ; function to return the index of close parenthesis ; Inbuilt stack ; if open parenthesis , push it ; if close parenthesis ; if stack is empty , this is the required index ; if not found return - 1 ; function to conStruct tree from String ; Base case ; new root ; if next char is ' ( ' find the index of its complement ')   ; if index found ; call for left subtree ; call for right subtree ; Driver Code",
        "Category": "Binary Tree"
    },
    {
        "ID": "890-890",
        "Code": "def printCoils ( n ) : NEW_LINE INDENT m = 8 * n * n NEW_LINE coil1 = [ 0 ] * m NEW_LINE coil1 [ 0 ] = 8 * n * n + 2 * n NEW_LINE curr = coil1 [ 0 ] NEW_LINE nflg = 1 NEW_LINE step = 2 NEW_LINE index = 1 NEW_LINE while ( index < m ) : NEW_LINE INDENT for i in range ( step ) : NEW_LINE INDENT curr = coil1 [ index ] = ( curr - 4 * n * nflg ) NEW_LINE index += 1 NEW_LINE if ( index >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( index >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( step ) : NEW_LINE INDENT curr = coil1 [ index ] = curr + nflg NEW_LINE index += 1 NEW_LINE if ( index >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT nflg = nflg * ( - 1 ) NEW_LINE step += 2 NEW_LINE DEDENT coil2 = [ 0 ] * m NEW_LINE i = 0 NEW_LINE while ( i < 8 * n * n ) : NEW_LINE INDENT coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( \" Coil ▁ 1 ▁ : \" , end = \" ▁ \" ) NEW_LINE i = 0 NEW_LINE while ( i < 8 * n * n ) : NEW_LINE INDENT print ( coil1 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT print ( \" Coil 2 : \" , ▁ end ▁ = ▁ \"   \" ) NEW_LINE i = 0 NEW_LINE while ( i < 8 * n * n ) : NEW_LINE INDENT print ( coil2 [ i ] , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 1 NEW_LINE printCoils ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Form coils in a matrix | Prcoils in a matrix of size 4 n x 4 n ; Number of elements in each coil ; Let us fill elements in coil 1. ; First element of coil1 4 * n * 2 * n + 2 * n ; Fill remaining m - 1 elements in coil1 [ ] ; Fill elements of current step from down to up ; Next element from current element ; Fill elements of current step from up to down . ; get coil2 from coil1 ; Prboth coils ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "8900-8900",
        "Code": "def printPairs ( a , n , x ) : NEW_LINE INDENT rem = [ ] NEW_LINE for i in range ( x ) : NEW_LINE INDENT rem . append ( 0 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < x ) : NEW_LINE INDENT rem [ a [ i ] % x ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , x // 2 ) : NEW_LINE INDENT if ( rem [ i ] > 0 and rem [ x - i ] > 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( i >= x // 2 ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT if ( rem [ x // 2 ] > 1 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( rem [ x // 2 ] > 0 and rem [ x - x // 2 ] > 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT A = [ 1 , 4 , 45 , 6 , 10 , 8 ] NEW_LINE n = 16 NEW_LINE arr_size = len ( A ) NEW_LINE printPairs ( A , arr_size , n ) NEW_LINE",
        "Type": "py",
        "NL": "Given an array A [ ] and a number x , check for pair in A [ ] with sum as x | Function to print pairs ; Initializing the rem values with 0 's. ; Perform the remainder operation only if the element is x , as numbers greater than x can 't  be used to get a sum x.Updating  the count of remainders. ; Traversing the remainder list from start to middle to find pairs ; The elements with remainders i and x - i will result to a sum of x . Once we get two elements which add up to x , we print x and break . ; Once we reach middle of remainder array , we have to do operations based on x . ; If x is even and we have more than 1 elements with remainder x / 2 , then we will have two distinct elements which add up to x . if we dont have than 1 element , print \" No \" . ; When x is odd we continue the same process which we did in previous loop . ; Driver Code ; Function calling",
        "Category": "Hash Table"
    },
    {
        "ID": "8902-8902",
        "Code": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def remainder ( n , a , p ) : NEW_LINE INDENT ans = a % p NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = power ( ans , i , p ) NEW_LINE DEDENT return ans NEW_LINE DEDENT A = 2 NEW_LINE N = 1 NEW_LINE P = 2 NEW_LINE print ( remainder ( N , A , P ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find remainder when a number A raised to N factorial is divided by P | Function to calculate ( A ^ N ! ) % P in O ( log y ) ; Initialize result ; Update x if it is more than or Equal to p ; In case x is divisible by p ; If y is odd , multiply x with result ; y must be even now ; Returning modular power ; Function to calculate resultant remainder ; Initializing ans to store final remainder ; Calculating remainder ; Returning resultant remainder ; Given input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "8908-8908",
        "Code": "mod = 1000000007 NEW_LINE def exponentMod ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT y = 0 ; NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B // 2 ) ; NEW_LINE y = ( y * y ) % mod ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A % mod ; NEW_LINE y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod ; NEW_LINE DEDENT return ( ( y + mod ) % mod ) ; NEW_LINE DEDENT def countWays ( N ) : NEW_LINE INDENT select = exponentMod ( 2 , N - 1 ) ; NEW_LINE ways = ( ( N % mod ) * ( select % mod ) ) ; NEW_LINE ways %= mod ; NEW_LINE print ( ways ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE countWays ( N ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of groups among N people having only one leader in each group | Python3 program for the above approach ; Function to find 2 ^ x using modular exponentiation ; Base cases ; If B is even ; If B is odd ; Function to count the number of ways to form the group having one leader ; Find 2 ^ ( N - 1 ) using modular exponentiation ; Count total ways ; Print the total ways ; Driver code ; Given N number of people ; Function call",
        "Category": "Math"
    },
    {
        "ID": "8914-8914",
        "Code": "from typing import List NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self ) -> None : NEW_LINE INDENT self . value = 0 NEW_LINE self . max_set_bits = 0 NEW_LINE DEDENT DEDENT tree = [ Node ( ) for _ in range ( 4 * 10000 ) ] NEW_LINE def setBits ( x : int ) -> int : NEW_LINE INDENT parity = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT parity += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT return parity NEW_LINE DEDENT def buildSegmentTree ( a : List [ int ] , index : int , beg : int , end : int ) -> None : NEW_LINE INDENT if ( beg == end ) : NEW_LINE INDENT tree [ index ] . value = a [ beg ] NEW_LINE tree [ index ] . max_set_bits = setBits ( a [ beg ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( beg + end ) // 2 NEW_LINE buildSegmentTree ( a , 2 * index + 1 , beg , mid ) NEW_LINE buildSegmentTree ( a , 2 * index + 2 , mid + 1 , end ) NEW_LINE if ( tree [ 2 * index + 1 ] . max_set_bits > tree [ 2 * index + 2 ] . max_set_bits ) : NEW_LINE INDENT tree [ index ] . max_set_bits = tree [ 2 * index + 1 ] . max_set_bits NEW_LINE tree [ index ] . value = tree [ 2 * index + 1 ] . value NEW_LINE DEDENT elif ( tree [ 2 * index + 2 ] . max_set_bits > tree [ 2 * index + 1 ] . max_set_bits ) : NEW_LINE INDENT tree [ index ] . max_set_bits = tree [ 2 * index + 2 ] . max_set_bits NEW_LINE tree [ index ] . value = tree [ 2 * index + 2 ] . value NEW_LINE DEDENT else : NEW_LINE INDENT tree [ index ] . max_set_bits = tree [ 2 * index + 2 ] . max_set_bits NEW_LINE tree [ index ] . value = max ( tree [ 2 * index + 2 ] . value , tree [ 2 * index + 1 ] . value ) NEW_LINE DEDENT DEDENT DEDENT def query ( index : int , beg : int , end : int , l : int , r : int ) -> Node : NEW_LINE INDENT result = Node ( ) NEW_LINE result . value = result . max_set_bits = - 1 NEW_LINE if ( beg > r or end < l ) : NEW_LINE INDENT return result NEW_LINE DEDENT if ( beg >= l and end <= r ) : NEW_LINE INDENT return tree [ index ] NEW_LINE DEDENT mid = ( beg + end ) // 2 NEW_LINE if ( l > mid ) : NEW_LINE INDENT return query ( 2 * index + 2 , mid + 1 , end , l , r ) NEW_LINE DEDENT if ( r <= mid ) : NEW_LINE INDENT return query ( 2 * index + 1 , beg , mid , l , r ) NEW_LINE DEDENT left = query ( 2 * index + 1 , beg , mid , l , r ) NEW_LINE right = query ( 2 * index + 2 , mid + 1 , end , l , r ) NEW_LINE if ( left . max_set_bits > right . max_set_bits ) : NEW_LINE INDENT result . max_set_bits = left . max_set_bits NEW_LINE result . value = left . value NEW_LINE DEDENT elif ( right . max_set_bits > left . max_set_bits ) : NEW_LINE INDENT result . max_set_bits = right . max_set_bits NEW_LINE result . value = right . value NEW_LINE DEDENT else : NEW_LINE INDENT result . max_set_bits = left . max_set_bits NEW_LINE result . value = max ( right . value , left . value ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 18 , 9 , 8 , 15 , 14 , 5 ] NEW_LINE N = len ( a ) NEW_LINE buildSegmentTree ( a , 0 , 0 , N - 1 ) NEW_LINE print ( query ( 0 , 0 , N - 1 , 1 , 4 ) . value ) NEW_LINE print ( query ( 0 , 0 , N - 1 , 0 , 2 ) . value ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the element having maximum set bits in the given range for Q queries | Structure to store two values in one node ; Function that returns the count of set bits in a number ; Parity will store the count of set bits ; Function to build the segment tree ; Condition to check if there is only one element in the array ; If there are more than one elements , then recur for left and right subtrees ; Condition to check the maximum set bits is greater in two subtrees ; Condition when maximum set bits are equal in both subtrees ; Function to do the range query in the segment tree ; If segment of this node is outside the given range , then return the minimum value . ; If segment of this node is a part of given range , then return the node of the segment ; If left segment of this node falls out of range , then recur in the right side of the tree ; If right segment of this node falls out of range , then recur in the left side of the tree ; If a part of this segment overlaps with the given range ; Returns the value ; Driver code ; Calculates the length of array ; Build Segment Tree ; Find the max set bits value between 1 st and 4 th index of array ; Find the max set bits value between 0 th and 2 nd index of array",
        "Category": "Segment Tree"
    },
    {
        "ID": "8919-8919",
        "Code": "import random NEW_LINE a , b = None , None ; NEW_LINE def Partition ( arr , l , r ) : NEW_LINE INDENT lst = arr [ r ] ; i = l ; j = l ; NEW_LINE while ( j < r ) : NEW_LINE INDENT if ( arr [ j ] < lst ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT arr [ i ] , arr [ r ] = arr [ r ] , arr [ i ] ; NEW_LINE return i ; NEW_LINE DEDENT def randomPartition ( arr , l , r ) : NEW_LINE INDENT n = r - l + 1 ; NEW_LINE pivot = random . randrange ( 1 , 100 ) % n ; NEW_LINE arr [ l + pivot ] , arr [ r ] = arr [ r ] , arr [ l + pivot ] ; NEW_LINE return Partition ( arr , l , r ) ; NEW_LINE DEDENT def MedianUtil ( arr , l , r , k , a1 , b1 ) : NEW_LINE INDENT global a , b ; NEW_LINE if ( l <= r ) : NEW_LINE INDENT partitionIndex = randomPartition ( arr , l , r ) ; NEW_LINE if ( partitionIndex == k ) : NEW_LINE INDENT b = arr [ partitionIndex ] ; NEW_LINE if ( a1 != - 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT DEDENT elif ( partitionIndex == k - 1 ) : NEW_LINE INDENT a = arr [ partitionIndex ] ; NEW_LINE if ( b1 != - 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT DEDENT if ( partitionIndex >= k ) : NEW_LINE INDENT return MedianUtil ( arr , l , partitionIndex - 1 , k , a , b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return MedianUtil ( arr , partitionIndex + 1 , r , k , a , b ) ; NEW_LINE DEDENT DEDENT return ; NEW_LINE DEDENT def findMedian ( arr , n ) : NEW_LINE INDENT global a ; NEW_LINE global b ; NEW_LINE a = - 1 ; NEW_LINE b = - 1 ; NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT MedianUtil ( arr , 0 , n - 1 , n // 2 , a , b ) ; NEW_LINE ans = b ; NEW_LINE DEDENT else : NEW_LINE INDENT MedianUtil ( arr , 0 , n - 1 , n // 2 , a , b ) ; NEW_LINE ans = ( a + b ) // 2 ; NEW_LINE DEDENT print ( \" Median ▁ = ▁ \" , ans ) ; NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 4 , 19 , 26 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMedian ( arr , n ) ; NEW_LINE",
        "Type": "py",
        "NL": "Median of an unsorted array using Quick Select Algorithm | Python3 program to find median of an array ; Returns the correct position of pivot element ; Picks a random pivot element between l and r and partitions arr [ l . . r ] around the randomly picked element using partition ( ) ; Utility function to find median ; if l < r ; Find the partition index ; If partition index = k , then we found the median of odd number element in arr [ ] ; If index = k - 1 , then we get a & b as middle element of arr [ ] ; If partitionIndex >= k then find the index in first half of the arr [ ] ; If partitionIndex <= k then find the index in second half of the arr [ ] ; Function to find Median ; If n is odd ; If n is even ; Print the Median of arr [ ] ; Driver code",
        "Category": "Quick Select Algorithm"
    },
    {
        "ID": "8923-8923",
        "Code": "def solve ( n ) : NEW_LINE INDENT low = 1 NEW_LINE high = 10 ** 4 NEW_LINE x , p = n , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( x - sum >= 1 ) : NEW_LINE INDENT p = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT start , end , y , q = 1 , 10 ** 4 , 1 , 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE sum = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( y + sum <= n ) : NEW_LINE INDENT q = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT x = x - ( p * ( p + 1 ) ) // 2 NEW_LINE y = y + ( q * ( q + 1 ) ) // 2 NEW_LINE r = x NEW_LINE c = q + 1 - n + y NEW_LINE return r , c NEW_LINE DEDENT n = 5 NEW_LINE r , c = solve ( n ) NEW_LINE print ( r , c ) NEW_LINE",
        "Type": "py",
        "NL": "Find N in the given matrix that follows a pattern | Function to return the row and the column of the given integer ; Binary search for the row number ; Condition to get the maximum x that satisfies the criteria ; Binary search for the column number ; Condition to get the maximum y that satisfies the criteria ; Get the row and the column number ; Return the pair ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "8926-8926",
        "Code": "def mergeSort ( arr , array_size ) : NEW_LINE INDENT temp = [ 0 for i in range ( array_size ) ] NEW_LINE return _mergeSort ( arr , temp , 0 , array_size - 1 ) NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT mid , inv_count = 0 , 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = ( right + left ) // 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] > 2 * arr [ j ] ) : NEW_LINE INDENT inv_count += ( mid - i ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i , k = i + 1 , k + 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k , j = k + 1 , j + 1 NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE i , k = i + 1 , k + 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE j , k = j + 1 , k + 1 NEW_LINE DEDENT for i in range ( left , right + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT arr = [ 1 , 20 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mergeSort ( arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Significant Inversions in an Array | Function that sorts the input array and returns the number of inversions in the array ; Recursive function that sorts the input array and returns the number of inversions in the array ; Divide the array into two parts and call _mergeSortAndCountInv ( ) for each of the parts ; Inversion count will be sum of the inversions in the left - part , the right - part and the number of inversions in merging ; Merge the two parts ; Function that merges the two sorted arrays and returns the inversion count in the arrays ; i is the index for the left subarray ; j is the index for the right subarray ; k is the index for the resultant merged subarray ; First pass to count number of significant inversions ; i is the index for the left subarray ; j is the index for the right subarray ; k is the index for the resultant merged subarray ; Second pass to merge the two sorted arrays ; Copy the remaining elements of the left subarray ( if there are any ) to temp ; Copy the remaining elements of the right subarray ( if there are any ) to temp ; Copy back the merged elements to the original array ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "8929-8929",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data = None , left = None , right = None ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = right NEW_LINE self . left = left NEW_LINE DEDENT DEDENT maxLen = 30 NEW_LINE segtree = [ 0 ] * ( maxLen * 4 ) NEW_LINE def buildTree ( l , r , i , arr ) : NEW_LINE INDENT global segtree NEW_LINE global maxLen NEW_LINE if ( l == r ) : NEW_LINE INDENT segtree [ i ] = l NEW_LINE return l NEW_LINE DEDENT l1 = buildTree ( l , int ( ( l + r ) / 2 ) , 2 * i + 1 , arr ) NEW_LINE r1 = buildTree ( int ( ( l + r ) / 2 ) + 1 , r , 2 * i + 2 , arr ) NEW_LINE if ( arr [ l1 ] > arr [ r1 ] ) : NEW_LINE INDENT segtree [ i ] = l1 NEW_LINE DEDENT else : NEW_LINE INDENT segtree [ i ] = r1 NEW_LINE DEDENT return segtree [ i ] NEW_LINE DEDENT def rangeMax ( l , r , rl , rr , i , arr ) : NEW_LINE INDENT global segtree NEW_LINE global maxLen NEW_LINE if ( r < rl or l > rr ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l >= rl and r <= rr ) : NEW_LINE INDENT return segtree [ i ] NEW_LINE DEDENT l1 = rangeMax ( l , int ( ( l + r ) / 2 ) , rl , rr , 2 * i + 1 , arr ) NEW_LINE r1 = rangeMax ( int ( ( l + r ) / 2 ) + 1 , r , rl , rr , 2 * i + 2 , arr ) NEW_LINE if ( l1 == - 1 ) : NEW_LINE INDENT return r1 NEW_LINE DEDENT if ( r1 == - 1 ) : NEW_LINE INDENT return l1 NEW_LINE DEDENT if ( arr [ l1 ] > arr [ r1 ] ) : NEW_LINE INDENT return l1 NEW_LINE DEDENT else : NEW_LINE INDENT return r1 NEW_LINE DEDENT DEDENT def inorder ( curr ) : NEW_LINE INDENT if ( curr == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( curr . left ) NEW_LINE print ( curr . data , end = \" ▁ \" ) NEW_LINE inorder ( curr . right ) NEW_LINE DEDENT def createCartesianTree ( l , r , arr , n ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return None NEW_LINE DEDENT m = rangeMax ( 0 , n - 1 , l , r , 0 , arr ) NEW_LINE curr = Node ( arr [ m ] ) NEW_LINE curr . left = createCartesianTree ( l , m - 1 , arr , n ) NEW_LINE curr . right = createCartesianTree ( m + 1 , r , arr , n ) NEW_LINE return curr NEW_LINE DEDENT arr = [ 8 , 11 , 21 , 100 , 5 , 70 , 55 ] NEW_LINE n = len ( arr ) NEW_LINE buildTree ( 0 , n - 1 , 0 , arr ) NEW_LINE inorder ( createCartesianTree ( 0 , n - 1 , arr , n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Cartesian tree from inorder traversal | Segment Tree | Node of a linked list ; Array to store segment tree ; Function to create segment - tree to answer range - max query ; Base case ; Maximum index in left range ; Maximum index in right range ; If value at l1 > r1 ; Else ; Returning the maximum in range ; Function to answer range max query ; Base cases ; Maximum in left range ; Maximum in right range ; l1 = - 1 means left range was out - side required range ; Returning the maximum among two ranges ; Function to print the inorder traversal of the binary tree ; Base case ; Traversing the left sub - tree ; Printing current node ; Traversing the right sub - tree ; Function to build cartesian tree ; Base case ; Maximum in the range ; Creating current node ; Creating left sub - tree ; Creating right sub - tree ; Returning current node ; In - order traversal of cartesian tree ; Size of the array ; Building the segment tree ; Building && printing cartesian tree",
        "Category": "Segment Tree"
    },
    {
        "ID": "8932-8932",
        "Code": "N = 100005 NEW_LINE lazy = [ 0 ] * ( 4 * N ) ; NEW_LINE se = set ( ) NEW_LINE def update ( x , y , value , id , l , r ) : NEW_LINE INDENT if ( x >= r or l >= y ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( x <= l and r <= y ) : NEW_LINE INDENT lazy [ id ] = value ; NEW_LINE return ; NEW_LINE DEDENT mid = ( l + r ) // 2 ; NEW_LINE if ( lazy [ id ] ) : NEW_LINE INDENT lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ; NEW_LINE DEDENT lazy [ id ] = 0 ; NEW_LINE update ( x , y , value , 2 * id , l , mid ) ; NEW_LINE update ( x , y , value , 2 * id + 1 , mid , r ) ; NEW_LINE DEDENT def query ( id , l , r ) : NEW_LINE INDENT if ( lazy [ id ] ) : NEW_LINE INDENT se . add ( lazy [ id ] ) ; NEW_LINE return ; NEW_LINE DEDENT if ( r - l < 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT mid = ( l + r ) // 2 ; NEW_LINE query ( 2 * id , l , mid ) ; NEW_LINE query ( 2 * id + 1 , mid , r ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; q = 3 ; NEW_LINE update ( 1 , 4 , 1 , 1 , 0 , n ) ; NEW_LINE update ( 0 , 2 , 2 , 1 , 0 , n ) ; NEW_LINE update ( 3 , 4 , 3 , 1 , 0 , n ) ; NEW_LINE query ( 1 , 0 , n ) ; NEW_LINE print ( len ( se ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the number of different numbers in the array after applying the given operation q times | Python3 implementation for above approach ; To store the tree in lazy propagation ; To store the different numbers ; Function to update in the range [ x , y ) with given value ; check out of bound ; check for complete overlap ; find the mid number ; check for pending updates ; make lazy [ id ] = 0 , so that it has no pending updates ; call for two child nodes ; Function to find non - zero integersin the range [ l , r ) ; if id contains positive number ; There is no need to see the children , because all the interval have same number ; check for out of bound ; find the middle number ; call for two child nodes ; Driver code ; size of the array and number of queries ; Update operation for l , r , x , id , 0 , n ; Query operation to get answer in the range [ 0 , n - 1 ] ; Print the count of non - zero elements",
        "Category": "Segment Tree with Lazy Propagation"
    },
    {
        "ID": "8934-8934",
        "Code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT lower_bound = 2 ; NEW_LINE upper_bound = 10 ; NEW_LINE for i in range ( lower_bound , upper_bound + 1 ) : NEW_LINE INDENT print ( i ) NEW_LINE response = int ( input ( ) ) NEW_LINE if ( response == 0 ) : NEW_LINE INDENT print ( \" Number ▁ guessed ▁ is ▁ : \" , i , end = ' ' ) NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Interactive Problems in Competitive Programming |  ; Iterating from lower_bound to upper_bound ; Input the response from the judge",
        "Category": "Iterating from lower_bound to upper_bound"
    },
    {
        "ID": "8936-8936",
        "Code": "MAX = 1000 NEW_LINE tree = [ 0 ] * MAX ; NEW_LINE lazy = [ 0 ] * MAX ; NEW_LINE def updateRangeUtil ( si , ss , se , us , ue , diff ) : NEW_LINE INDENT if ( lazy [ si ] != 0 ) : NEW_LINE INDENT tree [ si ] += lazy [ si ] ; NEW_LINE if ( ss != se ) : NEW_LINE INDENT lazy [ si * 2 + 1 ] += lazy [ si ] ; NEW_LINE lazy [ si * 2 + 2 ] += lazy [ si ] ; NEW_LINE DEDENT lazy [ si ] = 0 ; NEW_LINE DEDENT if ( ss > se or ss > ue or se < us ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( ss >= us and se <= ue ) : NEW_LINE INDENT tree [ si ] += diff ; NEW_LINE if ( ss != se ) : NEW_LINE INDENT lazy [ si * 2 + 1 ] += diff ; NEW_LINE lazy [ si * 2 + 2 ] += diff ; NEW_LINE DEDENT return ; NEW_LINE DEDENT mid = ( ss + se ) // 2 ; NEW_LINE updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) ; NEW_LINE updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) ; NEW_LINE tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; NEW_LINE DEDENT def updateRange ( n , us , ue , diff ) : NEW_LINE INDENT updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) ; NEW_LINE DEDENT def getSumUtil ( ss , se , qs , qe , si ) : NEW_LINE INDENT if ( lazy [ si ] != 0 ) : NEW_LINE INDENT tree [ si ] += lazy [ si ] ; NEW_LINE if ( ss != se ) : NEW_LINE INDENT lazy [ si * 2 + 1 ] += lazy [ si ] ; NEW_LINE lazy [ si * 2 + 2 ] += lazy [ si ] ; NEW_LINE DEDENT lazy [ si ] = 0 ; NEW_LINE DEDENT if ( ss > se or ss > qe or se < qs ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( ss >= qs and se <= qe ) : NEW_LINE INDENT return tree [ si ] ; NEW_LINE DEDENT mid = ( ss + se ) // 2 ; NEW_LINE return max ( getSumUtil ( ss , mid , qs , qe , 2 * si + 1 ) , getSumUtil ( mid + 1 , se , qs , qe , 2 * si + 2 ) ) ; NEW_LINE DEDENT def getSum ( n , qs , qe ) : NEW_LINE INDENT if ( qs < 0 or qe > n - 1 or qs > qe ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" , end = \" \" ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT return getSumUtil ( 0 , n - 1 , qs , qe , 0 ) ; NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , si ) : NEW_LINE INDENT if ( ss > se ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( ss == se ) : NEW_LINE INDENT tree [ si ] = arr [ ss ] ; NEW_LINE return ; NEW_LINE DEDENT mid = ( ss + se ) // 2 ; NEW_LINE constructSTUtil ( arr , ss , mid , si * 2 + 1 ) ; NEW_LINE constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) ; NEW_LINE tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT constructSTUtil ( arr , 0 , n - 1 , 0 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE constructST ( arr , n ) ; NEW_LINE updateRange ( n , 0 , 3 , 4 ) ; NEW_LINE print ( getSum ( n , 1 , 4 ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Lazy Propagation in Segment Tree | Set 2 | Python3 implementation of the approach ; To store segment tree ; To store pending updates ; si -> index of current node in segment tree ss and se -> Starting and ending indexes of elements for which current nodes stores sum us and ue -> starting and ending indexes of update query diff -> which we need to add in the range us to ue ; If lazy value is non - zero for current node of segment tree , then there are some pending updates . So we need to make sure that the pending updates are done before making new updates . Because this value may be used by parent after recursive calls ( See last line of this function ) ; Make pending updates using value stored in lazy nodes ; Checking if it is not leaf node because if it is leaf node then we cannot go further ; We can postpone updating children we don 't need their new values now.  Since we are not yet updating children of si,  we need to set lazy flags for the children ; Set the lazy value for current node as 0 as it has been updated ; Out of range ; Current segment is fully in range ; Add the difference to current node ; Same logic for checking leaf node or not ; This is where we store values in lazy nodes , rather than updating the segment tree itelf Since we don 't need these updated values now  we postpone updates by storing values in lazy[] ; If not completely in range , but overlaps recur for children ; And use the result of children calls to update this node ; Function to update a range of values in segment tree us and eu -> starting and ending indexes of update query ue -> ending index of update query diff -> which we need to add in the range us to ue ; A recursive function to get the sum of values in a given range of the array . The following are the parameters for this function si -- > Index of the current node in the segment tree Initially , 0 is passed as root is always at index 0 ss & se -- > Starting and ending indexes of the segment represented by current node i . e . , tree [ si ] qs & qe -- > Starting and ending indexes of query range ; If lazy flag is set for current node of segment tree then there are some pending updates . So we need to make sure that the pending updates are done before processing the sub sum query ; Make pending updates to this node . Note that this node represents sum of elements in arr [ ss . . se ] and all these elements must be increased by lazy [ si ] ; Checking if it is not leaf node because if it is leaf node then we cannot go further ; Since we are not yet updating children os si , we need to set lazy values for the children ; Unset the lazy value for current node as it has been updated ; Out of range ; If this segment lies in range ; If a part of this segment overlaps with the given range ; Return sum of elements in range from index qs ( querystart ) to qe ( query end ) . It mainly uses getSumUtil ( ) ; Check for erroneous input values ; A recursive function that constructs Segment Tree for array [ ss . . se ] . si is index of current node in segment tree st . ; out of range as ss can never be greater than se ; If there is one element in array , store it in current node of segment tree and return ; If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node ; Function to construct a segment tree from a given array . This function allocates memory for segment tree and calls constructSTUtil ( ) to fill the allocated memory ; Fill the allocated memory st ; Driver code ; Build segment tree from given array ; Add 4 to all nodes in index range [ 0 , 3 ] ; Print maximum element in index range [ 1 , 4 ]",
        "Category": "Segment Tree with Lazy Propagation is a technique used in conjunction with segment trees to efficiently handle range queries and updates. Although the term \"Segment Tree\" is not in the provided category list, the closest and most representative category that encompasses this technique is:"
    },
    {
        "ID": "8938-8938",
        "Code": "def F ( A , B ) : NEW_LINE INDENT if ( A == 1 ) : NEW_LINE INDENT return ( 4 % B ) ; NEW_LINE DEDENT else : NEW_LINE INDENT temp = F ( A - 1 , B ) ; NEW_LINE return ( temp * temp ) % B ; NEW_LINE DEDENT DEDENT A = 25 ; NEW_LINE B = 50 ; NEW_LINE print ( F ( A , B ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find 2 ^ ( 2 ^ A ) % B | Function to return 2 ^ ( 2 ^ A ) % B ; Base case , 2 ^ ( 2 ^ 1 ) % B = 4 % B ; Driver code ; Print 2 ^ ( 2 ^ A ) % B",
        "Category": "Math"
    },
    {
        "ID": "8942-8942",
        "Code": "INF = 99999 NEW_LINE size = 10 NEW_LINE def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two , ans = 2 , 0 NEW_LINE n = N NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( N // two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def findMinimum ( x ) : NEW_LINE INDENT low = 0 NEW_LINE high = 100000 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( getSetBitsFromOneToN ( mid ) >= x ) : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = 20 NEW_LINE print ( findMinimum ( x ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number N such that total set bits of all numbers from 1 to N is at | Python3 implementation of the above approach ; Function to count sum of set bits of all numbers till N ; Function to find the minimum number ; Binary search for the lowest number ; Find mid number ; Check if it is atleast x ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "8945-8945",
        "Code": "MOD = 1000000009 ; NEW_LINE def power ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT n -= 1 ; NEW_LINE res = [ [ 1 , 0 ] , [ 0 , 1 ] ] ; NEW_LINE tMat = [ [ 2 , 3 ] , [ 1 , 0 ] ] ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT tmp = [ [ 0 for x in range ( 2 ) ] for y in range ( 2 ) ] ; NEW_LINE tmp [ 0 ] [ 0 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 0 ] [ 1 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 0 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 1 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE res [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; NEW_LINE res [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; NEW_LINE res [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; NEW_LINE res [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; NEW_LINE DEDENT n = n // 2 ; NEW_LINE tmp = [ [ 0 for x in range ( 2 ) ] for y in range ( 2 ) ] ; NEW_LINE tmp [ 0 ] [ 0 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 0 ] [ 1 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 0 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 1 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE tMat [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; NEW_LINE tMat [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; NEW_LINE tMat [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; NEW_LINE tMat [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; NEW_LINE DEDENT return ( res [ 0 ] [ 0 ] * 1 + res [ 0 ] [ 1 ] * 1 ) % MOD ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( power ( n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find Nth term ( A matrix exponentiation example ) | Python3 program to find n - th term of a recursive function using matrix exponentiation . ; This power function returns first row of { Transformation Matrix } ^ n - 1 * Initial Vector ; This is an identity matrix . ; this is Transformation matrix . ; Matrix exponentiation to calculate power of { tMat } ^ n - 1 store res in \" res \" matrix . ; res store { Transformation matrix } ^ n - 1 hence will be first row of res * Initial Vector . ; Driver code",
        "Category": "Matrix"
    },
    {
        "ID": "8949-8949",
        "Code": "def trailingZeroes ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = int ( n / 5 ) NEW_LINE cnt += n NEW_LINE DEDENT return cnt NEW_LINE DEDENT def binarySearch ( n ) : NEW_LINE INDENT low = 0 NEW_LINE while low < high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE count = trailingZeroes ( mid ) NEW_LINE if count < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT result = list ( ) NEW_LINE while trailingZeroes ( low ) == n : NEW_LINE INDENT result . append ( low ) NEW_LINE low += 1 NEW_LINE DEDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE binarySearch ( n ) NEW_LINE",
        "Type": "py",
        "NL": "Numbers whose factorials end with n zeros | Function to calculate trailing zeros ; binary search for first number with n trailing zeros ; Print all numbers after low with n trailing zeros . ; Print result ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "8950-8950",
        "Code": "def getCumulateSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) ) / 2 ) NEW_LINE DEDENT def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( C <= l ) : return C NEW_LINE lo , hi = 0 , 1e4 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( getCumulateSum ( mid ) >= ( C - l ) ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT return ( l + lo ) NEW_LINE DEDENT C , l = 5 , 2 NEW_LINE print ( minDaysToEmpty ( C , l ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of days after which tank will become empty | Utility method to get sum of first n numbers ; Method returns minimum number of days after which tank will become empty ; if water filling is more than capacity then after C days only tank will become empty ; initialize binary search variable ; loop until low is less than high ; if cumulate sum is greater than ( C - l ) then search on left side ; if ( C - l ) is more then search on right side ; Final answer will be obtained by adding l to binary search result ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "8951-8951",
        "Code": "import math NEW_LINE def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : return C NEW_LINE eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT print ( minDaysToEmpty ( 5 , 2 ) ) NEW_LINE print ( minDaysToEmpty ( 6514683 , 4965 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of days after which tank will become empty | Python3 code to find number of days after which tank will become empty ; Method returns minimum number of days after which tank will become empty ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "8957-8957",
        "Code": "def kth ( arr1 , arr2 , m , n , k , st1 = 0 , st2 = 0 ) : NEW_LINE INDENT if ( st1 == m ) : NEW_LINE INDENT return arr2 [ st2 + k - 1 ] NEW_LINE DEDENT if ( st2 == n ) : NEW_LINE INDENT return arr1 [ st1 + k - 1 ] NEW_LINE DEDENT if ( k == 0 or k > ( m - st1 ) + ( n - st2 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT if ( arr1 [ st1 ] < arr2 [ st2 ] ) : NEW_LINE INDENT return arr1 [ st1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return arr2 [ st2 ] NEW_LINE DEDENT DEDENT curr = int ( k / 2 ) NEW_LINE if ( curr - 1 >= m - st1 ) : NEW_LINE INDENT if ( arr1 [ m - 1 ] < arr2 [ st2 + curr - 1 ] ) : NEW_LINE INDENT return arr2 [ st2 + ( k - ( m - st1 ) - 1 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT return kth ( arr1 , arr2 , m , n , k - curr , st1 , st2 + curr ) NEW_LINE DEDENT DEDENT if ( curr - 1 >= n - st2 ) : NEW_LINE INDENT if ( arr2 [ n - 1 ] < arr1 [ st1 + curr - 1 ] ) : NEW_LINE INDENT return arr1 [ st1 + ( k - ( n - st2 ) - 1 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT return kth ( arr1 , arr2 , m , n , k - curr , st1 + curr , st2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr1 [ curr + st1 - 1 ] < arr2 [ curr + st2 - 1 ] ) : NEW_LINE INDENT return kth ( arr1 , arr2 , m , n , k - curr , st1 + curr , st2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return kth ( arr1 , arr2 , m , n , k - curr , st1 , st2 + curr ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 2 , 3 , 6 , 7 , 9 ] NEW_LINE arr2 = [ 1 , 4 , 8 , 10 ] NEW_LINE k = 5 NEW_LINE print ( kth ( arr1 , arr2 , 5 , 4 , k ) ) NEW_LINE",
        "Type": "py",
        "NL": "K | Python3 program to find kth element from two sorted arrays ; In case we have reached end of array 1 ; In case we have reached end of array 2 ; k should never reach 0 or exceed sizes of arrays ; Compare first elements of arrays and return ; Size of array 1 is less than k / 2 ; Last element of array 1 is not kth We can directly return the ( k - m ) th element in array 2 ; Size of array 2 is less than k / 2 ; Normal comparison , move starting index of one array k / 2 to the right ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "8962-8962",
        "Code": "MAX = 100 NEW_LINE def binarySearch ( mat , i , j_low , j_high , x ) : NEW_LINE INDENT while ( j_low <= j_high ) : NEW_LINE INDENT j_mid = ( j_low + j_high ) // 2 NEW_LINE if ( mat [ i ] [ j_mid ] == x ) : NEW_LINE INDENT print ( \" Found ▁ at ▁ ( \" , i , \" , ▁ \" , j_mid , \" ) \" ) NEW_LINE return NEW_LINE DEDENT elif ( mat [ i ] [ j_mid ] > x ) : NEW_LINE INDENT j_high = j_mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT j_low = j_mid + 1 NEW_LINE DEDENT DEDENT print ( \" Element ▁ no ▁ found \" ) NEW_LINE DEDENT def sortedMatrixSearch ( mat , n , m , x ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT binarySearch ( mat , 0 , 0 , m - 1 , x ) NEW_LINE return NEW_LINE DEDENT i_low = 0 NEW_LINE i_high = n - 1 NEW_LINE j_mid = m // 2 NEW_LINE while ( ( i_low + 1 ) < i_high ) : NEW_LINE INDENT i_mid = ( i_low + i_high ) // 2 NEW_LINE if ( mat [ i_mid ] [ j_mid ] == x ) : NEW_LINE INDENT print ( \" Found ▁ at ▁ ( \" , i_mid , \" , ▁ \" , j_mid , \" ) \" ) NEW_LINE return NEW_LINE DEDENT elif ( mat [ i_mid ] [ j_mid ] > x ) : NEW_LINE INDENT i_high = i_mid NEW_LINE DEDENT else : NEW_LINE INDENT i_low = i_mid NEW_LINE DEDENT DEDENT if ( mat [ i_low ] [ j_mid ] == x ) : NEW_LINE INDENT print ( \" Found ▁ at ▁ ( \" , i_low , \" , \" , j_mid , \" ) \" ) NEW_LINE DEDENT elif ( mat [ i_low + 1 ] [ j_mid ] == x ) : NEW_LINE INDENT print ( \" Found ▁ at ▁ ( \" , ( i_low + 1 ) , \" , ▁ \" , j_mid , \" ) \" ) NEW_LINE DEDENT elif ( x <= mat [ i_low ] [ j_mid - 1 ] ) : NEW_LINE INDENT binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) NEW_LINE DEDENT elif ( x >= mat [ i_low ] [ j_mid + 1 ] and x <= mat [ i_low ] [ m - 1 ] ) : NEW_LINE binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) NEW_LINE elif ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) : NEW_LINE INDENT binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 8 NEW_LINE mat = [ [ 0 , 6 , 8 , 9 , 11 ] , [ 20 , 22 , 28 , 29 , 31 ] , [ 36 , 38 , 50 , 61 , 63 ] , [ 64 , 66 , 100 , 122 , 128 ] ] NEW_LINE sortedMatrixSearch ( mat , n , m , x ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Search element in a sorted matrix | Python3 implementation to search an element in a sorted matrix ; This function does Binary search for x in i - th row . It does the search from mat [ i ] [ j_low ] to mat [ i ] [ j_high ] ; Element found ; Element not found ; Function to perform binary search on the mid values of row to get the desired pair of rows where the element can be found ; Single row matrix ; Do binary search in middle column . Condition to terminate the loop when the 2 desired rows are found ; element found ; If element is present on the mid of the two rows ; search element on 1 st half of 1 st row ; Search element on 2 nd half of 1 st row ; Search element on 1 st half of 2 nd row ; Search element on 2 nd half of 2 nd row ; Driver program to test above",
        "Category": "Binary Search"
    },
    {
        "ID": "8965-8965",
        "Code": "def bsearch ( low , high , n , arr ) : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE if ( low <= high ) : NEW_LINE INDENT if ( arr [ mid ] < n ) : NEW_LINE INDENT return bsearch ( mid + 1 , high , n , arr ) ; NEW_LINE DEDENT return bsearch ( low , mid - 1 , n , arr ) ; NEW_LINE DEDENT return low ; NEW_LINE DEDENT def mindiff ( arr , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE DEDENT ans = 2147483647 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) NEW_LINE ans = min ( ans , abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) NEW_LINE if ( p - 1 >= 0 ) : NEW_LINE INDENT ans = min ( ans , abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT m = [ 8 , 5 ] , [ 6 , 8 ] NEW_LINE print mindiff ( m , 2 , 2 ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum difference between adjacent elements of array which contain elements from each row of a matrix | Return smallest element greater than or equal to the current element . ; Return the minimum absolute difference adjacent elements of array ; arr = [ 0 for i in range ( R ) ] [ for j in range ( C ) ] Sort each row of the matrix . ; For each matrix element ; Search smallest element in the next row which is greater than or equal to the current element ; largest element which is smaller than the current element in the next row must be just before smallest element which is greater than or equal to the current element because rows are sorted . ; Driver Program",
        "Category": "Binary Search"
    },
    {
        "ID": "8968-8968",
        "Code": "def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE print ( \" Cubic ▁ root ▁ of \" , n , \" is \" , round ( cubicRoot ( n ) , 6 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find cubic root of a number | Returns the absolute value of n - mid * mid * mid ; Returns cube root of a no n ; Set start and end for binary search ; Set precision ; If error is less than e then mid is our answer so return mid ; If mid * mid * mid is greater than n set end = mid ; If mid * mid * mid is less than n set start = mid ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "8969-8969",
        "Code": "def findFrequencies ( ele , n ) : NEW_LINE INDENT freq = 1 NEW_LINE idx = 1 NEW_LINE element = ele [ 0 ] NEW_LINE while ( idx < n ) : NEW_LINE INDENT if ( ele [ idx - 1 ] == ele [ idx ] ) : NEW_LINE INDENT freq += 1 NEW_LINE idx += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( element , \" ▁ \" , freq ) ; NEW_LINE element = ele [ idx ] NEW_LINE idx += 1 NEW_LINE freq = 1 NEW_LINE DEDENT DEDENT print ( element , \" ▁ \" , freq ) ; NEW_LINE DEDENT / * Driver code * / NEW_LINE print ( \" - - - frequencies ▁ in ▁ a ▁ sorted ▁ array - - - - \" ) ; NEW_LINE arr = [ 10 , 20 , 30 , 30 , 30 , 40 , 50 , 50 , 50 , 50 , 70 ] ; NEW_LINE n = len ( arr ) NEW_LINE findFrequencies ( arr , n ) NEW_LINE",
        "Type": "py",
        "NL": "Find frequency of each element in a limited range array in less than O ( n ) time | python program to count number of occurrences of each element in the array in O ( n ) time and O ( 1 ) space ; check if the current element is equal to previous element . ; reset the frequency ; print the last element and its frequency ;",
        "Category": "Array"
    },
    {
        "ID": "8971-8971",
        "Code": "def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurs \" , freq [ i ] , \" times \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find frequency of each element in a limited range array in less than O ( n ) time | A recursive function to count number of occurrences for each element in the array without traversing the whole array ; If element at index low is equal to element at index high in the array ; increment the frequency of the element by count of elements between high and low ; Find mid and recurse for left and right subarray ; A wrapper over recursive function findFrequencyUtil ( ) . It print number of occurrences of each element in the array . ; create a empty vector to store frequencies and initialize it by 0. Size of vector is maximum value ( which is last value in sorted array ) plus 1. ; Fill the vector with frequency ; Print the frequencies ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "8972-8972",
        "Code": "def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT DEDENT DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE INDENT return res NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modular Exponentiation ( Power in Modular Arithmetic ) | Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Change x to x ^ 2",
        "Category": "Math"
    },
    {
        "ID": "8986-8986",
        "Code": "import math NEW_LINE def isPossibleToReach ( A , N , X , Y ) : NEW_LINE INDENT distance = math . sqrt ( X * X + Y * Y ) NEW_LINE mx = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mx += A [ i ] NEW_LINE DEDENT if ( mx < distance ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return 0 NEW_LINE DEDENT if ( ( mx - distance ) < 0.000001 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( distance + mx < ( 2 ) * ( A [ i ] ) ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( \" Yes \" ) NEW_LINE return 0 NEW_LINE DEDENT A = [ 2 , 5 ] NEW_LINE X = 5 NEW_LINE Y = 4 NEW_LINE N = len ( A ) NEW_LINE isPossibleToReach ( A , N , X , Y ) NEW_LINE",
        "Type": "py",
        "NL": "Check if it is possible to reach the point ( X , Y ) using distances given in an array | Python program for the above approach ; Function to check if the po ( X , Y ) is reachable from ( 0 , 0 ) or not ; Find the Euclidian Distance ; Calculate the maximum distance ; Case 1. ; Case 2. ; Otherwise , check for the polygon condition for each side ; Otherwise , prYes ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "8989-8989",
        "Code": "from math import pow NEW_LINE def findArea ( a , b , c ) : NEW_LINE INDENT area = ( 4 * 3.141592653 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ) NEW_LINE print ( \" { : . 2f } \" . format ( round ( area , 2 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 11 NEW_LINE B = 12 NEW_LINE C = 13 NEW_LINE findArea ( A , B , C ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate Surface Area of Ellipsoid | Python3 program for the above approach ; Function to find the surface area of the given Ellipsoid ; Formula to find surface area of an Ellipsoid ; Print the area ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "899-899",
        "Code": "R = 3 NEW_LINE C = 5 NEW_LINE def numofneighbour ( mat , i , j ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( i > 0 and mat [ i - 1 ] [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( j > 0 and mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( i < R - 1 and mat [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( j < C - 1 and mat [ i ] [ j + 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def findperimeter ( mat ) : NEW_LINE INDENT perimeter = 0 ; NEW_LINE for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; NEW_LINE DEDENT DEDENT DEDENT return perimeter ; NEW_LINE DEDENT mat = [ [ 0 , 1 , 0 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 , 0 ] ] NEW_LINE print ( findperimeter ( mat ) , end = \" \" ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find perimeter of shapes formed with 1 s in binary matrix | Python3 program to find perimeter of area covered by 1 in 2D matrix consisits of 0 ' s ▁ and ▁ 1' s . ; Find the number of covered side for mat [ i ] [ j ] . ; UP ; LEFT ; DOWN ; RIGHT ; Returns sum of perimeter of shapes formed with 1 s ; Traversing the matrix and finding ones to calculate their contribution . ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "8991-8991",
        "Code": "from math import sqrt NEW_LINE def findRadius ( r1 , r2 , r3 ) : NEW_LINE INDENT r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) NEW_LINE return r4 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r1 = 1 NEW_LINE r2 = 1 NEW_LINE r3 = 1 NEW_LINE r4 = findRadius ( r1 , r2 , r3 ) NEW_LINE print ( \" The ▁ radius ▁ of ▁ fourth ▁ circle : \" , r4 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Descartes ' Circle Theorem with implementation | Python 3 implementation of the above formulae ; Function to find the fourth circle 's when three radius are given ; Driver code ; Radius of three circles ; Calculation of r4 using formula given above",
        "Category": "Math"
    },
    {
        "ID": "8994-8994",
        "Code": "import math NEW_LINE def findSides ( A , C , c ) : NEW_LINE INDENT B = 180 - ( A + C ) NEW_LINE A = A * ( 3.14159 / 180 ) NEW_LINE C = C * ( 3.14159 / 180 ) NEW_LINE B = B * ( 3.14159 / 180 ) NEW_LINE a = ( c / math . sin ( C ) ) * math . sin ( A ) NEW_LINE b = ( c / math . sin ( C ) ) * math . sin ( B ) NEW_LINE print ( \" { 0 : . 2f } \" . format ( a ) ) NEW_LINE print ( \" { 0 : . 2f } \" . format ( b ) ) NEW_LINE DEDENT A = 45.0 NEW_LINE C = 35.0 NEW_LINE c = 23 NEW_LINE findSides ( A , C , c ) NEW_LINE",
        "Type": "py",
        "NL": "Sine Rule with Derivation , Example and Implementation | Python3 program for the above approach ; Function to calculate remaining two sides ; Calculate angle B ; Convert angles to their respective radians for using trigonometric functions ; Sine rule ; Print the answer ; Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9000-9000",
        "Code": "def check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT value_1 = a * x1 + b * y1 + c * z1 + d NEW_LINE value_2 = a * x2 + b * y2 + c * z2 + d NEW_LINE if ( ( value_1 > 0 and value_2 > 0 ) or ( value_1 < 0 and value_2 < 0 ) ) : NEW_LINE INDENT print ( \" On ▁ same ▁ side \" ) NEW_LINE DEDENT if ( ( value_1 > 0 and value_2 < 0 ) or ( value_1 < 0 and value_2 > 0 ) ) : NEW_LINE INDENT print ( \" On ▁ different ▁ sides \" ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 == 0 ) : NEW_LINE INDENT print ( \" Both ▁ on ▁ the ▁ plane \" ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 != 0 ) : NEW_LINE INDENT print ( \" Point ▁ 1 ▁ on ▁ the ▁ plane \" ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 == 0 ) : NEW_LINE INDENT print ( \" Point ▁ 2 ▁ on ▁ the ▁ plane \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE x1 , y1 , z1 = - 2 , - 2 , 1 NEW_LINE x2 , y2 , z2 = - 4 , 11 , - 1 NEW_LINE check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Determine position of two points with respect to a 3D plane | Function to check position of two points with respect to a plane in 3D ; Put coordinates in plane equation ; If both values have same sign ; If both values have different sign ; If both values are zero ; If either of the two values is zero ; Driver Code ; Given Input ; Coordinates of points ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9001-9001",
        "Code": "import math NEW_LINE def line_slope ( a , b ) : NEW_LINE INDENT if ( a != 0 ) : NEW_LINE INDENT return - b / a NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 ) NEW_LINE DEDENT DEDENT def line_equation ( a , b , c , x1 , y1 , alfa ) : NEW_LINE INDENT given_slope = line_slope ( a , b ) NEW_LINE x = alfa * 3.14159 / 180 NEW_LINE if ( given_slope == - 2 ) : NEW_LINE INDENT slope_1 = math . tan ( x ) NEW_LINE slope_2 = math . tan ( 3.14159 - x ) NEW_LINE g = x1 , f = x1 NEW_LINE g *= ( - slope_1 ) NEW_LINE g += y1 NEW_LINE if ( g > 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_1 , 2 ) , \" x ▁ + \" , round ( g ) ) ; NEW_LINE DEDENT if ( g <= 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_1 , 2 ) , \" x ▁ \" , round ( g ) ) NEW_LINE DEDENT f *= ( - slope_2 ) NEW_LINE f += y1 NEW_LINE if ( f > 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_2 , 2 ) , \" x ▁ + \" , round ( f ) ) NEW_LINE DEDENT if ( f <= 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_2 , 2 ) , \" x ▁ \" , round ( f ) ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( 1 - math . tan ( x ) * given_slope == 0 ) : NEW_LINE INDENT print ( \" x ▁ = \" , x1 ) NEW_LINE DEDENT if ( 1 + math . tan ( x ) * given_slope == 0 ) : NEW_LINE INDENT print ( \" x ▁ = \" , x1 ) NEW_LINE DEDENT slope_1 = ( ( given_slope + math . tan ( x ) ) / ( 1 - math . tan ( x ) * given_slope ) ) NEW_LINE slope_2 = ( ( given_slope - math . tan ( x ) ) / ( 1 + math . tan ( x ) * given_slope ) ) NEW_LINE g = x1 NEW_LINE f = x1 NEW_LINE g *= ( - slope_1 ) NEW_LINE g += y1 NEW_LINE if ( g > 0 and 1 - math . tan ( x ) * given_slope != 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_1 , 2 ) , \" x ▁ + \" , round ( g ) ) NEW_LINE DEDENT if ( g <= 0 and 1 - math . tan ( x ) * given_slope != 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_1 , 2 ) , \" x ▁ \" , round ( g ) ) NEW_LINE DEDENT f *= ( - slope_2 ) NEW_LINE f += y1 NEW_LINE if ( f > 0 and 1 + math . tan ( x ) * given_slope != 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_2 , 2 ) , \" x ▁ + \" , round ( f ) ) NEW_LINE DEDENT if ( f <= 0 and 1 + math . tan ( x ) * given_slope != 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , round ( slope_2 , 2 ) , \" x ▁ \" , round ( f ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 7 NEW_LINE x1 = 4 NEW_LINE y1 = 9 NEW_LINE alfa = 30 NEW_LINE line_equation ( a , b , c , x1 , y1 , alfa ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Equation of a straight line passing through a point and making a given angle with a given line | Python3 program for the above approach ; Function to find slope of given line ; Special case when slope of line is infinity or is perpendicular to x - axis ; Function to find equations of lines passing through the given point and making an angle with given line ; Store slope of given line ; Convert degrees to radians ; Special case when slope of given line is infinity : In this case slope of one line will be equal to alfa and the other line will be equal to ( 180 - alfa ) ; In this case slope of required lines can 't be  infinity ; g and f are the variables of required equations ; Print first line equation ; Print second line equation ; Special case when slope of required line becomes infinity ; General case ; g and f are the variables of required equations ; Print first line equation ; Print second line equation ; Driver Code ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9002-9002",
        "Code": "import math NEW_LINE def findLine ( distance , degree ) : NEW_LINE INDENT x = degree * 3.14159 / 180 NEW_LINE if ( degree > 90 ) : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE return NEW_LINE DEDENT result_1 = math . sin ( x ) NEW_LINE result_2 = math . cos ( x ) NEW_LINE print ( ' % .2f ' % result_2 , \" x ▁ + \" , ' % .2f ' % result_1 , \" y ▁ = ▁ \" , distance , sep = \" \" ) NEW_LINE DEDENT D = 10 NEW_LINE A = 30 NEW_LINE findLine ( D , A ) NEW_LINE",
        "Type": "py",
        "NL": "Equation of a straight line with perpendicular distance D from origin and an angle A between the perpendicular from origin and x | Python3 program for the approach ; Function to find equation of a line whose distance from origin and angle made by the perpendicular from origin with x - axis is given ; Convert angle from degree to radian ; Handle the special case ; Calculate the sin and cos of angle ; Print the equation of the line ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9003-9003",
        "Code": "def normal_slope ( a , b , x1 , y1 ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE if ( g - x1 == 0 ) : NEW_LINE INDENT return ( - 1 ) NEW_LINE DEDENT slope = ( f - y1 ) / ( g - x1 ) NEW_LINE if ( slope == 0 ) : NEW_LINE INDENT return ( - 2 ) NEW_LINE DEDENT return slope NEW_LINE DEDENT def normal_equation ( a , b , x1 , y1 ) : NEW_LINE INDENT slope = normal_slope ( a , b , x1 , y1 ) NEW_LINE if ( slope == - 1 ) : NEW_LINE INDENT print ( \" x ▁ = ▁ \" , x1 ) NEW_LINE DEDENT if ( slope == - 2 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , y1 ) NEW_LINE DEDENT if ( slope != - 1 and slope != - 2 ) : NEW_LINE INDENT x1 *= - slope NEW_LINE x1 += y1 NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , slope , \" x ▁ + ▁ \" , x1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" y ▁ = ▁ \" , slope , \" x ▁ \" , x1 ) NEW_LINE DEDENT DEDENT DEDENT a = 4 NEW_LINE b = 6 NEW_LINE c = 5 NEW_LINE x1 = 12 NEW_LINE y1 = 14 NEW_LINE normal_equation ( a , b , x1 , y1 ) NEW_LINE",
        "Type": "py",
        "NL": "Equation of a normal to a Circle from a given point | Function to calculate the slope ; Store the coordinates the center of the circle ; If slope becomes infinity ; Stores the slope ; If slope is zero ; Return the result ; Function to find the equation of the normal to a circle from a given point ; Stores the slope of the normal ; If slope becomes infinity ; If slope is zero ; Otherwise , print the equation of the normal ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9006-9006",
        "Code": "import math NEW_LINE def AreaFactor ( n ) : NEW_LINE INDENT pi = 3.14159265 NEW_LINE areaf = 1 / ( math . cos ( pi / n ) * math . cos ( pi / n ) ) NEW_LINE print ( ' % .6f ' % areaf ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE AreaFactor ( n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Ratio of area of two nested polygons formed by connecting midpoints of sides of a regular N | Python3 code for the above approach ; Function to calculate the ratio of area of N - th and ( N + 1 ) - th nested polygons formed by connecting midpoints ; Stores the value of PI ; Calculating area the factor ; Printing the ratio precise upto 6 decimal places ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9010-9010",
        "Code": "import math NEW_LINE PI = 3.14159265 NEW_LINE def findInteriorAngle ( n ) : NEW_LINE INDENT return ( n - 2 ) * PI / n NEW_LINE DEDENT def calculateSideLength ( L , N , K ) : NEW_LINE INDENT angle = findInteriorAngle ( N ) NEW_LINE length = L * pow ( math . sin ( angle / 2 ) , ( K - 1 ) ) NEW_LINE return length NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE L = 21 NEW_LINE K = 7 NEW_LINE print ( calculateSideLength ( L , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the length of Kth N | Python3 program for the above approach ; Function to calculate the interior angle of a N - sided regular polygon ; Function to find the K - th polygon formed inside the ( K - 1 ) th polygon ; Stores the interior angle ; Stores the side length of K - th regular polygon ; Return the length ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9011-9011",
        "Code": "from math import atan NEW_LINE def findAngle ( M1 , M2 ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) NEW_LINE ret = atan ( angle ) NEW_LINE val = ( ret * 180 ) / PI NEW_LINE print ( round ( val , 4 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M1 = 1.75 NEW_LINE M2 = 0.27 NEW_LINE findAngle ( M1 , M2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Angle between a Pair of Lines | Python3 program for the above approach ; Function to find the angle between two lines ; Store the tan value of the angle ; Calculate tan inverse of the angle ; Convert the angle from radian to degree ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9018-9018",
        "Code": "from math import sqrt , floor NEW_LINE def finalPosition ( a , b , M ) : NEW_LINE INDENT n = 0 NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE w = 0 NEW_LINE p = ' N ' NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( p == ' N ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == ' S ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == ' E ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == ' W ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT DEDENT DEDENT ver_disp = n - s NEW_LINE hor_disp = e - w NEW_LINE displacement = floor ( sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) + 1 ) NEW_LINE print ( displacement , p ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ' U ' , ' R ' , ' R ' , ' R ' , ' R ' ] NEW_LINE B = [ 1 , 1 , 1 , 1 , 0 ] NEW_LINE N = len ( A ) NEW_LINE finalPosition ( A , B , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Displacement from origin after N moves of given distances in specified directions | Python3 program for the above approach ; Function to find the displacement from the origin and direction after performing the given set of moves ; Stores the distances travelled in the directions North , South , East , and West respectively ; Store the initial position of robot ; Traverse the array B [ ] ; If the current direction is North ; If the current direction is South ; If the current direction is East ; If the current direction is West ; Stores the total vertical displacement ; Stores the total horizontal displacement ; Find the displacement ; Print the displacement and direction after N moves ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9019-9019",
        "Code": "import math NEW_LINE def findAngles ( a , b , c , d ) : NEW_LINE INDENT numerator = a * a + d * d - b * b - c * c NEW_LINE denominator = 2 * ( a * b + c * d ) NEW_LINE x = numerator / denominator NEW_LINE print ( \" A : ▁ \" , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , \" ▁ degrees \" ) NEW_LINE numerator = a * a + b * b - c * c - d * d NEW_LINE x = numerator / denominator NEW_LINE print ( \" B : ▁ \" , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , \" ▁ degrees \" ) NEW_LINE numerator = c * c + b * b - a * a - d * d NEW_LINE x = numerator / denominator NEW_LINE print ( \" C : ▁ \" , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , \" ▁ degrees \" ) NEW_LINE numerator = d * d + c * c - a * a - b * b NEW_LINE x = numerator / denominator NEW_LINE print ( \" D : ▁ \" , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , \" ▁ degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 10 NEW_LINE B = 15 NEW_LINE C = 20 NEW_LINE D = 25 NEW_LINE findAngles ( A , B , C , D ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find interior angles for each side of a given Cyclic Quadrilateral | Python3 program for the above approach ; Function to find the interior angles of the cyclic quadrilateral ; Stores the numerator and the denominator to find angle A ; Stores the numerator and the denominator to find angle B ; Stores the numerator and the denominator to find angle C : ; Stores the numerator and the denominator to find angle D : ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "902-902",
        "Code": "mat = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] ; NEW_LINE n = 4 NEW_LINE mode = 0 NEW_LINE it = 0 NEW_LINE lower = 0 NEW_LINE for t in range ( 2 * n - 1 ) : NEW_LINE INDENT t1 = t NEW_LINE if ( t1 >= n ) : NEW_LINE INDENT mode += 1 NEW_LINE t1 = n - 1 NEW_LINE it -= 1 NEW_LINE lower += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lower = 0 NEW_LINE it += 1 NEW_LINE DEDENT for i in range ( t1 , lower - 1 , - 1 ) : NEW_LINE INDENT if ( ( t1 + mode ) % 2 == 0 ) : NEW_LINE INDENT print ( ( mat [ i ] [ t1 + lower - i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( mat [ t1 + lower - i ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT",
        "Type": "py",
        "NL": "Print matrix in diagonal pattern | Initialize matrix ; n - size mode - switch to derive up / down traversal it - iterator count - increases until it reaches n and then decreases ; 2 n will be the number of iterations",
        "Category": "Matrix"
    },
    {
        "ID": "9020-9020",
        "Code": "import math NEW_LINE def countInscribed ( R1 , R2 ) : NEW_LINE INDENT if ( R2 > R1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT angle = 0 NEW_LINE ratio = 0 NEW_LINE number_of_circles = 0 NEW_LINE ratio = R2 / ( R1 - R2 ) NEW_LINE if ( R1 < 2 * R2 ) : NEW_LINE INDENT number_of_circles = 1 NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( abs ( math . asin ( ratio ) * 180 ) / 3.14159265 ) NEW_LINE number_of_circles = ( 360 / ( 2 * math . floor ( angle ) ) ) NEW_LINE DEDENT return number_of_circles NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R1 = 3 NEW_LINE R2 = 1 NEW_LINE print ( int ( countInscribed ( R1 , R2 ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of smaller circles that can be inscribed in a larger circle | Python3 program for the above approach ; Function to count number of smaller circles that can be inscribed in the larger circle touching its boundary ; If R2 is greater than R1 ; Stores the angle made by the smaller circle ; Stores the ratio of R2 / ( R1 - R2 ) ; Stores the count of smaller circles that can be inscribed ; Stores the ratio ; If the diameter of smaller circle is greater than the radius of the larger circle ; Otherwise ; Find the angle using formula ; Divide 360 with angle and take the floor value ; Return the final result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9023-9023",
        "Code": "import math NEW_LINE def magnitude ( arr , N ) : NEW_LINE INDENT magnitude = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT magnitude += arr [ i ] * arr [ i ] NEW_LINE DEDENT return math . sqrt ( magnitude ) NEW_LINE DEDENT def dotProduct ( arr , brr , N ) : NEW_LINE INDENT product = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT product = product + arr [ i ] * brr [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT def angleBetweenVectors ( arr , brr , N ) : NEW_LINE INDENT dotProductOfVectors = dotProduct ( arr , brr , N ) NEW_LINE magnitudeOfA = magnitude ( arr , N ) NEW_LINE magnitudeOfB = magnitude ( brr , N ) NEW_LINE angle = ( dotProductOfVectors / ( magnitudeOfA * magnitudeOfB ) ) NEW_LINE print ( ' % .5f ' % angle ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 0.5 , - 2 , 1 ] NEW_LINE brr = [ - 1 , - 1 , 0.3 ] NEW_LINE N = len ( arr ) NEW_LINE angleBetweenVectors ( arr , brr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate angle between two N | Python3 program for the above approach ; Function to find the magnitude of the given vector ; Stores the final magnitude ; Traverse the array ; Return square root of magnitude ; Function to find the dot product of two vectors ; Stores dot product ; Traverse the array ; Return the product ; Stores dot product of two vectors ; Stores magnitude of vector A ; Stores magnitude of vector B ; Stores angle between given vectors ; Print the angle ; Driver Code ; Given magnitude arrays ; Size of the array ; Function call to find the angle between two vectors",
        "Category": "Math"
    },
    {
        "ID": "9026-9026",
        "Code": "def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return \" Not ▁ Possible \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Angle = 45 NEW_LINE print ( secondary_polygon ( Angle ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of sides of largest and smallest child polygons possible from a given polygon | Function to find the sum of largest and smallest secondary polygons if possible ; Count edges of primary polygon ; Calculate edges present in the largest secondary polygon ; Driver Code ; Given Exterior Angle",
        "Category": "Math"
    },
    {
        "ID": "9027-9027",
        "Code": "def findSquareSum ( Coordinates , N ) : NEW_LINE INDENT xq , yq = 0 , 0 NEW_LINE xs , ys = 0 , 0 NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = Coordinates [ i ] [ 0 ] NEW_LINE b = Coordinates [ i ] [ 1 ] NEW_LINE res += xq NEW_LINE res -= 2 * xs * a NEW_LINE res += i * ( a * a ) NEW_LINE xq += a * a NEW_LINE xs += a NEW_LINE res += yq NEW_LINE res -= 2 * ys * b NEW_LINE res += i * b * b NEW_LINE yq += b * b NEW_LINE ys += b NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 1 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] NEW_LINE N = len ( arr ) NEW_LINE findSquareSum ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of squares of distances between all pairs from given points | Function to find the sum of squares of distance between all distinct pairs ; Stores final answer ; Traverse the array ; Adding the effect of this point for all the previous x - points ; Temporarily add the square of x - coordinate ; Add the effect of this point for all the previous y - points ; Print the desired answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9031-9031",
        "Code": "from math import sqrt , pow NEW_LINE def coneSlantHeight ( cone_h , cone_r ) : NEW_LINE INDENT slant_height_cone = sqrt ( pow ( cone_h , 2 ) + pow ( cone_r , 2 ) ) NEW_LINE print ( \" Slant ▁ height ▁ of ▁ cone ▁ is : \" , slant_height_cone ) NEW_LINE DEDENT def pyramidSlantHeight ( pyramid_h , pyramid_s ) : NEW_LINE INDENT slant_height_pyramid = sqrt ( pow ( pyramid_s / 2 , 2 ) + pow ( pyramid_h , 2 ) ) NEW_LINE print ( \" Slant ▁ height ▁ of ▁ pyramid ▁ is : \" , \" { : . 5f } \" . format ( slant_height_pyramid ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H1 = 4.5 NEW_LINE R = 6 NEW_LINE coneSlantHeight ( H1 , R ) ; NEW_LINE H2 = 4 NEW_LINE S = 4.8 NEW_LINE pyramidSlantHeight ( H2 , S ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find slant height of cone and pyramid | Python 3 program for the above approach ; Function to calculate slant height of a cone ; Store the slant height of cone ; Print the result ; Function to find the slant height of a pyramid ; Store the slant height of pyramid ; Print the result ; Driver Code ; Dimensions of Cone ; Function Call for slant height of Cone ; Dimensions of Pyramid ; Function to calculate slant height of a pyramid",
        "Category": "Math"
    },
    {
        "ID": "9032-9032",
        "Code": "MAX = 10 ** 6 + 5 NEW_LINE from math import ceil NEW_LINE def query ( arr , Q ) : NEW_LINE INDENT pre = [ 0 ] * ( MAX ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] < 0 or arr [ i ] [ 1 ] < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum = ceil ( ( arr [ i ] [ 0 ] + arr [ i ] [ 1 ] ) ) ; NEW_LINE pre [ sum ] += 1 NEW_LINE DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT print ( pre [ Q [ i ] ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 2.1 , 3.0 ] , [ 3.7 , 1.2 ] , [ 1.5 , 6.5 ] , [ 1.2 , 0.0 ] ] NEW_LINE Q = [ 2 , 8 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q ) NEW_LINE query ( arr , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Queries to count points lying on or inside an isosceles Triangle with given length of equal sides | Python3 implementation of above approach ; Function to find answer of each query ; Stores the count of points with sum less than or equal to their indices ; Traverse the array ; ` If both x and y - coordinate < 0 ; Stores the sum of co - ordinates ; Increment count of sum by 1 ; Prefix array ; Perform queries ; Drivers Code",
        "Category": "Math"
    },
    {
        "ID": "9033-9033",
        "Code": "from math import sqrt NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) NEW_LINE DEDENT def lengthOfLatusRectum ( a , b , c ) : NEW_LINE INDENT vertex = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ] NEW_LINE focus = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ] NEW_LINE print ( \" { : . 6f } \" . format ( 4 * distance ( focus [ 0 ] , focus [ 1 ] , vertex [ 0 ] , vertex [ 1 ] ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 1 NEW_LINE lengthOfLatusRectum ( a , b , c ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the length of Latus Rectum of a Parabola | Python 3 program for the above approach ; Function to calculate distance between two points ; Calculating distance ; Function to calculate length of the latus rectum of a parabola ; Stores the co - ordinates of the vertex of the parabola ; Stores the co - ordinates of the focus of parabola ; Print the distance between focus and vertex ; Driver Code ; Given a , b & c ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9037-9037",
        "Code": "def getPointsIns ( x1 , y1 , radius , x2 , y2 , points ) : NEW_LINE INDENT for point in points : NEW_LINE INDENT condOne = ( point [ 1 ] - y2 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( point [ 0 ] - x2 ) >= 0 NEW_LINE condTwo = radius >= ( ( y1 - point [ 1 ] ) ** 2 + ( x1 - point [ 0 ] ) ** 2 ) ** ( 0.5 ) NEW_LINE if condOne and condTwo : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT X = 0 NEW_LINE Y = 0 NEW_LINE R = 5 NEW_LINE P = 5 NEW_LINE Q = 0 NEW_LINE arr = [ [ 2 , 3 ] , [ 5 , 6 ] , [ - 1 , 4 ] , [ 5 , 5 ] ] NEW_LINE print ( getPointsIns ( X , Y , R , P , Q , arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count points from an array that lies inside a semi | Python implementation of above approach ; Traverse the array ; Stores if a point lies above the diameter or not ; Stores if the R is less than or equal to the distance between center and point ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9039-9039",
        "Code": "import math NEW_LINE def ConvertDegToRad ( degree ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE return ( degree * ( pi / 180.0 ) ) NEW_LINE DEDENT def ConvertToCartesian ( polar ) : NEW_LINE INDENT polar [ 1 ] = ConvertDegToRad ( polar [ 1 ] ) NEW_LINE cartesian = [ polar [ 0 ] * math . cos ( polar [ 1 ] ) , polar [ 0 ] * math . sin ( polar [ 1 ] ) ] NEW_LINE print ( ' % .3f ' % cartesian [ 0 ] , ' % .3f ' % cartesian [ 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT polar = [ 1.4142 , 45 ] NEW_LINE ConvertToCartesian ( polar ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to convert polar co | Python 3 program for the above approach ; Function to convert degree to radian ; Function to convert the polar coordinate to cartesian ; Convert degerees to radian ; Applying the formula : x = rcos ( theata ) , y = rsin ( theta ) ; Print cartesian coordinates ; Driver Code ; Given polar coordinates ; Function to convert polar coordinates to equivalent cartesian coordinates",
        "Category": "Math"
    },
    {
        "ID": "9041-9041",
        "Code": "def cntPairs ( points , n , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dist = 0 NEW_LINE for k in range ( K ) : NEW_LINE INDENT temp = ( points [ i ] [ k ] - points [ j ] [ k ] ) NEW_LINE dist += temp * temp NEW_LINE DEDENT if ( ( ( dist ) ** ( 1 / 2 ) ) * ( ( dist ) ** ( 1 / 2 ) ) == dist ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT K = 2 NEW_LINE points = [ [ 1 , 2 ] , [ 5 , 5 ] , [ - 2 , 8 ] ] NEW_LINE n = len ( points ) NEW_LINE cntPairs ( points , n , K ) NEW_LINE",
        "Type": "py",
        "NL": "Count pairs of points having distance between them equal to integral values in a K | Function to find pairs whose distance between the points of is an integer value . ; Stores count of pairs whose distance between points is an integer ; Traverse the array , points [ ] ; Stores distance between points ( i , j ) ; Traverse all the points of current pair ; Update temp ; Update dist ; If dist is a perfect square ; Update ans ; Given value of K ; Given points ; Given value of N ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9044-9044",
        "Code": "def find_lcm ( a , b , c ) : NEW_LINE INDENT g = __gcd ( a , b ) ; NEW_LINE LCM1 = ( a * b ) // g ; NEW_LINE g = __gcd ( LCM1 , c ) ; NEW_LINE LCM = ( LCM1 * c ) // g ; NEW_LINE return LCM ; NEW_LINE DEDENT def minimumCuboids ( L , B , H ) : NEW_LINE INDENT lcm = find_lcm ( L , B , H ) ; NEW_LINE volume_cube = lcm * lcm * lcm ; NEW_LINE volume_cuboid = L * B * H ; NEW_LINE print ( ( volume_cube // volume_cuboid ) ) ; NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 ; B = 1 ; H = 2 ; NEW_LINE minimumCuboids ( L , B , H ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of Cuboids required to form a Cube | Function to calculate and return LCM of a , b , and c ; Find GCD of a and b ; Find LCM of a and b ; LCM ( a , b , c ) = LCM ( LCM ( a , b ) , c ) ; Finding LCM of a , b , c ; return LCM ( a , b , c ) ; Function to find the minimum number of cuboids required to make the volume of a valid cube ; Find the LCM of L , B , H ; Volume of the cube ; Volume of the cuboid ; Minimum number cuboids required to form a cube ; Driver Code ; Given dimensions of cuboid ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9045-9045",
        "Code": "import math NEW_LINE def distance ( p1 , p2 ) : NEW_LINE INDENT x1 , x2 = p1 [ 0 ] , p2 [ 0 ] NEW_LINE y1 , y2 = p1 [ 1 ] , p2 [ 1 ] NEW_LINE return int ( math . sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) ) ) NEW_LINE DEDENT def find_orthocenter ( A , B , C ) : NEW_LINE INDENT AB = distance ( A , B ) NEW_LINE BC = distance ( B , C ) NEW_LINE CA = distance ( C , A ) NEW_LINE if ( AB > BC and AB > CA ) : NEW_LINE INDENT return C NEW_LINE DEDENT if ( BC > AB and BC > CA ) : NEW_LINE INDENT return A NEW_LINE DEDENT return B NEW_LINE DEDENT def find_circumcenter ( A , B , C ) : NEW_LINE INDENT AB = distance ( A , B ) NEW_LINE BC = distance ( B , C ) NEW_LINE CA = distance ( C , A ) NEW_LINE if ( AB > BC and AB > CA ) : NEW_LINE INDENT return ( ( A [ 0 ] + B [ 0 ] ) // 2 , ( A [ 1 ] + B [ 1 ] ) // 2 ) NEW_LINE DEDENT if ( BC > AB and BC > CA ) : NEW_LINE INDENT return ( ( B [ 0 ] + C [ 0 ] ) // 2 , ( B [ 1 ] + C [ 1 ] ) // 2 ) NEW_LINE DEDENT return ( ( C [ 0 ] + A [ 0 ] ) // 2 , ( C [ 1 ] + A [ 1 ] ) // 2 ) NEW_LINE DEDENT def findDistance ( A , B , C ) : NEW_LINE INDENT circumcenter = find_circumcenter ( A , B , C ) NEW_LINE orthocenter = find_orthocenter ( A , B , C ) NEW_LINE distance_between = distance ( circumcenter , orthocenter ) NEW_LINE print ( distance_between ) NEW_LINE DEDENT A = [ 0 , 0 ] NEW_LINE B = [ 6 , 0 ] NEW_LINE C = [ 0 , 8 ] NEW_LINE findDistance ( A , B , C ) NEW_LINE",
        "Type": "py",
        "NL": "Distance between orthocenter and circumcenter of a right | Python3 program for the above approach ; Function to calculate Euclidean distance between the points p1 and p2 ; Stores x coordinates of both points ; Stores y coordinates of both points ; Return the Euclid distance using distance formula ; Function to find orthocenter of the right angled triangle ; Find the length of the three sides ; Orthocenter will be the vertex opposite to the largest side ; Function to find the circumcenter of right angle triangle ; Circumcenter will be located at center of hypotenuse ; If AB is the hypotenuse ; If BC is the hypotenuse ; If AC is the hypotenuse ; Function to find distance between orthocenter and circumcenter ; Find circumcenter ; Find orthocenter ; Find the distance between the orthocenter and circumcenter ; Print distance between orthocenter and circumcenter ; Given coordinates A , B , and C ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9046-9046",
        "Code": "def CrossProduct ( A ) : NEW_LINE INDENT X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) NEW_LINE Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) NEW_LINE X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) NEW_LINE Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) NEW_LINE return ( X1 * Y2 - Y1 * X2 ) NEW_LINE DEDENT def isConvex ( points ) : NEW_LINE INDENT N = len ( points ) NEW_LINE prev = 0 NEW_LINE curr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = [ points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] ] NEW_LINE curr = CrossProduct ( temp ) NEW_LINE if ( curr != 0 ) : NEW_LINE INDENT if ( curr * prev < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT prev = curr NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT points = [ [ 0 , 0 ] , [ 0 , 1 ] , [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( isConvex ( points ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given polygon is a convex polygon or not | Utility function to find cross product of two vectors ; Stores coefficient of X direction of vector A [ 1 ] A [ 0 ] ; Stores coefficient of Y direction of vector A [ 1 ] A [ 0 ] ; Stores coefficient of X direction of vector A [ 2 ] A [ 0 ] ; Stores coefficient of Y direction of vector A [ 2 ] A [ 0 ] ; Return cross product ; Function to check if the polygon is convex polygon or not ; Stores count of edges in polygon ; Stores direction of cross product of previous traversed edges ; Stores direction of cross product of current traversed edges ; Traverse the array ; Stores three adjacent edges of the polygon ; Update curr ; If curr is not equal to 0 ; If direction of cross product of all adjacent edges are not same ; Update curr ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9052-9052",
        "Code": "import math NEW_LINE def Area_Parallelogram1 ( a , b , theta ) : NEW_LINE INDENT area = ( abs ( math . tan ( math . radians ( theta ) ) ) / 2 ) * abs ( a ** 2 - b ** 2 ) NEW_LINE return area NEW_LINE DEDENT def Area_Parallelogram2 ( a , b , gamma ) : NEW_LINE INDENT area = ( abs ( math . sin ( math . radians ( gamma ) ) ) ) * abs ( a * b ) NEW_LINE return area NEW_LINE DEDENT def Area_Parallelogram3 ( d1 , d2 , theta ) : NEW_LINE INDENT area = ( abs ( math . sin ( math . radians ( theta ) ) ) / 2 ) * abs ( d1 * d2 ) NEW_LINE return area NEW_LINE DEDENT d1 = 3 NEW_LINE d2 = 5 NEW_LINE theta = 90 NEW_LINE area = Area_Parallelogram3 ( d1 , d2 , theta ) NEW_LINE print ( round ( area , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate area of a parallelogram | Python3 program for the above approach ; Function to return the area of parallelogram using sides and angle at the intersection of diagonal ; Calculate area of parallelogram ; Return the answer ; Function to return the area of parallelogram using sides and angle at the intersection of sides ; Calculate area of parallelogram ; Return the answer ; Function to return the area of parallelogram using diagonals and angle at the intersection of diagonals ; Calculate area of parallelogram ; Return the answer ; Given diagonal and angle ; Function Call ; Print the area",
        "Category": "Math"
    },
    {
        "ID": "9060-9060",
        "Code": "import math NEW_LINE def Circumradius ( a , b , c , d ) : NEW_LINE INDENT s = ( a + b + c + d ) / 2 NEW_LINE radius = ( 1 / 4 ) * math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) NEW_LINE return radius NEW_LINE DEDENT A = 3 NEW_LINE B = 4 NEW_LINE C = 5 NEW_LINE D = 6 NEW_LINE ans = Circumradius ( A , B , C , D ) NEW_LINE print ( round ( ans , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Circumradius of a Cyclic Quadrilateral using the length of Sides | Program to find Circumradius of a cyclic quadrilateral using sides ; Function to return the Circumradius of a cyclic quadrilateral using sides ; Find semiperimeter ; Calculate the radius ; Driver Code ; Function Call ; Print the radius",
        "Category": "Math"
    },
    {
        "ID": "9061-9061",
        "Code": "import math NEW_LINE def Area_of_Rhombus ( a , theta ) : NEW_LINE INDENT area = ( a ** 2 ) * math . sin ( math . radians ( theta ) ) NEW_LINE return area NEW_LINE DEDENT a = 4 NEW_LINE theta = 60 NEW_LINE ans = Area_of_Rhombus ( a , theta ) NEW_LINE print ( round ( ans , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the area of rhombus from given Angle and Side length | Python3 Program to calculate area of rhombus from given angle and side length ; Function to return the area of rhombus using one angle and side . ; Driver Code ; Function Call ; Print the final answer",
        "Category": "Math"
    },
    {
        "ID": "9062-9062",
        "Code": "def calculateTriangles ( sides ) : NEW_LINE INDENT count = pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) NEW_LINE count -= pow ( sides [ 0 ] , 2 ) NEW_LINE count -= pow ( sides [ 2 ] , 2 ) NEW_LINE count -= pow ( sides [ 4 ] , 2 ) NEW_LINE return int ( count ) NEW_LINE DEDENT sides = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE print ( calculateTriangles ( sides ) ) NEW_LINE sides = [ 2 , 2 , 1 , 3 , 1 , 2 ] NEW_LINE print ( calculateTriangles ( sides ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of Equilateral Triangles of unit length possible from a given Hexagon | Function to calculate the the number of Triangles possible ; Regular Hexagon ; Irregular Hexagon",
        "Category": "Math"
    },
    {
        "ID": "9063-9063",
        "Code": "import math NEW_LINE def Length_Diagonal ( a , b , theta ) : NEW_LINE INDENT diagonal = math . sqrt ( ( ( a ** 2 ) + ( b ** 2 ) ) - 2 * a * b * math . cos ( math . radians ( theta ) ) ) NEW_LINE return diagonal NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonal ( a , b , theta ) NEW_LINE print ( round ( ans , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of diagonal of a parallelogram using adjacent sides and angle between them | Python3 Program to find length Of diagonal of a parallelogram Using sides and angle between them . ; Function to return the length Of diagonal of a parallelogram using sides and angle between them . ; Given Sides ; Given Angle ; Function Call ; Print the final answer",
        "Category": "Math"
    },
    {
        "ID": "9065-9065",
        "Code": "import math NEW_LINE def Length_Diagonal ( a , b , d ) : NEW_LINE INDENT diagonal = math . sqrt ( 2 * ( ( a ** 2 ) + ( b ** 2 ) ) - ( d ** 2 ) ) NEW_LINE return diagonal NEW_LINE DEDENT A = 10 NEW_LINE B = 30 NEW_LINE D = 20 NEW_LINE ans = Length_Diagonal ( A , B , D ) NEW_LINE print ( round ( ans , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of a Diagonal of a Parallelogram using the length of Sides and the other Diagonal | Python Program to implement the above approach ; Function to calculate the length of the diagonal of a parallelogram using two sides and other diagonal ; Driver Code ; Function Call ; Print the final answer",
        "Category": "Math"
    },
    {
        "ID": "9066-9066",
        "Code": "import math NEW_LINE def Diagonals ( a , b , c , d ) : NEW_LINE INDENT p = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) NEW_LINE q = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT A = 10 NEW_LINE B = 15 NEW_LINE C = 20 NEW_LINE D = 25 NEW_LINE ans = Diagonals ( A , B , C , D ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of Diagonals of a Cyclic Quadrilateral using the length of Sides . | Python3 program to implement the above approach ; Function to calculate the length of diagonals of a cyclic quadrilateral ; Driver Code ; Function Call ; Print the final answer",
        "Category": "Math"
    },
    {
        "ID": "9068-9068",
        "Code": "def det ( d ) : NEW_LINE INDENT Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) NEW_LINE Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) NEW_LINE Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) NEW_LINE return Sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 , y1 , z1 = - 3 , 1 , 5 NEW_LINE a1 , b1 , c1 = - 3 , 1 , 5 NEW_LINE x2 , y2 , z2 = - 1 , 2 , 5 NEW_LINE a2 , b2 , c2 = - 1 , 2 , 5 NEW_LINE det_list = [ [ x2 - x1 , y2 - y1 , z2 - z1 ] , [ a1 , b1 , c1 ] , [ a2 , b2 , c2 ] ] NEW_LINE if ( det ( det_list ) == 0 ) : NEW_LINE INDENT print ( \" Lines ▁ are ▁ coplanar \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Lines ▁ are ▁ non ▁ coplanar \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Coplanarity of Two Lines in 3D Geometry | Function to generate determinant ; Return the sum ; Driver Code ; Position vector of first line ; Direction ratios of line to which first line is parallel ; Position vectors of second line ; Direction ratios of line to which second line is parallel ; Determinant to check coplanarity ; If determinant is zero ; Otherwise",
        "Category": "Math"
    },
    {
        "ID": "9073-9073",
        "Code": "import math NEW_LINE def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE return dig NEW_LINE DEDENT def isAllKs ( n , b , k ) : NEW_LINE INDENT len = findNumberOfDigits ( n , b ) NEW_LINE sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) NEW_LINE return sum == N NEW_LINE DEDENT N = 13 NEW_LINE B = 3 NEW_LINE K = 1 NEW_LINE if ( isAllKs ( N , B , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if N contains all digits as K in base B | Python3 program for the above approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Given number N ; Given base B ; Given digit K ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9078-9078",
        "Code": "def minAnglRot ( N ) : NEW_LINE INDENT res = 360 // N NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE print ( \" Angle ▁ of ▁ Rotational ▁ Symmetry : ▁ \" , minAnglRot ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the angle of Rotational Symmetry of an N | Function to find required minimum angle of rotation ; Calculating the angle of rotation and type - casting the integer N to type ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9081-9081",
        "Code": "import math NEW_LINE def Area_of_Triangle ( a , b , k ) : NEW_LINE INDENT area = ( 1 / 2 ) * a * b * math . sin ( k ) NEW_LINE return area NEW_LINE DEDENT a = 9 NEW_LINE b = 12 NEW_LINE k = 2 NEW_LINE ans = Area_of_Triangle ( a , b , k ) NEW_LINE print ( round ( ans , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Area of Triangle using Side | Python3 program to calculate the area of a triangle when the length of two adjacent sides and the angle between them is provided ; Function to return the area of triangle using Side - Angle - Side formula ; Driver Code ; Function Call ; Print the final answer",
        "Category": "Math"
    },
    {
        "ID": "9082-9082",
        "Code": "MAX = 1001 NEW_LINE arr = [ [ False for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def updateArray ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT for i in range ( x1 , x2 ) : NEW_LINE INDENT for j in range ( y1 , y2 ) : NEW_LINE INDENT arr [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT def findAreaCovered ( ) : NEW_LINE INDENT area = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT if arr [ i ] [ j ] : NEW_LINE INDENT area += 1 NEW_LINE DEDENT DEDENT DEDENT return area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE A = [ [ 1 , 3 , 4 , 5 ] , [ 3 , 1 , 7 , 4 ] , [ 5 , 3 , 8 , 6 ] ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT updateArray ( A [ i ] [ 0 ] , A [ i ] [ 1 ] , A [ i ] [ 2 ] , A [ i ] [ 3 ] ) ; NEW_LINE DEDENT area = findAreaCovered ( ) ; NEW_LINE print ( area ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Total number of unit cells covered by all given Rectangles | Python3 program to find the number of cells enclosed by the given rectangles ; Update the coordinates lying within the rectangle ; Update arr [ i ] [ j ] for all ( i , j ) lying within the rectangle ; Function to return the total area covered by rectangles ; Stores the number of cells ; arr [ i ] ] [ [ j ] == 1 means that grid is filled by some rectangle ; Driver code ; ( A [ i ] [ 0 ] , A [ i ] [ 1 ] ) denotes the coordinate of the bottom left of the rectangle ( A [ i ] [ 2 ] , A [ i ] [ 3 ] ) denotes the coordinate of upper right of the rectangle ; Update the coordinates that lie within the rectangle",
        "Category": "Array"
    },
    {
        "ID": "9083-9083",
        "Code": "def findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) : NEW_LINE INDENT a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE c = z2 - z1 NEW_LINE A = ( b * f - c * e ) NEW_LINE B = ( a * f - c * d ) NEW_LINE C = ( a * e - b * d ) NEW_LINE D = - ( A * d - B * e + C * f ) NEW_LINE print ( A , \" x ▁ + ▁ \" , B , \" y ▁ + ▁ \" , C , \" z ▁ + ▁ \" , D , \" = ▁ 0\" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 = 2 NEW_LINE y1 = 3 NEW_LINE z1 = 5 ; NEW_LINE x2 = 6 NEW_LINE y2 = 7 NEW_LINE z2 = 8 NEW_LINE a = 11 NEW_LINE b = 23 NEW_LINE c = 10 NEW_LINE findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , a , b , c ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the equation of plane which passes through two points and parallel to a given axis | Python3 implementation to find the equation of plane which passes through two points and parallel to a given axis ; Find direction vector of points ( x1 , y1 , z1 ) and ( x2 , y2 , z2 ) ; Values that are calculated and simplified from the cross product ; Print the equation of plane ; Driver Code ; Point A ; Point B ; Given axis ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9085-9085",
        "Code": "def count_rectangles ( N , M ) : NEW_LINE INDENT p_x = ( N * ( N - 1 ) ) // 2 NEW_LINE p_y = ( M * ( M - 1 ) ) // 2 NEW_LINE return p_x * p_y NEW_LINE DEDENT N = 3 NEW_LINE M = 6 NEW_LINE print ( count_rectangles ( N , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of rectangles possible from N and M straight lines parallel to X and Y axis respectively | Function to calculate number of rectangles ; Total number of ways to select two lines parallel to X axis ; Total number of ways to select two lines parallel to Y axis ; Total number of rectangles ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9088-9088",
        "Code": "pi = 3.14159265358979323846 NEW_LINE def circleArea ( r ) : NEW_LINE INDENT print ( round ( pi * r * r , 4 ) ) NEW_LINE DEDENT def findCircleAreaByMedian ( m ) : NEW_LINE INDENT r = 2 * m / 3 NEW_LINE circleArea ( r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE findCircleAreaByMedian ( m ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Area of Circumcircle of an Equilateral Triangle using Median | Python3 implementation to find the equation of circle which inscribes equilateral triangle of median M ; Function to find the equation of circle whose center is ( x1 , y1 ) and the radius of circle is r ; Function to find the equation of circle which inscribes equilateral triangle of median M ; Function to find the circle equation ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9089-9089",
        "Code": "import math NEW_LINE def findSide ( a , B , C ) : NEW_LINE INDENT A = 180 - C - B NEW_LINE radA = math . pi * ( A / 180 ) NEW_LINE radB = math . pi * ( B / 180 ) NEW_LINE radC = math . pi * ( C / 180 ) NEW_LINE b = a / math . sin ( radA ) * math . sin ( radB ) NEW_LINE c = a / math . sin ( radA ) * math . sin ( radC ) NEW_LINE return b , c NEW_LINE DEDENT a = 12 NEW_LINE B = 60 NEW_LINE C = 30 NEW_LINE b , c = findSide ( a , B , C ) NEW_LINE print ( b , c ) NEW_LINE",
        "Type": "py",
        "NL": "Length of remaining two sides of a Triangle from a given side and its adjacent angles | Python3 program for above approach ; Function for computing other 2 side of the trianlgle ; computing angle C ; converting A in to radian ; converting B in to radian ; converting C in to radian ; computing length of side b ; computing length of side c ; driver program ; calling function",
        "Category": "Math"
    },
    {
        "ID": "9090-9090",
        "Code": "def areaSquare ( L , B ) : NEW_LINE INDENT large = max ( L , B ) NEW_LINE small = min ( L , B ) NEW_LINE if ( large >= 2 * small ) : NEW_LINE INDENT return large * large NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * small ) * ( 2 * small ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 7 NEW_LINE B = 4 NEW_LINE print ( areaSquare ( L , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum area of square holding two identical rectangles | Function to find the area of the square ; Larger side of rectangle ; Smaller side of the rectangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9091-9091",
        "Code": "import math NEW_LINE def calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT ABx = x1 - x2 ; NEW_LINE ABy = y1 - y2 ; NEW_LINE ABz = z1 - z2 ; NEW_LINE BCx = x3 - x2 ; NEW_LINE BCy = y3 - y2 ; NEW_LINE BCz = z3 - z2 ; NEW_LINE dotProduct = ( ABx * BCx + ABy * BCy + ABz * BCz ) ; NEW_LINE magnitudeAB = ( ABx * ABx + ABy * ABy + ABz * ABz ) ; NEW_LINE magnitudeBC = ( BCx * BCx + BCy * BCy + BCz * BCz ) ; NEW_LINE angle = dotProduct ; NEW_LINE angle /= math . sqrt ( magnitudeAB * magnitudeBC ) ; NEW_LINE angle = ( angle * 180 ) / 3.14 ; NEW_LINE print ( round ( abs ( angle ) , 4 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 , y1 , z1 = 1 , 3 , 3 ; NEW_LINE x2 , y2 , z2 = 3 , 4 , 5 ; NEW_LINE x3 , y3 , z3 = 5 , 6 , 9 ; NEW_LINE calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Angle between a Pair of Lines in 3D | Python3 program for the above approach ; Function to find the angle between the two lines ; Find direction ratio of line AB ; Find direction ratio of line BC ; Find the dotProduct of lines AB & BC ; Find magnitude of line AB and BC ; Find the cosine of the angle formed by line AB and BC ; Find angle in radian ; Print angle ; Driver Code ; Given coordinates Points A ; Points B ; Points C ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9092-9092",
        "Code": "import math NEW_LINE pi = math . acos ( - 1.0 ) NEW_LINE def nGon ( N ) : NEW_LINE INDENT proAngleVar = 0 NEW_LINE if ( N % 4 == 0 ) : NEW_LINE INDENT proAngleVar = ( pi * ( 180.0 / N ) / 180 ) NEW_LINE DEDENT else : NEW_LINE INDENT proAngleVar = ( pi * ( 180.0 / ( 2 * N ) ) / 180 ) NEW_LINE DEDENT negX = 1.0e+99 NEW_LINE posX = - 1.0e+99 NEW_LINE negY = 1.0e+99 NEW_LINE posY = - 1.0e+99 NEW_LINE for j in range ( N ) : NEW_LINE INDENT px = math . cos ( 2 * pi * j / N + proAngleVar ) NEW_LINE py = math . sin ( 2 * pi * j / N + proAngleVar ) NEW_LINE negX = min ( negX , px ) NEW_LINE posX = max ( posX , px ) NEW_LINE negY = min ( negY , py ) NEW_LINE posY = max ( posY , py ) NEW_LINE DEDENT opt2 = max ( posX - negX , posY - negY ) NEW_LINE return ( opt2 / math . sin ( pi / N ) / 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE print ( ' % .5f ' % nGon ( N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum side of square embedded in Regular polygon with N sides | Python 3 program to find the minimum side of the square in which a regular polygon with even sides can completely embed ; PI value in Python 3 using acos function ; Function to find the minimum side of the square in which a regular polygon with even sides can completely embed ; Projection angle variation from axes ; Projection angle variation when the number of sides are in multiple of 4 ; Distance between the end points ; Projection from all N points on X - axis ; Projection from all N points on Y - axis ; Maximum side ; Return the portion of side forming the square ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "910-910",
        "Code": "MAX = 1000 NEW_LINE def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT N = 3 NEW_LINE mat = [ [ 1 , 5 , 4 ] , [ 3 , 7 , 2 ] , [ 5 , 9 , 10 ] ] NEW_LINE print ( \" maximum ▁ XOR ▁ value ▁ : ▁ \" , maxXOR ( mat , N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum XOR value in matrix | Python3 program to Find maximum XOR value in matrix either row / column wise maximum number of row and column ; Function return the maximum xor value that is either row or column wise ; For row xor and column xor ; Traverse matrix ; xor row element ; for each column : j is act as row & i act as column xor column element ; update maximum between r_xor , c_xor ; return maximum xor value ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9102-9102",
        "Code": "import math NEW_LINE def isicositrigonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 168 * N + 361 ) ) / 42 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 23 NEW_LINE if ( isicositrigonal ( i ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to check if N is a Icositrigonal number | Python3 implementation to check that a number is a icositrigonal number or not ; Function to check that the number is a icositrigonal number ; Condition to check if the number is a icositrigonal number ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9117-9117",
        "Code": "def checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT Xn = max ( X1 , min ( Xc , X2 ) ) NEW_LINE Yn = max ( Y1 , min ( Yc , Y2 ) ) NEW_LINE Dx = Xn - Xc NEW_LINE Dy = Yn - Yc NEW_LINE return ( Dx ** 2 + Dy ** 2 ) <= R ** 2 NEW_LINE DEDENT if ( __name__ == \" _ _ main _ _ \" ) : NEW_LINE INDENT R = 1 NEW_LINE Xc , Yc = 0 , 0 NEW_LINE X1 , Y1 = 1 , - 1 NEW_LINE X2 , Y2 = 3 , 1 NEW_LINE print ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if any point overlaps the given Circle and Rectangle | Function to check if any point overlaps the given Circle and Rectangle ; Find the nearest point on the rectangle to the center of the circle ; Find the distance between the nearest point and the center of the circle Distance between 2 points , ( x1 , y1 ) & ( x2 , y2 ) in 2D Euclidean space is ( ( x1 - x2 ) * * 2 + ( y1 - y2 ) * * 2 ) * * 0.5 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "912-912",
        "Code": "def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( \" Left \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( \" Up \" ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 != 0 and C % 2 != 0 : NEW_LINE INDENT print ( \" Right \" ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 == 0 and C % 2 == 0 : NEW_LINE INDENT print ( \" Left \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( \" Right \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( \" Down \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( \" Left \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( \" Up \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( \" Down \" ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( \" Right \" ) NEW_LINE return NEW_LINE DEDENT DEDENT R = 3 ; C = 1 NEW_LINE direction ( R , C ) NEW_LINE",
        "Type": "py",
        "NL": "Direction at last square block | Function which tells the Current direction ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9120-9120",
        "Code": "def checkIntersection ( p1 , p2 , p ) : NEW_LINE INDENT if ( p1 [ 1 ] == p2 [ 1 ] and p1 [ 1 ] == p [ 1 ] ) : NEW_LINE INDENT if ( p [ 0 ] <= max ( p1 [ 0 ] , p2 [ 0 ] ) and ( p [ 0 ] >= min ( p1 [ 0 ] , p2 [ 0 ] ) ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( p1 [ 0 ] == p2 [ 0 ] and p1 [ 0 ] == p [ 0 ] ) : NEW_LINE INDENT if ( p [ 1 ] <= max ( p1 [ 1 ] , p2 [ 1 ] ) and ( p [ 1 ] >= min ( p1 [ 1 ] , p2 [ 1 ] ) ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT val = ( ( p [ 1 ] - p1 [ 1 ] ) * ( p2 [ 0 ] - p1 [ 0 ] ) - ( p [ 0 ] - p1 [ 0 ] ) * ( p2 [ 1 ] - p1 [ 1 ] ) ) NEW_LINE if ( val == 0 ) : NEW_LINE INDENT if ( ( p [ 0 ] <= max ( p1 [ 0 ] , p2 [ 0 ] ) and ( p [ 0 ] >= min ( p1 [ 0 ] , p2 [ 0 ] ) ) ) and ( p [ 1 ] <= max ( p1 [ 1 ] , p2 [ 1 ] ) and ( p [ 1 ] >= min ( p1 [ 1 ] , p2 [ 1 ] ) ) ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def towerOfSight ( a , b , c , d ) : NEW_LINE INDENT flag = 0 NEW_LINE if ( checkIntersection ( a , c , b ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( checkIntersection ( a , c , d ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( checkIntersection ( b , d , a ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( checkIntersection ( b , d , c ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 0 , 0 ] NEW_LINE b = [ 0 , - 2 ] NEW_LINE c = [ 2 , 0 ] NEW_LINE d = [ 0 , 2 ] NEW_LINE towerOfSight ( a , b , c , d ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the tower of sight issue occurs or not | Function to check if point p lies in between the line joining p1 and p2 ; If parallel to X - axis ; Point p lies between p1 and p2 ; If parallel to Y - axis ; Point p lies between p1 and p2 ; If point p satisfies the equation of line joining p1 and p2 ; Function to check if tower of sight issue occurred ; B lies between AC ; D lies between AC ; A lies between BD ; C lies between BD ; Driver code ; Point A ; Point B ; Point C ; Point D",
        "Category": "Math"
    },
    {
        "ID": "9123-9123",
        "Code": "def calculate_change ( length , breadth ) : NEW_LINE INDENT change = 0 NEW_LINE change = length + breadth + ( ( length * breadth ) // 100 ) NEW_LINE return change NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cL = 20 NEW_LINE cB = - 10 NEW_LINE cA = calculate_change ( cL , cB ) NEW_LINE print ( cA ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the percentage change in the area of a Rectangle | Function to calculate percentage change in area of rectangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9124-9124",
        "Code": "from math import sqrt NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE DEDENT ' NEW_LINE INDENT if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( int ( sqrt ( x * x + y * y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Modulus of a Complex Number | Python 3 program to find the Modulus of a Complex Number ; Function to find modulus of a complex number ; Storing the index of '+ ; Storing the index of '- ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9126-9126",
        "Code": "def lineFromPoints ( P , Q , a , b , c ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE return a , b , c NEW_LINE DEDENT def perpenBisectorFromLine ( P , Q , a , b , c ) : NEW_LINE INDENT mid_point = [ 0 , 0 ] NEW_LINE mid_point [ 0 ] = ( P [ 0 ] + Q [ 0 ] ) / 2 NEW_LINE mid_point [ 1 ] = ( P [ 1 ] + Q [ 1 ] ) / 2 NEW_LINE c = ( - b * ( mid_point [ 0 ] ) + a * ( mid_point [ 1 ] ) ) NEW_LINE temp = a NEW_LINE a = - b NEW_LINE b = temp NEW_LINE return a , b , c NEW_LINE DEDENT def LineInterX ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determ = a1 * b2 - a2 * b1 NEW_LINE x = ( b2 * c1 - b1 * c2 ) NEW_LINE x /= determ NEW_LINE return x NEW_LINE DEDENT def LineInterY ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determ = a1 * b2 - a2 * b1 NEW_LINE y = ( a1 * c2 - a2 * c1 ) NEW_LINE print ( y ) NEW_LINE y /= determ NEW_LINE return y NEW_LINE DEDENT def findPosition ( P , Q , R , D ) : NEW_LINE INDENT r = [ 0 , 0 ] NEW_LINE a , b , c = lineFromPoints ( P , Q , 0 , 0 , 0 ) NEW_LINE e , f , g = lineFromPoints ( Q , R , 0 , 0 , 0 ) NEW_LINE a , b , c = perpenBisectorFromLine ( P , Q , a , b , c ) NEW_LINE e , f , g = perpenBisectorFromLine ( Q , R , e , f , g ) NEW_LINE r [ 0 ] = LineInterX ( a , b , c , e , f , g ) NEW_LINE r [ 1 ] = LineInterY ( a , b , c , e , f , g ) NEW_LINE q = ( ( r [ 0 ] - P [ 0 ] ) * ( r [ 0 ] - P [ 0 ] ) + ( r [ 1 ] - P [ 1 ] ) * ( r [ 1 ] - P [ 1 ] ) ) NEW_LINE dis = ( ( r [ 0 ] - D [ 0 ] ) * ( r [ 0 ] - D [ 0 ] ) + ( r [ 1 ] - D [ 1 ] ) * ( r [ 1 ] - D [ 1 ] ) ) NEW_LINE if ( dis < q ) : NEW_LINE INDENT print ( \" Point ▁ ( \" , D [ 0 ] , \" , \" , D [ 1 ] , \" ) ▁ is ▁ inside ▁ the ▁ circumcircle \" ) NEW_LINE DEDENT elif ( dis == q ) : NEW_LINE INDENT print ( \" Point ▁ ( \" , D [ 0 ] , \" , \" , D [ 1 ] , \" ) ▁ lies ▁ on ▁ the ▁ circumcircle \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Point ▁ ( \" , D [ 0 ] , \" , \" , D [ 1 ] , \" ) ▁ lies ▁ outside ▁ the ▁ circumcircle \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 8 ] NEW_LINE B = [ 2 , 1 ] NEW_LINE C = [ 4 , 5 ] NEW_LINE D = [ 3 , 0 ] NEW_LINE findPosition ( A , B , C , D ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find if a point lies inside , outside or on the circumcircle of three points A , B , C | Function to find the line given two points ; Function which converts the input line to its perpendicular bisector . It also inputs the points whose mid - lies o on the bisector ; Find the mid point ; x coordinates ; y coordinates ; c = - bx + ay ; Assign the coefficient of a and b ; Returns the intersection of two lines ; Find determinant ; Returns the intersection of two lines ; Find determinant ; Function to find the point lies inside , outside or on the circle ; Store the coordinates radius of circumcircle ; Line PQ is represented as ax + by = c ; Line QR is represented as ex + fy = g ; Converting lines PQ and QR to perpendicular bisectors . After this , L = ax + by = c M = ex + fy = g ; The of intersection of L and M gives r as the circumcenter ; Length of radius ; Distance between radius and the given D ; Condition for lies inside circumcircle ; Condition for lies on circumcircle ; Condition for lies outside circumcircle ; Driver Code ; Given Points ; Function call to find the lies inside , outside or on the circle",
        "Category": "Math"
    },
    {
        "ID": "9127-9127",
        "Code": "def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_block ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 50 NEW_LINE w = 20 NEW_LINE h = 35 NEW_LINE a = 700 NEW_LINE ht = 140 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of blocks required to form Hollow Rectangular Prism | Function to display output ; Function to return minimum no of layers required to form the hollow prism ; Function to calculate no of blocks required for each layer ; No of blocks required for each row ; Check for no of layers is minimum ; Driver function ; Length , width , height of each block ; Side of one wall ; height of each wall",
        "Category": "Math"
    },
    {
        "ID": "9131-9131",
        "Code": "from math import sqrt NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 4 ; NEW_LINE print ( \" Area ▁ of ▁ semicircle ▁ = \" , find_Area ( a ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Area of largest semicircle that can be drawn inside a square | Python3 program to find Area of semicircle in a square ; Function to find area of semicircle ; Driver code ; side of a square ; Call Function to find the area of semicircle",
        "Category": "Math"
    },
    {
        "ID": "9134-9134",
        "Code": "def solve ( n , m , obstacles , rangee ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE rangee = sorted ( rangee ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT rangee [ i ] = 2 * rangee [ i ] NEW_LINE val -= rangee [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE m = 5 NEW_LINE obstacles = 3 NEW_LINE rangee = [ 1.0 , 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , rangee ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum number of Circular obstacles required to obstruct the path in a Grid | Function to find the minimum number of obstacles required ; Find the minimum rangee required to put obstacles ; Sorting the radius ; If val is less than zero then we have find the number of obstacles required ; Driver code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9136-9136",
        "Code": "def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find X , Y and Z intercepts of a plane | Python program to find the X , Y and Z intercepts of a plane ; For finding the x - intercept put y = 0 and z = 0 ; For finding the y - intercept put x = 0 and z = 0 ; For finding the z - intercept put x = 0 and y = 0 ; For Finding value of A , B , C , D ; Calling the first created function ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9138-9138",
        "Code": "def new_vol ( x ) : NEW_LINE INDENT if ( x > 0 ) : NEW_LINE INDENT print ( \" % ▁ change ▁ in ▁ the ▁ volume ▁ of ▁ the ▁ hemisphere : ▁ \" , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , \" % ▁ increase \" ) NEW_LINE DEDENT elif ( x < 0 ) : NEW_LINE INDENT print ( \" % ▁ change ▁ in ▁ the ▁ volume ▁ of ▁ the ▁ hemisphere : ▁ \" , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , \" % ▁ decrease \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Volume ▁ remains ▁ the ▁ same . \" ) NEW_LINE DEDENT DEDENT x = - 10.0 NEW_LINE new_vol ( x ) NEW_LINE",
        "Type": "py",
        "NL": "Percentage change in Hemisphere volume if radius is changed | Function to find the change in hemispheric volume ; Get the change in radius ; Calculate the change in hemispheric volume",
        "Category": "Math"
    },
    {
        "ID": "9139-9139",
        "Code": "from math import * NEW_LINE def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y ; NEW_LINE ans = 0 ; NEW_LINE if ( z < volume // 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z ; NEW_LINE d = ( 2 * z ) / ( float ) ( x * x * x ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT ans = ( ans * 180 ) / 3.14159265 ; NEW_LINE return round ( ans , 4 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 12 ; NEW_LINE y = 21 ; NEW_LINE z = 10 ; NEW_LINE print ( find_angle ( x , y , z ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the maximum angle at which we can tilt the bottle without spilling any water | Python3 program to find the maximum angle at which we can tilt the bottle without spilling any water ; Now we have the volume of rectangular prism a * a * b ; Now we have 2 cases ! ; Taking the tangent inverse of value d As we want to take out the required angle ; Taking the tangent inverse of value d As we want to take out the required angle ; As of now the angle is in radian . So we have to convert it in degree . ; Driver Code ; Enter the Base square side length ; Enter the Height of rectangular prism ; Enter the Base square side length",
        "Category": "Math"
    },
    {
        "ID": "9140-9140",
        "Code": "def FindPoints ( n ) : NEW_LINE INDENT v = [ ] ; NEW_LINE v . append ( [ 0 , 0 ] ) ; NEW_LINE v . append ( [ 0 , n ] ) ; NEW_LINE v . append ( [ n , 0 ] ) ; NEW_LINE v . append ( [ n , n ] ) ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( [ n // 2 , n // 2 ] ) ; NEW_LINE DEDENT return v ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; NEW_LINE v = FindPoints ( N ) ; NEW_LINE for element in v : NEW_LINE INDENT print ( \" ( \" , element [ 0 ] , \" , \" , element [ 1 ] , \" ) \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Find the integer points ( x , y ) with Manhattan distance atleast N | function to find all possible point ; Find all 4 corners of the square whose side length is n ; If n is even then the middle point of the square will be an integer , so we will take that point ; Driver Code ; Printing all possible points",
        "Category": "Math"
    },
    {
        "ID": "9148-9148",
        "Code": "def orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE if ( dsquare == r1 * r1 + r2 * r2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x1 , y1 = 4 , 3 NEW_LINE x2 , y2 = 0 , 1 NEW_LINE r1 , r2 = 2 , 4 NEW_LINE f = orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE if ( f ) : NEW_LINE INDENT print ( \" Given ▁ circles ▁ are ▁ orthogonal . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Given ▁ circles ▁ are ▁ not ▁ orthogonal . \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if two given Circles are Orthogonal or not | Function to Check if the given circles are orthogonal ; calculating the square of the distance between C1 and C2 ; Check if the given circles are orthogonal ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9149-9149",
        "Code": "def area ( d1 , a ) : NEW_LINE INDENT d2 = ( 4 * ( a ** 2 ) - d1 ** 2 ) ** 0.5 NEW_LINE area = 0.5 * d1 * d2 NEW_LINE return ( area ) NEW_LINE DEDENT d = 7.07 NEW_LINE a = 5 NEW_LINE print ( area ( d , a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate area of a rhombus whose one side and diagonal are given | function to calculate the area of the rhombus ; Second diagonal ; area of rhombus ; return the area ; driver code",
        "Category": "Math"
    },
    {
        "ID": "9150-9150",
        "Code": "dx = [ - 1 , 0 , 1 , 0 ] NEW_LINE dy = [ 0 , 1 , 0 , - 1 ] NEW_LINE def ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) NEW_LINE c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) NEW_LINE if ( ( a == ( b + c ) and a != 0 and b != 0 and c != 0 ) or ( b == ( a + c ) and a != 0 and b != 0 and c != 0 ) or ( c == ( a + b ) and a != 0 and b != 0 and c != 0 ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def isValidCombination ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE possible = 0 NEW_LINE if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) : NEW_LINE INDENT print ( \" ALREADY ▁ RIGHT ▁ ANGLED \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT x = dx [ i ] + x1 NEW_LINE y = dy [ i ] + y1 NEW_LINE if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) : NEW_LINE INDENT print ( \" POSSIBLE \" ) NEW_LINE return NEW_LINE DEDENT x = dx [ i ] + x2 NEW_LINE y = dy [ i ] + y2 NEW_LINE if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) : NEW_LINE INDENT print ( \" POSSIBLE \" ) NEW_LINE return NEW_LINE DEDENT x = dx [ i ] + x3 NEW_LINE y = dy [ i ] + y3 NEW_LINE if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) : NEW_LINE INDENT print ( \" POSSIBLE \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( possible == 0 ) : NEW_LINE INDENT print ( \" NOT ▁ POSSIBLE \" ) NEW_LINE DEDENT DEDENT x1 = - 49 NEW_LINE y1 = 0 NEW_LINE x2 = 0 NEW_LINE y2 = 50 NEW_LINE x3 = 0 NEW_LINE y3 = - 50 NEW_LINE isValidCombination ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE",
        "Type": "py",
        "NL": "Check if a right | Storing all the possible changes to make the triangle right - angled ; Function to check if the triangle is right - angled or not ; Function to check if the triangle can be transformed to right - angled ; Boolean variable to return true or false ; If it is already right - angled ; Applying the changes on the co - ordinates ; Applying on the first co - ordinate ; Applying on the second co - ordinate ; Applying on the third co - ordinate ; If can 't be transformed ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9151-9151",
        "Code": "import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len / ( 2 * math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find Area of Triangle inscribed in N | Python3 Program to find the area of a triangle inscribed in N - sided regular polygon ; Function to find the area of the polygon ; area of a regular polygon with N sides and side length len ; Function to find the area of a triangle ; area of one triangle in an N - sided regular polygon ; area of inscribed triangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9153-9153",
        "Code": "def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT fx1 = a * x1 + b * y1 - c NEW_LINE fx2 = a * x2 + b * y2 - c NEW_LINE if ( ( fx1 * fx2 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c = 1 , 1 , 1 NEW_LINE x1 , y1 = 1 , 1 NEW_LINE x2 , y2 = 2 , 1 NEW_LINE if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether two points ( x1 , y1 ) and ( x2 , y2 ) lie on same side of a given line or not | Function to check if two points lie on the same side or not ; fx1 = 0 Variable to store a * x1 + b * y1 - c fx2 = 0 Variable to store a * x2 + b * y2 - c ; If fx1 and fx2 have same sign ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9157-9157",
        "Code": "PI = 3.14 NEW_LINE from math import pow , sqrt NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 4 NEW_LINE d = 5 NEW_LINE print ( find_area ( r , d ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find area of the larger circle when radius of the smaller circle and difference in the area is given | Python 3 implementation of the approach ; Function to return the area of the bigger circle ; Find the radius of the bigger circle ; Calculate the area of the bigger circle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9158-9158",
        "Code": "def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT a = 80 ; b = 70 ; c = 100 ; d = 110 ; NEW_LINE if ( Valid ( a , b , c , d ) ) : NEW_LINE INDENT print ( \" Valid ▁ quadrilateral \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid ▁ quadrilateral \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether Quadrilateral is valid or not if angles are given | Function to check if a given quadrilateral is valid or not ; Check condition ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9161-9161",
        "Code": "def calculate_angle ( n ) : NEW_LINE INDENT total_angle = 360 ; NEW_LINE return ( total_angle // n ) NEW_LINE DEDENT N = 5 NEW_LINE print ( calculate_angle ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Central angle of a N sided Regular Polygon | Function to calculate central angle of a polygon ; Calculate the angle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9164-9164",
        "Code": "import math NEW_LINE PI = 3.14159 / 180 ; NEW_LINE def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT a = 4 ; b = 7 ; angle = 78 ; NEW_LINE print ( \" Area ▁ of ▁ Kite ▁ = ▁ \" , areaOfKite ( a , b , angle ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate the area of Kite | Python implementation of the approach ; Function to return the area of the kite ; convert angle degree to radians ; use above formula ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9166-9166",
        "Code": "def angleOncirCumference ( z ) : NEW_LINE INDENT return ( z / 2 ) ; NEW_LINE DEDENT angle = 65 ; NEW_LINE z = angleOncirCumference ( angle ) ; NEW_LINE print ( \" The ▁ angle ▁ is \" , ( z ) , \" degrees \" ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate angle on circumference subtended by the chord when the central angle subtended by the chord is given | Python3 Program to calculate angle on the circumference subtended by the chord when the central angle subtended by the chord is given ; Angle on center",
        "Category": "Math"
    },
    {
        "ID": "9168-9168",
        "Code": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage ▁ increase \" \" in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ \" , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , \" % \" ) ; NEW_LINE DEDENT x = 10 ; NEW_LINE newvol ( x ) ; NEW_LINE",
        "Type": "py",
        "NL": "Percentage increase in volume of the cube if a side of cube is increased by a given percentage | Python program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9170-9170",
        "Code": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage ▁ increase ▁ in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ \" , x , \" % \" ) NEW_LINE DEDENT x = 10.0 NEW_LINE newvol ( x ) NEW_LINE",
        "Type": "py",
        "NL": "Percentage increase in the cylinder if the height is increased by given percentage but radius remains constant | Python3 program to find percentage increase in the cylinder if the height is increased by given percentage but radius remains constant ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9176-9176",
        "Code": "def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius / 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 ; NEW_LINE print ( \" Area ▁ of ▁ circle ▁ c2 ▁ = \" , innerCirclearea ( radius ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate area of inner circle which passes through center of outer circle and touches its circumference | Function calculate the area of the inner circle ; the radius cannot be negative ; area of the circle ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9178-9178",
        "Code": "def angleequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ subtended ▁ at \" , \" the ▁ center ▁ is \" , z , \" degrees \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 ; NEW_LINE angleequichord ( z ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Angle subtended by the chord when the angle subtended by another chord of same length is given | Python3 program to find the angle subtended at the center by the chord when the angle subtended at center by another chord of equal length is given ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9179-9179",
        "Code": "def lengequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ distance ▁ between ▁ the \" , \" chord ▁ and ▁ the ▁ center ▁ is \" , z ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE lengequichord ( z ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Distance of chord from center when distance between center and another equal length chord is given | Python 3 program to find the distance of chord from center when distance between center and another equal length chord is given ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9180-9180",
        "Code": "def lengperpbisect ( r1 , r2 ) : NEW_LINE INDENT z = 2 * ( ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ** ( 1 / 2 ) ) ; NEW_LINE print ( \" The ▁ length ▁ of ▁ the ▁ perpendicular ▁ bisector ▁ is ▁ \" , z ) ; NEW_LINE DEDENT r1 = 5 ; r2 = 3 ; NEW_LINE lengperpbisect ( r1 , r2 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Length of the perpendicular bisector of the line joining the centers of two circles | Python program to find the Length of the perpendicular bisector of the line joining the centers of two circles in which one lies completely inside touching the bigger circle at one point ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9182-9182",
        "Code": "def lengchord ( z ) : NEW_LINE INDENT print ( \" The ▁ length ▁ is ▁ \" , end = \" \" ) ; NEW_LINE print ( z ) ; NEW_LINE DEDENT z = 48 ; NEW_LINE lengchord ( z ) ; NEW_LINE",
        "Type": "py",
        "NL": "Length of the chord the circle if length of the another chord which is equally inclined through the diameter is given | Python3 program to find the length of the chord of the circle if length of the other chord which is equally inclined through the diameter is given ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9183-9183",
        "Code": "def distcenter ( r1 , r2 , x ) : NEW_LINE INDENT z = ( ( ( r1 * r1 ) - ( x / 2 * x / 2 ) ) ** ( 1 / 2 ) ) + ( ( ( r2 * r2 ) - ( x / 2 * x / 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE print ( \" distance ▁ between ▁ thecenters ▁ is ▁ \" , end = \" \" ) ; NEW_LINE print ( int ( z ) ) ; NEW_LINE DEDENT r1 = 24 ; r2 = 37 ; x = 40 ; NEW_LINE distcenter ( r1 , r2 , x ) ; NEW_LINE",
        "Type": "py",
        "NL": "Distance between centers of two intersecting circles if the radii and common chord length is given | Python program to find the distance between centers of two intersecting circles if the radii and common chord length is given ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9189-9189",
        "Code": "def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) / 2 ) NEW_LINE j = ( i * ( i + 1 ) ) // 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Count of distinct rectangles inscribed in an equilateral triangle | Function to return the count of rectangles when n is odd ; Calculating number of dots in vertical level ; Calculating number of ways to select two points in the horizontal level i ; Multiply both to obtain the number of rectangles formed at that level ; Calculating number of dots in vertical level ; Calculating number of ways to select two points in the horizontal level i ; Multiply both to obtain the number of rectangles formed at that level ; Function to return the count of rectangles when n is even ; Driver code ; If n is odd",
        "Category": "Math"
    },
    {
        "ID": "9191-9191",
        "Code": "def Regions ( Vertices , Edges ) : NEW_LINE INDENT R = Edges + 2 - Vertices ; NEW_LINE return R ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT V = 5 ; E = 7 ; NEW_LINE print ( Regions ( V , E ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the number of region in Planar Graph | Function to return the number of regions in a Planar Graph ; Driver code",
        "Category": "Graph Theory"
    },
    {
        "ID": "9193-9193",
        "Code": "from math import sqrt , pow NEW_LINE def lengthOfTangent ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The ▁ length ▁ of ▁ the ▁ transverse \" , \" common ▁ tangent ▁ is \" , ' { 0 : . 6g } ' . format ( sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r1 = 4 NEW_LINE r2 = 6 NEW_LINE d = 12 NEW_LINE lengthOfTangent ( r1 , r2 , d ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the transverse common tangent between the two non intersecting circles | python 3 program to find the length of the transverse common tangent between two circles which do not touch each other ; Function to find the length of the transverse common tangent ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9198-9198",
        "Code": "def lengtang ( r1 , r2 ) : NEW_LINE INDENT print ( \" The ▁ length ▁ of ▁ the ▁ direct \" , \" common ▁ tangent ▁ is \" , 2 * ( r1 * r2 ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT r1 = 5 ; r2 = 9 ; NEW_LINE lengtang ( r1 , r2 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Length of the direct common tangent between two externally touching circles | Function to find the length of the direct common tangent ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9199-9199",
        "Code": "def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ \" , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 / 2 ) ) - r ) ; NEW_LINE DEDENT x1 = 4 ; NEW_LINE y1 = 6 ; NEW_LINE x2 = 35 ; NEW_LINE y2 = 42 ; NEW_LINE r = 5 ; NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) ; NEW_LINE",
        "Type": "py",
        "NL": "Shortest distance between a point and a circle | Function to find the shortest distance ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9202-9202",
        "Code": "def diameter ( r ) : NEW_LINE INDENT print ( \" The ▁ length ▁ of ▁ the ▁ longest ▁ chord \" , \" ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ \" , 2 * r ) NEW_LINE DEDENT r = 4 NEW_LINE diameter ( r ) NEW_LINE",
        "Type": "py",
        "NL": "Find the Diameter or Longest chord of a Circle | Function to find the longest chord ; Get the radius ; Find the diameter",
        "Category": "Math"
    },
    {
        "ID": "9204-9204",
        "Code": "import math ; NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT m = - 5 ; n = 3 ; NEW_LINE print ( normal ( m , n ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Length of the normal from origin on a straight line whose intercepts are given | Python3 implementation of the approach ; Function to find the normal of the straight line ; Length of the normal ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9210-9210",
        "Code": "def findAreaShaded ( a ) : NEW_LINE INDENT sqArea = a * a ; NEW_LINE semiCircleArea = ( 3.14 * ( a * a ) / 8 ) NEW_LINE ShadedArea = 4 * semiCircleArea - sqArea ; NEW_LINE return ShadedArea ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE print ( findAreaShaded ( a ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the area of the shaded region formed by the intersection of four semicircles in a square | Function to return the area of the shaded region ; Area of the square ; Area of the semicircle ; There are 4 semicircles shadedArea = Area of 4 semicircles - Area of square ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9216-9216",
        "Code": "def isSlopeGood ( slope , arr , n ) : NEW_LINE INDENT setOfLines = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT setOfLines [ arr [ i ] - slope * ( i ) ] = 1 NEW_LINE DEDENT return len ( setOfLines ) == 2 NEW_LINE DEDENT def checkForParallel ( arr , n ) : NEW_LINE INDENT slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) NEW_LINE slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) NEW_LINE slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) // 2 , arr , n ) NEW_LINE return ( slope1 or slope2 or slope3 ) NEW_LINE DEDENT arr = [ 1 , 6 , 3 , 8 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if checkForParallel ( arr , n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find whether only two parallel lines contain all coordinates points or not | Find if slope is good with only two intercept ; if set of lines have only two distinct intercept ; Function to check if required solution exist ; check the result by processing the slope by starting three points ; Driver code",
        "Category": "Hash Table"
    },
    {
        "ID": "9217-9217",
        "Code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count paths with distance equal to Manhattan distance | Function to return the value of nCk ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; Function to return the number of paths ; Difference between the ' x ' coordinates of the given points ; Difference between the ' y ' coordinates of the given points ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "922-922",
        "Code": "def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) - 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' c ' + str [ n + 1 : ] ; NEW_LINE break ; NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' a ' + str [ n + 1 : ] ; NEW_LINE break ; NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' b ' + str [ n + 1 : ] ; NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' d ' + str [ n + 1 : ] ; NEW_LINE DEDENT n -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" aacbddc \" ; NEW_LINE print ( \" Left ▁ of \" , str , \" is \" , findLeft ( str ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Return previous element in an expanding matrix | Returns left of str in an expanding matrix of a , b , c , and d . ; Start from rightmost position ; If the current character is b or d , change to a or c respectively and break the loop ; If the current character is a or c , change it to b or d respectively ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "9223-9223",
        "Code": "def maxRectangles ( L , B , l , b ) : NEW_LINE INDENT horizontal , vertical = 0 , 0 NEW_LINE if l <= L and b <= B : NEW_LINE INDENT columns = B // b NEW_LINE rows = L // l NEW_LINE horizontal = rows * columns NEW_LINE DEDENT if l <= B and b <= L : NEW_LINE INDENT columns = L // b NEW_LINE rows = B // l NEW_LINE vertical = rows * columns NEW_LINE DEDENT return max ( horizontal , vertical ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , B , l , b = 10 , 7 , 4 , 3 NEW_LINE print ( maxRectangles ( L , B , l , b ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum given sized rectangles that can be cut out of a sheet of paper | Function to return the maximum rectangles possible ; Cut rectangles horizontally if possible ; One rectangle is a single cell ; Total rectangles = total cells ; Cut rectangles vertically if possible ; Return the maximum possible rectangles ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9231-9231",
        "Code": "def checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT if ( x2 - x1 == 0 and x4 - x3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( x2 - x1 == 0 ) : NEW_LINE INDENT m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( x4 - x3 == 0 ) : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) ; NEW_LINE if ( m1 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m1 * m2 == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 4 NEW_LINE x2 = 0 NEW_LINE y2 = - 9 NEW_LINE x3 = 2 NEW_LINE y3 = 0 NEW_LINE x4 = - 1 NEW_LINE y4 = 0 NEW_LINE if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether two straight lines are orthogonal or not | Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9239-9239",
        "Code": "import math as mt NEW_LINE def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEW_LINE DEDENT a , n = 9 , 10 NEW_LINE print ( polydiagonal ( n , a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of Diagonal of a n | Python3 Program to find the diagonal of a regular polygon with given side length ; Function to find the diagonal of a regular polygon ; Side and side length cannot be negative ; diagonal degree converted to radians ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9245-9245",
        "Code": "def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT x = 0.5176 * a ; NEW_LINE return x ; NEW_LINE DEDENT a = 6 ; NEW_LINE print ( hexagonside ( a ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Largest hexagon that can be inscribed within a square | Function to return the side of the hexagon ; Side cannot be negative ; Side of the hexagon ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9246-9246",
        "Code": "def hexagonside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a // 3 NEW_LINE return x NEW_LINE DEDENT a = 6 NEW_LINE print ( hexagonside ( a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Largest hexagon that can be inscribed within an equilateral triangle | function to find the side of the hexagon ; Side cannot be negative ; Side of the hexagon ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9253-9253",
        "Code": "from math import sqrt , pow NEW_LINE def CubeVolume ( d ) : NEW_LINE INDENT Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 NEW_LINE return Volume NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = 5 NEW_LINE print ( \" Volume ▁ of ▁ Cube : \" , ' { 0 : . 6 } ' . format ( CubeVolume ( d ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Volume of cube using its space diagonal | Python 3 program to find the volume occupied by Cube with given space diagonal ; Function to calculate Volume ; Formula to find Volume ; Drivers code ; space diagonal of Cube",
        "Category": "Math"
    },
    {
        "ID": "9254-9254",
        "Code": "from math import sqrt NEW_LINE def hexagonArea ( d ) : NEW_LINE INDENT return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = 10 NEW_LINE print ( \" Area ▁ of ▁ hexagon : \" , round ( hexagonArea ( d ) , 3 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Area of hexagon with given diagonal length | Python3 program to find the area of Hexagon with given diagonal ; Function to calculate area ; Formula to find area ; Driver ode",
        "Category": "Math"
    },
    {
        "ID": "9260-9260",
        "Code": "PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Length of rope tied around three equal circles touching each other | Python3 code to find the length of rope ; Function to find the length of rope ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9263-9263",
        "Code": "PI = 3.14159265 NEW_LINE def area_cicumscribed ( c ) : NEW_LINE INDENT return ( c * c * ( PI / 4 ) ) NEW_LINE DEDENT c = 8.0 NEW_LINE print ( area_cicumscribed ( c ) ) NEW_LINE",
        "Type": "py",
        "NL": "Area of Circumcircle of a Right Angled Triangle | Python3 code to find the area of circumscribed circle of right angled triangle ; Function to find the area of circumscribed circle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9277-9277",
        "Code": "from math import sqrt NEW_LINE def maxVol ( P , A ) : NEW_LINE INDENT l = ( P - sqrt ( P * P - 24 * A ) ) / 12 NEW_LINE V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) NEW_LINE return V NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = 20 NEW_LINE A = 16 NEW_LINE print ( maxVol ( P , A ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find maximum volume of a cuboid from the given perimeter and area | Python3 implementation of the above approach ; function to return maximum volume ; calculate length ; calculate volume ; return result ; Driver code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9278-9278",
        "Code": "from math import sqrt , pow NEW_LINE def rhombusAreaPeri ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) NEW_LINE print ( \" The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals \" , d1 , \" and \" , d2 , \" is \" , area , \" . \" ) NEW_LINE print ( \" The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals \" , d1 , \" and \" , d2 , \" is \" , perimeter , \" . \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 = 2 NEW_LINE d2 = 4 NEW_LINE rhombusAreaPeri ( d1 , d2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate area and perimeter of a rhombus whose diagonals are given | Python 3 Program to calculate area and perimeter of a rhombus using diagonals ; calculate area and perimeter of a rhombus ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9281-9281",
        "Code": "from math import ceil , floor NEW_LINE def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 38 NEW_LINE print ( \" Maximum ▁ Area ▁ = \" , maxArea ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum area of rectangle possible with given perimeter | Python3 program to find maximum area rectangle ; Function to find max area ; return area ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9287-9287",
        "Code": "def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 ; NEW_LINE b = - 2 * y1 ; NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; NEW_LINE print ( \" x ^ 2 ▁ + ▁ ( \" , a , \" x ) ▁ + ▁ \" , end = \" \" ) ; NEW_LINE print ( \" y ^ 2 ▁ + ▁ ( \" , b , \" y ) ▁ = ▁ \" , end = \" \" ) ; NEW_LINE print ( c , \" . \" ) ; NEW_LINE DEDENT x1 = 2 ; NEW_LINE y1 = - 3 ; NEW_LINE r = 8 ; NEW_LINE circle_equation ( x1 , y1 , r ) ; NEW_LINE",
        "Type": "py",
        "NL": "Equation of circle from center and radius | Function to find the equation of circle ; Printing result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9288-9288",
        "Code": "def section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) : NEW_LINE INDENT x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) NEW_LINE y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) NEW_LINE z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) NEW_LINE print ( \" ( \" , x , \" , \" , y , \" , \" , z , \" ) \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 2 NEW_LINE x2 = 4 NEW_LINE y1 = - 1 NEW_LINE y2 = 3 NEW_LINE z1 = 4 NEW_LINE z2 = 2 NEW_LINE m = 2 NEW_LINE n = 3 NEW_LINE section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Section formula for 3 D | Function to find the section of the line ; Applying section formula ; Printing result ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9291-9291",
        "Code": "def area ( r ) : NEW_LINE INDENT return ( 0.5 ) * ( 3.14 ) * ( r * r ) NEW_LINE DEDENT def perimeter ( r ) : NEW_LINE INDENT return ( 3.14 ) * ( r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 10 NEW_LINE print ( \" The ▁ Area ▁ of ▁ Semicircle : ▁ \" , area ( r ) ) NEW_LINE print ( \" The ▁ Perimeter ▁ of ▁ Semicircle : ▁ \" , perimeter ( r ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Area and Perimeter of a Semicircle | Function for calculating the area ; Formula for finding the area ; Function for calculating the perimeter ; Formula for finding the perimeter ; driver code ; Get the radius ; Find the area ; Find the perimeter",
        "Category": "Math"
    },
    {
        "ID": "9292-9292",
        "Code": "def checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT resx = x1 + x2 + x3 NEW_LINE resy = y1 + y2 + y3 NEW_LINE resz = z1 + z2 + z3 NEW_LINE if ( resx == 0 and resy == 0 and resz == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x1 = - 2 ; y1 = - 7 ; z1 = - 9 NEW_LINE x2 = 5 ; y2 = - 14 ; z2 = 14 NEW_LINE x3 = - 3 ; y3 = 21 ; z3 = - 5 NEW_LINE if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) : NEW_LINE INDENT print ( \" The ▁ vectors ▁ are ▁ at ▁ equilibrium . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if the given vectors are at equilibrium or not | Function to check the equilibrium of three vectors ; summing the x coordinates ; summing the y coordinates ; summing the z coordinates ; Checking the condition for equilibrium ; Driver code ; Checking for equilibrium",
        "Category": "Math"
    },
    {
        "ID": "9293-9293",
        "Code": "def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if y == ( 2 * x - x * x ) : NEW_LINE INDENT if dif < 0 : NEW_LINE INDENT print ( \" y ▁ = \" , dif , \" x \" , ( x * dif ) + ( y ) ) NEW_LINE DEDENT elif dif > 0 : NEW_LINE INDENT print ( \" y ▁ = \" , dif , \" x + \" , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , x , y = 2 , 2 , 0 NEW_LINE findTangent ( A , x , y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Tangent at a given point on the curve | function for find Tangent ; differentiate given equation ; check that point on the curve or not ; if differentiate is negative ; differentiate is positive ; differentiate is zero ; Driver code ; declare variable ; call function findTangent",
        "Category": "Math"
    },
    {
        "ID": "9296-9296",
        "Code": "import math NEW_LINE def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE print ( octadiagonal ( a ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of the Diagonal of the Octagon | Python3 Program to find the diagonal of the octagon ; Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9298-9298",
        "Code": "def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( \" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ \" , Perimeter ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT CalPeri ( ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to Calculate the Perimeter of a Decagon | Function for finding the perimeter ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9300-9300",
        "Code": "from math import sqrt , ceil , floor NEW_LINE def dis ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE DEDENT def check ( c1 , c2 , k ) : NEW_LINE INDENT min = 0 NEW_LINE max = 0 NEW_LINE de = dis ( c1 [ 0 ] , c1 [ 1 ] , c2 [ 0 ] , c2 [ 1 ] ) NEW_LINE if ( de == 0 ) : NEW_LINE INDENT if ( c1 [ 2 ] == c2 [ 2 ] ) : NEW_LINE INDENT min = 0 NEW_LINE max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c1 [ 2 ] - c2 [ 2 ] > 0 ) : NEW_LINE INDENT min = c1 [ 2 ] - c2 [ 2 ] NEW_LINE max = min + 2 * c2 [ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT min = c2 [ 2 ] - c1 [ 2 ] NEW_LINE max = min + 2 * c1 [ 2 ] NEW_LINE DEDENT DEDENT DEDENT elif ( de >= c1 [ 2 ] + c2 [ 2 ] ) : NEW_LINE INDENT min = de - c1 [ 2 ] - c2 [ 2 ] NEW_LINE max = de + c1 [ 2 ] + c2 [ 2 ] NEW_LINE DEDENT elif ( de + c2 [ 2 ] < c1 [ 2 ] ) : NEW_LINE INDENT max = c2 [ 2 ] + c1 [ 2 ] + de NEW_LINE min = c1 [ 2 ] - de - c2 [ 2 ] NEW_LINE DEDENT elif ( de + c1 [ 2 ] < c2 [ 2 ] ) : NEW_LINE INDENT max = c2 [ 2 ] + c1 [ 2 ] + de NEW_LINE min = c2 [ 2 ] - de - c1 [ 2 ] NEW_LINE DEDENT elif ( ( de + c2 [ 2 ] >= c1 [ 2 ] ) or ( de + c1 [ 2 ] >= c2 [ 2 ] ) ) : NEW_LINE INDENT max = c2 [ 2 ] + c1 [ 2 ] + de NEW_LINE min = 0 NEW_LINE DEDENT temin = ceil ( min ) NEW_LINE re = max NEW_LINE if ( k >= temin and k <= re ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT circle1 = [ 0 , 0 , 5 ] NEW_LINE circle2 = [ 8 , 3 , 2 ] NEW_LINE k = 3 NEW_LINE if ( check ( circle1 , circle2 , k ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check whether it is possible to join two points given on circle such that distance between them is k | Python3 program to implement above approach ; Return distance between the centers ; Distance between centers ; Case 5 ; SubCase 1 ; Subcase 2 ; Case 1 ; Case 3 ; Case 4 ; Case 2 ; Since value of k wialways be an integer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9301-9301",
        "Code": "import math NEW_LINE def findEdges ( s1 , s2 , s3 ) : NEW_LINE INDENT a = math . sqrt ( s1 * s2 / s3 ) NEW_LINE b = math . sqrt ( s3 * s1 / s2 ) NEW_LINE c = math . sqrt ( s3 * s2 / s1 ) NEW_LINE sum = a + b + c NEW_LINE return 4 * sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = 65 NEW_LINE s2 = 156 NEW_LINE s3 = 60 NEW_LINE print ( int ( findEdges ( s1 , s2 , s3 ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of lengths of all 12 edges of any rectangular parallelepiped | Python3 program to illustrate the above problem ; function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; Driver code ; initialize the area of three faces which has a common vertex",
        "Category": "Math"
    },
    {
        "ID": "9310-9310",
        "Code": "from math import pi NEW_LINE def circle_inscribed ( a ) : NEW_LINE INDENT return pi * ( a * a ) / 12 NEW_LINE DEDENT a = 4 NEW_LINE print ( circle_inscribed ( a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Area of circle which is inscribed in equilateral triangle | Python3 program to find the area of circle which is inscribed in equilateral triangle ; Function return the area of circle inscribed in equilateral triangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9311-9311",
        "Code": "def surfaceArea ( a , b , h ) : NEW_LINE INDENT return 5 * a * b + 5 * b * h NEW_LINE DEDENT def volume ( b , h ) : NEW_LINE INDENT return ( 5 * b * h ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE h = 7 NEW_LINE print ( \" surface ▁ area ▁ = \" , surfaceArea ( a , b , h ) , \" , \" , \" volume ▁ = \" , volume ( b , h ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find volume and surface area of pentagonal prism | function for surface area ; function for VOlume ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9314-9314",
        "Code": "import math NEW_LINE def altitude ( a , b ) : NEW_LINE INDENT return math . sqrt ( pow ( a , 2 ) - ( pow ( b , 2 ) / 4 ) ) NEW_LINE DEDENT def area ( b , h ) : NEW_LINE INDENT return ( 1 * b * h ) / 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE h = altitude ( a , b ) NEW_LINE print ( \" Altitude ▁ = ▁ \" + str ( round ( h , 3 ) ) , end = \" , ▁ \" ) NEW_LINE print ( \" Area ▁ = ▁ \" + str ( round ( area ( b , h ) , 3 ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the altitude and area of an isosceles triangle | Python 3 program to find the Altitude Area of an isosceles triangle ; function to find the altitude ; return altitude ; function to find the area ; return area ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9320-9320",
        "Code": "def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 NEW_LINE x , y = 51 , 100 NEW_LINE halfsquare ( n , x , y ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if any square ( with one colored cell ) can be divided into two equal parts | function to check if it 's possible to divide the square in two equal parts ; if the painted square is linked anyway to the center of the square then it 's  not possible ; else yes it 's possible ; Driver code ; initialize the size of the square ; initialize the dimension of the painted square",
        "Category": "Math"
    },
    {
        "ID": "9326-9326",
        "Code": "from math import * NEW_LINE def findVolume ( u , v , w , U , V , W , b ) : NEW_LINE INDENT uPow = pow ( u , 2 ) NEW_LINE vPow = pow ( v , 2 ) NEW_LINE wPow = pow ( w , 2 ) NEW_LINE UPow = pow ( U , 2 ) NEW_LINE VPow = pow ( V , 2 ) NEW_LINE WPow = pow ( W , 2 ) NEW_LINE a = ( 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ) NEW_LINE vol = sqrt ( a ) NEW_LINE vol /= b NEW_LINE print ( round ( vol , 4 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT u , v , w = 1000 , 1000 , 1000 NEW_LINE U , V , W = 3 , 4 , 5 NEW_LINE b = 12 NEW_LINE findVolume ( u , v , w , U , V , W , b ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find the Volume of an irregular tetrahedron | Python 3 implementation of above approach ; Function to find the volume ; Steps to calculate volume of a Tetrahedron using formula ; Driver code ; edge lengths",
        "Category": "Math"
    },
    {
        "ID": "933-933",
        "Code": "ROW = 4 NEW_LINE COL = 5 NEW_LINE def findUniqueRows ( M ) : NEW_LINE INDENT for i in range ( ROW ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT flag = 1 NEW_LINE for k in range ( COL ) : NEW_LINE INDENT if ( M [ i ] [ k ] != M [ j ] [ k ] ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT print ( M [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = [ [ 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 0 ] , [ 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 0 , 0 ] ] NEW_LINE findUniqueRows ( M ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Print unique rows in a given boolean matrix | Given a binary matrix of M X N of integers , you need to return only unique rows of binary array ; The main function that prints all unique rows in a given matrix . ; Traverse through the matrix ; Check if there is similar column is already printed , i . e if i and jth column match . ; If no row is similar ; Print the row ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9342-9342",
        "Code": "import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum squares to cover a rectangle | Python3 program to find the minimum number of squares to cover the surface of the rectangle with given dimensions ; function to count the number of squares that can cover the surface of the rectangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9344-9344",
        "Code": "import math NEW_LINE def angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) : NEW_LINE INDENT num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) NEW_LINE den = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) * math . sqrt ( ( x3 - x1 ) ** 2 + ( y3 - y1 ) ** 2 + ( z3 - z1 ) ** 2 ) NEW_LINE angle = math . degrees ( math . acos ( num / den ) ) NEW_LINE return round ( angle , 3 ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 2 NEW_LINE x2 = 2 NEW_LINE y2 = 3 NEW_LINE z2 = 5 NEW_LINE x3 = 3 NEW_LINE y3 = 5 NEW_LINE z3 = - 2 NEW_LINE angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) NEW_LINE angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) NEW_LINE angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) NEW_LINE print ( \" Angles ▁ are ▁ : \" ) NEW_LINE print ( \" angle ▁ A ▁ = ▁ \" , angle_A , \" degree \" ) NEW_LINE print ( \" angle ▁ B ▁ = ▁ \" , angle_B , \" degree \" ) NEW_LINE print ( \" angle ▁ C ▁ = ▁ \" , angle_C , \" degree \" ) NEW_LINE",
        "Type": "py",
        "NL": "Find all angles of a triangle in 3D | Python Code for finding all angles of a triangle ; function for finding the angle ; driver code",
        "Category": "Math"
    },
    {
        "ID": "9345-9345",
        "Code": "def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ \" + str ( n ) + \" ▁ is ▁ \" + str ( findMaximumPieces ( 3 ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number of pieces in N cuts | Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Driver code ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces",
        "Category": "Math"
    },
    {
        "ID": "9347-9347",
        "Code": "def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 90 NEW_LINE makePolygon ( a ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to create a polygon with a given angle | Function to check whether it is possible to make a regular polygon with a given angle . ; N denotes the number of sides of polygons possible ; Driver Code ; function calling",
        "Category": "Math"
    },
    {
        "ID": "9350-9350",
        "Code": "def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( \" Coplanar \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Coplanar \" ) NEW_LINE DEDENT DEDENT x1 = 3 NEW_LINE y1 = 2 NEW_LINE z1 = - 5 NEW_LINE x2 = - 1 NEW_LINE y2 = 4 NEW_LINE z2 = - 3 NEW_LINE x3 = - 3 NEW_LINE y3 = 8 NEW_LINE z3 = - 5 NEW_LINE x4 = - 3 NEW_LINE y4 = 2 NEW_LINE z4 = 1 NEW_LINE / * function calling * / NEW_LINE equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) NEW_LINE",
        "Type": "py",
        "NL": "Program to check whether 4 points in a 3 | Function to find equation of plane . ; checking if the 4 th point satisfies the above equation ; Driver Code ;",
        "Category": "Math"
    },
    {
        "ID": "9361-9361",
        "Code": "import math NEW_LINE def distance ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT d = ( a1 * a2 + b1 * b2 + c1 * c2 ) NEW_LINE e1 = math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) NEW_LINE e2 = math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) NEW_LINE d = d / ( e1 * e2 ) NEW_LINE A = math . degrees ( math . acos ( d ) ) NEW_LINE print ( \" Angle ▁ is \" ) , A , ( \" degree \" ) NEW_LINE DEDENT a1 = 1 NEW_LINE b1 = 1 NEW_LINE c1 = 2 NEW_LINE d1 = 1 NEW_LINE a2 = 2 NEW_LINE b2 = - 1 NEW_LINE c2 = 1 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , a2 , b2 , c2 ) NEW_LINE",
        "Type": "py",
        "NL": "Angle between two Planes in 3D | Python program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9363-9363",
        "Code": "import math NEW_LINE def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) ; NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lat1 = 51.5007 NEW_LINE lon1 = 0.1246 NEW_LINE lat2 = 40.6892 NEW_LINE lon2 = 74.0445 NEW_LINE print ( haversine ( lat1 , lon1 , lat2 , lon2 ) , \" K . M . \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Haversine formula to find distance between two points on a sphere | Python 3 program for the haversine formula ; distance between latitudes and longitudes ; convert to radians ; apply formulae ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9368-9368",
        "Code": "def octant ( x , y , z ) : NEW_LINE INDENT if x >= 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 1st ▁ octant \" NEW_LINE DEDENT elif x < 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 2nd ▁ octant \" NEW_LINE DEDENT elif x < 0 and y < 0 and z >= 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 3rd ▁ octant \" NEW_LINE DEDENT elif x >= 0 and y < 0 and z >= 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 4th ▁ octant \" NEW_LINE DEDENT elif x >= 0 and y >= 0 and z < 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 5th ▁ octant \" NEW_LINE DEDENT elif x < 0 and y >= 0 and z < 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 6th ▁ octant \" NEW_LINE DEDENT elif x < 0 and y < 0 and z < 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 7th ▁ octant \" NEW_LINE DEDENT elif x >= 0 and y < 0 and z < 0 : NEW_LINE INDENT print \" Point ▁ lies ▁ in ▁ 8th ▁ octant \" NEW_LINE DEDENT DEDENT x , y , z = 2 , 3 , 4 NEW_LINE octant ( x , y , z ) NEW_LINE x , y , z = - 4 , 2 , - 8 NEW_LINE octant ( x , y , z ) NEW_LINE x , y , z = - 6 , - 2 , 8 NEW_LINE octant ( x , y , z ) NEW_LINE",
        "Type": "py",
        "NL": "Program to determine the octant of the axial plane | Function to print octant ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "937-937",
        "Code": "R = 3 NEW_LINE C = 5 NEW_LINE def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 0 ] ] NEW_LINE print ( \" Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is \" , maxArea ( mat ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the largest rectangle of 1 's with swapping of columns allowed | Python 3 program to find the largest rectangle of 1 's with swapping of columns allowed. ; Returns area of the largest rectangle of 1 's ; An auxiliary array to store count of consecutive 1 's in every column. ; Step 1 : Fill the auxiliary array hist [ ] [ ] ; First row in hist [ ] [ ] is copy of first row in mat [ ] [ ] ; Fill remaining rows of hist [ ] [ ] ; Step 2 : Sort rows of hist [ ] [ ] in non - increasing order ; counting occurrence ; Traverse the count array from right side ; Step 3 : Traverse the sorted hist [ ] [ ] to find maximum area ; Since values are in decreasing order , The area ending with cell ( i , j ) can be obtained by multiplying column number with value of hist [ i ] [ j ] ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9371-9371",
        "Code": "def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT radius = 2 NEW_LINE totalRectangles = countRectangles ( radius ) NEW_LINE print ( totalRectangles , \" rectangles ▁ can ▁ be \" , \" cut ▁ from ▁ a ▁ circle ▁ of ▁ Radius \" , radius ) NEW_LINE",
        "Type": "py",
        "NL": "Number of rectangles in a circle of radius R | Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's Diagonal  Length is less than the  Diameter, it is a valid  rectangle, thus increment counter ; Radius of the circle",
        "Category": "Math"
    },
    {
        "ID": "9383-9383",
        "Code": "import math NEW_LINE def getQuadrant ( X , Y , R , PX , PY ) : NEW_LINE INDENT if ( PX == X and PY == Y ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT val = ( math . pow ( ( PX - X ) , 2 ) + math . pow ( ( PY - Y ) , 2 ) ) ; NEW_LINE if ( val > pow ( R , 2 ) ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( PX > X and PY >= Y ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( PX <= X and PY > Y ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( PX < X and PY <= Y ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT if ( PX >= X and PY < Y ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT DEDENT X = 0 ; NEW_LINE Y = 3 ; NEW_LINE R = 2 ; NEW_LINE PX = 1 ; NEW_LINE PY = 4 ; NEW_LINE ans = getQuadrant ( X , Y , R , PX , PY ) ; NEW_LINE if ( ans == - 1 ) : print ( \" Lies ▁ Outside ▁ the ▁ circle \" ) ; NEW_LINE elif ( ans == 0 ) : print ( \" Coincides ▁ with ▁ centre \" ) ; NEW_LINE else : print ( ans , \" Quadrant \" ) ; NEW_LINE",
        "Type": "py",
        "NL": "Finding Quadrant of a Coordinate with respect to a Circle | Python3 Program to find the quadrant of a given coordinate w . rt . the centre of a circle ; Thus function returns the quadrant number ; Coincides with center ; Outside circle ; 1 st quadrant ; 2 nd quadrant ; 3 rd quadrant ; 4 th quadrant ; Coordinates of centre ; Radius of circle ; Coordinates of the given po",
        "Category": "Math"
    },
    {
        "ID": "939-939",
        "Code": "M = 4 NEW_LINE N = 5 NEW_LINE def preProcess ( mat , aux ) : NEW_LINE INDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT aux [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( 1 , M , 1 ) : NEW_LINE INDENT for j in range ( 0 , N , 1 ) : NEW_LINE INDENT aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , M , 1 ) : NEW_LINE INDENT for j in range ( 1 , N , 1 ) : NEW_LINE INDENT aux [ i ] [ j ] += aux [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def sumQuery ( aux , tli , tlj , rbi , rbj ) : NEW_LINE INDENT res = aux [ rbi ] [ rbj ] NEW_LINE if ( tli > 0 ) : NEW_LINE INDENT res = res - aux [ tli - 1 ] [ rbj ] NEW_LINE DEDENT if ( tlj > 0 ) : NEW_LINE INDENT res = res - aux [ rbi ] [ tlj - 1 ] NEW_LINE DEDENT if ( tli > 0 and tlj > 0 ) : NEW_LINE INDENT res = res + aux [ tli - 1 ] [ tlj - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 , 4 , 6 ] , [ 5 , 3 , 8 , 1 , 2 ] , [ 4 , 6 , 7 , 5 , 5 ] , [ 2 , 4 , 8 , 9 , 4 ] ] NEW_LINE DEDENT aux = [ [ 0 for i in range ( N ) ] for j in range ( M ) ] NEW_LINE preProcess ( mat , aux ) NEW_LINE tli = 2 NEW_LINE tlj = 2 NEW_LINE rbi = 3 NEW_LINE rbj = 4 NEW_LINE print ( \" Query1 : \" , sumQuery ( aux , tli , tlj , rbi , rbj ) ) NEW_LINE tli = 0 NEW_LINE tlj = 0 NEW_LINE rbi = 1 NEW_LINE rbj = 1 NEW_LINE print ( \" Query2 : \" , sumQuery ( aux , tli , tlj , rbi , rbj ) ) NEW_LINE tli = 1 NEW_LINE tlj = 2 NEW_LINE rbi = 3 NEW_LINE rbj = 3 NEW_LINE print ( \" Query3 : \" , sumQuery ( aux , tli , tlj , rbi , rbj ) ) NEW_LINE",
        "Type": "py",
        "NL": "Submatrix Sum Queries | Python 3 program to compute submatrix query sum in O ( 1 ) time ; Function to preprcess input mat [ M ] [ N ] . This function mainly fills aux [ M ] [ N ] such that aux [ i ] [ j ] stores sum of elements from ( 0 , 0 ) to ( i , j ) ; Copy first row of mat [ ] [ ] to aux [ ] [ ] ; Do column wise sum ; Do row wise sum ; A O ( 1 ) time function to compute sum of submatrix between ( tli , tlj ) and ( rbi , rbj ) using aux [ ] [ ] which is built by the preprocess function ; result is now sum of elements between ( 0 , 0 ) and ( rbi , rbj ) ; Remove elements between ( 0 , 0 ) and ( tli - 1 , rbj ) ; Remove elements between ( 0 , 0 ) and ( rbi , tlj - 1 ) ; Add aux [ tli - 1 ] [ tlj - 1 ] as elements between ( 0 , 0 ) and ( tli - 1 , tlj - 1 ) are subtracted twice ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9392-9392",
        "Code": "def centereddecagonalnum ( n ) : NEW_LINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" th ▁ centered ▁ decagonal ▁ \" + \" number ▁ : ▁ \" , centereddecagonalnum ( n ) ) NEW_LINE n = 9 NEW_LINE print ( n , \" th ▁ centered ▁ decagonal ▁ \" + \" number ▁ : ▁ \" , centereddecagonalnum ( n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Centered decagonal number | Centered decagonal number function ; Formula to calculate nth centered decagonal number & return it into main function . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "94-94",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT inorder ( root . left ) NEW_LINE print \" TABSYMBOL % d \" % ( root . data ) , NEW_LINE inorder ( root . right ) NEW_LINE DEDENT DEDENT def fixPrevPtr ( root ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT fixPrevPtr ( root . left ) NEW_LINE root . left = fixPrevPtr . pre NEW_LINE fixPrevPtr . pre = root NEW_LINE fixPrevPtr ( root . right ) NEW_LINE DEDENT DEDENT def fixNextPtr ( root ) : NEW_LINE INDENT prev = None NEW_LINE while ( root and root . right != None ) : NEW_LINE INDENT root = root . right NEW_LINE DEDENT while ( root and root . left != None ) : NEW_LINE INDENT prev = root NEW_LINE root = root . left NEW_LINE root . right = prev NEW_LINE DEDENT return root NEW_LINE DEDENT def BTToDLL ( root ) : NEW_LINE INDENT fixPrevPtr ( root ) NEW_LINE return fixNextPtr ( root ) NEW_LINE DEDENT def printList ( root ) : NEW_LINE INDENT while ( root != None ) : NEW_LINE INDENT print \" TABSYMBOL % d \" % ( root . data ) , NEW_LINE root = root . right NEW_LINE DEDENT DEDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 12 ) NEW_LINE root . right = Node ( 15 ) NEW_LINE root . left . left = Node ( 25 ) NEW_LINE root . left . right = Node ( 30 ) NEW_LINE root . right . left = Node ( 36 ) NEW_LINE print   \" NEW_LINE INDENT Inorder Tree Traversal NEW_LINE DEDENT \" NEW_LINE inorder ( root ) NEW_LINE fixPrevPtr . pre = None NEW_LINE head = BTToDLL ( root ) NEW_LINE print   \" NEW_LINE INDENT DLL Traversal NEW_LINE DEDENT \" NEW_LINE printList ( head ) NEW_LINE",
        "Type": "py",
        "NL": "Convert a given Binary Tree to Doubly Linked List | Set 2 | A Binary Tree node ; Standard Inorder traversal of tree ; Changes left pointers to work as previous pointers in converted DLL The function simply does inorder traversal of Binary Tree and updates left pointer using previously visited node ; Changes right pointers to work as nexr pointers in converted DLL ; Find the right most node in BT or last node in DLL ; Start from the rightmost node , traverse back using left pointers While traversing , change right pointer of nodes ; The leftmost node is head of linked list , return it ; The main function that converts BST to DLL and returns head of DLL ; Set the previous pointer ; Set the next pointer and return head of DLL ; Traversses the DLL from left to right ; Let us create the tree shown in above diagram",
        "Category": "Binary Tree"
    },
    {
        "ID": "940-940",
        "Code": "class rankMatrix ( object ) : NEW_LINE INDENT def __init__ ( self , Matrix ) : NEW_LINE INDENT self . R = len ( Matrix ) NEW_LINE self . C = len ( Matrix [ 0 ] ) NEW_LINE DEDENT def swap ( self , Matrix , row1 , row2 , col ) : NEW_LINE INDENT for i in range ( col ) : NEW_LINE INDENT temp = Matrix [ row1 ] [ i ] NEW_LINE Matrix [ row1 ] [ i ] = Matrix [ row2 ] [ i ] NEW_LINE Matrix [ row2 ] [ i ] = temp NEW_LINE DEDENT DEDENT def rankOfMatrix ( self , Matrix ) : NEW_LINE INDENT rank = self . C NEW_LINE for row in range ( 0 , rank , 1 ) : NEW_LINE INDENT if Matrix [ row ] [ row ] != 0 : NEW_LINE INDENT for col in range ( 0 , self . R , 1 ) : NEW_LINE INDENT if col != row : NEW_LINE INDENT multiplier = ( Matrix [ col ] [ row ] / Matrix [ row ] [ row ] ) NEW_LINE for i in range ( rank ) : NEW_LINE INDENT Matrix [ col ] [ i ] -= ( multiplier * Matrix [ row ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT reduce = True NEW_LINE for i in range ( row + 1 , self . R , 1 ) : NEW_LINE INDENT if Matrix [ i ] [ row ] != 0 : NEW_LINE INDENT self . swap ( Matrix , row , i , rank ) NEW_LINE reduce = False NEW_LINE break NEW_LINE DEDENT DEDENT if reduce : NEW_LINE INDENT rank -= 1 NEW_LINE for i in range ( 0 , self . R , 1 ) : NEW_LINE INDENT Matrix [ i ] [ row ] = Matrix [ i ] [ rank ] NEW_LINE DEDENT DEDENT row -= 1 NEW_LINE DEDENT DEDENT return ( rank ) NEW_LINE DEDENT def Display ( self , Matrix , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( \" ▁ \" + str ( Matrix [ i ] [ j ] ) ) NEW_LINE DEDENT print ( ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Matrix = [ [ 10 , 20 , 10 ] , [ - 20 , - 30 , 10 ] , [ 30 , 50 , 0 ] ] NEW_LINE RankMatrix = rankMatrix ( Matrix ) NEW_LINE print ( \" Rank ▁ of ▁ the ▁ Matrix ▁ is : \" , ( RankMatrix . rankOfMatrix ( Matrix ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program for Rank of Matrix | Python 3 program to find rank of a matrix ; Function for exchanging two rows of a matrix ; Find rank of a matrix ; Before we visit current row ' row ' , we make sure that mat [ row ] [ 0 ] , ... . mat [ row ] [ row - 1 ] are 0. Diagonal element is not zero ; This makes all entries of current column as 0 except entry 'mat[row][row]   ; Diagonal element is already zero . Two cases arise : 1 ) If there is a row below it with non - zero entry , then swap this row with that row and process that row 2 ) If all elements in current column below mat [ r ] [ row ] are 0 , then remvoe this column by swapping it with last column and reducing number of columns by 1. ; Find the non - zero element in current column ; Swap the row with non - zero element with this row . ; If we did not find any row with non - zero element in current columnm , then all values in this column are 0. ; Reduce number of columns ; copy the last column here ; process this row again ; self . Display ( Matrix , self . R , self . C ) ; Function to Display a matrix ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9413-9413",
        "Code": "def overlappingArea ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 1 NEW_LINE area1 = abs ( l1 [ x ] - r1 [ x ] ) * abs ( l1 [ y ] - r1 [ y ] ) NEW_LINE area2 = abs ( l2 [ x ] - r2 [ x ] ) * abs ( l2 [ y ] - r2 [ y ] ) NEW_LINE x_dist = ( min ( r1 [ x ] , r2 [ x ] ) - max ( l1 [ x ] , l2 [ x ] ) ) NEW_LINE y_dist = ( min ( r1 [ y ] , r2 [ y ] ) - max ( l1 [ y ] , l2 [ y ] ) ) NEW_LINE areaI = 0 NEW_LINE if x_dist > 0 and y_dist > 0 : NEW_LINE INDENT areaI = x_dist * y_dist NEW_LINE DEDENT return ( area1 + area2 - areaI ) NEW_LINE DEDENT l1 = [ 2 , 2 ] NEW_LINE r1 = [ 5 , 7 ] NEW_LINE l2 = [ 3 , 4 ] NEW_LINE r2 = [ 6 , 9 ] NEW_LINE print ( overlappingArea ( l1 , r1 , l2 , r2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Total area of two overlapping rectangles | Python program to find total area of two overlapping Rectangles Returns Total Area of two overlap rectangles ; Area of 1 st Rectangle ; Area of 2 nd Rectangle ; Length of intersecting part i . e start from max ( l1 [ x ] , l2 [ x ] ) of x - coordinate and end at min ( r1 [ x ] , r2 [ x ] ) x - coordinate by subtracting start from end we get required lengths ; Driver 's Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9417-9417",
        "Code": "import math NEW_LINE def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT r = 8 ; R = 4 ; r1 = 2 ; x1 = 6 ; y1 = 0 NEW_LINE if ( checkcircle ( r , R , r1 , x1 , y1 ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a given circle lies completely inside the ring formed by two concentric circles | Python3 code to check if a circle lies in the ring ; Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )",
        "Category": "Math"
    },
    {
        "ID": "9420-9420",
        "Code": "import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" , surface_area_octahedron ( side ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Surface Area of Octahedron | Python Program to calculate surface area of Octahedron . ; utility Function ; driver code",
        "Category": "Math"
    },
    {
        "ID": "9421-9421",
        "Code": "def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT r = 3 NEW_LINE print ( \" ▁ Area ▁ of ▁ square ▁ = ▁ \" , find_Area ( r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Area of square Circumscribed by Circle | Function to find area of square ; Radius of a circle ; Call Function to find an area of square",
        "Category": "Math"
    },
    {
        "ID": "9427-9427",
        "Code": "import math NEW_LINE def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT side = 4 NEW_LINE print ( \" Volume ▁ of ▁ dodecahedron ▁ = \" , round ( vol_of_dodecahedron ( side ) , 2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Calculate Volume of Dodecahedron | Python3 program to calculate Volume of dodecahedron ; utility Function ; Driver Function",
        "Category": "Math"
    },
    {
        "ID": "9428-9428",
        "Code": "def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( int ( ( x1 + x2 ) / 2 ) , end = \" \" ) NEW_LINE print ( \" , \" , int ( ( y1 + y2 ) / 2 ) ) NEW_LINE DEDENT x1 = - 9 ; y1 = 3 ; x2 = 5 ; y2 = - 7 NEW_LINE center ( x1 , x2 , y1 , y2 ) NEW_LINE",
        "Type": "py",
        "NL": "Find the center of the circle using endpoints of diameter | Function to find the center of the circle ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9429-9429",
        "Code": "def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT diameter = 5 ; NEW_LINE height = 10 ; NEW_LINE print ( \" Perimeter ▁ = ▁ \" , perimeter ( diameter , height ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the perimeter of a cylinder | Function to calculate the perimeter of a cylinder ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "9433-9433",
        "Code": "M = 3 ; NEW_LINE N = 3 ; NEW_LINE def contribution_height ( current , previous ) : NEW_LINE INDENT return abs ( current - previous ) ; NEW_LINE DEDENT def surfaceArea ( A ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT up = 0 ; NEW_LINE left = 0 ; NEW_LINE if ( i > 0 ) : NEW_LINE INDENT up = A [ i - 1 ] [ j ] ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT left = A [ i ] [ j - 1 ] ; NEW_LINE DEDENT ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; NEW_LINE if ( i == N - 1 ) : NEW_LINE INDENT ans += A [ i ] [ j ] ; NEW_LINE DEDENT if ( j == M - 1 ) : NEW_LINE INDENT ans += A [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT ans += N * M * 2 ; NEW_LINE return ans ; NEW_LINE DEDENT A = [ [ 1 , 3 , 4 ] , [ 2 , 2 , 3 ] , [ 1 , 2 , 4 ] ] ; NEW_LINE print ( surfaceArea ( A ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find the Surface area of a 3D figure | Declaring the size of the matrix ; Absolute Difference between the height of two consecutive blocks ; Function To calculate the Total surfaceArea . ; Traversing the matrix . ; If we are traveling the topmost row in the matrix , we declare the wall above it as 0 as there is no wall above it . ; If we are traveling the leftmost column in the matrix , we declare the wall left to it as 0 as there is no wall left it . ; If its not the topmost row ; If its not the leftmost column ; Summing up the contribution of by the current block ; If its the rightmost block of the matrix it will contribute area equal to its height as a wall on the right of the figure ; If its the lowest block of the matrix it will contribute area equal to its height as a wall on the bottom of the figure ; Adding the contribution by the base and top of the figure ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9434-9434",
        "Code": "import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , R , h ) : NEW_LINE INDENT return 1 / 3 * pi * h * ( r * r + R * R + r * R ) NEW_LINE DEDENT def curved_surface_area ( r , R , l ) : NEW_LINE INDENT return pi * l * ( R + r ) NEW_LINE DEDENT def total_surface_area ( r , R , l , h ) : NEW_LINE INDENT return pi * l * ( R + r ) + pi * ( r * r + R * R ) NEW_LINE DEDENT small_radius = 3 NEW_LINE big_radius = 8 NEW_LINE slant_height = 13 NEW_LINE height = 12 NEW_LINE print ( \" Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ \" , end = ' ' ) NEW_LINE print ( volume ( small_radius , big_radius , height ) ) NEW_LINE print ( \" Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum \" + \" ▁ of ▁ Cone ▁ : ▁ \" , end = ' ' ) NEW_LINE print ( curved_surface_area ( small_radius , big_radius , slant_height ) ) NEW_LINE print ( \" Total ▁ Surface ▁ Area ▁ Of ▁ Frustum \" + \" ▁ of ▁ Cone ▁ : ▁ \" , end = ' ' ) NEW_LINE print ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Volume and Surface area of Frustum of Cone | Python3 code to calculate Volume and Surface area of frustum of cone ; Function to calculate Volume of frustum of cone ; Function to calculate Curved Surface area of frustum of cone ; Function to calculate Total Surface area of frustum of cone ; Driver Code ; Printing value of volume and surface area",
        "Category": "Math"
    },
    {
        "ID": "9437-9437",
        "Code": "import math NEW_LINE def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT side = 3 NEW_LINE print ( \" Volume ▁ of ▁ octahedron ▁ = \" , round ( vol_of_octahedron ( side ) , 4 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate volume of Octahedron | Python3 Program to calculate volume of Octahedron ; utility Function ; Driver Function",
        "Category": "Math"
    },
    {
        "ID": "9438-9438",
        "Code": "import math NEW_LINE / * Utility Function * / NEW_LINE def area_of_tetrahedron ( side ) : NEW_LINE INDENT return ( math . sqrt ( 3 ) * ( side * side ) ) ; NEW_LINE DEDENT side = 3 ; NEW_LINE print ( \" Area ▁ of ▁ Tetrahedron ▁ = ▁ \" , round ( area_of_tetrahedron ( side ) , 4 ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate area and volume of a Tetrahedron | Python3 Program to Calculate area of tetrahedron ;  ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9440-9440",
        "Code": "def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( \" Overflow \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ in ▁ overflow ▁ state \" ) NEW_LINE DEDENT DEDENT H = 10 NEW_LINE r = 5 NEW_LINE h = 5 NEW_LINE N = 2 NEW_LINE R = 2 NEW_LINE overflow ( H , r , h , N , R ) NEW_LINE",
        "Type": "py",
        "NL": "Program to check if water tank overflows when n solid balls are dipped in the water tank | function to find if tak will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; giving dimensions ; calling function",
        "Category": "Math"
    },
    {
        "ID": "9444-9444",
        "Code": "def volume ( radius , height ) : NEW_LINE INDENT return ( ( 22 / 7 ) * radius * radius * height ) NEW_LINE DEDENT def check_and_print ( required_time , given_time ) : NEW_LINE INDENT if required_time < given_time : NEW_LINE INDENT print ( \" Overflow \" ) NEW_LINE DEDENT elif required_time > given_time : NEW_LINE INDENT print ( \" Underflow \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Filled \" ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE height = 10 NEW_LINE rate_of_flow = 10 NEW_LINE given_time = 70.0 NEW_LINE required_time = volume ( radius , height ) / rate_of_flow NEW_LINE check_and_print ( required_time , given_time ) NEW_LINE",
        "Type": "py",
        "NL": "Program to check if tank will overflow , underflow or filled in given time | function to calculate the volume of tank ; function to print overflow / filled / underflow accordingly ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result",
        "Category": "Math"
    },
    {
        "ID": "9447-9447",
        "Code": "import math NEW_LINE def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT r1 = float ( 2.3 ) NEW_LINE r2 = float ( 3.4 ) NEW_LINE r3 = float ( 5.7 ) NEW_LINE print ( \" Volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ \" , volumeOfEllipsoid ( r1 , r2 , r3 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate volume of Ellipsoid | Python3 program to Volume of ellipsoid ; Function To calculate Volume ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9450-9450",
        "Code": "import math as mt NEW_LINE def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE x1 , denominator , cosx , cosval = 0 , 0 , 0 , 0 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = mt . cos ( n ) NEW_LINE i = 1 NEW_LINE while ( accuracy <= abs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT return cosx NEW_LINE DEDENT def third_side ( a , b , c ) : NEW_LINE INDENT angle = cal_cos ( c ) NEW_LINE return mt . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) NEW_LINE DEDENT c = 49 NEW_LINE a , b = 5 , 8 NEW_LINE print ( third_side ( a , b , c ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find third side of triangle using law of cosines | Python3 program to find third side of triangle using law of cosines ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver Code ; function call",
        "Category": "Math"
    },
    {
        "ID": "9453-9453",
        "Code": "from math import * NEW_LINE def area_equilateral ( side ) : NEW_LINE INDENT area = ( sqrt ( 3 ) / 4 ) * side * side NEW_LINE print ( \" Area ▁ of ▁ Equilateral ▁ Triangle : ▁ % ▁ f \" % area ) NEW_LINE DEDENT def perimeter ( side ) : NEW_LINE INDENT perimeter = 3 * side NEW_LINE print ( \" Perimeter ▁ of ▁ Equilateral ▁ Triangle : ▁ % ▁ f \" % perimeter ) NEW_LINE DEDENT side = 4 NEW_LINE area_equilateral ( side ) NEW_LINE perimeter ( side ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate area and perimeter of equilateral triangle | Python3 program to calculate Area and Perimeter of equilateral Triangle ; Function to calculate Area of equilateral triangle ; Function to calculate Perimeter of equilateral triangle ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9454-9454",
        "Code": "import math NEW_LINE def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT side = 4 NEW_LINE print ( \" Area ▁ of ▁ Regular ▁ Octagon ▁ = \" , round ( areaOctagon ( side ) , 4 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to calculate Area Of Octagon | Python3 program to find area of octagon ; Utility function ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "9466-9466",
        "Code": "import math NEW_LINE def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 1 NEW_LINE d = 2 NEW_LINE print ( \" % .2f \" % maxArea ( a , b , c , d ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum area of quadrilateral | Python3 program to find maximum area of a quadrilateral ; Calculating the semi - perimeter of the given quadrilateral ; Applying Brahmagupta 's formula to  get maximum area of quadrilateral ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9469-9469",
        "Code": "class point : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x = 0 NEW_LINE self . y = 0 NEW_LINE DEDENT DEDENT RIGHT = 1 NEW_LINE LEFT = - 1 NEW_LINE ZERO = 0 NEW_LINE def directionOfPoint ( A , B , P ) : NEW_LINE INDENT global RIGHT , LEFT , ZERO NEW_LINE B . x -= A . x NEW_LINE B . y -= A . y NEW_LINE P . x -= A . x NEW_LINE P . y -= A . y NEW_LINE cross_product = B . x * P . y - B . y * P . x NEW_LINE if ( cross_product > 0 ) : NEW_LINE INDENT return RIGHT NEW_LINE DEDENT if ( cross_product < 0 ) : NEW_LINE INDENT return LEFT NEW_LINE DEDENT return ZERO NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = point ( ) NEW_LINE B = point ( ) NEW_LINE P = point ( ) NEW_LINE A . x = - 30 NEW_LINE B . x = 29 NEW_LINE P . x = 15 NEW_LINE direction = directionOfPoint ( A , B , P ) NEW_LINE if ( direction == 1 ) : NEW_LINE INDENT print ( \" Right ▁ Direction \" ) NEW_LINE DEDENT elif ( direction == - 1 ) : NEW_LINE INDENT print ( \" Left ▁ Direction \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Point ▁ is ▁ on ▁ the ▁ Line \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Direction of a Point from a Line Segment | Structure for point in cartesian plane . ; Constant integers for directions ; Subtracting co - ordinates of point A from B and P , to make A as origin ; Determining cross Product ; Return RIGHT if cross product is positive ; Return LEFT if cross product is negative ; Return ZERO if cross product is zero ; Driver code ; A . y = 10 A ( - 30 , 10 ) ; B . y = - 15 B ( 29 , - 15 ) ; P . y = 28 P ( 15 , 28 )",
        "Category": "Math"
    },
    {
        "ID": "9470-9470",
        "Code": "def volumeCuboid ( l , h , w ) : NEW_LINE INDENT return ( l * h * w ) NEW_LINE DEDENT def surfaceAreaCuboid ( l , h , w ) : NEW_LINE INDENT return ( 2 * l * w + 2 * w * h + 2 * l * h ) NEW_LINE DEDENT l = 1 NEW_LINE h = 5 NEW_LINE w = 7 NEW_LINE print ( \" Volume ▁ = \" , volumeCuboid ( l , h , w ) ) NEW_LINE print ( \" Total ▁ Surface ▁ Area ▁ = \" , surfaceAreaCuboid ( l , h , w ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Volume and Surface Area of Cuboid | utility function ; driver function",
        "Category": "Math"
    },
    {
        "ID": "9471-9471",
        "Code": "def areaCube ( a ) : NEW_LINE INDENT return ( a * a * a ) NEW_LINE DEDENT def surfaceCube ( a ) : NEW_LINE INDENT return ( 6 * a * a ) NEW_LINE DEDENT a = 5 NEW_LINE print ( \" Area ▁ = \" , areaCube ( a ) ) NEW_LINE print ( \" Total ▁ surface ▁ area ▁ = \" , surfaceCube ( a ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Volume and Surface Area of Cube | utility function ; driver function",
        "Category": "Math"
    },
    {
        "ID": "9473-9473",
        "Code": "PI = 3.1415 NEW_LINE def circumference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT print ( ' % .3f ' % circumference ( 5 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to find Circumference of a Circle | Python3 code to find circumference of circle ; utility function ; driver function",
        "Category": "Math"
    },
    {
        "ID": "9474-9474",
        "Code": "def areaRectangle ( a , b ) : NEW_LINE INDENT return ( a * b ) NEW_LINE DEDENT def perimeterRectangle ( a , b ) : NEW_LINE INDENT return ( 2 * ( a + b ) ) NEW_LINE DEDENT a = 5 ; NEW_LINE b = 6 ; NEW_LINE print ( \" Area ▁ = ▁ \" , areaRectangle ( a , b ) ) NEW_LINE print ( \" Perimeter ▁ = ▁ \" , perimeterRectangle ( a , b ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program for Area And Perimeter Of Rectangle | Utility function ; Driver function",
        "Category": "Math"
    },
    {
        "ID": "9477-9477",
        "Code": "import math NEW_LINE def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( int ( minPerimeter ( n ) ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum Perimeter of n blocks | Python3 program to find minimum perimeter using n blocks . ; if n is a perfect square ; Number of rows ; perimeter of the rectangular grid ; if there are blocks left ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9479-9479",
        "Code": "def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) NEW_LINE dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT a1 , b1 , c1 = 1 , 2 , 3 NEW_LINE a2 = b2 = c2 = 0 NEW_LINE possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) NEW_LINE",
        "Type": "py",
        "NL": "Find if it 's possible to rotate the page by an angle or not. | Function to find if it 's possible to rotate page or not ; Calculating distance b / w points ; If distance is not equal ; If the points are in same line ; Points a , b , and c",
        "Category": "Math"
    },
    {
        "ID": "9480-9480",
        "Code": "import math NEW_LINE def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( \" Fits \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Doesn ' t ▁ Fit \" ) NEW_LINE DEDENT DEDENT R = 8 NEW_LINE r = 4 NEW_LINE x = 5 NEW_LINE y = 3 NEW_LINE rad = 3 NEW_LINE fitOrNotFit ( R , r , x , y , rad ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether given circle resides in boundary maintained by two other circles | Python3 program to check whether circle with given co - ordinates reside within the boundary of outer circle and inner circle ; function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked",
        "Category": "Math"
    },
    {
        "ID": "9484-9484",
        "Code": "def area ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) NEW_LINE DEDENT def check ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 , x , y ) : NEW_LINE INDENT A = ( area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ) NEW_LINE A1 = area ( x , y , x1 , y1 , x2 , y2 ) NEW_LINE A2 = area ( x , y , x2 , y2 , x3 , y3 ) NEW_LINE A3 = area ( x , y , x3 , y3 , x4 , y4 ) NEW_LINE A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; NEW_LINE return ( A == A1 + A2 + A3 + A4 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT if ( check ( 0 , 10 , 10 , 0 , 0 , - 10 , - 10 , 0 , 10 , 15 ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check whether a given point lies inside a rectangle or not | A utility function to calculate area of triangle formed by ( x1 , y1 ) , ( x2 , y2 ) and ( x3 , y3 ) ; A function to check whether point P ( x , y ) lies inside the rectangle formed by A ( x1 , y1 ) , B ( x2 , y2 ) , C ( x3 , y3 ) and D ( x4 , y4 ) ; Calculate area of rectangle ABCD ; Calculate area of triangle PAB ; Calculate area of triangle PBC ; Calculate area of triangle PCD ; Calculate area of triangle PAD ; Check if sum of A1 , A2 , A3 and A4 is same as A ; Driver Code ; Let us check whether the point P ( 10 , 15 ) lies inside the rectangle formed by A ( 0 , 10 ) , B ( 10 , 0 ) C ( 0 , - 10 ) D ( - 10 , 0 )",
        "Category": "Math"
    },
    {
        "ID": "9487-9487",
        "Code": "import math NEW_LINE def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE print ( countRect ( n ) ) NEW_LINE",
        "Type": "py",
        "NL": "Number of unique rectangles formed using N unit squares | Python3 program to count rotationally equivalent rectangles with n unit squares ; height >= length is maintained ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9488-9488",
        "Code": "def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return ( x , y ) NEW_LINE DEDENT a = - 1.0 NEW_LINE b = 1.0 NEW_LINE c = 0.0 NEW_LINE x1 = 1.0 NEW_LINE y1 = 0.0 NEW_LINE x , y = mirrorImage ( a , b , c , x1 , y1 ) ; NEW_LINE print ( \" Image ▁ of ▁ point ▁ ( \" + str ( x1 ) + \" , ▁ \" + str ( y1 ) + \" ) ▁ \" ) NEW_LINE print ( \" by ▁ mirror ▁ ( \" + str ( a ) + \" ) x ▁ + ▁ ( \" + str ( b ) + \" ) y ▁ + ▁ ( \" + str ( c ) + \" ) ▁ = ▁ 0 , ▁ is ▁ : \" ) NEW_LINE print ( \" ( \" + str ( x ) + \" , ▁ \" + str ( y ) + \" ) \" ) NEW_LINE",
        "Type": "py",
        "NL": "Find mirror image of a point in 2 | Python function which finds coordinates of mirror image . This function return a pair of double ; Driver code to test above function",
        "Category": "Math"
    },
    {
        "ID": "9494-9494",
        "Code": "def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( \" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : \" , a , \" x ▁ - ▁ \" , b , \" y ▁ = ▁ \" , c ,   \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ \" , a , \" x ▁ + ▁ \" , b , \" y ▁ = ▁ \" , c ,   \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ 3 , 2 ] NEW_LINE Q = [ 2 , 6 ] NEW_LINE lineFromPoints ( P , Q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to find line passing through 2 Points | Function to find the line given two points ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9497-9497",
        "Code": "def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n ; NEW_LINE print ( \" m ▁ = ▁ \" , m ) ; NEW_LINE print ( \" c ▁ = ▁ \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE",
        "Type": "py",
        "NL": "Represent a given set of points by the best possible straight line | function to calculate m and c that best fit points represented by x [ ] and y [ ] ; Driver main function",
        "Category": "Math"
    },
    {
        "ID": "9499-9499",
        "Code": "from math import sqrt NEW_LINE def checkPolygonWithMidpoints ( arr , N , midpoints ) : NEW_LINE INDENT for j in range ( midpoints ) : NEW_LINE INDENT val = 1 NEW_LINE for k in range ( j , N , midpoints ) : NEW_LINE INDENT val &= arr [ k ] NEW_LINE DEDENT if ( val and N // midpoints > 2 ) : NEW_LINE INDENT print ( \" Polygon ▁ possible ▁ with ▁ side ▁ length \" , ( N // midpoints ) ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isPolygonPossible ( arr , N ) : NEW_LINE INDENT limit = sqrt ( N ) NEW_LINE for i in range ( 1 , int ( limit ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( checkPolygonWithMidpoints ( arr , N , i ) or checkPolygonWithMidpoints ( arr , N , ( N // i ) ) ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT print ( \" Not ▁ possiblen \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE isPolygonPossible ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Regular polygon using only 1 s in a binary numbered circle | Python3 program to find whether a regular polygon is possible in circle with 1 s as vertices ; method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N / midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N / i ) will be divisors ; check polygon for both divisors ; Driver code",
        "Category": "Array"
    },
    {
        "ID": "950-950",
        "Code": "N = 6 NEW_LINE def maximumSubSquare ( arr ) : NEW_LINE INDENT dp = [ [ [ - 1 , - 1 ] for i in range ( 51 ) ] for j in range ( 51 ) ] NEW_LINE maxside = [ [ 0 for i in range ( 51 ) ] for j in range ( 51 ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT dp [ i ] [ j ] [ 0 ] = x NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ j ] [ i ] == ' X ' ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 0 NEW_LINE DEDENT dp [ j ] [ i ] [ 1 ] = y NEW_LINE DEDENT DEDENT maxval = 0 NEW_LINE val = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT val = min ( dp [ i ] [ j ] [ 0 ] , dp [ i ] [ j ] [ 1 ] ) NEW_LINE if ( dp [ i ] [ j - val + 1 ] [ 1 ] >= val and dp [ i - val + 1 ] [ j ] [ 0 ] >= val ) : NEW_LINE INDENT maxside [ i ] [ j ] = val NEW_LINE DEDENT else : NEW_LINE INDENT maxside [ i ] [ j ] = 0 NEW_LINE DEDENT maxval = max ( maxval , maxside [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return maxval NEW_LINE DEDENT mat = [ [ ' X ' , ' O ' , ' X ' , ' X ' , ' X ' , ' X ' ] , [ ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' ] , [ ' X ' , ' X ' , ' X ' , ' O ' , ' O ' , ' X ' ] , [ ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' ] , [ ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' ] , [ ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' ] ] NEW_LINE print ( maximumSubSquare ( mat ) ) NEW_LINE",
        "Type": "py",
        "NL": "Given a matrix of ' O ' and ' X ' , find the largest subsquare surrounded by ' X ' | Size of given matrix is N X N ; Initialize maxside with 0 ; Fill the dp matrix horizontally . for contiguous ' X ' increment the value of x , otherwise make it 0 ; Fill the dp matrix vertically . For contiguous ' X ' increment the value of y , otherwise make it 0 ; Now check , for every value of ( i , j ) if sub - square is possible , traverse back horizontally by value val , and check if vertical contiguous ' X ' enfing at ( i , j - val + 1 ) is greater than equal to val . Similarly , check if traversing back vertically , the horizontal contiguous ' X ' ending at ( i - val + 1 , j ) is greater than equal to val . ; Store the final answer in maxval ; Return the final answe . ; Driver code ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9500-9500",
        "Code": "import math NEW_LINE def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT r = 2 NEW_LINE x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 0 NEW_LINE y2 = 4 NEW_LINE print ( minRevolutions ( r , x1 , y1 , x2 , y2 ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum revolutions to move center of a circle to a target | Python program to find minimum number of revolutions to reach a target center ; Minimum revolutions to move center from ( x1 , y1 ) to ( x2 , y2 ) ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9502-9502",
        "Code": "import math NEW_LINE def lengthSquare ( X , Y ) : NEW_LINE INDENT xDiff = X [ 0 ] - Y [ 0 ] NEW_LINE yDiff = X [ 1 ] - Y [ 1 ] NEW_LINE return xDiff * xDiff + yDiff * yDiff NEW_LINE DEDENT def printAngle ( A , B , C ) : NEW_LINE INDENT a2 = lengthSquare ( B , C ) NEW_LINE b2 = lengthSquare ( A , C ) NEW_LINE c2 = lengthSquare ( A , B ) NEW_LINE a = math . sqrt ( a2 ) ; NEW_LINE b = math . sqrt ( b2 ) ; NEW_LINE c = math . sqrt ( c2 ) ; NEW_LINE alpha = math . acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ; NEW_LINE betta = math . acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ; NEW_LINE gamma = math . acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ; NEW_LINE alpha = alpha * 180 / math . pi ; NEW_LINE betta = betta * 180 / math . pi ; NEW_LINE gamma = gamma * 180 / math . pi ; NEW_LINE print ( \" alpha ▁ : ▁ % f \" % ( alpha ) ) NEW_LINE print ( \" betta ▁ : ▁ % f \" % ( betta ) ) NEW_LINE print ( \" gamma ▁ : ▁ % f \" % ( gamma ) ) NEW_LINE DEDENT A = ( 0 , 0 ) NEW_LINE B = ( 0 , 1 ) NEW_LINE C = ( 1 , 0 ) NEW_LINE printAngle ( A , B , C ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find all angles of a given triangle | Python3 code to find all three angles of a triangle given coordinate of all three vertices ; returns square of distance b / w two points ; Square of lengths be a2 , b2 , c2 ; length of sides be a , b , c ; From Cosine law ; Converting to degree ; printing all the angles ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9511-9511",
        "Code": "import math NEW_LINE def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( \" Point ▁ ( \" , x , \" , \" , y , \" ) ▁ \" \" exist ▁ in ▁ the ▁ circle ▁ sector \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Point ▁ ( \" , x , \" , \" , y , \" ) ▁ \" \" does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector \" ) NEW_LINE DEDENT DEDENT radius , x , y = 8 , 3 , 4 NEW_LINE percent , startAngle = 12 , 0 NEW_LINE checkPoint ( radius , x , y , percent , startAngle ) NEW_LINE",
        "Type": "py",
        "NL": "Check whether a point exists in circle sector or not . | Python3 program to check if a point lies inside a circle sector . ; calculate endAngle ; Calculate polar co - ordinates ; Check whether polarradius is less then radius of circle or not and Angle is between startAngle and endAngle or not ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9514-9514",
        "Code": "import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not ▁ possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) / 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find all sides of a right angled triangle from given hypotenuse and area | Set 1 | limit for float comparison define eps 1e-6 ; Utility method to get area of right angle triangle , given base and hypotenuse ; Prints base and height of triangle using hypotenuse and area information ; maximum area will be obtained when base and height are equal ( = sqrt ( h * h / 2 ) ) ; if given area itself is larger than maxArea then no solution is possible ; binary search for base ; get height by pythagorean rule ; Driver code to test above methods",
        "Category": "Binary Search"
    },
    {
        "ID": "9515-9515",
        "Code": "import math NEW_LINE def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT r = 5 NEW_LINE print ( countLattice ( r ) ) NEW_LINE",
        "Type": "py",
        "NL": "Circle and Lattice Points | Python3 program to find countLattice podefs on a circle ; Function to count Lattice podefs on a circle ; Initialize result as 4 for ( r , 0 ) , ( - r . 0 ) , ( 0 , r ) and ( 0 , - r ) ; Check every value that can be potential x ; Find a potential y ; checking whether square root is an defeger or not . Count increments by 4 for four different quadrant values ; Driver program",
        "Category": "Math"
    },
    {
        "ID": "9517-9517",
        "Code": "def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT def findMaximumHeight ( N ) : NEW_LINE INDENT n = 1 + 8 * N NEW_LINE maxH = ( - 1 + squareRoot ( n ) ) / 2 NEW_LINE return int ( maxH ) NEW_LINE DEDENT N = 12 NEW_LINE print ( findMaximumHeight ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum height when coins are arranged in a triangle | Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e = 0.000001 e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; Driver code to test above method",
        "Category": "Math"
    },
    {
        "ID": "9519-9519",
        "Code": "import math NEW_LINE class Optimum_distance : NEW_LINE INDENT class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT class Line : NEW_LINE INDENT def __init__ ( self , a , b , c ) : NEW_LINE INDENT self . a = a NEW_LINE self . b = b NEW_LINE self . c = c NEW_LINE DEDENT DEDENT def dist ( self , x , y , p ) : NEW_LINE INDENT return math . sqrt ( ( x - p . x ) ** 2 + ( y - p . y ) ** 2 ) NEW_LINE DEDENT def compute ( self , p , n , l , x ) : NEW_LINE INDENT res = 0 NEW_LINE y = - 1 * ( l . a * x + l . c ) / l . b NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += self . dist ( x , y , p [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def find_Optimum_cost_untill ( self , p , n , l ) : NEW_LINE INDENT low = - 1e6 NEW_LINE high = 1e6 NEW_LINE eps = 1e-6 + 1 NEW_LINE while ( ( high - low ) > eps ) : NEW_LINE INDENT mid1 = low + ( high - low ) / 3 NEW_LINE mid2 = high - ( high - low ) / 3 NEW_LINE dist1 = self . compute ( p , n , l , mid1 ) NEW_LINE dist2 = self . compute ( p , n , l , mid2 ) NEW_LINE if ( dist1 < dist2 ) : NEW_LINE INDENT high = mid2 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid1 NEW_LINE DEDENT DEDENT return self . compute ( p , n , l , ( low + high ) / 2 ) NEW_LINE DEDENT def find_Optimum_cost ( self , p , l ) : NEW_LINE INDENT n = len ( p ) NEW_LINE p_arr = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT p_obj = self . Point ( p [ i ] [ 0 ] , p [ i ] [ 1 ] ) NEW_LINE p_arr [ i ] = p_obj NEW_LINE DEDENT return self . find_Optimum_cost_untill ( p_arr , n , l ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT obj = Optimum_distance ( ) NEW_LINE l = obj . Line ( 1 , - 1 , - 3 ) NEW_LINE p = [ [ - 3 , - 2 ] , [ - 1 , 0 ] , [ - 1 , 2 ] , [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE print ( obj . find_Optimum_cost ( p , l ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Optimum location of point to minimize total distance | A Python3 program to find optimum location and total cost ; Class defining a point ; Class defining a line of ax + by + c = 0 form ; Method to get distance of point ( x , y ) from point p ; Utility method to compute total distance all points when choose point on given line has x - coordinate value as X ; Calculating Y of chosen point by line equation ; Utility method to find minimum total distance ; Loop until difference between low and high become less than EPS ; mid1 and mid2 are representative x co - ordiantes of search space ; If mid2 point gives more total distance , skip third part ; If mid1 point gives more total distance , skip first part ; Compute optimum distance cost by sending average of low and high as X ; Method to find optimum cost ; Converting 2D array input to point array ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9522-9522",
        "Code": "class Point : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def getCount ( p , q ) : NEW_LINE INDENT if p . x == q . x : NEW_LINE INDENT return abs ( p . y - q . y ) - 1 NEW_LINE DEDENT if p . y == q . y : NEW_LINE INDENT return abs ( p . x - q . x ) - 1 NEW_LINE DEDENT return gcd ( abs ( p . x - q . x ) , abs ( p . y - q . y ) ) - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = Point ( 1 , 9 ) NEW_LINE q = Point ( 8 , 16 ) NEW_LINE print ( \" The ▁ number ▁ of ▁ integral ▁ points \" , \" between ▁ ( { } , ▁ { } ) ▁ and ▁ ( { } , ▁ { } ) ▁ is ▁ { } \" . format ( p . x , p . y , q . x , q . y , getCount ( p , q ) ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Number of Integral Points between Two Points | Class to represent an Integral point on XY plane . ; Utility function to find GCD of two numbers GCD of a and b ; Finds the no . of Integral points between two given points . ; If line joining p and q is parallel to x axis , then count is difference of y values ; If line joining p and q is parallel to y axis , then count is difference of x values ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9533-9533",
        "Code": "def f ( x , p , num ) : NEW_LINE INDENT return pow ( x , p ) - num NEW_LINE DEDENT def f_prime ( x , p ) : NEW_LINE INDENT return p * pow ( x , p - 1 ) NEW_LINE DEDENT def root ( num , p ) : NEW_LINE INDENT left = - num NEW_LINE right = num NEW_LINE x = 0 NEW_LINE while ( True ) : NEW_LINE INDENT x = ( left + right ) / 2.0 NEW_LINE value = f ( x , p , num ) NEW_LINE prime = f_prime ( x , p ) NEW_LINE if ( value * prime <= 0 ) : NEW_LINE INDENT left = x NEW_LINE DEDENT else : NEW_LINE INDENT right = x NEW_LINE DEDENT if ( value < 0.000001 and value >= 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = 1234321 NEW_LINE N = 2 NEW_LINE ans = root ( P , N ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find Nth root of a number using Bisection method | Function that returns the value of the function at a given value of x ; calculating the value of the differential of the function ; The function that returns the root of given number ; Defining range on which answer can be found ; finding mid value ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "9540-9540",
        "Code": "def minimumSizeArr ( A , B ) : NEW_LINE INDENT currXor = 0 NEW_LINE reminder = ( A - 1 ) % 4 NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT currXor = A - 1 NEW_LINE DEDENT elif ( reminder == 1 ) : NEW_LINE INDENT currXor = 1 NEW_LINE DEDENT elif ( reminder == 2 ) : NEW_LINE INDENT currXor = A NEW_LINE DEDENT minSize = A NEW_LINE if ( currXor == B ) : NEW_LINE INDENT return minSize NEW_LINE DEDENT elif ( currXor ^ B == A ) : NEW_LINE INDENT return minSize + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return minSize + 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 1 NEW_LINE B = 999 NEW_LINE print ( minimumSizeArr ( A , B ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum size of the array with MEX as A and XOR of the array elements as B | Function to find the minimum size of array with given MEX and XOR ; Find the XOR of values from 0 to A - 1 ; If A is a multiple of 4 ; If A % 4 gives remainder 1 ; If A % 4 gives remainder 2 ; Initializing array size by A ; If XOR of all values of array is equal to B ; If the required integer to be added is equal to A ; Else any integer can be added ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9544-9544",
        "Code": "import math NEW_LINE mxn = 10000 + 1 NEW_LINE prime = [ True for _ in range ( mxn + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT global prime NEW_LINE for p in range ( 2 , int ( math . sqrt ( mxn ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , mxn + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countMin ( arr , n ) : NEW_LINE INDENT cMinSwaps = 0 NEW_LINE cPrimeIndices = 0 NEW_LINE cPrimeNos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ i + 1 ] ) : NEW_LINE INDENT cPrimeIndices += 1 NEW_LINE if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT cMinSwaps += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cPrimeNos += 1 NEW_LINE DEDENT DEDENT elif ( prime [ arr [ i ] ] ) : NEW_LINE INDENT cPrimeNos += 1 NEW_LINE DEDENT DEDENT if ( cPrimeNos >= cPrimeIndices ) : NEW_LINE INDENT return cMinSwaps NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE arr = [ 2 , 7 , 8 , 5 , 13 ] NEW_LINE print ( countMin ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize swaps required to make all prime | Python program for the above approach ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; Function to count minimum number of swaps required ; To count the minimum number of swaps required to convert the array into perfectly prime ; To count total number of prime indexes in the array ; To count the total number of prime numbers in the array ; Check whether index is prime or not ; Element is not prime ; If the total number of prime numbers is greater than or equal to the total number of prime indices , then it is possible to convert the array into perfectly prime ; Driver Code ; Pre - calculate prime [ ]",
        "Category": "Math"
    },
    {
        "ID": "9557-9557",
        "Code": "def convertToBase9 ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE a = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( a * ( n % 9 ) ) NEW_LINE a *= 10 NEW_LINE n //= 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNthnumber ( base9 , K ) : NEW_LINE INDENT ans = 0 NEW_LINE a = 1 NEW_LINE while ( base9 > 0 ) : NEW_LINE INDENT cur = base9 % 10 NEW_LINE if ( cur >= K ) : NEW_LINE INDENT ans += a * ( cur + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += a * cur NEW_LINE DEDENT base9 //= 10 NEW_LINE a *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE K = 1 NEW_LINE base9 = convertToBase9 ( N ) NEW_LINE print ( getNthnumber ( base9 , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Finding the Nth term in a sequence formed by removing digit K from natural numbers | Python 3 implementation for the above approach ; Denotes the digit place ; Method to convert any number to binary equivalent ; denotes the current digits place ; If current digit is >= K increment its value by 1 ; Else add the digit as it is ; Move to the next digit ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9558-9558",
        "Code": "def binarySearch ( arr , size , key ) : NEW_LINE INDENT low = 0 NEW_LINE high = size - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( key > arr [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT elif ( key < arr [ mid ] ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def twoPointers ( arr , N , mean ) : NEW_LINE INDENT i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT temp = ( arr [ i ] + arr [ j ] ) / 2 NEW_LINE if ( temp > mean ) : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT elif ( temp < mean ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def checkArray ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT mean = sum / N NEW_LINE if ( N & 1 ) : NEW_LINE INDENT return binarySearch ( arr , N , mean ) NEW_LINE DEDENT else : NEW_LINE INDENT return twoPointers ( arr , N , mean ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1.0 , 3.0 , 6.0 , 9.0 , 12.0 , 32.0 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkArray ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if given array can be rearranged such that mean is equal to median | Function to return true or false if size of array is odd ; To prevent overflow ; If element is greater than mid , then it can only be present in right subarray ; If element is smaller than mid , then it can only be present in left subarray ; Else the element is present at the middle then return 1 ; when element is not present in array then return 0 ; Function to return true or false if size of array is even ; Calculating Candidate Median ; If Candidate Median if greater than Mean then decrement j ; If Candidate Median if less than Mean then increment i ; If Candidate Median if equal to Mean then return 1 ; when No candidate found for mean ; Function to return true if Mean can be equal to any candidate median otherwise return false ; Calculating Mean ; If N is Odd ; If N is even ; Driver Code",
        "Category": "Binary Search"
    },
    {
        "ID": "9561-9561",
        "Code": "def minOperations ( arr , N , K ) : NEW_LINE INDENT vp = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT vp . append ( [ arr [ i ] , i ] ) NEW_LINE DEDENT vp . sort ( ) NEW_LINE minCnt = 0 NEW_LINE while ( len ( vp ) != 0 ) : NEW_LINE INDENT val = vp [ - 1 ] [ 0 ] NEW_LINE ind = vp [ - 1 ] [ 1 ] NEW_LINE minCnt += 1 NEW_LINE while ( len ( vp ) != 0 and vp [ - 1 ] [ 0 ] == val and ind - vp [ - 1 ] [ 1 ] + 1 <= K ) : NEW_LINE INDENT vp . pop ( ) NEW_LINE DEDENT DEDENT return minCnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 18 , 11 , 18 , 11 , 18 ] NEW_LINE K = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( minOperations ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimize operations to make all array elements | Function to find minimum the number of operations required to make all the array elements to - 1 ; Stores the array elements with their corresponding indices ; Push the array element and it 's index ; Sort the elements according to it 's first value ; Stores the minimum number of operations required ; Traverse until vp is not empty ; Stores the first value of vp ; Stores the second value of vp ; Update the minCnt ; Pop the back element from the vp until the first value is same as val and difference between indices is less than K ; Return the minCnt ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9562-9562",
        "Code": "def nearestLeft ( arr , N , steps ) : NEW_LINE INDENT L = - N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT L = - ( N - i ) NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT L = i NEW_LINE DEDENT steps [ i ] = i - L NEW_LINE DEDENT DEDENT def nearestRight ( arr , N , steps ) : NEW_LINE INDENT R = 2 * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT R = N + i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT R = i NEW_LINE DEDENT steps [ i ] = min ( steps [ i ] , R - i ) NEW_LINE DEDENT DEDENT def findSum ( arr , N , M , K ) : NEW_LINE INDENT steps = [ 0 ] * N NEW_LINE s = sum ( arr ) NEW_LINE if ( s == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT nearestLeft ( arr , N , steps ) NEW_LINE nearestRight ( arr , N , steps ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s += 2 * K * max ( 0 , M - steps [ i ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 0 , 1 , 0 , 1 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE M = 2 NEW_LINE K = 1 NEW_LINE print ( findSum ( arr , N , M , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find array sum after incrementing by K adjacent elements of every positive element M times | Function to find the nearest non - zero element in the left direction ; Stores the index of the first element greater than 0 from the right side ; Traverse the array in the range [ 1 , N ] ; Check arr [ i ] is greater than 0 ; Update the value of L ; Traverse the array from the left side ; Check arr [ i ] is greater than 0 ; Update the value of L ; Update the value of steps [ i ] ; Function to find the nearest non - zero element in the right direction ; Stores the index of the first element greater than 0 from the left side ; Traverse the array from the left side ; Check arr [ i ] is greater than 0 ; Update the value of R ; Traverse the array from the right side ; Check arr [ i ] is greater than 0 ; Update the value of R ; Update the value of steps [ i ] ; Function to find the sum of the array after the given operation M times ; Stores the distance of the nearest non zero element . ; Stores sum of the initial array arr [ ] ; Traverse the array from the left side ; Update the value of sum ; Print the total sum of the array ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "9568-9568",
        "Code": "def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT def countPairs ( L , R ) : NEW_LINE INDENT cntPair = 0 NEW_LINE for a in range ( L , R + 1 , 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 , 1 ) : NEW_LINE INDENT x = getProduct ( a ) NEW_LINE y = getProduct ( b ) NEW_LINE if ( x and y and ( a * y ) == ( b * x ) ) : NEW_LINE INDENT cntPair += 1 NEW_LINE DEDENT DEDENT DEDENT return cntPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 100 NEW_LINE print ( countPairs ( 1 , 100 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of pairs in given range having their ratio equal to ratio of product of their digits | Function to find the product of digits of the given number ; Function to find the count of pairs ( a , b ) such that a : b = ( product ofdigits of a ) : ( product of digits of b ) ; Stores the count of the valid pairs ; Loop to iterate over all unordered pairs ( a , b ) ; Stores the product of digits of a ; Stores the product of digits of b ; If x != 0 and y != 0 and a : b is equivalent to x : y ; Increment valid pair count ; Return Answer ; Driver code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9573-9573",
        "Code": "def lastPositiveElement ( arr ) : NEW_LINE INDENT N = len ( arr ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return arr [ 0 ] ; NEW_LINE DEDENT greatest = - 1 ; secondGreatest = - 1 ; NEW_LINE for x in arr : NEW_LINE INDENT if ( x >= greatest ) : NEW_LINE INDENT secondGreatest = greatest ; NEW_LINE greatest = x ; NEW_LINE DEDENT elif ( x >= secondGreatest ) : NEW_LINE INDENT secondGreatest = x ; NEW_LINE DEDENT DEDENT return greatest - secondGreatest ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 4 , 7 ] ; NEW_LINE print ( lastPositiveElement ( arr ) ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the last positive element remaining after repeated subtractions of smallest positive element from all Array elements | Function to calculate last positive element of the array ; Return the first element if N = 1 ; Stores the greatest and the second greatest element ; Traverse the array A [ ] ; If current element is greater than the greatest element ; If current element is greater than second greatest element ; Return the final answer ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "9578-9578",
        "Code": "from queue import Queue NEW_LINE adj = [ [ 0 ] * 100000 ] * 100000 NEW_LINE setNum = [ 0 ] * 100000 NEW_LINE def addEdge ( a1 , a2 ) : NEW_LINE INDENT adj [ a1 ] . append ( a2 ) ; NEW_LINE adj [ a2 ] . append ( a1 ) ; NEW_LINE DEDENT def toBipartite ( N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT setNum [ i ] = - 1 NEW_LINE DEDENT q = Queue ( ) ; NEW_LINE q . put ( 0 ) ; NEW_LINE setNum [ 0 ] = 0 ; NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT v = q . queue [ 0 ] ; NEW_LINE q . get ( ) ; NEW_LINE for u in adj [ v ] : NEW_LINE INDENT if ( setNum [ u ] == - 1 ) : NEW_LINE INDENT setNum [ u ] = setNum [ v ] ^ 1 ; NEW_LINE q . put ( u ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def pathLengthQuery ( A , B ) : NEW_LINE INDENT if ( setNum [ A ] == setNum [ B ] ) : NEW_LINE INDENT print ( \" Odd \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Even \" ) ; NEW_LINE DEDENT DEDENT N = 7 ; NEW_LINE addEdge ( 0 , 1 ) ; NEW_LINE addEdge ( 0 , 2 ) ; NEW_LINE addEdge ( 1 , 3 ) ; NEW_LINE addEdge ( 3 , 4 ) ; NEW_LINE addEdge ( 3 , 5 ) ; NEW_LINE addEdge ( 2 , 6 ) ; NEW_LINE toBipartite ( N ) ; NEW_LINE pathLengthQuery ( 4 , 2 ) ; NEW_LINE pathLengthQuery ( 0 , 4 ) ; NEW_LINE",
        "Type": "py",
        "NL": "Find if path length is even or odd between given Tree nodes for Q queries | Python program for the above approach ; Stores the input tree ; Stores the set number of all nodes ; Function to add an edge in the tree ; Function to convert the given tree into a bipartite graph using BFS ; Set the set number to - 1 for all node of the given tree ; Stores the current node during the BFS traversal of the tree ; Initialize the set number of 1 st node and enqueue it ; BFS traversal of the given tree ; Current node ; Traverse over all neighbours of the current node ; If the set is not assigned ; Assign set number to node u ; Function to find if the path length between node A and B is even or odd ; If the set number of both nodes is same , path length is odd else even ; Driver Code ; Function to convert tree into bipartite",
        "Category": "Graph Theory"
    },
    {
        "ID": "9579-9579",
        "Code": "import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) NEW_LINE if p % 2 == 0 : NEW_LINE INDENT p -= 1 NEW_LINE DEDENT return int ( pow ( 2 , p ) ) NEW_LINE DEDENT def minStep ( N , X ) : NEW_LINE INDENT if N % 2 and X == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT size = 0 NEW_LINE while X < N : NEW_LINE INDENT N -= highestPowerof2 ( N ) NEW_LINE size += 1 NEW_LINE DEDENT if N : NEW_LINE INDENT size += 1 NEW_LINE DEDENT return size NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE X = 2 NEW_LINE print ( minStep ( N , X ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum size of set having either element in range [ 0 , X ] or an odd power of 2 with sum N | Python program for the above approach ; Function to find the highest odd power of 2 in the range [ 0 , N ] ; If P is even , subtract 1 ; Function to find the minimum operations to make N ; If N is odd and X = 0 , then no valid set exist ; Stores the minimum possible size of the valid set ; Loop to subtract highest odd power of 2 while X < N , step 2 ; If N > 0 , then increment the value of answer by 1 ; Return the resultant size of set ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9584-9584",
        "Code": "maxSumPath = 0 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . val = key NEW_LINE self . child = [ ] NEW_LINE DEDENT DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( key ) NEW_LINE return temp NEW_LINE DEDENT def DFS ( root , Sum ) : NEW_LINE INDENT global maxSumPath NEW_LINE if ( len ( root . child ) == 0 ) : NEW_LINE INDENT maxSumPath = max ( maxSumPath , Sum ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( root . child ) ) : NEW_LINE INDENT DFS ( root . child [ i ] , Sum + root . child [ i ] . val ) NEW_LINE DEDENT DEDENT root = newNode ( 1 ) NEW_LINE ( root . child ) . append ( newNode ( 2 ) ) NEW_LINE ( root . child ) . append ( newNode ( 3 ) ) NEW_LINE ( root . child [ 0 ] . child ) . append ( newNode ( 4 ) ) NEW_LINE ( root . child [ 1 ] . child ) . append ( newNode ( 6 ) ) NEW_LINE ( root . child [ 0 ] . child ) . append ( newNode ( 5 ) ) NEW_LINE ( root . child [ 1 ] ) . child . append ( newNode ( 7 ) ) NEW_LINE ( root . child [ 1 ] . child ) . append ( newNode ( 8 ) ) NEW_LINE DFS ( root , root . val ) NEW_LINE print ( maxSumPath ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize sum of path from the Root to a Leaf node in N | Stores the maximum sum of a path ; Structure of a node in the tree ; Utility function to create a new node in the tree ; Recursive function to calculate the maximum sum in a path using DFS ; If current node is a leaf node ; Traversing all children of the current node ; Recursive call for all the children nodes ; Given Generic Tree ; Function Call",
        "Category": "Binary Tree"
    },
    {
        "ID": "9588-9588",
        "Code": "def countTriplets ( size , queries , arr , Q ) : NEW_LINE INDENT arr_even = [ 0 for i in range ( size + 1 ) ] NEW_LINE arr_odd = [ 0 for i in range ( size + 1 ) ] NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE arr_even [ 0 ] = 0 NEW_LINE arr_odd [ 0 ] = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT arr_even [ i + 1 ] = even NEW_LINE arr_odd [ i + 1 ] = odd NEW_LINE DEDENT for i in range ( queries ) : NEW_LINE INDENT l = Q [ i ] [ 0 ] NEW_LINE r = Q [ i ] [ 1 ] NEW_LINE odd = arr_odd [ r ] - arr_odd [ l - 1 ] NEW_LINE even = arr_even [ r ] - arr_even [ l - 1 ] NEW_LINE ans = ( even * ( even - 1 ) * ( even - 2 ) ) // 6 + ( odd * ( odd - 1 ) // 2 ) * even NEW_LINE print ( ans , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE Q = 2 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 5 ] ] NEW_LINE countTriplets ( N , Q , arr , queries ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of even sum triplets in the array for Q range queries | Function to count number of triplets with even sum in range l , r for each query ; Initialization of array ; Initialization of variables ; Traversing array ; If element is odd ; If element is even ; Storing count of even and odd till each i ; Traversing each query ; Count of odd numbers in l to r ; Count of even numbers in l to r ; Finding the ans ; Printing the ans ; Driver Code ; Given Input ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "9596-9596",
        "Code": "def findIfPossible ( N , S , X ) : NEW_LINE INDENT if ( S >= X and S % 2 == X % 2 ) : NEW_LINE INDENT if ( N >= 3 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( S == X ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT if ( N == 2 ) : NEW_LINE INDENT C = ( S - X ) // 2 NEW_LINE A = C NEW_LINE B = C NEW_LINE A = A + X NEW_LINE if ( ( ( A ^ B ) == X ) ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT N = 3 NEW_LINE S = 10 NEW_LINE X = 4 NEW_LINE print ( findIfPossible ( N , S , X ) ) NEW_LINE",
        "Type": "py",
        "NL": "Check if it is possible to construct an Array of size N having sum as S and XOR value as X | Function to find if any sequence is possible or not . ; Since , S is greater than equal to X , and either both are odd or even There always exists a sequence ; Only one case possible is S == X or NOT ; Considering the above conditions true , check if XOR of S ^ ( S - X ) is X or not ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9599-9599",
        "Code": "a = [ ] NEW_LINE seg_tree = [ ] NEW_LINE query = [ ] NEW_LINE def build_tree ( v , tl , tr ) : NEW_LINE INDENT global a , seg_tree , query NEW_LINE if ( tl != tr ) : NEW_LINE INDENT if ( a [ tl ] == 0 ) : NEW_LINE INDENT seg_tree [ v ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT seg_tree [ v ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tm = int ( ( tl + tr ) / 2 ) NEW_LINE build_tree ( v * 2 , tl , tm ) NEW_LINE build_tree ( v * 2 + 1 , tm + 1 , tr ) NEW_LINE seg_tree [ v ] = seg_tree [ v * 2 ] + seg_tree [ v * 2 + 1 ] NEW_LINE DEDENT DEDENT def frequency_zero ( v , tl , tr , l , r ) : NEW_LINE INDENT global a , seg_tree , query NEW_LINE if ( l > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == tl and r == tr ) : NEW_LINE INDENT return seg_tree [ v ] NEW_LINE DEDENT tm = int ( ( tl + tr ) / 2 ) NEW_LINE return frequency_zero ( v * 2 , tl , tm , l , min ( r , tm ) ) + frequency_zero ( v * 2 + 1 , tm + 1 , tr , max ( l , tm + 1 ) , r ) NEW_LINE DEDENT def update ( v , tl , tr , pos , new_val ) : NEW_LINE INDENT global a , seg_tree , query NEW_LINE if ( tl == tr ) : NEW_LINE INDENT if ( new_val == 0 ) : NEW_LINE INDENT seg_tree [ v ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT seg_tree [ v ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tm = int ( ( tl + tr ) / 2 ) NEW_LINE if ( pos <= tm ) : NEW_LINE INDENT update ( v * 2 , tl , tm , pos , new_val ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( v * 2 + 1 , tm + 1 , tr , pos , new_val ) NEW_LINE DEDENT seg_tree [ v ] = seg_tree [ v * 2 ] + seg_tree [ v * 2 + 1 ] NEW_LINE DEDENT DEDENT def solve ( n , q ) : NEW_LINE INDENT global a , seg_tree , query NEW_LINE qu = [ 5 , 3 , 6 ] NEW_LINE seg_tree = [ 0 ] * ( 4 * n + 1 ) NEW_LINE build_tree ( 1 , 0 , n - 1 ) NEW_LINE for i in range ( len ( qu ) ) : NEW_LINE INDENT print ( qu [ i ] ) NEW_LINE DEDENT for i in range ( q , q ) : NEW_LINE INDENT if query [ i - 1 ] [ 0 ] == 1 : NEW_LINE INDENT l = query [ i - 1 ] [ 1 ] NEW_LINE r = query [ i - 1 ] [ 2 ] NEW_LINE print ( frequency_zero ( 1 , 0 , n - 1 , l , r ) ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] NEW_LINE pos = query [ i - 1 ] [ 1 ] NEW_LINE new_val = query [ i - 1 ] [ 2 ] NEW_LINE update ( 1 , 0 , n - 1 , pos , new_val ) NEW_LINE DEDENT DEDENT DEDENT a = [ 9 , 5 , 7 , 6 , 9 , 0 , 0 , 0 , 0 , 5 , 6 , 7 , 3 , 9 , 0 , 7 , 0 , 9 , 0 ] NEW_LINE Q = 5 NEW_LINE query = [ [ 1 , 5 , 14 ] , [ 2 , 6 , 1 ] , [ 1 , 0 , 8 ] , [ 2 , 13 , 0 ] , [ 1 , 6 , 18 ] ] NEW_LINE N = len ( a ) NEW_LINE solve ( N , Q ) NEW_LINE",
        "Type": "py",
        "NL": "Count of Ks in the Array for a given range of indices after array updates for Q queries | Python3 program for the above approach ; Function to build the segment tree ; Base case ; Since the count of zero is required set leaf node as 1 ; If the value in array is not zero , store 0 in the leaf node ; Find the mid ; Recursive call for left subtree ; Recursive call for right subtree ; Parent nodes contains the count of zero in range tl to tr ; Function to find the count of 0 s in range l to r ; Base Case ; Case when no two segment are combining ; Finding the mid ; When it is required to combine left subtree and right subtree to get the range l to r ; Function that updates the segment tree nodes ; Base Case ; If array element is 0 ; If array element is not 0 ; Otherwise ; Find the mid ; Update the tree or count which is stored in parent node ; Function to solve all the queries ; When query type is 1 ; When query type is 2 ; Driver code",
        "Category": "Segment Tree"
    },
    {
        "ID": "9603-9603",
        "Code": "import math NEW_LINE def Binary_Num ( N , K ) : NEW_LINE INDENT if N - K - 1 >= 0 and K - 1 >= 0 : NEW_LINE INDENT num_even = math . factorial ( N - 2 ) / ( math . factorial ( K - 1 ) * math . factorial ( N - K - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT num_even = 0 NEW_LINE DEDENT if K - 2 >= 0 : NEW_LINE INDENT num_odd = math . factorial ( N - 2 ) / ( math . factorial ( K - 2 ) * math . factorial ( N - K ) ) NEW_LINE DEDENT else : NEW_LINE INDENT num_odd = 0 NEW_LINE DEDENT print ( int ( num_even ) , int ( num_odd ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE K = 6 NEW_LINE Binary_Num ( N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of N | Python program for the above approach ; Function to find the count of odd and even integers having N bits and K set bits ; Find the count of even integers ; Find the count of odd integers ; Print the total count ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9605-9605",
        "Code": "def gcd1OfTwoNos ( num1 , num2 ) : NEW_LINE INDENT if ( num1 == 0 ) : NEW_LINE INDENT return num2 NEW_LINE DEDENT if ( num2 == 0 ) : NEW_LINE INDENT return num1 NEW_LINE DEDENT if ( num1 == num2 ) : NEW_LINE INDENT return num1 NEW_LINE DEDENT if ( num1 > num2 ) : NEW_LINE INDENT return gcd1OfTwoNos ( num1 - num2 , num2 ) NEW_LINE DEDENT return gcd1OfTwoNos ( num1 , num2 - num1 ) NEW_LINE DEDENT def Min_sum ( arr , N ) : NEW_LINE INDENT min_sum = 1000000 NEW_LINE maxgcd1 = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT gcd1 = 1 NEW_LINE if ( i == 0 ) : NEW_LINE INDENT gcd1 = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT gcd1 = arr [ i - 1 ] NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT if ( j != i ) : NEW_LINE INDENT gcd1 = gcd1OfTwoNos ( gcd1 , arr [ j ] ) NEW_LINE DEDENT DEDENT c = arr [ i ] NEW_LINE if ( gcd1 > maxgcd1 ) : NEW_LINE INDENT maxgcd1 = gcd1 NEW_LINE DEDENT DEDENT return maxgcd1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 16 , 5 , 10 , 25 ] NEW_LINE N = len ( arr ) NEW_LINE print ( Min_sum ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number which can divide all array element after one replacement | Function to return gcd1 of two numbers ; If one of numbers is 0 then gcd1 is other number ; If both are equal then that value is gcd1 ; One is greater ; Function to return minimum sum ; Initialize min_sum with large value ; Initialize variable gcd1 ; Storing value of arr [ i ] in c ; Update maxgcd1 if gcd1 is greater than maxgcd1 ; returning the maximum divisor of all elements ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9609-9609",
        "Code": "def findSumOfAllSubsets ( arr , n , k ) : NEW_LINE INDENT factorial_N = 1 NEW_LINE factorial_d = 1 NEW_LINE factorial_D = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT factorial_N *= i NEW_LINE DEDENT for i in range ( 1 , k , 1 ) : NEW_LINE INDENT factorial_d *= i NEW_LINE DEDENT for i in range ( 1 , n - k + 1 , 1 ) : NEW_LINE INDENT factorial_D *= i NEW_LINE DEDENT freq = factorial_N // ( factorial_d * factorial_D ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum = sum * freq NEW_LINE print ( \" Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ \" , k , \" ▁ is ▁ = > \" , sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = 4 NEW_LINE k = 2 NEW_LINE findSumOfAllSubsets ( arr , n , k ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of all subsets of a given size ( = K ) | Function to find the sum of all sub - sets of size K ; Frequency of each array element in summation equation . ; calculate factorial of n - 1 ; calculate factorial of k - 1 ; calculate factorial of n - k ; Calculate sum of array . ; Sum of all subsets of size k . ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9612-9612",
        "Code": "def maximumTripletXOR ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT cur = 1 << i NEW_LINE if ( A >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE A -= cur NEW_LINE DEDENT elif ( B >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE B -= cur NEW_LINE DEDENT elif ( C >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE C -= cur NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = 6 NEW_LINE B = 2 NEW_LINE C = 10 NEW_LINE print ( maximumTripletXOR ( A , B , C ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize XOR by selecting 3 numbers in range [ 0 , A ] , [ 0 , B ] , and [ 0 , C ] respectively | Function to calculate maximum triplet XOR form 3 ranges ; Initialize a variable to store the answer ; create minimum number that have a set bit at ith position ; Check for each number and try to greedily choose the bit if possible If A >= cur then A also have a set bit at ith position ; Increment the answer ; Subtract this value from A ; Check for B ; Increment the answer ; Subtract this value from B ; Check for C ; Increment the answer ; Subtract this value from C ; If any of the above conditions is not satisfied then there is no way to turn that bit ON . ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9613-9613",
        "Code": "def intCount ( X , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for z in range ( 0 , int ( pow ( 10 , K ) ) , int ( ( pow ( 10 , K ) - 1 ) / 9 ) ) : NEW_LINE INDENT if ( z > X ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += int ( ( X - z ) / int ( pow ( 10 , K ) ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def intCountInRange ( L , R , K ) : NEW_LINE INDENT return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) NEW_LINE DEDENT L = 49 NEW_LINE R = 101 NEW_LINE K = 2 NEW_LINE print ( intCountInRange ( L , R , K ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of integers in given range having their last K digits are equal | Function to return the count of integers from 1 to X having the last K digits as equal ; Stores the total count of integers ; Loop to iterate over all possible values of z ; Terminate the loop when z > X ; Add count of integers with last K digits equal to z ; Return count ; Function to return the count of integers from L to R having the last K digits as equal ; Driver Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9617-9617",
        "Code": "def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N ) : NEW_LINE INDENT sum += ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def CountPair ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = arr [ i ] + sumOfDigits ( arr [ i ] ) NEW_LINE if val in mp : NEW_LINE INDENT mp [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ val ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT val = key NEW_LINE times = value NEW_LINE count += ( ( times * ( times - 1 ) ) // 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 105 , 96 , 20 , 2 , 87 , 96 ] NEW_LINE N = len ( arr ) NEW_LINE print ( CountPair ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs in an array having sum of elements with their respective sum of digits equal | Function to find the sum of digits of the number N ; Stores the sum of digits ; If the number N is greater than 0 ; Return the sum ; Function to find the count of pairs such that arr [ i ] + sumOfDigits ( arr [ i ] ) is equal to ( arr [ j ] + sumOfDigits ( arr [ j ] ) ; Stores the frequency of value of arr [ i ] + sumOfDigits ( arr [ i ] ) ; Traverse the given array ; Find the value ; Increment the frequency ; Stores the total count of pairs ; Traverse the map mp ; Update the count of pairs ; Return the total count of pairs ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "9619-9619",
        "Code": "MAXN = 10000000 NEW_LINE def can ( Mid , X , Y , A , B ) : NEW_LINE INDENT p1 = X - Mid * B NEW_LINE p2 = Y - Mid * B NEW_LINE if ( p1 < 0 or p2 < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = A - B NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT val = p1 // k + p2 // k NEW_LINE if ( val >= Mid ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxPossibleMoves ( X , Y , A , B ) : NEW_LINE INDENT ans = 0 NEW_LINE L = 1 NEW_LINE R = MAXN NEW_LINE while ( L <= R ) : NEW_LINE INDENT Mid = ( L + R ) // 2 NEW_LINE if ( can ( Mid , X , Y , A , B ) ) : NEW_LINE INDENT L = Mid + 1 NEW_LINE ans = max ( ans , Mid ) NEW_LINE DEDENT else : NEW_LINE INDENT R = Mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT X = 10 NEW_LINE Y = 12 NEW_LINE A = 2 NEW_LINE B = 5 NEW_LINE if ( A < B ) : NEW_LINE INDENT tmp = A NEW_LINE A = B NEW_LINE B = tmp NEW_LINE DEDENT print ( maxPossibleMoves ( X , Y , A , B ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximum times X and Y can be reduced to near 0 using numbers A or B | Helper function to check if we can perform Mid number of moves ; Remove atleast Mid * B from both X and Y ; If any value is negative return false . ; Calculate remaining values ; If val >= Mid then it is possible to perform this much moves ; else return false ; Initialize a variable to store the answer ; Fix the left and right range ; Binary Search over the answer ; Check for the middle value as the answer ; It is possible to perform this much moves ; Maximise the answer ; Return answer ; Driver Code ; Generalise that A >= B",
        "Category": "Binary Search"
    },
    {
        "ID": "9627-9627",
        "Code": "def countCells ( n , m , s ) : NEW_LINE INDENT mx1 = - 1 NEW_LINE cont1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < s and i < n ) : NEW_LINE INDENT aux = ( n - ( i + 1 ) ) // s + 1 NEW_LINE if ( aux > mx1 ) : NEW_LINE INDENT mx1 = cont1 = aux NEW_LINE DEDENT elif ( aux == mx1 ) : NEW_LINE INDENT cont1 += aux NEW_LINE DEDENT i += 1 NEW_LINE DEDENT mx2 = - 1 NEW_LINE cont2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < s and i < m ) : NEW_LINE INDENT aux = ( m - ( i + 1 ) ) // s + 1 NEW_LINE if ( aux > mx2 ) : NEW_LINE INDENT mx2 = cont2 = aux NEW_LINE DEDENT elif ( aux == mx2 ) : NEW_LINE INDENT cont2 += aux NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cont1 * cont2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE M = 5 NEW_LINE K = 2 NEW_LINE print ( countCells ( N , M , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count cells in a grid from which maximum number of cells can be reached by K vertical or horizontal jumps | Function to count the number of cells in the grid such that maximum cell is reachable with a jump of K ; Maximum reachable rows from the current row ; Stores the count of cell that are reachable from the current row ; Count of reachable rows ; Update the maximum value ; Add it to the count ; Maximum reachable columns from the current column ; Stores the count of cell that are reachable from the current column ; Count of rechable columns ; Update the maximum value ; Add it to the count ; Return the total count of cells ; Driver Code",
        "Category": "Matrix"
    },
    {
        "ID": "9631-9631",
        "Code": "def can_empty ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 4 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( a , min ( b , c ) ) ; NEW_LINE if ( m < ( a + b + c ) // 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT a = 4 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE print ( \" true \" if can_empty ( a , b , c ) else \" false \" ) ; NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 2 NEW_LINE print ( \" true \" if can_empty ( a , b , c ) else \" false \" ) ; NEW_LINE",
        "Type": "py",
        "NL": "Check if all 3 Candy bags can be emptied by removing 2 candies from any one bag and 1 from the other two repeatedly | Python code for the above approach ; If total candies are not multiple of 4 then its not possible to be left with 0 candies ; If minimum candies of three bags are less than number of operations required then the task is not possible ; Driver code",
        "Category": "Math"
    },
    {
        "ID": "9643-9643",
        "Code": "def oppositeFaceOfDice ( N ) : NEW_LINE INDENT ans = 7 - N NEW_LINE print ( ans ) NEW_LINE DEDENT N = 2 NEW_LINE oppositeFaceOfDice ( N ) NEW_LINE",
        "Type": "py",
        "NL": "The dice problem | Function to find number written on the opposite face of the dice ; Stores number on opposite face of dice ; Print the answer ; Given value of N ; Function call to find number written on the opposite face of the dice",
        "Category": "Math"
    },
    {
        "ID": "9646-9646",
        "Code": "def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N / i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT curr = s [ N ] NEW_LINE cnt = { s [ N ] : 1 } NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if N and s [ N ] : NEW_LINE INDENT if cnt . get ( s [ N ] , 0 ) == 0 : NEW_LINE INDENT cnt [ s [ N ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ s [ N ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT if 0 in cnt : NEW_LINE INDENT cnt . pop ( 0 ) NEW_LINE DEDENT totfactor = 1 NEW_LINE for i in cnt . values ( ) : NEW_LINE INDENT totfactor *= i + 1 NEW_LINE DEDENT return totfactor NEW_LINE DEDENT def countTriplets ( N ) : NEW_LINE INDENT CountTriplet = 0 NEW_LINE for z in range ( 1 , N + 1 ) : NEW_LINE INDENT p = generatePrimeFactors ( N - z ) NEW_LINE if p > 1 : NEW_LINE INDENT CountTriplet += p NEW_LINE DEDENT DEDENT return CountTriplet + 1 NEW_LINE DEDENT N = 10 NEW_LINE s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( countTriplets ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count of triplets having sum of product of any two numbers with the third number equal to N | Function to find the SPF [ i ] using the Sieve Of Erastothenes ; Stores whether i is prime or not ; Initializing smallest factor as 2 for all even numbers ; Iterate for all odd numbers < N ; SPF of i for a prime is the number itself ; Iterate for all the multiples of the current prime number ; The value i is smallest prime factor for i * j ; Function to generate prime factors and its power ; Current prime factor of N ; Stores the powers of the current prime factor ; Find all the prime factors and their powers ; Return the total count of factors ; Function to count the number of triplets satisfying the given criteria ; Stores the count of resultant triplets ; Add the count all factors of N - z to the variable CountTriplet ; Return total count of triplets ; Driver Code ; S [ i ] stores the smallest prime factor for each element i ; Find the SPF [ i ] ; Function Call",
        "Category": "Hash Table"
    },
    {
        "ID": "9648-9648",
        "Code": "from math import log2 NEW_LINE def findAandB ( N ) : NEW_LINE INDENT K = int ( log2 ( N ) ) NEW_LINE B = ( 1 << K ) NEW_LINE A = B ^ N NEW_LINE print ( A , B ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 26 NEW_LINE findAandB ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest pair of integers with minimum difference whose Bitwise XOR is N | Python3 program for the above approach ; Function to find the numbers A and B whose Bitwise XOR is N and the difference between them is minimum ; Find the MSB of the N ; Find the value of B ; Find the value of A ; Print the result ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "9657-9657",
        "Code": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . data = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getNewNode ( val ) : NEW_LINE INDENT newNode = Node ( val ) NEW_LINE return newNode NEW_LINE DEDENT def buildPerfectBT_helper ( preStart , preEnd , pre ) : NEW_LINE INDENT if ( preStart > preEnd ) : NEW_LINE INDENT return None NEW_LINE DEDENT root = getNewNode ( pre [ preStart ] ) NEW_LINE if ( preStart == preEnd ) : NEW_LINE INDENT return root NEW_LINE DEDENT leftPreStart = preStart + 1 NEW_LINE rightPreStart = leftPreStart + int ( ( preEnd - leftPreStart + 1 ) / 2 ) NEW_LINE leftPreEnd = rightPreStart - 1 NEW_LINE rightPreEnd = preEnd NEW_LINE root . left = buildPerfectBT_helper ( leftPreStart , leftPreEnd , pre ) NEW_LINE root . right = buildPerfectBT_helper ( rightPreStart , rightPreEnd , pre ) NEW_LINE return root NEW_LINE DEDENT def buildPerfectBT ( pre , size ) : NEW_LINE INDENT return buildPerfectBT_helper ( 0 , size - 1 , pre ) NEW_LINE DEDENT def printInorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( root . left ) NEW_LINE print ( root . data , \" \" , end = \" \" ) NEW_LINE printInorder ( root . right ) NEW_LINE DEDENT pre = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE N = len ( pre ) NEW_LINE root = buildPerfectBT ( pre , N ) NEW_LINE print ( \" Inorder ▁ traversal ▁ of ▁ the ▁ tree : ▁ \" , end = \" \" ) NEW_LINE printInorder ( root ) NEW_LINE",
        "Type": "py",
        "NL": "Construct a Perfect Binary Tree from Preorder Traversal | Structure of the tree ; Function to create a new node with the value val ; Return the newly created node ; Function to create the Perfect Binary Tree ; If preStart > preEnd return NULL ; Initialize root as pre [ preStart ] ; If the only node is left , then return node ; Parameters for further recursion ; Recursive Call to build the subtree of root node ; Return the created root ; Function to build Perfect Binary Tree ; Function to print the Inorder of the given Tree ; Base Case ; Left Recursive Call ; Print the data ; Right Recursive Call ; Driver Code ; Function Call ; Print Inorder Traversal",
        "Category": "Binary Tree"
    },
    {
        "ID": "9661-9661",
        "Code": "def checkDistribution ( R , B , D ) : NEW_LINE INDENT if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT R = 1 NEW_LINE B = 1 NEW_LINE D = 0 NEW_LINE checkDistribution ( R , B , D ) NEW_LINE",
        "Type": "py",
        "NL": "Distribute R , B beans such that each packet has at least 1 R and 1 B bean with absolute difference at most D | Function to check if it is possible to distribute R red and B blue beans in packets such that the difference between the beans in each packet is atmost D ; Check for the condition to distributing beans ; Print the answer ; Distribution is not possible ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9666-9666",
        "Code": "def IsEvenPath ( Source , Destination ) : NEW_LINE INDENT x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) NEW_LINE y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) NEW_LINE minsteps = x_dif + y_dif NEW_LINE if ( minsteps % 2 == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Source = [ 2 , 1 ] NEW_LINE Destination = [ 1 , 4 ] NEW_LINE IsEvenPath ( Source , Destination ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if it is possible to reach destination in even number of steps in an Infinite Matrix | Function to check destination can be reached from source in even number of steps ; Coordinates differences ; Minimum number of steps required ; Minsteps is even ; Minsteps is odd ; Driver Code ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9667-9667",
        "Code": "def ABS ( x ) : NEW_LINE INDENT return max ( x , - x ) NEW_LINE DEDENT def findFraction ( x , y , n ) : NEW_LINE INDENT A = - 1 NEW_LINE B = - 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT d = ( i * x ) // y NEW_LINE if ( d >= 0 and ( A == - 1 or ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) : NEW_LINE INDENT A = d NEW_LINE B = i NEW_LINE DEDENT d += 1 NEW_LINE if ( d >= 0 and ( A == - 1 or ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) : NEW_LINE INDENT A = d NEW_LINE B = i NEW_LINE DEDENT DEDENT print ( str ( A ) + \" / \" + str ( B ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE y = 7 NEW_LINE n = 6 NEW_LINE findFraction ( x , y , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find the closest Fraction to given fraction having minimum absolute difference | Function to find the absolute value of x ; Function to find the fraction with minimum absolute difference ; Initialize the answer variables ; Iterate over the range ; Nearest fraction ; x / y - d / i < x / y - A / B ( B * x - y * A ) * ( i * y ) > ( i * x - y * d ) * ( B * y ) ; Check for d + 1 ; Print the answer ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "967-967",
        "Code": "R = 3 NEW_LINE C = 3 NEW_LINE x = [ 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 ] NEW_LINE y = [ 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 ] NEW_LINE dp = [ [ 0 for i in range ( C ) ] for i in range ( R ) ] NEW_LINE def isvalid ( i , j ) : NEW_LINE INDENT if ( i < 0 or j < 0 or i >= R or j >= C ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isadjacent ( prev , curr ) : NEW_LINE INDENT if ( ord ( curr ) - ord ( prev ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def getLenUtil ( mat , i , j , prev ) : NEW_LINE INDENT if ( isvalid ( i , j ) == False or isadjacent ( prev , mat [ i ] [ j ] ) == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ans = 0 NEW_LINE for k in range ( 8 ) : NEW_LINE INDENT ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ans NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT def getLen ( mat , s ) : NEW_LINE INDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == s ) : NEW_LINE INDENT for k in range ( 8 ) : NEW_LINE INDENT ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ ' a ' , ' c ' , ' d ' ] , [ ' h ' , ' b ' , ' a ' ] , [ ' i ' , ' g ' , ' f ' ] ] NEW_LINE print ( getLen ( mat , ' a ' ) ) NEW_LINE print ( getLen ( mat , ' e ' ) ) NEW_LINE print ( getLen ( mat , ' b ' ) ) NEW_LINE print ( getLen ( mat , ' f ' ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find length of the longest consecutive path from a given starting character | Python3 program to find the longest consecutive path ; tool matrices to recur for adjacent cells . ; dp [ i ] [ j ] Stores length of longest consecutive path starting at arr [ i ] [ j ] . ; check whether mat [ i ] [ j ] is a valid cell or not . ; Check whether current character is adjacent to previous character ( character processed in parent call ) or not . ; i , j are the indices of the current cell and prev is the character processed in the parent call . . also mat [ i ] [ j ] is our current character . ; If this cell is not valid or current character is not adjacent to previous one ( e . g . d is not adjacent to b ) or if this cell is already included in the path than return 0. ; If this subproblem is already solved , return the answer ; Initialize answer ; recur for paths with different adjacent cells and store the length of longest path . ; save the answer and return ; Returns length of the longest path with all characters consecutive to each other . This function first initializes dp array that is used to store results of subproblems , then it calls recursive DFS based function getLenUtil ( ) to find max length path ; check for each possible starting point ; recur for all eight adjacent cells ; Driver program",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9671-9671",
        "Code": "def BaseConversion ( N ) : NEW_LINE INDENT s = \" \" NEW_LINE while ( N != 0 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT s = \"0\" + s NEW_LINE DEDENT else : NEW_LINE INDENT s = \"1\" + s NEW_LINE N -= 1 NEW_LINE DEDENT N /= - 2 NEW_LINE DEDENT if ( s == \" \" ) : NEW_LINE INDENT s = \"0\" NEW_LINE DEDENT return s NEW_LINE DEDENT N = - 9 NEW_LINE print ( BaseConversion ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Represent a number N in base | Function to convert N to equivalent representation in base - 2 ; Stores the required answer ; Iterate until N is not equal to zero ; If N is Even ; Add char '0' in front of string ; Add char '1' in front of string ; Decrement N by 1 ; Divide N by - 2 ; If string is empty , that means N is zero ; Put '0' in string s ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9672-9672",
        "Code": "from math import ceil NEW_LINE def finalInstances ( instances , arr ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT if arr [ i ] < 25 and instances > 1 : NEW_LINE INDENT instances = ceil ( instances / 2 ) NEW_LINE i += 10 NEW_LINE DEDENT elif arr [ i ] > 60 and instances <= 10 ** 8 : NEW_LINE INDENT instances *= 2 NEW_LINE i += 10 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( instances ) NEW_LINE DEDENT instances = 2 NEW_LINE arr = [ 25 , 23 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 76 , 80 ] NEW_LINE finalInstances ( instances , arr ) NEW_LINE",
        "Type": "py",
        "NL": "Find instances at end of time frame after auto scaling | Python program for the above approach ; Function to find the number of instances after completion ; Traverse the array , arr [ ] ; If current element is less than 25 ; Divide instances by 2 ; If the current element is greater than 60 ; Double the instances ; Print the instances at the end of the traversal ; Driver Code ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "9683-9683",
        "Code": "def FractionSplit ( n , d ) : NEW_LINE INDENT UnitFactions = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = ( d + n - 1 ) // n NEW_LINE s = \"1 / \" + str ( x ) NEW_LINE UnitFactions . append ( s ) ; NEW_LINE n = n * x - d ; NEW_LINE d = d * x NEW_LINE DEDENT return UnitFactions ; NEW_LINE DEDENT n = 13 ; NEW_LINE d = 18 ; NEW_LINE res = FractionSplit ( n , d ) ; NEW_LINE for s in res : NEW_LINE INDENT print ( s + \" , ▁ \" , end = \" ▁ \" ) ; NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Split the fraction into sum of multiple fractions having numerator as 1 | Function to split the fraction into distinct unit fraction ; To store answer ; While numerator is positive ; Finding x = ceil ( d / n ) ; Add 1 / x to list of ans ; Update fraction ; Given Input ; Function Call ; Print Answer",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9687-9687",
        "Code": "def addAP ( A , Q , operations ) : NEW_LINE INDENT for L , R , a , d in operations : NEW_LINE INDENT curr = a NEW_LINE for i in range ( L - 1 , R ) : NEW_LINE INDENT A [ i ] += curr NEW_LINE curr += d NEW_LINE DEDENT DEDENT for i in A : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT A = [ 5 , 4 , 2 , 8 ] NEW_LINE Q = 2 NEW_LINE Query = [ ( 1 , 2 , 1 , 3 ) , ( 1 , 4 , 4 , 1 ) ] NEW_LINE addAP ( A , Q , Query ) NEW_LINE",
        "Type": "py",
        "NL": "Find Array obtained after adding terms of AP for Q queries | Function to find array after performing the given query to the array elements ; Traverse the given query ; Traverse the given array ; Update the value of A [ i ] ; Update the value of curr ; Print the array elements ; Driver Code ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "9688-9688",
        "Code": "def maximizeNumber ( N , K ) : NEW_LINE INDENT s = str ( N ) NEW_LINE L = len ( s ) NEW_LINE result = \" \" NEW_LINE i = 0 NEW_LINE while ( ( i < L ) and ( K <= ( ord ( s [ i ] ) - ord ( '0' ) ) ) ) : NEW_LINE INDENT result += ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT result += ( chr ( K + ord ( '0' ) ) ) NEW_LINE while ( i < L ) : NEW_LINE INDENT result += ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6673 NEW_LINE K = 6 NEW_LINE maximizeNumber ( N , K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximize the number N by inserting given digit at any position | Function to find the maximum value of N after inserting the digit K ; Convert it into N to string ; Stores the maximum value of N after inserting K ; Iterate till all digits that are not less than K ; Add the current digit to the string result ; Add digit ' K ' to result ; Iterate through all remaining characters ; Add current digit to result ; Print the maximum number formed ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "969-969",
        "Code": "import math as mt NEW_LINE R = 3 NEW_LINE C = 3 NEW_LINE def minInitialPoints ( points ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] NEW_LINE m , n = R , C NEW_LINE if points [ m - 1 ] [ n - 1 ] > 0 : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) NEW_LINE DEDENT for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT points = [ [ - 2 , - 3 , 3 ] , [ - 5 , - 10 , 1 ] , [ 10 , 30 , - 5 ] ] NEW_LINE print ( \" Minimum ▁ Initial ▁ Points ▁ Required : \" , minInitialPoints ( points ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimum Initial Points to Reach Destination | Python3 program to find minimum initial points to reach destination ; dp [ i ] [ j ] represents the minimum initial points player should have so that when starts with cell ( i , j ) successfully reaches the destination cell ( m - 1 , n - 1 ) ; Base case ; Fill last row and last column as base to fill entire table ; fill the table in bottom - up fashion ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9698-9698",
        "Code": "def DistRecursion ( S , i , dist ) : NEW_LINE INDENT if i == len ( S ) : NEW_LINE INDENT return abs ( dist ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if S [ i ] == ' L ' : NEW_LINE INDENT return DistRecursion ( S , i + 1 , dist - 1 ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if S [ i ] == ' R ' : NEW_LINE INDENT return DistRecursion ( S , i + 1 , dist + 1 ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT return max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) NEW_LINE DEDENT def maxDistance ( S ) : NEW_LINE INDENT return DistRecursion ( S , 0 , 0 ) NEW_LINE DEDENT S = \" ? RRR ? \" NEW_LINE print ( maxDistance ( S ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize absolute displacement from origin by moving on X | Recursive function to find the maximum absolute displacement from origin by performing the given set of moves ; If i is equal to N ; If S [ i ] is equal to 'L ; If S [ i ] is equal to 'R ; If S [ i ] is equal to '? ; Function to find the maximum absolute displacement from the origin ; Return the maximum absolute displacement ; Input ; Function call",
        "Category": "Backtracking"
    },
    {
        "ID": "9700-9700",
        "Code": "MAX = 100005 NEW_LINE from math import sqrt NEW_LINE def isPerfect ( N ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i * i != N ) : NEW_LINE INDENT sum = sum + i + N // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if ( sum == N and N != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def Query ( arr , N ) : NEW_LINE INDENT prefix = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( 2 , MAX + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + isPerfect ( i ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( prefix [ arr [ i ] [ 1 ] ] - prefix [ arr [ i ] [ 0 ] - 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 1000 ] , [ 1000 , 2000 ] , [ 2000 , 3000 ] ] NEW_LINE N = len ( arr ) NEW_LINE Query ( arr , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of Perfect Numbers in given range for Q queries | python 3 program for the above approach ; Function to check whether a number is perfect Number ; Stores sum of divisors ; Itearate over the range [ 2 , sqrt ( N ) ] ; If sum of divisors is equal to N , then N is a perfect number ; Function to find count of perfect numbers in a given range ; Stores the count of perfect Numbers upto a every number less than MAX ; Iterate over the range [ 1 , MAX ] ; Traverse the array arr [ ] ; Print the count of perfect numbers in the range [ arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ] ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9705-9705",
        "Code": "import sys NEW_LINE def MaxRange ( A , n ) : NEW_LINE INDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE s = [ ] NEW_LINE s . append ( ( sys . maxsize , - 1 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( s [ - 1 ] [ 0 ] < A [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT left [ i ] = s [ - 1 ] [ 1 ] NEW_LINE s . append ( ( A [ i ] , i ) ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT s . append ( ( sys . maxsize , n ) ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( s [ - 1 ] [ 0 ] < A [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT right [ i ] = s [ - 1 ] [ 1 ] NEW_LINE s . append ( ( A [ i ] , i ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( left [ i ] + 1 , ' ▁ ' , right [ i ] - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE MaxRange ( arr , n ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum range length such that A [ i ] is maximum in given range for all i from [ 1 , N ] | Python 3 program for the above approach ; Function to find maximum range for each i such that arr [ i ] is max in range ; Vector to store the left and right index for each i such that left [ i ] > arr [ i ] and right [ i ] > arr [ i ] ; Traverse the array ; While s . top ( ) . first < a [ i ] remove the top element from the stack ; Modify left [ i ] ; Clear the stack ; Traverse the array to find right [ i ] for each i ; While s . top ( ) . first < a [ i ] remove the top element from the stack ; Modify right [ i ] ; Print the value range for each i ; Driver Code ; Given Input ; Function Call",
        "Category": "Two Pointers"
    },
    {
        "ID": "9710-9710",
        "Code": "def findkey ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE cur = 1 NEW_LINE while ( A > 0 ) : NEW_LINE INDENT a = A % 10 NEW_LINE b = B % 10 NEW_LINE c = C % 10 NEW_LINE A = A // 10 NEW_LINE B = B // 10 NEW_LINE C = C // 10 NEW_LINE m = max ( a , max ( c , b ) ) NEW_LINE ans += cur * m NEW_LINE cur = cur * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 3521 NEW_LINE B = 2452 NEW_LINE C = 1352 NEW_LINE print ( findkey ( A , B , C ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Maximum number formed from the digits of given three numbers | Function to find the maximum number formed by taking the maximum digit at the same position from each number ; Stores the result ; Stores the position value of a digit ; Stores the digit at the unit place ; Stores the digit at the unit place ; Stores the digit at the unit place ; Update A , B and C ; Stores the maximum digit ; Increment ans cur * a ; Update cur ; Return ans ; Driver Code ; Given Input ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9716-9716",
        "Code": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE if s * s == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def contiguousFibonacciNumber ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isFibonacci ( arr [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 8 , 21 , 5 , 3 , 28 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( contiguousFibonacciNumber ( arr , n ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of longest Fibonacci subarray | Python3 program for the above approach ; A utility function that returns true if x is perfect square ; Returns true if n is a Fibonacci Number , else false ; Here n is fibonacci if one of 5 * n * n + 4 or 5 * n * n - 4 or both is a perfect square ; Function to find the length of the largest sub - array of an array every element of whose is a Fibonacci number ; Traverse the array arr ; Check if arr [ i ] is a Fibonacci number ; stores the maximum length of the Fibonacci number subarray ; Finally , return the maximum length ; Driver code ; Given Input ; Function Call",
        "Category": "Array"
    },
    {
        "ID": "9717-9717",
        "Code": "direction = [ [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] ] NEW_LINE def dfs ( i , j , N , M ) : NEW_LINE INDENT global matrix NEW_LINE if ( i == N - 1 and j == M - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT matrix [ i ] [ j ] = 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT newX = i + direction [ k ] [ 0 ] NEW_LINE newY = j + direction [ k ] [ 1 ] NEW_LINE if ( newX >= 0 and newX < N and newY >= 0 and newY < M and matrix [ newX ] [ newY ] == 0 ) : NEW_LINE INDENT if ( dfs ( newX , newY , N , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT global matrix NEW_LINE N = len ( matrix ) NEW_LINE M = len ( matrix [ 0 ] ) NEW_LINE if ( not dfs ( 0 , 0 , N , M ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( not dfs ( 0 , 0 , N , M ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT matrix = [ [ 0 , 1 , 0 , 0 ] , [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( solve ( ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of flips required such that a Binary Matrix doesn 't contain any path from the top left to the bottom right consisting only of 0s | The four direction coordinates changes from the current cell ; Function that returns true if there exists any path from the top - left to the bottom - right cell of 0 s ; If the bottom - right cell is reached ; Update the cell to 1 ; Traverse in all four directions ; Find the new coordinates ; If the new cell is valid ; Recursively call DFS ; If path exists , then return true ; Return false , if there doesn 't  exists any such path ; Function to flip the minimum number of cells such that there doesn 't exists any such path from (0, 0) to (N - 1, M - 1) cell consisting of 0s ; Case 1 : If no such path exists already ; Case 2 : If there exists only one path ; Case 3 : If there exists two - path ; Driver Code",
        "Category": "Graph Theory"
    },
    {
        "ID": "9720-9720",
        "Code": "def evenOdd ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT even_digits = 0 ; NEW_LINE odd_digits = 0 ; NEW_LINE temp = arr [ i ] ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( ( temp % 10 ) & 1 ) : NEW_LINE INDENT odd_digits += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even_digits += 1 ; NEW_LINE DEDENT temp = temp // 10 NEW_LINE DEDENT if ( even_digits > odd_digits ) : NEW_LINE INDENT res = 0 ; NEW_LINE while ( arr [ i ] ) : NEW_LINE INDENT res += arr [ i ] % 10 ; NEW_LINE arr [ i ] = arr [ i ] // 10 ; NEW_LINE DEDENT print ( res , end = \" ▁ \" ) ; NEW_LINE DEDENT elif ( odd_digits > even_digits ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( arr [ i ] ) : NEW_LINE INDENT res *= arr [ i ] % 10 ; NEW_LINE arr [ i ] = arr [ i ] // 10 NEW_LINE DEDENT print ( res , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 113 , 141 , 214 , 3186 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE evenOdd ( arr , N ) ; NEW_LINE",
        "Type": "py",
        "NL": "Modify a given array by replacing each element with the sum or product of their digits based on a given condition | Function to modify the given array as per the given conditions ; Traverse the given array arr [ ] ; Initialize the count of even and odd digits ; Initialize temp with the current array element ; For count the number of even digits ; Increment the odd count ; Otherwise ; Divide temp by 10 ; Performe addition ; Performe multiplication ; Otherwise ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "9723-9723",
        "Code": "def findSmallestNumK ( n ) : NEW_LINE INDENT cummAnd = n NEW_LINE i = n - 1 NEW_LINE while ( cummAnd != 0 ) : NEW_LINE INDENT cummAnd = cummAnd & i NEW_LINE if ( cummAnd == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 17 NEW_LINE lastNum = findSmallestNumK ( N ) ; NEW_LINE K = lastNum if lastNum == - 1 else N - lastNum NEW_LINE print ( K ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Find smallest value of K such that bitwise AND of numbers in range [ N , N | Function is to find the largest no which gives the sequence n & ( n - 1 ) & ( n - 2 ) & ... . . & ( n - k ) = 0. ; Since , we need the largest no , we start from n itself , till 0 ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "9724-9724",
        "Code": "import sys NEW_LINE def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks \" NEW_LINE print ( findMinInsertions ( str , 0 , len ( str ) - 1 ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum insertions to form a palindrome | DP | A Naive recursive program to find minimum number insertions needed to make a string palindrome ; Recursive function to find minimum number of insertions ; Base Cases ; Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9731-9731",
        "Code": "def isPossible ( W , B , D ) : NEW_LINE INDENT if ( W > B ) : NEW_LINE INDENT temp = W NEW_LINE W = B NEW_LINE B = temp NEW_LINE DEDENT if ( B > W * ( D + 1 ) ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT W = 2 NEW_LINE B = 5 NEW_LINE D = 2 NEW_LINE isPossible ( W , B , D ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Distribute the white and black objects into maximum groups under certain constraints | Function to check if it is possible to distribute W and B into maximum groups possible ; If W is greater than B , swap them ; Distribution is not possible ; Distribution is possible ; Driver code ; Input ; Function call",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9732-9732",
        "Code": "def ExtendedEuclidAlgo ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b , 0 , 1 NEW_LINE DEDENT gcd , x1 , y1 = ExtendedEuclidAlgo ( b % a , a ) NEW_LINE x = y1 - ( b // a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd , x , y NEW_LINE DEDENT def linearCongruence ( A , B , N ) : NEW_LINE INDENT A = A % N NEW_LINE B = B % N NEW_LINE u = 0 NEW_LINE v = 0 NEW_LINE d , u , v = ExtendedEuclidAlgo ( A , N ) NEW_LINE if ( B % d != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT x0 = ( u * ( B // d ) ) % N NEW_LINE if ( x0 < 0 ) : NEW_LINE INDENT x0 += N NEW_LINE DEDENT for i in range ( d ) : NEW_LINE INDENT print ( ( x0 + i * ( N // d ) ) % N , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 15 NEW_LINE B = 9 NEW_LINE N = 18 NEW_LINE linearCongruence ( A , B , N ) NEW_LINE",
        "Type": "py",
        "NL": "Solve Linear Congruences Ax = B ( mod N ) for values of x in range [ 0 , N | Function to stores the values of x and y and find the value of gcd ( a , b ) ; Base Case ; Store the result of recursive call ; Update x and y using results of recursive call ; Function to give the distinct solutions of ax = b ( mod n ) ; Function Call to find the value of d and u ; No solution exists ; Else , initialize the value of x0 ; Pr all the answers ; Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9734-9734",
        "Code": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def maxGCDInRange ( L , R ) : NEW_LINE INDENT ans = 1 NEW_LINE for Z in range ( R , 1 , - 1 ) : NEW_LINE INDENT if ( ( ( R // Z ) - ( L - 1 ) // Z ) > 1 ) : NEW_LINE INDENT ans = Z NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 102 NEW_LINE R = 139 NEW_LINE print ( maxGCDInRange ( L , R ) ) NEW_LINE",
        "Type": "py",
        "NL": "Find the maximum GCD possible for some pair in a given range [ L , R ] | Function to calculate GCD ; Function to calculate maximum GCD in a range ; Variable to store the answer ; If Z has two multiples in [ L , R ] ; Update ans ; Return the value ; Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9754-9754",
        "Code": "def PermuteAndFind ( power , idx , SumSoFar , target ) : NEW_LINE INDENT if ( idx == len ( power ) ) : NEW_LINE INDENT if ( SumSoFar == target ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) NEW_LINE notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) NEW_LINE return ( select or notselect ) NEW_LINE DEDENT def DistinctPowersOf3 ( N ) : NEW_LINE INDENT power = [ 0 for x in range ( 16 ) ] NEW_LINE power [ 0 ] = 1 NEW_LINE for i in range ( 1 , 16 ) : NEW_LINE INDENT power [ i ] = 3 * power [ i - 1 ] NEW_LINE DEDENT found = PermuteAndFind ( power , 0 , 0 , N ) NEW_LINE if ( found == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT N = 91 NEW_LINE DistinctPowersOf3 ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Check if N can be represented as sum of distinct powers of 3 | Function to try all permutations of distinct powers ; Base Case ; If the distinct powers sum is obtained ; Otherwise ; If current element not selected in power [ ] ; If current element selected in power [ ] ; Return 1 if any permutation found ; Function to check the N can be represented as the sum of the distinct powers of 3 ; Stores the all distincts powers of three to [ 0 , 15 ] ; Function Call ; Print ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "9757-9757",
        "Code": "import sys NEW_LINE def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE k = 10 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst ▁ case ▁ with \" , n , \" eggs ▁ and \" , k , \" floors ▁ is \" , eggDrop ( n , k ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Egg Dropping Puzzle | DP |  ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; If there are no floors , then no trials needed . OR if there is one floor , one trial needed . ; We need k trials for one egg and k floors ; Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1. ; Driver Code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9761-9761",
        "Code": "def getPermutation ( N ) : NEW_LINE INDENT if ( N <= 3 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT i = N NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT while ( i >= 1 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE i -= 2 NEW_LINE DEDENT print ( 4 , 2 , end = \" ▁ \" ) NEW_LINE i = 6 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE i += 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE getPermutation ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Generate an N | Function to print permutation of size N with absolute difference of adjacent elements in range [ 2 , 4 ] ; If N is less than 4 ; Check if N is even ; Traverse through odd integers ; Update the value of i ; Traverse through even integers ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "9762-9762",
        "Code": "def gcd ( A , B ) : NEW_LINE INDENT if ( B == 0 ) : NEW_LINE INDENT return A ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( B , A % B ) ; NEW_LINE DEDENT DEDENT def getDistinctValues ( A , B , C ) : NEW_LINE INDENT g = gcd ( A , B ) ; NEW_LINE num_values = C / g ; NEW_LINE return int ( num_values ) ; NEW_LINE DEDENT A = 2 ; NEW_LINE B = 3 ; NEW_LINE C = 10 ; NEW_LINE print ( getDistinctValues ( A , B , C ) ) ; NEW_LINE",
        "Type": "py",
        "NL": "Count of distinct values till C formed by adding or subtracting A , B , or 0 any number of times | Function to calculate gcd ; Function to find number of possible final values ; Find the gcd of two numbers ; Calculate number of distinct values ; Return values ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9765-9765",
        "Code": "def currSubArrayScore ( a , b , l , r ) : NEW_LINE INDENT straightScore = 0 NEW_LINE reverseScore = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT straightScore += a [ i ] * b [ i ] NEW_LINE reverseScore += a [ r - ( i - l ) ] * b [ i ] NEW_LINE DEDENT return max ( straightScore , reverseScore ) NEW_LINE DEDENT def maxScoreSubArray ( a , b , n ) : NEW_LINE INDENT res = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT currScore = currSubArrayScore ( a , b , i , j ) NEW_LINE if ( currScore > res ) : NEW_LINE INDENT res = currScore NEW_LINE start = i NEW_LINE end = j NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT A = [ 13 , 4 , 5 ] NEW_LINE B = [ 10 , 22 , 2 ] NEW_LINE N = len ( A ) NEW_LINE maxScoreSubArray ( A , B , N ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize score of same | Function to calculate the score of same - indexed subarrays selected from the arrays a [ ] and b [ ] ; Traverse the current subarray ; Finding the score without reversing the subarray ; Calculating the score of the reversed subarray ; Return the score of subarray ; Function to find the subarray with the maximum score ; Stores the maximum score and the starting and the ending point of subarray with maximum score ; Traverse all the subarrays ; Store the score of the current subarray ; Update the maximum score ; Prthe maximum score ; Driver Code",
        "Category": "Substring"
    },
    {
        "ID": "9769-9769",
        "Code": "def countValues ( A , B , C ) : NEW_LINE INDENT if ( B >= A ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT print ( C // A ) NEW_LINE return NEW_LINE DEDENT ans = C // A NEW_LINE if ( ans * A + B <= C ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 6 NEW_LINE B = 3 NEW_LINE N = 15 NEW_LINE countValues ( A , B , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers less than N whose modulo with A is equal to B | Function to count numbers less than N , whose modulo with A gives B ; If the value of B at least A ; If the value of B is 0 or not ; Stores the resultant count of numbers less than N ; Update the value of ans ; Print the value of ans ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9782-9782",
        "Code": "def EditDistDP ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE DP = [ [ 0 for i in range ( len1 + 1 ) ] for j in range ( 2 ) ] ; NEW_LINE for i in range ( 0 , len1 + 1 ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i NEW_LINE DEDENT for i in range ( 1 , len2 + 1 ) : NEW_LINE INDENT for j in range ( 0 , len1 + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT DP [ i % 2 ] [ j ] = i NEW_LINE DEDENT elif ( str1 [ j - 1 ] == str2 [ i - 1 ] ) : NEW_LINE INDENT DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i % 2 ] [ j ] = ( 1 + min ( DP [ ( i - 1 ) % 2 ] [ j ] , min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ) NEW_LINE DEDENT DEDENT DEDENT print ( DP [ len2 % 2 ] [ len1 ] , \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" food \" NEW_LINE str2 = \" money \" NEW_LINE EditDistDP ( str1 , str2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Edit Distance | DP | A Space efficient Dynamic Programming based Python3 program to find minimum number operations to convert str1 to str2 ; Create a DP array to memoize result of previous computations ; Base condition when second String is empty then we remove all characters ; Start filling the DP This loop run for every character in second String ; This loop compares the char from second String with first String characters ; If first String is empty then we have to perform add character operation to get second String ; If character from both String is same then we do not perform any operation . here i % 2 is for bound the row number . ; If character from both String is not same then we take the minimum from three specified operation ; After complete fill the DP array if the len2 is even then we end up in the 0 th row else we end up in the 1 th row so we take len2 % 2 to get row ; Driver code",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9785-9785",
        "Code": "def findWinner ( X , Y ) : NEW_LINE INDENT first = ( X ^ Y ) NEW_LINE second = ( X + Y ) NEW_LINE if ( first == second ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , B = 2 , 4 NEW_LINE findWinner ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a pair of integers from two ranges exists such that their Bitwise XOR exceeds both the ranges | Function to check if there exists any pair ( P , Q ) whose Bitwise XOR is greater than the Bitwise XOR of X and Y ; Check for the invalid condition ; Otherwise , ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "9790-9790",
        "Code": "dp = [ [ - 1 for i in range ( 2 ) ] for j in range ( 1000 ) ] NEW_LINE def IsSumEqualsXor ( i , n , bound , s ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ i ] [ bound ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ bound ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( bound and s [ i ] == '0' ) : NEW_LINE INDENT ans = IsSumEqualsXor ( i + 1 , n , 1 , s ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 2 * IsSumEqualsXor ( i + 1 , n , bound & ( s [ i ] == '1' ) , s ) NEW_LINE ans += IsSumEqualsXor ( i + 1 , n , 0 , s ) NEW_LINE DEDENT dp [ i ] [ bound ] = ans NEW_LINE return ans NEW_LINE DEDENT def convertToBinary ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE while ( n ) : NEW_LINE INDENT rem = chr ( n % 2 + 48 ) NEW_LINE ans . append ( rem ) NEW_LINE n //= 2 NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT def IsSumEqualsXorUtil ( N ) : NEW_LINE INDENT s = convertToBinary ( N ) NEW_LINE print ( IsSumEqualsXor ( 0 , len ( s ) , 1 , s ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE IsSumEqualsXorUtil ( N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count pairs up to N having sum equal to their XOR | 2D array for memoization ; Recursive Function to count pairs ( x , y ) such that x + y = x ^ y ; If the string is traversed completely ; If the current subproblem is already calculated ; If bound = 1 and s [ i ] = = '0' , only ( 0 , 0 ) can be placed ; Otherwise ; Placing ( 0 , 1 ) and ( 1 , 0 ) are equivalent . Hence , multiply by 2. ; Place ( 0 , 0 ) at the current position . ; Return the answer ; Utility Function to convert N to its binary representation ; Function to count pairs ( x , y ) such that x + y = x ^ y ; Convert the number to equivalent binary representation ; Print answer returned by recursive function ; Driver code ; Input ; Function call",
        "Category": "Dynamic Programming"
    },
    {
        "ID": "9791-9791",
        "Code": "def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N + K - rem NEW_LINE DEDENT DEDENT def findSmallest ( M , N ) : NEW_LINE INDENT x = findNum ( M , N ) NEW_LINE return x - M NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 100 NEW_LINE N = 28 NEW_LINE print ( findSmallest ( M , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Smallest number required to be added to M to make it divisible by N | Function to find the smallest number greater than or equal to N , that is divisible by k ; Function to find the smallest number required to be added to to M to make it divisible by N ; Stores the smallest multiple of N , greater than or equal to M ; Return the result ; Driver Code ; Given Input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9792-9792",
        "Code": "def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return ord ( c ) - 48 NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - 65 + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT print ( \" Invalid ▁ Number \" ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def reVal ( num ) : NEW_LINE INDENT if ( num >= 0 and num <= 9 ) : NEW_LINE INDENT return chr ( num + 48 ) NEW_LINE DEDENT else : NEW_LINE INDENT return chr ( num - 10 + 65 ) NEW_LINE DEDENT DEDENT def fromDeci ( base , inputNum ) : NEW_LINE INDENT res = \" \" NEW_LINE while ( inputNum > 0 ) : NEW_LINE INDENT res += reVal ( inputNum % base ) NEW_LINE inputNum //= base NEW_LINE DEDENT res = res [ : : - 1 ] NEW_LINE return res NEW_LINE DEDENT def convertBase ( s , a , b ) : NEW_LINE INDENT num = toDeci ( s , a ) NEW_LINE ans = fromDeci ( b , num ) NEW_LINE print ( ans ) NEW_LINE DEDENT s = \"10B \" NEW_LINE a = 16 NEW_LINE b = 10 NEW_LINE convertBase ( s , a , b ) NEW_LINE",
        "Type": "py",
        "NL": "Convert a number from base A to base B | Function to return ASCII value of a character ; Function to convert a number from given base to decimal number ; Stores the length of the string ; Initialize power of base ; Initialize result ; Decimal equivalent is strr [ len - 1 ] * 1 + strr [ len - 2 ] * base + strr [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Update num ; Update power ; Function to return equivalent character of a given value ; Function to convert a given decimal number to a given base ; Store the result ; Repeatedly divide inputNum by base and take remainder ; Update res ; Update inputNum ; Reverse the result ; Function to convert a given number from a base to another base ; Convert the number from base A to decimal ; Convert the number from decimal to base B ; Prthe result ; Given input ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "98-98",
        "Code": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def convert ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT convert ( root . left ) NEW_LINE convert ( root . right ) NEW_LINE if ( root . left == None ) : NEW_LINE INDENT root . left = root . right NEW_LINE DEDENT else : NEW_LINE INDENT root . left . right = root . right NEW_LINE DEDENT root . right = None NEW_LINE DEDENT def downRightTraversal ( root ) : NEW_LINE INDENT if ( root != None ) : NEW_LINE INDENT print ( root . key , end = \" ▁ \" ) NEW_LINE downRightTraversal ( root . right ) NEW_LINE downRightTraversal ( root . left ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE root . right . left . left = newNode ( 6 ) NEW_LINE root . right . right . left = newNode ( 7 ) NEW_LINE root . right . right . right = newNode ( 8 ) NEW_LINE convert ( root ) NEW_LINE print ( \" Traversal ▁ of ▁ the ▁ tree ▁ converted \" , \" to ▁ down - right ▁ form \" ) NEW_LINE downRightTraversal ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert left | Python3 program to convert left - right to down - right representation of binary tree Helper function that allocates a new node with the given data and None left and right poers . ; Construct to create a new node ; An Iterative level order traversal based function to convert left - right to down - right representation . ; Base Case ; Recursively convert left an right subtrees ; If left child is None , make right child as left as it is the first child . ; If left child is NOT None , then make right child as right of left child ; Set root 's right as None ; A utility function to traverse a tree stored in down - right form . ; Driver Code ; 1 / \\ 2 3 / \\ 4 5 / / \\ 6 7 8",
        "Category": "Binary Tree"
    },
    {
        "ID": "9802-9802",
        "Code": "def ToCheckPowerofX ( n , x ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % x NEW_LINE if ( rem >= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // x NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE X = 3 NEW_LINE if ( ToCheckPowerofX ( N , X ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if a number N can be expressed as the sum of powers of X or not | Function to check if the number N can be expressed as the sum of different powers of X or not ; While n is a positive number ; Find the remainder ; If rem is at least 2 , then representation is impossible ; Divide the value of N by x ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9807-9807",
        "Code": "from math import sqrt NEW_LINE def complexRoot ( A , B ) : NEW_LINE INDENT ans = [ ] NEW_LINE X1 = abs ( sqrt ( ( A + sqrt ( A * A + B * B ) ) / 2 ) ) NEW_LINE Y1 = B / ( 2 * X1 ) NEW_LINE ans . append ( [ X1 , Y1 ] ) NEW_LINE X2 = - 1 * X1 NEW_LINE Y2 = B / ( 2 * X2 ) NEW_LINE if ( X2 != 0 ) : NEW_LINE INDENT ans . append ( [ X2 , Y2 ] ) NEW_LINE DEDENT X3 = ( A - sqrt ( A * A + B * B ) ) / 2 NEW_LINE if ( X3 > 0 ) : NEW_LINE INDENT X3 = abs ( sqrt ( X3 ) ) NEW_LINE Y3 = B / ( 2 * X3 ) NEW_LINE ans . append ( [ X3 , Y3 ] ) NEW_LINE X4 = - 1 * X3 NEW_LINE Y4 = B / ( 2 * X4 ) NEW_LINE if ( X4 != 0 ) : NEW_LINE INDENT ans . append ( [ X4 , Y4 ] ) NEW_LINE DEDENT DEDENT print ( \" The ▁ Square ▁ roots ▁ are : ▁ \" ) NEW_LINE for p in ans : NEW_LINE INDENT print ( round ( p [ 0 ] , 6 ) , end = \" \" ) NEW_LINE if ( p [ 1 ] > 0 ) : NEW_LINE INDENT print ( \" + \" , end = \" \" ) NEW_LINE DEDENT if ( p [ 1 ] ) : NEW_LINE INDENT print ( str ( round ( p [ 1 ] , 6 ) ) + \" * i \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , B = 0 , 1 NEW_LINE complexRoot ( A , B ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Square root of two Complex Numbers | Python3 program for the above approach ; Function to find the square root of a complex number ; Stores all the square roots ; Stores the first square root ; Push the square root in the ans ; Stores the second square root ; If X2 is not 0 ; Push the square root in the array ans [ ] ; Stores the third square root ; If X3 is greater than 0 ; Push the square root in the array ans [ ] ; Stores the fourth square root ; Push the square root in the array ans [ ] ; Prints the square roots ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9808-9808",
        "Code": "def findDecimal ( arr , N ) : NEW_LINE INDENT power = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT bit = abs ( int ( arr [ i ] ) - round ( arr [ i ] ) ) ; NEW_LINE if ( bit ) : NEW_LINE INDENT result += pow ( 2 , power ) ; NEW_LINE DEDENT power += 1 ; NEW_LINE DEDENT print ( result ) ; NEW_LINE DEDENT arr = [ 1.2 , 2.6 , 4.2 , 6.9 , 3.1 , 21.6 , 91.2 ] ; NEW_LINE N = len ( arr ) NEW_LINE findDecimal ( arr , N ) ; NEW_LINE",
        "Type": "py",
        "NL": "Decimal equivalent of concatenation of absolute difference of floor and rounded | Function to find the decimal equivalent of the new binary array constructed from absolute decimal of floor and the round - off values ; Traverse the givenarray from the end ; Stores the absolute difference between floor and round - off each array element ; If bit / difference is 1 , then calculate the bit by proper power of 2 and add it to result ; Increment the value of power ; Print the result ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9819-9819",
        "Code": "def findDigit ( N , D ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT a = N % 10 NEW_LINE if ( a == D ) : NEW_LINE INDENT return True NEW_LINE DEDENT N /= 10 NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( N , D ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT if ( findDigit ( N , D ) == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT N -= D NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE D = 7 NEW_LINE if ( check ( N , D ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "Type": "py",
        "NL": "Check if N can be represented as sum of positive integers containing digit D at least once | Function to check if N contains digit D in it ; Iterate until N is positive ; Find the last digit ; If the last digit is the same as digit D ; Return false ; Function to check if the value of N can be represented as sum of integers having digit d in it ; Iterate until N is positive ; Check if N contains digit D or not ; Subtracting D from N ; Return false ; Driver Code",
        "Category": "Greedy Algorithm"
    },
    {
        "ID": "9835-9835",
        "Code": "import math NEW_LINE def nearestPow ( x , base ) : NEW_LINE INDENT k = int ( math . log ( x , base ) ) NEW_LINE if abs ( base ** k - x ) < abs ( base ** ( k + 1 ) - x ) : NEW_LINE INDENT return base ** k NEW_LINE DEDENT else : NEW_LINE INDENT return base ** ( k + 1 ) NEW_LINE DEDENT DEDENT def replaceWithNearestPowerOfK ( arr , K ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT strEle = str ( arr [ i ] ) NEW_LINE for c in strEle : NEW_LINE INDENT if int ( c ) == K : NEW_LINE INDENT arr [ i ] = nearestPow ( arr [ i ] , K ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( arr ) NEW_LINE DEDENT arr = [ 432 , 953 , 232 , 333 ] NEW_LINE K = 3 NEW_LINE replaceWithNearestPowerOfK ( arr , K ) NEW_LINE",
        "Type": "py",
        "NL": "Replace array elements that contains K as a digit with the nearest power of K | Python3 program for the above approach ; Function to calculate the power of base nearest to x ; Stores logX to the base K ; Function to replace array elements with nearest power of K ; Traverse the array ; Convert integer into a string ; If K is found , then replace with the nearest power of K ; Print the array ; Given array ; Given value of K ; Function call to replace array elements with nearest power of K",
        "Category": "Array"
    },
    {
        "ID": "9836-9836",
        "Code": "from math import ceil NEW_LINE def ceilDifference ( arr , n , x ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE perElementSum += ceil ( arr [ i ] / x ) NEW_LINE DEDENT totalCeilSum = ceil ( totalSum / x ) NEW_LINE return abs ( perElementSum - totalCeilSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) NEW_LINE print ( ceilDifference ( arr , N , K ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Difference between ceil of array sum divided by K and sum of ceil of array elements divided by K | Python3 program for the above approach ; Function to find absolute difference between array sum divided by x and sum of ceil of array elements divided by x ; Stores the total sum ; Stores the sum of ceil of array elements divided by x ; Traverse the array ; Adding each array element ; Add the value ceil of arr [ i ] / x ; Find the ceil of the total sum divided by x ; Return absolute difference ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9843-9843",
        "Code": "def findSumOfGP ( a , r ) : NEW_LINE INDENT if ( abs ( r ) >= 1 ) : NEW_LINE INDENT print ( \" Infinite \" ) NEW_LINE return NEW_LINE DEDENT sum = a / ( 1 - r ) NEW_LINE print ( int ( sum ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , R = 1 , 0.5 NEW_LINE findSumOfGP ( A , R ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Sum of an Infinite Geometric Progression ( GP ) | Function to calculate the sum of an infinite Geometric Progression ; Case for Infinite Sum ; Store the sum of GP Series ; Print the value of sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9848-9848",
        "Code": "import math NEW_LINE def nthFibo ( n ) : NEW_LINE INDENT a = ( 5 ** ( 1 / 2 ) + 1 ) / 2 NEW_LINE b = ( - 5 ** ( 1 / 2 ) + 1 ) / 2 NEW_LINE r = 5 ** ( 1 / 2 ) NEW_LINE ans = ( a ** n - b ** n ) / r NEW_LINE return int ( ans ) NEW_LINE DEDENT def nearFibo ( X ) : NEW_LINE INDENT a = ( 5 ** ( 1 / 2 ) + 1 ) / 2 NEW_LINE n = int ( math . log ( ( 5 ** ( 1 / 2 ) ) * X ) / math . log ( a ) ) NEW_LINE nth = nthFibo ( n ) NEW_LINE nplus = nthFibo ( n + 1 ) NEW_LINE if abs ( X - nth ) < abs ( X - nplus ) : NEW_LINE INDENT return nth NEW_LINE DEDENT else : NEW_LINE INDENT return nplus NEW_LINE DEDENT DEDENT def getCost ( arr ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in arr : NEW_LINE INDENT fibo = nearFibo ( i ) NEW_LINE cost += abs ( i - fibo ) NEW_LINE DEDENT return cost NEW_LINE DEDENT arr = [ 56 , 34 , 23 , 98 , 7 ] NEW_LINE print ( getCost ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize cost of converting all array elements to Fibonacci Numbers | Python program for the above approach ; Function to find the N - th Fibonacci Number ; Find the value of a , b , and r ; Find the N - th Fibonacci ; Return the result ; Function to find the Fibonacci number which is nearest to X ; Calculate the value of n for X ; Return the nearest Fibonacci Number ; Function to find the minimum cost to convert all array elements to Fibonacci Numbers ; Stores the total minimum cost ; Traverse the given array arr [ ] ; Find the nearest Fibonacci Number ; Add the cost ; Return the final cost ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9851-9851",
        "Code": "def sumOfInfiniteAGP ( a , d , r ) : NEW_LINE INDENT ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , d , r = 0 , 1 , 0.5 NEW_LINE sumOfInfiniteAGP ( a , d , r ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate sum of an Infinite Arithmetic | Function to find the sum of the infinite AGP ; Stores the sum of infinite AGP ; Print the required sum ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9861-9861",
        "Code": "def Rotate ( n , f ) : NEW_LINE INDENT temp = n NEW_LINE maxi = n NEW_LINE mini = n NEW_LINE for idx in range ( 7 ) : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT temp >>= 1 NEW_LINE temp += 2 ** 7 NEW_LINE DEDENT else : NEW_LINE INDENT temp >>= 1 NEW_LINE DEDENT mini = min ( mini , temp ) NEW_LINE maxi = max ( maxi , temp ) NEW_LINE DEDENT if ( f ) : NEW_LINE INDENT return ( maxi ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( mini ) NEW_LINE DEDENT DEDENT def calcMinDiff ( arr ) : NEW_LINE INDENT caseOne = 0 NEW_LINE sumOfodd = 0 NEW_LINE sumOfeven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT sumOfodd += Rotate ( arr [ i ] , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT sumOfeven += Rotate ( arr [ i ] , 1 ) NEW_LINE DEDENT DEDENT caseOne = abs ( sumOfodd - sumOfeven ) NEW_LINE caseTwo = 0 NEW_LINE sumOfodd = 0 NEW_LINE sumOfeven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT sumOfodd += Rotate ( arr [ i ] , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT sumOfeven += Rotate ( arr [ i ] , 0 ) NEW_LINE DEDENT DEDENT caseTwo = abs ( sumOfodd - sumOfeven ) NEW_LINE return max ( caseOne , caseTwo ) NEW_LINE DEDENT arr = [ 123 , 86 , 234 , 189 ] NEW_LINE print ( calcMinDiff ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize difference between odd and even | Function to find maximum and minimum value of a number that can be obtained by rotating bits ; Stores the value of N ; Stores the maximum value ; Stores the minimum value ; If temp is odd ; Update the maximum and the minimum value ; If flag is 1 , then return the maximum value ; Otherwise , return the maximum value ; Function to find the maximum difference between the sum of odd and even - indexed array elements possible by rotating bits ; Stores the maximum difference ; Stores the sum of elements present at odd indices ; Stores the sum of elements present at even indices ; Traverse the given array ; If the index is even ; Update the caseOne ; Stores the maximum difference ; Stores the sum of elements placed at odd positions ; Stores the sum of elements placed at even positions ; Traverse the array ; If the index is even ; Update the caseTwo ; Return the maximum of caseOne and caseTwo ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "9862-9862",
        "Code": "class pair : NEW_LINE INDENT def __init__ ( self , count , prevIndex ) : NEW_LINE INDENT self . count = count ; NEW_LINE self . prevIndex = prevIndex ; NEW_LINE DEDENT DEDENT def findSum ( arr , n ) : NEW_LINE INDENT map = { } ; NEW_LINE left = [ 0 for i in range ( n ) ] ; NEW_LINE right = [ 0 for i in range ( n ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in map ) : NEW_LINE INDENT left [ i ] = 0 ; NEW_LINE map [ arr [ i ] ] = pair ( 1 , i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tmp = map [ arr [ i ] ] ; NEW_LINE left [ i ] = ( tmp . count ) * ( i - tmp . prevIndex ) + left [ tmp . prevIndex ] NEW_LINE map [ arr [ i ] ] = pair ( tmp . count + 1 , i ) ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] not in map ) : NEW_LINE INDENT right [ i ] = 0 ; NEW_LINE map [ arr [ i ] ] = pair ( 1 , i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tmp = map [ arr [ i ] ] ; NEW_LINE right [ i ] = ( tmp . count ) * ( abs ( i - tmp . prevIndex ) ) + right [ tmp . prevIndex ] ; NEW_LINE map [ arr [ i ] ] = pair ( tmp . count + 1 , i ) ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( left [ i ] + right [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 1 , 1 , 2 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE findSum ( arr , N ) ; NEW_LINE",
        "Type": "py",
        "NL": "Sum of absolute differences of indices of occurrences of each array element | Set 2 | Stores the count of occurrences and previous index of every element ; Constructor ; Function to calculate the sum of absolute differences of indices of occurrences of array element ; Stores the count of elements and their previous indices ; Initialize 2 arrays left [ ] and right [ ] of size N ; Traverse the given array ; If arr [ i ] is present in the Map ; Update left [ i ] to 0 and update the value of arr [ i ] in map ; Otherwise , get the value from the map and update left [ i ] ; Clear the map to calculate right [ ] array ; Traverse the array arr [ ] in reverse ; If arr [ i ] is present in theMap ; Update right [ i ] to 0 and update the value of arr [ i ] in the Map ; Otherwise get the value from the map and update right [ i ] ; Iterate in the range [ 0 , N - 1 ] and print the sum of left [ i ] and right [ i ] as the result ; Driver Code",
        "Category": "Hash Table"
    },
    {
        "ID": "9873-9873",
        "Code": "def expectedValue ( P , a , b , N ) : NEW_LINE INDENT expValue = P + ( N * 0.5 * ( a + b ) ) NEW_LINE print ( int ( expValue ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = 3000 NEW_LINE a = 20 NEW_LINE b = 10 NEW_LINE N = 30 NEW_LINE expectedValue ( P , a , b , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate expected increase in price P after N consecutive days | Function to find the increased value of P after N days ; Expected value of the number P after N days ; Print the expected value ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9881-9881",
        "Code": "/ * Function to check if there is a NEW_LINE INDENT node in tree from where all other NEW_LINE nodes are accessible or not * / NEW_LINE DEDENT def findNode ( mp , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = mp [ i + 1 ] NEW_LINE DEDENT count0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT count0 -= 1 NEW_LINE if ( count0 <= ( n ) / ( 2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE mp = { } NEW_LINE mp [ 1 ] = 0 NEW_LINE mp [ 2 ] = 2 NEW_LINE mp [ 3 ] = 0 NEW_LINE findNode ( mp , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if every node can me made accessible from a node of a Tree by at most N / 2 given operations |  ; Store the indegree of every node ; Store the nodes having indegree equal to 0 ; Traverse the array ; If the indegree of i - th node is 0 ; Increment count0 by 1 ; If the number of operations needed is at most floor ( n / 2 ) ; Otherwise ; Driver Code ; Given number of nodes ; Given Directed Tree",
        "Category": "Graph Theory"
    },
    {
        "ID": "9888-9888",
        "Code": "def crossProduct ( vect_A , vect_B , cross_P ) : NEW_LINE INDENT cross_P [ 0 ] = ( vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ) NEW_LINE cross_P [ 1 ] = ( vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ) NEW_LINE cross_P [ 2 ] = ( vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ) NEW_LINE DEDENT def checkCollinearity ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT A = [ x1 , y1 , z1 ] NEW_LINE B = [ x2 , y2 , z2 ] NEW_LINE cross_P = [ 0 for i in range ( 3 ) ] NEW_LINE crossProduct ( A , B , cross_P ) NEW_LINE if ( cross_P [ 0 ] == 0 and cross_P [ 1 ] == 0 and cross_P [ 2 ] == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 4 NEW_LINE y1 = 8 NEW_LINE z1 = 12 NEW_LINE x2 = 8 NEW_LINE y2 = 16 NEW_LINE z2 = 24 NEW_LINE checkCollinearity ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if two vectors are collinear or not | Function to calculate cross product of two vectors ; Update cross_P [ 0 ] ; Update cross_P [ 1 ] ; Update cross_P [ 2 ] ; Function to check if two given vectors are collinear or not ; Store the first and second vectors ; Store their cross product ; Calculate their cross product ; Check if their cross product is a NULL Vector or not ; Driver Code ; Given coordinates of the two vectors",
        "Category": "Math"
    },
    {
        "ID": "9890-9890",
        "Code": "def kineticEnergy ( M , V ) : NEW_LINE INDENT KineticEnergy = 0.5 * M * V * V NEW_LINE return KineticEnergy NEW_LINE DEDENT def potentialEnergy ( M , H ) : NEW_LINE INDENT PotentialEnergy = M * 9.8 * H NEW_LINE return PotentialEnergy NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT M = 5.5 NEW_LINE H = 23.5 NEW_LINE V = 10.5 NEW_LINE print ( \" Kinetic ▁ Energy ▁ = ▁ \" , kineticEnergy ( M , V ) ) NEW_LINE print ( \" Potential ▁ Energy ▁ = ▁ \" , potentialEnergy ( M , H ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Program to calculate Kinetic Energy and Potential Energy | Function to calculate Kinetic Energy ; Stores the Kinetic Energy ; Function to calculate Potential Energy ; Stores the Potential Energy ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9892-9892",
        "Code": "import math NEW_LINE def nearestPow ( x , y ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT k = int ( math . log ( x , y ) ) NEW_LINE if abs ( y ** k - x ) < abs ( y ** ( k + 1 ) - x ) : NEW_LINE INDENT return y ** k NEW_LINE DEDENT return y ** ( k + 1 ) NEW_LINE DEDENT def replacebyNearestPower ( arr ) : NEW_LINE INDENT prev = arr [ - 1 ] NEW_LINE lastNext = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if i == len ( arr ) - 1 : NEW_LINE INDENT next = lastNext NEW_LINE DEDENT else : NEW_LINE INDENT next = arr [ ( i + 1 ) % len ( arr ) ] NEW_LINE DEDENT prevPow = nearestPow ( arr [ i ] , prev ) NEW_LINE nextPow = nearestPow ( arr [ i ] , next ) NEW_LINE if abs ( arr [ i ] - prevPow ) < abs ( arr [ i ] - nextPow ) : NEW_LINE INDENT arr [ i ] = prevPow NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = nextPow NEW_LINE DEDENT prev = temp NEW_LINE DEDENT print ( arr ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 2 ] NEW_LINE replacebyNearestPower ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Modify array by replacing elements with the nearest power of its previous or next element | Python3 program for the above approach ; Function to calculate the power of y which is nearest to x ; Base Case ; Stores the logarithmic value of x with base y ; Function to replace each array element by the nearest power of its previous or next element ; Stores the previous and next element ; Traverse the array ; Calculate nearest power for previous and next elements ; Replacing the array values ; Print the updated array ; Given array",
        "Category": "Array"
    },
    {
        "ID": "99-99",
        "Code": "class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . left = None NEW_LINE self . right = None NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def toSumTree ( Node ) : NEW_LINE INDENT if ( Node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT old_val = Node . data NEW_LINE Node . data = toSumTree ( Node . left ) + toSumTree ( Node . right ) NEW_LINE return Node . data + old_val NEW_LINE DEDENT def printInorder ( Node ) : NEW_LINE INDENT if ( Node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( Node . left ) NEW_LINE print ( Node . data , end = \" ▁ \" ) NEW_LINE printInorder ( Node . right ) NEW_LINE DEDENT def newNode ( data ) : NEW_LINE INDENT temp = node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = None NEW_LINE x = 0 NEW_LINE root = newNode ( 10 ) NEW_LINE root . left = newNode ( - 2 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 8 ) NEW_LINE root . left . right = newNode ( - 4 ) NEW_LINE root . right . left = newNode ( 7 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE toSumTree ( root ) NEW_LINE print ( \" Inorder ▁ Traversal ▁ of ▁ the ▁ resultant ▁ tree ▁ is : ▁ \" ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Convert a given tree to its Sum Tree | Node defintion ; Convert a given tree to a tree where every node contains sum of values of nodes in left and right subtrees in the original tree ; Base case ; Store the old value ; Recursively call for left and right subtrees and store the sum as new value of this node ; Return the sum of values of nodes in left and right subtrees and old_value of this node ; A utility function to print inorder traversal of a Binary Tree ; Utility function to create a new Binary Tree node ; Driver Code ; Constructing tree given in the above figure ; Print inorder traversal of the converted tree to test result of toSumTree ( )",
        "Category": "Binary Tree"
    },
    {
        "ID": "9922-9922",
        "Code": "def ValidPairs ( X , K ) : NEW_LINE INDENT count = 0 NEW_LINE for A in range ( - 1000 , 1001 , 1 ) : NEW_LINE INDENT for B in range ( - 1000 , 1001 , 1 ) : NEW_LINE INDENT if ( pow ( A , K ) - pow ( B , K ) == X ) : NEW_LINE INDENT count += 1 NEW_LINE print ( A , B ) NEW_LINE DEDENT DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT cout << \" - 1\" NEW_LINE DEDENT DEDENT X = 33 NEW_LINE K = 5 NEW_LINE ValidPairs ( X , K ) NEW_LINE",
        "Type": "py",
        "NL": "Find all pairs raised to power K differs by exactly N | Function to prpairs whose difference raised to the power K is X ; Stores the count of valid pairs ; Iterate over the range [ - 1000 , 1000 ] ; Iterate over the range [ - 1000 , 1000 ] ; If the current pair satisfies the given condition ; Increment the count by 1 ; If no such pair exists ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9923-9923",
        "Code": "def maximumAND ( arr , n , m ) : NEW_LINE INDENT tot = 1 << n NEW_LINE mx = 0 NEW_LINE for bm in range ( tot ) : NEW_LINE INDENT andans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( bm >> i ) & 1 ) : NEW_LINE INDENT if ( count == 0 ) : NEW_LINE INDENT andans = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT andans = andans & arr [ i ] NEW_LINE DEDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == ( m + 1 ) ) : NEW_LINE INDENT mx = max ( mx , andans ) NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE M = 2 NEW_LINE print ( maximumAND ( arr , N , M ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Connect a graph by M edges such that the graph does not contain any cycle and Bitwise AND of connected vertices is maximum | Function to find the maximum Bitwise AND of connected components possible by connecting a graph using M edges ; Stores total number of ways to connect the graph ; Stores the maximum Bitwise AND ; Iterate over the range [ 0 , 2 ^ n ] ; Store the Bitwise AND of the connected vertices ; Store the count of the connected vertices ; Check for all the bits ; If i - th bit is set ; If the first vertex is added ; Set andans equal to arr [ i ] ; Calculate Bitwise AND of arr [ i ] with andans ; Increase the count of connected vertices ; If number of connected vertices is ( m + 1 ) , no cycle is formed ; Find the maximum Bitwise AND value possible ; Return the maximum Bitwise AND possible ; Driver Code",
        "Category": "Bit Manipulation"
    },
    {
        "ID": "9928-9928",
        "Code": "MAX = 300004 NEW_LINE graph = [ [ ] for i in range ( MAX ) ] NEW_LINE mod = 10 ** 9 + 7 NEW_LINE ans = 0 NEW_LINE def countSubtreesUtil ( cur , par ) : NEW_LINE INDENT global mod , ans NEW_LINE res = 1 NEW_LINE for i in range ( len ( graph [ cur ] ) ) : NEW_LINE INDENT v = graph [ cur ] [ i ] NEW_LINE if ( v == par ) : NEW_LINE INDENT continue NEW_LINE DEDENT res = ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod NEW_LINE DEDENT ans = ( ans + res ) % mod NEW_LINE return res NEW_LINE DEDENT def countSubtrees ( N , adj ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT a = adj [ i ] [ 0 ] NEW_LINE b = adj [ i ] [ 1 ] NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT countSubtreesUtil ( 1 , 1 ) NEW_LINE print ( ans + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE adj = [ [ 0 , 1 ] , [ 1 , 2 ] ] NEW_LINE countSubtrees ( N , adj ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count of subtrees possible from an N | Python3 program of the above approach ; Adjacency list to represent the graph ; Stores the count of subtrees possible from given N - ary Tree ; Utility function to count the number of subtrees possible from given N - ary Tree ; Stores the count of subtrees when cur node is the root ; Traverse the adjacency list ; Iterate over every ancestor ; Calculate product of the number of subtrees for each child node ; Update the value of ans ; Return the resultant count ; Function to count the number of subtrees in the given tree ; Initialize an adjacency matrix ; Add the edges ; Function Call to count the number of subtrees possible ; Prcount of subtrees ; Driver Code",
        "Category": "Backtracking"
    },
    {
        "ID": "9939-9939",
        "Code": "P = 51 NEW_LINE def count1s ( start_i , start_j , end_i , end_j , mat ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( start_i , end_i ) : NEW_LINE INDENT for y in range ( start_j , end_j ) : NEW_LINE INDENT if ( mat [ x ] [ y ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def findMinimumCount ( N , M , A , B , mat ) : NEW_LINE INDENT minimum = 1e9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( i + A <= N and j + B <= M ) : NEW_LINE INDENT count = count1s ( i , j , i + A , j + B , mat ) NEW_LINE minimum = min ( count , minimum ) NEW_LINE DEDENT if ( i + B <= N and j + A <= M ) : NEW_LINE INDENT count = count1s ( i , j , i + B , j + A , mat ) NEW_LINE minimum = min ( count , minimum ) NEW_LINE DEDENT DEDENT DEDENT return minimum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 NEW_LINE B = 2 NEW_LINE N = 3 NEW_LINE M = 4 NEW_LINE mat = [ [ 1 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 0 ] ] NEW_LINE print ( findMinimumCount ( N , M , A , B , mat ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Minimum number of 1 s present in a submatrix of given dimensions in a Binary Matrix | Python3 program for the above approach ; Function to count number of 1 s present in a sub matrix from ( start_i , start_j ) to ( end_i , end_j ) ; Stores the number of 1 s present in current submatrix ; Traverse the submatrix ; If mat [ x ] [ y ] is equal to 1 ; Increase count by 1 ; Return the total count of 1 s ; Function to find the minimum number of 1 s present in a sub - matrix of size A * B or B * A ; Stores the minimum count of 1 s ; Iterate i from 0 to N ; Iterate j from 0 to M ; If a valid sub matrix of size A * B from ( i , j ) is possible ; Count the number of 1 s present in the sub matrix of size A * B from ( i , j ) ; Update minimum if count is less than the current minimum ; If a valid sub matrix of size B * A from ( i , j ) is possible ; Count the number of 1 s in the sub matrix of size B * A from ( i , j ) ; Update minimum if count is less than the current minimum ; Return minimum as the final result ; Driver Code ; Given Input ; Function call to find the minimum number of 1 s in a submatrix of size A * B or B * A",
        "Category": "Matrix"
    },
    {
        "ID": "9941-9941",
        "Code": "def checkEvenPower ( n ) : NEW_LINE INDENT low , high = 0 , n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE value = pow ( 2 , mid ) NEW_LINE if ( value == n ) : NEW_LINE INDENT if ( mid % 2 == 1 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT elif ( value < n ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return \" No \" NEW_LINE DEDENT N = 4 NEW_LINE print ( checkEvenPower ( N ) ) NEW_LINE",
        "Type": "py",
        "NL": "Program to check if a number can be expressed as an even power of 2 or not | Function to check if N can be expressed as an even power of 2 or not ; Iterate until low > high ; Calculate mid ; If 2 ^ mid is equal to n ; If mid is odd ; Update the value of low ; Update the value of high ; Otherwise ; Driver code",
        "Category": "Binary Search"
    },
    {
        "ID": "9957-9957",
        "Code": "def countAPs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= 2 * N ) : NEW_LINE INDENT res = 2 * N NEW_LINE if ( res % i == 0 ) : NEW_LINE INDENT op = res / i - i + 1 NEW_LINE if ( op % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( i * i != res and ( i - res / i + 1 ) % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( count - 1 ) NEW_LINE DEDENT N = 963761198400 NEW_LINE countAPs ( N ) NEW_LINE",
        "Type": "py",
        "NL": "Count Arithmetic Progressions having sum N and common difference equal to 1 | Function to count all possible AP series with common difference 1 and sum of elements equal to N ; Stores the count of AP series ; Traverse through all factors of 2 * N ; Check for the given conditions ; Increment count ; Prcount - 1 ; Given value of N ; Function call to count required number of AP series",
        "Category": "Math"
    },
    {
        "ID": "9959-9959",
        "Code": "R = 100005 NEW_LINE arr = [ 0 for i in range ( R ) ] NEW_LINE def canExpress ( N ) : NEW_LINE INDENT temp = N NEW_LINE n = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT N //= 10 NEW_LINE n += 1 NEW_LINE DEDENT N = temp NEW_LINE sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += pow ( N % 10 , n ) NEW_LINE N //= 10 NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( canExpress ( i ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT DEDENT def countNumbers ( queries , N ) : NEW_LINE INDENT precompute ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT L1 = queries [ i ] [ 0 ] NEW_LINE R1 = queries [ i ] [ 1 ] NEW_LINE print ( ( arr [ R1 ] - arr [ L1 - 1 ] ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT queries = [ [ 1 , 400 ] , [ 1 , 9 ] ] NEW_LINE N = len ( queries ) NEW_LINE countNumbers ( queries , N ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Count numbers from a given range that can be expressed as sum of digits raised to the power of count of digits | Python 3 program for the above approach ; Function to check if a number N can be expressed as sum of its digits raised to the power of the count of digits ; Stores the number of digits ; Stores the resultant number ; Return true if both the numbers are same ; Function to precompute and store for all numbers whether they can be expressed ; Mark all the index which are plus perfect number ; If true , then update the value at this index ; Compute prefix sum of the array ; Function to count array elements that can be expressed as the sum of digits raised to the power of count of digits ; Precompute the results ; Traverse the queries ; Print the resultant count ; Driver Code ; Function call",
        "Category": "Math"
    },
    {
        "ID": "9960-9960",
        "Code": "sieve = [ 0 for i in range ( 105 ) ] NEW_LINE def buildSieve ( ) : NEW_LINE INDENT global sieve NEW_LINE for i in range ( 2 , 100 ) : NEW_LINE INDENT sieve [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( sieve [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , 100 , i ) : NEW_LINE INDENT sieve [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT def isAnyPrime ( first , last ) : NEW_LINE INDENT global sieve NEW_LINE num1 = first * 10 + last NEW_LINE num2 = last * 10 + first NEW_LINE if ( sieve [ num1 ] == 1 or sieve [ num2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def performQueries ( q ) : NEW_LINE INDENT for i in range ( len ( q ) ) : NEW_LINE INDENT A = q [ i ] NEW_LINE last = A % 10 NEW_LINE first = 0 NEW_LINE while ( A >= 10 ) : NEW_LINE INDENT A = A // 10 NEW_LINE DEDENT first = A NEW_LINE if ( isAnyPrime ( first , last ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = [ 30 , 66 ] NEW_LINE buildSieve ( ) NEW_LINE performQueries ( q ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if concatenation of first and last digits forms a prime number or not for each array element | Stores if i is prime ( 1 ) or non - prime ( 0 ) ; Function to build sieve array ; Inititalize all the values in sieve equals to 1 ; Sieve of Eratosthenes ; If current number is prime ; Set all multiples as non - prime ; Function to check if the numbers formed by combining first and last digits generates a prime number or not ; Check if any of the numbers formed is a prime number or not ; Traverse the array of queries ; Extract the last digit ; Extract the first digit ; If any of the two numbers is prime ; Otherwise ; Driver Code ; Computes and stores primes using Sieve ; Function call to perform queries",
        "Category": "Math"
    },
    {
        "ID": "9961-9961",
        "Code": "def sumOfNodeInAPath ( node_value ) : NEW_LINE INDENT sum_of_node = 0 NEW_LINE while ( node_value ) : NEW_LINE INDENT sum_of_node += node_value NEW_LINE node_value //= 2 NEW_LINE DEDENT print ( sum_of_node , end = \" ▁ \" ) NEW_LINE DEDENT def findSum ( Q ) : NEW_LINE INDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT node_value = Q [ i ] NEW_LINE sumOfNodeInAPath ( node_value ) NEW_LINE print ( end = \" \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 20 , 100 ] NEW_LINE findSum ( arr ) NEW_LINE",
        "Type": "py",
        "NL": "Queries to calculate sum of the path from root to a given node in given Binary Tree | Function to find the sum of the path from root to the current node ; Sum of nodes in the path ; Iterate until root is reached ; Update the node value ; Print the resultant sum ; Function to print the path sum for each query ; Traverse the queries ; arraylist to store integers",
        "Category": "Binary Tree"
    },
    {
        "ID": "9969-9969",
        "Code": "primes = [ 0 ] * ( 1000006 ) NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def preprocess ( ) : NEW_LINE INDENT for i in range ( 1 , 1000001 ) : NEW_LINE INDENT primes [ i ] = i NEW_LINE DEDENT i = 2 NEW_LINE while ( i * i <= 1000000 ) : NEW_LINE INDENT if ( primes [ i ] == i ) : NEW_LINE INDENT for j in range ( 2 * i , 1000001 , i ) : NEW_LINE INDENT if ( primes [ j ] == j ) : NEW_LINE INDENT primes [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def Steps ( x , m ) : NEW_LINE INDENT steps = 0 NEW_LINE flag = False NEW_LINE while ( x > 1 ) : NEW_LINE INDENT if ( primes [ x ] > m ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT x //= primes [ x ] NEW_LINE steps += 1 NEW_LINE DEDENT if ( flag != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT def minimumSteps ( x , y , m ) : NEW_LINE INDENT preprocess ( ) NEW_LINE g = gcd ( x , y ) NEW_LINE x = x // g NEW_LINE y = y // g NEW_LINE x_steps = Steps ( x , m ) NEW_LINE y_steps = Steps ( y , m ) NEW_LINE if ( x_steps == - 1 or y_steps == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return x_steps + y_steps NEW_LINE DEDENT X = 160 NEW_LINE Y = 180 NEW_LINE M = 10 NEW_LINE print ( minimumSteps ( X , Y , M ) ) NEW_LINE",
        "Type": "py",
        "NL": "Minimize steps required to make two values equal by repeated division by any of their prime factor which is less than M | Stores the prime factor of numbers ; Function to find GCD of a and b ; Base Case ; Otherwise , calculate GCD ; Function to precompute the prime numbers till 1000000 ; Initialize all the positions with their respective values ; Iterate over the range [ 2 , sqrt ( 10 ^ 6 ) ] ; If i is prime number ; Mark it as the factor ; Utility function to count the number of steps to make X and Y equal ; Initialise steps ; Iterate x is at most 1 ; Divide with the smallest prime factor ; If X and Y can 't be  made equal ; Return steps ; Function to find the minimum number of steps required to make X and Y equal ; Generate all the prime factors ; Calculate GCD of x and y ; Divide the numbers by their gcd ; If not possible , then return - 1 ; Return the resultant number of steps ; Driver Code",
        "Category": "Math"
    },
    {
        "ID": "9970-9970",
        "Code": "import math NEW_LINE def isNonDeficient ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return sum >= 2 * n NEW_LINE DEDENT def LongestNonDeficientSubsequence ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isNonDeficient ( arr [ i ] ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 13 , 55 , 240 , 32 , 24 , 27 , 56 , 80 , 100 , 330 , 89 ] NEW_LINE N = len ( arr ) NEW_LINE print ( LongestNonDeficientSubsequence ( arr , N ) ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Length of longest subsequence consisting of Non | Python3 program for the above approach ; Function to check if n is a deficient number or not ; Stores sum of divisors ; Iterate over the range [ 1 , sqrt ( N ) ] ; If n is divisible by i ; If divisors are equal , add only one of them ; Otherwise add both ; Function to print the longest subsequence which does not contain any deficient numbers ; Stores the count of array elements which are non - deficient ; Traverse the array ; If element is non - deficient ; Return the answer ; Driver Code",
        "Category": "Array"
    },
    {
        "ID": "9987-9987",
        "Code": "import math NEW_LINE def countBit ( n ) : NEW_LINE INDENT return int ( math . log ( n , 2 ) ) + 1 NEW_LINE DEDENT def countSetBit ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE while n : NEW_LINE INDENT ans += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def maximize ( n ) : NEW_LINE INDENT bits = countBit ( n ) NEW_LINE setBits = countSetBit ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( bits ) : NEW_LINE INDENT if i < setBits : NEW_LINE INDENT ans |= 1 NEW_LINE DEDENT if i != setBits - 1 : NEW_LINE INDENT ans <<= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def minimize ( n ) : NEW_LINE INDENT setBits = countSetBit ( n ) NEW_LINE ans = 0 NEW_LINE for i in range ( setBits ) : NEW_LINE INDENT ans |= 1 NEW_LINE if i != setBits - 1 : NEW_LINE INDENT ans <<= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def maxDiff ( arr ) : NEW_LINE INDENT caseOne = 0 NEW_LINE SumOfOdd = 0 NEW_LINE SumOfeven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT SumOfOdd += minimize ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT SumOfeven += maximize ( arr [ i ] ) NEW_LINE DEDENT DEDENT caseOne = abs ( SumOfOdd - SumOfeven ) NEW_LINE caseTwo = 0 NEW_LINE SumOfOdd = 0 NEW_LINE SumOfeven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT SumOfOdd += maximize ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT SumOfeven += minimize ( arr [ i ] ) NEW_LINE DEDENT DEDENT caseTwo = abs ( SumOfOdd - SumOfeven ) NEW_LINE return max ( caseOne , caseTwo ) NEW_LINE DEDENT arr = [ 54 , 32 , 11 , 23 ] NEW_LINE print ( maxDiff ( arr ) ) NEW_LINE",
        "Type": "py",
        "NL": "Maximize difference between odd and even indexed array elements by swapping unequal adjacent bits in their binary representations | Python program for the above approach ; Function to count total number of bits present in a number ; Function to count total set bits in a number ; Stores the count of set bits ; Right shift by 1 ; Return the final count ; Function to find maximum number by shifting two unequal bits ; Count set bits in number n ; Iterate the string bits ; Function to find minimum number by shifting two unequal bits ; Iterate the set bit ; Function to find the maximum difference ; Stores the maximum difference ; Stores the sum of elements placed at odd positions ; Stores the sum of elements placed at even positions ; Traverse the array ; Update CaseOne ; Stores the maximum difference ; Assign value O ; Traverse the array ; Update caseTwo ; Return maximum of caseOne and CaseTwo ; Drivers Code ; Function Call",
        "Category": "Math"
    },
    {
        "ID": "9988-9988",
        "Code": "def isVowel ( c ) : NEW_LINE INDENT vowel = \" aeiou \" NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT name = \" alex \" NEW_LINE typed = \" aaalaeex \" NEW_LINE if ( printRLE ( name , typed ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "Type": "py",
        "NL": "Check if a string is the typed name of the given name | Check if the character is vowel or not ; Returns true if ' typed ' is a typed name given str ; Traverse through all characters of str ; If current characters do not match ; If not vowel , simply move ahead in both ; Count occurrences of current vowel in str ; Count occurrence of current vowel in typed ; Driver code",
        "Category": "Substring"
    },
    {
        "ID": "9995-9995",
        "Code": "import math NEW_LINE def solve ( A , n , Q , q ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT glows = 0 NEW_LINE count = 0 NEW_LINE if ( one >= int ( math . ceil ( n / 2 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT prev = glows NEW_LINE if ( A [ Q [ i ] - 1 ] == 1 ) : NEW_LINE INDENT one -= 1 NEW_LINE DEDENT if ( A [ Q [ i ] - 1 ] == 0 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT A [ Q [ i ] - 1 ] ^= 1 NEW_LINE if ( one >= int ( math . ceil ( n / 2.0 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT else : NEW_LINE INDENT glows = 0 NEW_LINE DEDENT if ( prev != glows ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE arr = [ 1 , 1 , 0 ] NEW_LINE q = 3 NEW_LINE Q = [ 3 , 2 , 1 ] NEW_LINE print ( solve ( arr , n , Q , q ) ) NEW_LINE",
        "Type": "py",
        "NL": "Count the number of times a Bulb switches its state | Python program for the above approach ; Function to find the number of times a bulb switches its state ; count of 1 's ; Traverse the array ; update the array ; update the status of bulb ; Traverse the array Q [ ] ; stores previous state of the bulb ; Toggle the switch and update the count of 1 's ; if the bulb switches state ; Return count ; Input ; Queries ; Function call to find number of times the bulb toggles",
        "Category": "Array"
    },
    {
        "ID": "9996-9996",
        "Code": "def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += N % 10 NEW_LINE N //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def elementsHavingDigitSumK ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( sumOfDigits ( arr [ i ] ) == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT arr = [ 23 , 54 , 87 , 29 , 92 , 62 ] NEW_LINE K = 11 NEW_LINE N = len ( arr ) NEW_LINE elementsHavingDigitSumK ( arr , N , K ) NEW_LINE",
        "Type": "py",
        "NL": "Count array elements having sum of digits equal to K | Function to calculate the sum of digits of the number N ; Stores the sum of digits ; Return the sum ; Function to count array elements ; Store the count of array elements having sum of digits K ; Traverse the array ; If sum of digits is equal to K ; Increment the count ; Prthe count ; Given array ; Given value of K ; Size of the array ; Function call to count array elements having sum of digits equal to K",
        "Category": "Array"
    },
    {
        "ID": "9998-9998",
        "Code": "def processDiagonal ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE getBit = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT S = 0 NEW_LINE NS = 0 NEW_LINE for j in arr : NEW_LINE if getBit & j : NEW_LINE INDENT S += 1 NEW_LINE DEDENT else : NEW_LINE INDENT NS += 1 NEW_LINE DEDENT if S > NS : NEW_LINE ans += 2 ** i NEW_LINE getBit <<= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def findSum ( mat ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE priDiag = [ ] NEW_LINE while i < len ( mat ) : NEW_LINE INDENT priDiag . append ( mat [ i ] [ j ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT i = 0 NEW_LINE j = len ( mat ) - 1 NEW_LINE secDiag = [ ] NEW_LINE while i < len ( mat ) : NEW_LINE INDENT secDiag . append ( mat [ i ] [ j ] ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return processDiagonal ( priDiag ) + processDiagonal ( secDiag ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( findSum ( mat ) ) NEW_LINE",
        "Type": "py",
        "NL": "Sum of numbers obtained by the count of set and non | Functino to find the number after processing the diagonal elements ; Store the required number ; Checking for each position ; Store the number of set bits & non - set bits at position i ; Traverse the diagonal elements ; Update count of S if current element is set at position i ; Else update NS ; If number of set bits is > number of non - set bits , add set bits value to the ans ; Return the answer ; Function to find the sum of the numbers generated after processing both the diagonals of the matrix ; Store the primary diagonal elements ; Store the secondary diagonal elements ; Function Call to get the required numbers and return their sum ; Driver Code ; Function Call",
        "Category": "Matrix"
    }
]