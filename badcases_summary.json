[
  {
    "type": "cpp_to_java",
    "GT": "static long f_gold ( long n ) {\n  long count = 0 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) for ( int j = 0 ;\n  j <= n ;\n  j ++ ) for ( int k = 0 ;\n  k <= n ;\n  k ++ ) if ( i + j + k == n ) count ++ ;\n  return count ;\n}",
    "badcase": "static int count_of_ways ( int n ) {\n    int count = 0 ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) for ( int j = 0 ;\n    j <= n ;\n    j ++ ) for ( int k = 0 ;\n    k <= n ;\n    k ++ ) if ( i + j + k == n ) count ++ ;\n    return count ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( String num ) {\n  int n = num . length ( ) ;\n  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;\n  if ( n % 3 == 1 ) num = \"00\" + num ;\n  if ( n % 3 == 2 ) num = \"0\" + num ;\n  int gSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int group = 0 ;\n    group += ( num . charAt ( i ++ ) - '0' ) * 100 ;\n    group += ( num . charAt ( i ++ ) - '0' ) * 10 ;\n    group += num . charAt ( i ) - '0' ;\n    gSum += group ;\n  }\n  if ( gSum > 1000 ) {\n    num = Integer . toString ( gSum ) ;\n    n = num . length ( ) ;\n    gSum = f_gold ( num ) ? 1 : 0 ;\n  }\n  return ( gSum == 999 ) ;\n}",
    "badcase": "static boolean isDivisible999 ( String num ) {\n    int n = num . length ( ) ;\n    if ( n == 0 && num . charAt ( 0 ) =='0') return true ;\n    if ( n % 3 == 1 ) num = \"00\" + num ;\n    if ( n % 3 == 2 ) num = \"0\" + num ;\n    int gSum = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int group = 0 ;\n      group += ( num . charAt ( i ++ ) -'0') * 100 ;\n      group += ( num . charAt ( i ++ ) -'0') * 10 ;\n      group += num . charAt ( i ) -'0';\n      gSum += group ;\n    }\n    if ( gSum > 1000 ) {\n      num = String . valueOf ( gSum ) ;\n      n = num . length ( ) ;\n      gSum = isDivisible999 ( num ) ;\n    }\n    return ( gSum == 999 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int x , int y ) {\n  int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ;\n  double res2 = Math . log ( y ) / Math . log ( x ) ;\n  return ( res1 == res2 ) ;\n}",
    "badcase": "static boolean isPower ( int x , int y ) {\n    int res1 = ( int ) ( log ( y ) / log ( x ) ) ;\n    double res2 = log ( y ) / log ( x ) ;\n    return ( res1 == res2 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( String str ) {\n  int n = str . length ( ) ;\n  int digitSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;\n  return ( digitSum % 9 == 0 ) ? 1 : 0  ;\n}",
    "badcase": "static boolean check ( String str ) {\n    int n = str . length ( ) ;\n    int digitSum = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) digitSum += ( str . charAt ( i ) -'0') ;\n    return ( digitSum % 9 == 0 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int arr [ ] , int n ) {\n  if ( n == 1 ) {\n    return true ;\n  }\n  int i ;\n  for ( i = 1 ;\n  arr [ i - 1 ] < arr [ i ] && i < n ;\n  i ++ ) ;\n  if ( i == n ) {\n    return true ;\n  }\n  int j = i ++ ;\n  while ( arr [ j ] < arr [ j - 1 ] ) {\n    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) {\n      return false ;\n    }\n    j ++ ;\n  }\n  if ( j == n ) {\n    return true ;\n  }\n  int k = j ;\n  if ( arr [ k ] < arr [ i - 1 ] ) {\n    return false ;\n  }\n  while ( k > 1 && k < n ) {\n    if ( arr [ k ] < arr [ k - 1 ] ) {\n      return false ;\n    }\n    k ++ ;\n  }\n  return true ;\n}",
    "badcase": "static boolean checkReverse ( int arr [ ] , int n ) {\n    if ( n == 1 ) return true ;\n    int i ;\n    for ( i = 1 ;\n    i < n && arr [ i - 1 ] < arr [ i ] ;\n    i ++ ) ;\n    if ( i == n ) return true ;\n    int j = i ;\n    while ( arr [ j ] < arr [ j - 1 ] ) {\n      if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ;\n      j ++ ;\n    }\n    if ( j == n ) return true ;\n    int k = j ;\n    if ( arr [ k ] < arr [ i - 1 ] ) return false ;\n    while ( k > 1 && k < n ) {\n      if ( arr [ k ] < arr [ k - 1 ] ) return false ;\n      k ++ ;\n    }\n    return true ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( String num ) {\n  int n = num . length ( ) ;\n  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;\n  if ( n % 3 == 1 ) num = \"00\" + num ;\n  if ( n % 3 == 2 ) num = \"0\" + num ;\n  n = num . length ( ) ;\n  int gSum = 0 , p = 1 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    int group = 0 ;\n    group += num . charAt ( i -- ) - '0' ;\n    group += ( num . charAt ( i -- ) - '0' ) * 10 ;\n    group += ( num . charAt ( i ) - '0' ) * 100 ;\n    gSum = gSum + group * p ;\n    p = p * - 1 ;\n  }\n  return ( gSum % 7 == 0 )  ? 1 : 0 ;\n}",
    "badcase": "static int isdivisible7 ( String num ) {\n    int n = num . length ( ) ;\n    if ( n == 0 && num . charAt ( 0 ) =='â–') return 1 ;\n    if ( n % 3 == 1 ) {\n      num += \"00\" ;\n      n += 2 ;\n    }\n    else if ( n % 3 == 2 ) {\n      num += \"0\" ;\n      n ++ ;\n    }\n    int i , GSum = 0 , p = 1 ;\n    for ( i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      int group = 0 ;\n      group += num . charAt ( i -- ) -'0';\n      group += ( num . charAt ( i -- ) -'0') * 10 ;\n      group += ( num . charAt ( i ) -'0') * 100 ;\n      gSum = gSum + group * p ;\n      p *= ( - 1 ) ;\n    }\n    return ( gSum % 7 == 0 ) ? 1 : 0 ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int arr [ ] , int low , int high ) {\n  if ( high >= low ) {\n    int mid = low + ( high - low ) / 2 ;\n    if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ;\n    if ( arr [ mid ] == 1 ) return f_gold ( arr , ( mid + 1 ) , high ) ;\n    return f_gold ( arr , low , ( mid - 1 ) ) ;\n  }\n  return 0 ;\n}",
    "badcase": "static int countOnes ( boolean arr [ ] , int low , int high ) {\n  if ( high >= low ) {\n    int mid = low + ( high - low ) / 2 ;\n    if ( ( mid == high || arr [ mid + 1 ] == false ) && ( arr [ mid ] == true ) ) return mid + 1 ;\n    if ( arr [ mid ] == true ) return countOnes ( arr , ( mid + 1 ) , high ) ;\n    return countOnes ( arr , low , ( mid - 1 ) ) ;\n  }\n  return 0 ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static int f_gold ( int n , int k , int x ) {\n  int [ ] dp = new int [ 109 ] ;\n  dp [ 0 ] = 0 ;\n  dp [ 1 ] = 1 ;\n  for ( int i = 2 ;\n  i < n ;\n  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ;\n  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ;\n}",
    "badcase": "static int countarray ( int n , int k , int x ) {\n    int dp [ ] = new int [ MAXN ] ;\n    dp [ 0 ] = 0 ;\n    dp [ 1 ] = 1 ;\n    for ( int i = 2 ;\n    i < n ;\n    i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ;\n    return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n , int k ) {\n  int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ;\n  dp [ 1 ] [ 0 ] [ 0 ] = 1 ;\n  dp [ 1 ] [ 0 ] [ 1 ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < i && j < k + 1 ;\n    j ++ ) {\n      dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ;\n      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;\n      if ( j - 1 >= 0 ) {\n        dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ;\n      }\n    }\n  }\n  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;\n}",
    "badcase": "static int countStrings ( int n , int k ) {\n    int [ ] [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] [ 2 ] ;\n    for ( int i = 0 ;\n    i < n + 1 ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < k + 1 ;\n      j ++ ) {\n        Arrays . fill ( dp [ i ] [ j ] , 0 ) ;\n      }\n    }\n    dp [ 1 ] [ 0 ] [ 0 ] = 1 ;\n    dp [ 1 ] [ 0 ] [ 1 ] = 1 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < i ;\n      j ++ ) {\n        dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ;\n        dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;\n        if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ;\n      }\n    }\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n , int k ) {\n  int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) dp [ i ] [ 0 ] = 0 ;\n  for ( int i = 0 ;\n  i <= k ;\n  i ++ ) dp [ 0 ] [ k ] = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) for ( int j = 1 ;\n  j <= k ;\n  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;\n  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ;\n  return dp [ n ] [ k ] ;\n}",
    "badcase": "static int countP ( int n , int k ) {\n    int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) dp [ i ] [ 0 ] = 0 ;\n    for ( int i = 0 ;\n    i <= k ;\n    i ++ ) dp [ 0 ] [ k ] = 0 ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) for ( int j = 1 ;\n    j <= i ;\n    j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;\n    else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ;\n    return dp [ n ] [ k ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( char str [ ] , int n ) {\n  int ans = ( n * ( n + 1 ) ) / 2 ;\n  int a_index = 0 ;\n  int b_index = 0 ;\n  int c_index = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( str [ i ] == 'a' ) {\n      a_index = i + 1 ;\n      ans -= Math . min ( b_index , c_index ) ;\n    }\n    else if ( str [ i ] == 'b' ) {\n      b_index = i + 1 ;\n      ans -= Math . min ( a_index , c_index ) ;\n    }\n    else {\n      c_index = i + 1 ;\n      ans -= Math . min ( a_index , b_index ) ;\n    }\n  }\n  return ans ;\n}",
    "badcase": "static int CountSubstring ( char str [ ] , int n ) {\n    int ans = ( n * ( n + 1 ) ) / 2 ;\n    int a_index = 0 , b_index = 0 , c_index = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( str [ i ] =='a') {\n        a_index = i + 1 ;\n        ans -= Math . min ( b_index , c_index ) ;\n      }\n      else if ( str [ i ] =='b') {\n        b_index = i + 1 ;\n        ans -= Math . min ( a_index , c_index ) ;\n      }\n      else {\n        c_index = i + 1 ;\n        ans -= Math . min ( a_index , b_index ) ;\n      }\n    }\n    return ans ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( char [ ] s ) {\n  int b_count = 0 ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < s . length ;\n  i ++ ) {\n    if ( s [ s . length - i - 1 ] == 'a' ) {\n      res = ( res + b_count ) ;\n      b_count = ( b_count * 2 ) ;\n    }\n    else {\n      b_count += 1 ;\n    }\n  }\n  return res ;\n}",
    "badcase": "static int abFree ( String s ) {\n    int n = s . length ( ) ;\n    char [ ] char_array = s . toCharArray ( ) ;\n    int b_count = 0 ;\n    int res = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( char_array [ n - i - 1 ] =='a') {\n        res = ( res + b_count ) ;\n        b_count = ( b_count * 2 ) ;\n      }\n      else {\n        b_count += 1 ;\n      }\n    }\n    return res ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( char str [ ] , int n ) {\n  int dp [ ] [ ] = new int [ n ] [ n ] ;\n  boolean P [ ] [ ] = new boolean [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) P [ i ] [ i ] = true ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( str [ i ] == str [ i + 1 ] ) {\n      P [ i ] [ i + 1 ] = true ;\n      dp [ i ] [ i + 1 ] = 1 ;\n    }\n  }\n  for ( int gap = 2 ;\n  gap < n ;\n  gap ++ ) {\n    for ( int i = 0 ;\n    i < n - gap ;\n    i ++ ) {\n      int j = gap + i ;\n      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;\n      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;\n    }\n  }\n  return dp [ 0 ] [ n - 1 ] ;\n}",
    "badcase": "static int CountPS ( String str , int n ) {\n    int dp [ ] [ ] = new int [ n ] [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) dp [ i ] [ i ] = 1 ;\n    boolean P [ ] [ ] = new boolean [ n ] [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) P [ i ] [ i ] = true ;\n    for ( int i = 0 ;\n    i < n - 1 ;\n    i ++ ) {\n      if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) {\n        P [ i ] [ i + 1 ] = true ;\n        dp [ i ] [ i + 1 ] = 1 ;\n      }\n    }\n    for ( int gap = 2 ;\n    gap < n ;\n    gap ++ ) {\n      for ( int i = 0 ;\n      i < n - gap ;\n      i ++ ) {\n        int j = gap + i ;\n        if ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;\n        if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;\n        else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;\n      }\n    }\n    return dp [ 0 ] [ n - 1 ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( String str ) {\n  int N = str . length ( ) ;\n  int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) cps [ i ] [ i ] = 1 ;\n  for ( int L = 2 ;\n  L <= N ;\n  L ++ ) {\n    for ( int i = 0 ;\n    i < N ;\n    i ++ ) {\n      int k = L + i - 1 ;\n      if ( k < N ) {\n        if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ;\n        else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ;\n      }\n    }\n  }\n  return cps [ 0 ] [ N - 1 ] ;\n}",
    "badcase": "static int countPS ( String str ) {\n    int N = str . length ( ) ;\n    int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ;\n    for ( int i = 0 ;\n    i < N ;\n    i ++ ) cps [ i ] [ i ] = 1 ;\n    for ( int L = 2 ;\n    L <= N ;\n    L ++ ) {\n      for ( int i = 0 ;\n      i < N ;\n      i ++ ) {\n        int k = L + i - 1 ;\n        if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ;\n        else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ;\n      }\n    }\n    return cps [ 0 ] [ N - 1 ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int m , int n ) {\n  int [ ] dp = new int [ n ] ;\n  dp [ 0 ] = 1 ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j < n ;\n    j ++ ) {\n      dp [ j ] += dp [ j - 1 ] ;\n    }\n  }\n  return dp [ n - 1 ] ;\n}",
    "badcase": "static int numberOfPaths ( int m , int n ) {\n    int [ ] dp = new int [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) dp [ i ] = 1 ;\n    for ( int i = 0 ;\n    i < m ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j < n ;\n      j ++ ) {\n        dp [ j ] += dp [ j - 1 ] ;\n      }\n    }\n    return dp [ n - 1 ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  Arrays . sort ( arr ) ;\n  return arr [ n - 1 ] ;\n}",
    "badcase": "static int largest ( int arr [ ] , int n ) {\n    return Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static long f_gold ( int m , int n , int x ) {\n  long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ;\n  for ( int j = 1 ;\n  j <= m && j <= x ;\n  j ++ ) table [ 1 ] [ j ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= x ;\n    j ++ ) {\n      for ( int k = 1 ;\n      k < j && k <= m ;\n      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;\n    }\n  }\n  return table [ n ] [ x ] ;\n}",
    "badcase": "static int findWays ( int m , int n , int x ) {\n    int table [ ] [ ] = new int [ n + 1 ] [ x + 1 ] ;\n    for ( int i = 0 ;\n    i < n + 1 ;\n    i ++ ) Arrays . fill ( table [ i ] , 0 ) ;\n    for ( int j = 1 ;\n    j <= m && j <= x ;\n    j ++ ) table [ 1 ] [ j ] = 1 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) for ( int j = 1 ;\n    j <= x ;\n    j ++ ) for ( int k = 1 ;\n    k <= m && k < j ;\n    k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;\n    return table [ n ] [ x ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  if ( n == 0 || n == 9 ) return true ;\n  if ( n < 9 ) return false ;\n  return f_gold ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ;\n}",
    "badcase": "static boolean isDivBy9 ( int n ) {\n    if ( n == 0 n == 9 ) return true ;\n    if ( n < 9 ) return false ;\n    return isDivBy9 ( ( n >> 3 ) - ( n & 7 ) ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( String num ) {\n  if ( num . length ( ) >= 3 ) {\n    int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ;\n    if ( d1 % 2 != 0 ) return false ;\n    int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ;\n    int sum = 0 ;\n    for ( int i = 0 ;\n    i < num . length ( ) ;\n    i ++ ) sum += num . charAt ( i ) ;\n    return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;\n  }\n  else {\n    int number = Integer . parseInt ( num ) ;\n    return ( number % 12 == 0 ) ;\n  }\n}",
    "badcase": "static boolean isDivisibleBy12 ( String num ) {\n    if ( num . length ( ) >= 3 ) {\n      int d1 = num . charAt ( num . length ( ) - 1 ) ;\n      if ( d1 % 2 != 0 ) return false ;\n      int d2 = num . charAt ( num . length ( ) - 2 ) ;\n      int sum = 0 ;\n      for ( int i = 0 ;\n      i < num . length ( ) ;\n      i ++ ) sum += num . charAt ( i ) ;\n      return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;\n    }\n    else {\n      int number = Integer . parseInt ( num ) ;\n      return ( number % 12 == 0 ) ;\n    }\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n ) {\n  int res = 1 ;\n  for ( int i = n ;\n  i >= 0 ;\n  i = i - 2 ) {\n    if ( i == 0 || i == 1 ) return res ;\n    else res *= i ;\n  }\n  return res ;\n}",
    "badcase": "static int doublefactorial ( int n ) {\n    int res = 1 ;\n    for ( int i = n ;\n    i >= 0 ;\n    i = i - 2 ) {\n      if ( i == 0 i == 1 ) return res ;\n      else res *= i ;\n    }\n    return res ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( char symb [ ] , char oper [ ] , int n ) {\n  int F [ ] [ ] = new int [ n ] [ n ] ;\n  int T [ ] [ ] = new int [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ;\n    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ;\n  }\n  for ( int gap = 1 ;\n  gap < n ;\n  ++ gap ) {\n    for ( int i = 0 , j = gap ;\n    j < n ;\n    ++ i , ++ j ) {\n      T [ i ] [ j ] = F [ i ] [ j ] = 0 ;\n      for ( int g = 0 ;\n      g < gap ;\n      g ++ ) {\n        int k = i + g ;\n        int tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n        if ( oper [ k ] == '&' ) {\n          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '|' ) {\n          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '^' ) {\n          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n        }\n      }\n    }\n  }\n  return T [ 0 ] [ n - 1 ] ;\n}",
    "badcase": "static int countParenth ( char symb [ ] , char oper [ ] , int n ) {\n    int F [ ] [ ] = new int [ n ] [ n ] ;\n    int T [ ] [ ] = new int [ n ] [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      F [ i ] [ i ] = ( symb [ i ] =='F') ? 1 : 0 ;\n      T [ i ] [ i ] = ( symb [ i ] =='T') ? 1 : 0 ;\n    }\n    for ( int gap = 1 ;\n    gap < n ;\n    ++ gap ) {\n      for ( int i = 0 , j = gap ;\n      j < n ;\n      ++ i , ++ j ) {\n        T [ i ] [ j ] = F [ i ] [ j ] = 0 ;\n        for ( int g = 0 ;\n        g < gap ;\n        g ++ ) {\n          int k = i + g ;\n          int tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n          int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n          if ( oper [ k ] =='&') {\n            T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n            F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;\n          }\n          if ( oper [ k ] =='|') {\n            F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n            T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;\n          }\n        }\n      }\n    }\n    return T [ 0 ] [ n - 1 ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  HashSet < Integer > s = new HashSet < > ( ) ;\n  int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    s . add ( arr [ i ] ) ;\n    if ( arr [ i ] < minm ) minm = arr [ i ] ;\n    if ( arr [ i ] > maxm ) maxm = arr [ i ] ;\n  }\n  for ( int i = minm ;\n  i <= maxm ;\n  i ++ ) if ( ! s . contains ( i ) ) count ++ ;\n  return count ;\n}",
    "badcase": "static int countNum ( int arr [ ] , int n ) {\n    HashSet < Integer > s = new HashSet < Integer > ( ) ;\n    int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      s . add ( arr [ i ] ) ;\n      if ( arr [ i ] < minm ) minm = arr [ i ] ;\n      if ( arr [ i ] > maxm ) maxm = arr [ i ] ;\n    }\n    for ( int i = minm ;\n    i <= maxm ;\n    i ++ ) if ( ! s . contains ( arr [ i ] ) ) count ++ ;\n    return count ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n , int p ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    int count = 0 , temp = i ;\n    while ( temp % p == 0 ) {\n      count ++ ;\n      temp = temp / p ;\n    }\n    ans += count ;\n  }\n  return ans ;\n}",
    "badcase": "static int PowerOFPINnfactorial ( int n , int p ) {\n    int ans = 0 ;\n    int temp = p ;\n    while ( temp <= n ) {\n      ans += n / temp ;\n      temp = temp * p ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n , int p ) {\n  int ans = 0 ;\n  int temp = p ;\n  while ( temp <= n ) {\n    ans += n / temp ;\n    temp = temp * p ;\n  }\n  return ans ;\n}",
    "badcase": "static int PowerOFPINnfactorial ( int n , int p ) {\n    int ans = 0 ;\n    int temp = p ;\n    while ( temp <= n ) {\n      ans += n / temp ;\n      temp = temp * p ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int [ ] S , int n ) {\n  boolean found = false ;\n  Arrays . sort ( S ) ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( i == j ) continue ;\n      for ( int k = j + 1 ;\n      k < n ;\n      k ++ ) {\n        if ( i == k ) continue ;\n        for ( int l = k + 1 ;\n        l < n ;\n        l ++ ) {\n          if ( i == l ) continue ;\n          if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {\n            found = true ;\n            return S [ i ] ;\n          }\n        }\n      }\n    }\n  }\n  if ( found == false ) return Integer . MAX_VALUE ;\n  return - 1 ;\n}",
    "badcase": "static int findLargestd ( int S [ ] , int n ) {\n    boolean found = false ;\n    Arrays . sort ( S ) ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      for ( int j = 0 ;\n      j < n ;\n      j ++ ) {\n        if ( i == j ) continue ;\n        for ( int k = j + 1 ;\n        k < n ;\n        k ++ ) {\n          if ( i == k ) continue ;\n          for ( int l = k + 1 ;\n          l < n ;\n          l ++ ) {\n            if ( i == l ) continue ;\n            if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {\n              found = true ;\n              return S [ i ] ;\n            }\n          }\n        }\n      }\n    }\n    if ( found == false ) return Integer . MIN_VALUE ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int m [ ] [ ] , int r , int c ) {\n  int max = Integer . MIN_VALUE ;\n  int min = Integer . MAX_VALUE ;\n  for ( int i = 0 ;\n  i < r ;\n  i ++ ) {\n    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;\n    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;\n  }\n  int desired = ( r * c + 1 ) / 2 ;\n  while ( min < max ) {\n    int mid = min + ( max - min ) / 2 ;\n    int place = 0 ;\n    int get = 0 ;\n    for ( int i = 0 ;\n    i < r ;\n    ++ i ) {\n      get = Arrays . binarySearch ( m [ i ] , mid ) ;\n      if ( get < 0 ) get = Math . abs ( get ) - 1 ;\n      else {\n        while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ;\n      }\n      place = place + get ;\n    }\n    if ( place < desired ) min = mid + 1 ;\n    else max = mid ;\n  }\n  return min ;\n}",
    "badcase": "static int binaryMedian ( int m [ ] [ ] , int r , int c ) {\n    int min = Integer . MAX_VALUE ;\n    int max = Integer . MIN_VALUE ;\n    for ( int i = 0 ;\n    i < r ;\n    i ++ ) {\n      if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;\n      if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;\n    }\n    int desired = ( r * c + 1 ) / 2 ;\n    while ( min < max ) {\n      int mid = min + ( max - min ) / 2 ;\n      int place = 0 ;\n      for ( int i = 0 ;\n      i < r ;\n      ++ i ) place += upper_bound ( m [ i ] , c , mid ) ;\n      if ( place < desired ) min = mid + 1 ;\n      else max = mid ;\n    }\n    return min ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( boolean input [ ] [ ] , int n ) {\n  boolean row [ ] [ ] = new boolean [ n ] [ n ] ;\n  boolean col [ ] [ ] = new boolean [ n ] [ n ] ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    boolean isEndless = true ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      if ( input [ i ] [ j ] == false ) isEndless = false ;\n      col [ i ] [ j ] = isEndless ;\n    }\n  }\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    boolean isEndless = true ;\n    for ( int j = n - 1 ;\n    j >= 0 ;\n    j -- ) {\n      if ( input [ i ] [ j ] == false ) isEndless = false ;\n      row [ i ] [ j ] = isEndless ;\n    }\n  }\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 1 ;\n  j < n ;\n  j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;\n  return ans ;\n}",
    "badcase": "static int countEndless ( int input [ ] [ ] , int n ) {\n    boolean [ ] [ ] row = new boolean [ n ] [ n ] ;\n    boolean [ ] [ ] col = new boolean [ n ] [ n ] ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      boolean isEndless = true ;\n      for ( int i = n - 1 ;\n      i >= 0 ;\n      i -- ) {\n        if ( input [ i ] [ j ] == 0 ) isEndless = false ;\n        col [ i ] [ j ] = isEndless ;\n      }\n    }\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      boolean isEndless = true ;\n      for ( int j = n - 1 ;\n      j >= 0 ;\n      j -- ) {\n        if ( input [ i ] [ j ] == 0 ) isEndless = false ;\n        row [ i ] [ j ] = isEndless ;\n      }\n    }\n    int ans = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) for ( int j = 1 ;\n    j < n ;\n    j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;\n    return ans ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int a , int b ) {\n  int cnt = 0 ;\n  for ( int i = a ;\n  i <= b ;\n  i ++ ) for ( int j = 1 ;\n  j * j <= i ;\n  j ++ ) if ( j * j == i ) cnt ++ ;\n  return cnt ;\n}",
    "badcase": "static int countSquares ( int a , int b ) {\n    int cnt = 0 ;\n    for ( int i = a ;\n    i <= b ;\n    i ++ ) for ( int j = 1 ;\n    j * j <= i ;\n    j ++ ) if ( j * j == i ) c jnt ++ ;\n    return cnt ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static int f_gold ( int arr [ ] , int n ) {\n  int high = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) high = Math . max ( high , arr [ i ] ) ;\n  int divisors [ ] = new int [ high + 1 ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= Math . sqrt ( arr [ i ] ) ;\n    j ++ ) {\n      if ( arr [ i ] % j == 0 ) {\n        divisors [ j ] ++ ;\n        if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ;\n      }\n    }\n  }\n  for ( int i = high ;\n  i >= 1 ;\n  i -- ) if ( divisors [ i ] > 1 ) return i ;\n  return 1 ;\n}",
    "badcase": "static int findMaxGCD ( int arr [ ] , int n ) {\n    int high = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) high = Math . max ( high , arr [ i ] ) ;\n    int [ ] divisors = new int [ high + 1 ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j <= Math . sqrt ( arr [ i ] ) ;\n      j ++ ) {\n        if ( arr [ i ] % j == 0 ) {\n          divisors [ j ] ++ ;\n          if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ;\n        }\n      }\n    }\n    for ( int i = high ;\n    i >= 1 ;\n    i -- ) if ( divisors [ i ] > 1 ) return i ;\n    return - 1 ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) sum += arr [ i ] ;\n  return sum - ( ( ( n - 1 ) * n ) / 2 ) ;\n}",
    "badcase": "static int findRepeating ( int arr [ ] , int n ) {\n    return Arrays . stream ( arr ) . sum ( ) - ( ( n - 1 ) * n / 2 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static double f_gold ( int l ) {\n  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;\n  double sumLastLevel = 0 ;\n  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ;\n  double sum = sumLastLevel * l ;\n  return sum ;\n}",
    "badcase": "static int sumNodes ( int l ) {\n    int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ;\n    int sumLastLevel = 0 ;\n    sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ;\n    int sum = sumLastLevel * l ;\n    return sum ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int a [ ] , int n ) {\n  HashSet < Integer > s = new HashSet < Integer > ( ) ;\n  for ( int i : a ) {\n    s . add ( i ) ;\n  }\n  int arr_sum = 0 ;\n  for ( int i : a ) {\n    arr_sum += i ;\n  }\n  int set_sum = 0 ;\n  for ( int i : s ) {\n    set_sum += i ;\n  }\n  return ( 3 * set_sum - arr_sum ) / 2 ;\n}",
    "badcase": "static int singleNumber ( int a [ ] , int n ) {\n    Set < Integer > s = new HashSet < > ( ) ;\n    int arr_sum = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      s . add ( a [ i ] ) ;\n      arr_sum += a [ i ] ;\n    }\n    int set_sum = 0 ;\n    for ( int i : s ) set_sum += i ;\n    return ( 3 * set_sum - arr_sum ) / 2 ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int arr [ ] , int low , int high ) {\n  int max = arr [ low ] ;\n  int i ;\n  for ( i = low ;\n  i <= high ;\n  i ++ ) {\n    if ( arr [ i ] > max ) max = arr [ i ] ;\n  }\n  return max ;\n}",
    "badcase": "static int findMaximum ( int arr [ ] , int low , int high ) {\n  int max = arr [ low ] ;\n  int i ;\n  for ( i = low + 1 ;\n  i <= high ;\n  i ++ ) {\n    if ( arr [ i ] > max ) max = arr [ i ] ;\n    else break ;\n  }\n  return max ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  int count = 0 ;\n  int x = n & ( n - 1 ) ;\n  if ( n > 0 && x == 0 ) {\n    while ( n > 1 ) {\n      n >>= 1 ;\n      count += 1 ;\n    }\n    return ( count % 2 == 0 );\n  }\n  return false ;\n}",
    "badcase": "static int isPowerOfFour ( int n ) {\n    int count = 0 ;\n    if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) {\n      while ( n > 1 ) {\n        n >>= 1 ;\n        count += 1 ;\n      }\n      return ( count % 2 == 0 ) ? 1 : 0 ;\n    }\n    return 0 ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static String f_gold ( String seq ) {\n  int n = seq . length ( ) ;\n  if ( n >= 9 ) return \"-1\" ;\n  char result [ ] = new char [ n + 1 ] ;\n  int count = 1 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i == n || seq . charAt ( i ) == 'I' ) {\n      for ( int j = i - 1 ;\n      j >= - 1 ;\n      j -- ) {\n        result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ;\n        if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ;\n      }\n    }\n  }\n  return new String ( result ) ;\n}",
    "badcase": "static String getMinNumberForPattern ( String seq ) {\n    int n = seq . length ( ) ;\n    if ( n >= 9 ) return \"-1\" ;\n    char [ ] result = new char [ n + 1 ] ;\n    Arrays . fill ( result ,'#') ;\n    int count = 1 ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) {\n      if ( i == n result [ i ] =='I') {\n        for ( int j = i - 1 ;\n        j >= - 1 ;\n        j -- ) {\n          result [ j + 1 ] = ( char ) ('0'+ count ++ ) ;\n          if ( j >= 0 && result [ j ] =='I') break ;\n        }\n      }\n    }\n    return String . valueOf ( result ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n ) {\n  int a = 1 , b = 2 , c = 0 ;\n  if ( n <= 2 ) {\n    return n ;\n  }\n  for ( int i = 3 ;\n  i <= n ;\n  i ++ ) {\n    c = b + ( i - 1 ) * a ;\n    a = b ;\n    b = c ;\n  }\n  return c ;\n}",
    "badcase": "static int countFriendsPairings ( int n ) {\n  int a = 1 , b = 2 , c ;\n  if ( n <= 2 ) {\n    return n ;\n  }\n  for ( int i = 3 ;\n  i <= n ;\n  i ++ ) {\n    c = b + ( i - 1 ) * a ;\n    a = b ;\n    b = c ;\n  }\n  return c ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( String str ) {\n  int i , j , k , l = str . length ( ) ;\n  int arr [ ] = new int [ l ] ;\n  for ( i = 0 ;\n  i < l ;\n  i ++ ) {\n    for ( j = i ;\n    j < l ;\n    j ++ ) {\n      for ( k = j ;\n      k < l ;\n      k ++ ) {\n        if ( arr [ i ] % 8 == 0 ) return true ;\n        else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ;\n        else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ;\n      }\n    }\n  }\n  return false ;\n}",
    "badcase": "static boolean isSubSeqDivisible ( int [ ] arr , int l ) {\n    for ( int i = 0 ;\n    i < l ;\n    i ++ ) {\n      for ( int j = i ;\n      j < l ;\n      j ++ ) {\n        for ( int k = j ;\n        k < l ;\n        k ++ ) {\n          if ( arr [ i ] % 8 == 0 ) return true ;\n          else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ;\n          else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ;\n        }\n      }\n    }\n    return false ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( char X [ ] , char Y [ ] , int m , int n ) {\n  int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;\n  int result = 0 ;\n  for ( int i = 0 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= n ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ;\n      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {\n        LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ;\n        result = Integer . max ( result , LCStuff [ i ] [ j ] ) ;\n      }\n      else LCStuff [ i ] [ j ] = 0 ;\n    }\n  }\n  return result ;\n}",
    "badcase": "static int LCSubStr ( String X , String Y , int m , int n ) {\n    int LCSuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;\n    int result = 0 ;\n    for ( int i = 0 ;\n    i <= m ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j <= n ;\n      j ++ ) {\n        if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ;\n        else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {\n          LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ;\n          result = Math . max ( result , LCSuff [ i ] [ j ] ) ;\n        }\n        else LCSuff [ i ] [ j ] = 0 ;\n      }\n    }\n    return result ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static String f_gold ( String str ) {\n  int n = str . length ( ) ;\n  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) for ( int j = 0 ;\n  j <= n ;\n  j ++ ) dp [ i ] [ j ] = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) for ( int j = 1 ;\n  j <= n ;\n  j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;\n  else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;\n  String res = \"\" ;\n  int i = n , j = n ;\n  while ( i > 0 && j > 0 ) {\n    if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {\n      res = res + str . charAt ( i - 1 ) ;\n      i -- ;\n      j -- ;\n    }\n    else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;\n    else j -- ;\n  }\n  String reverse = \"\" ;\n  for ( int k = res . length ( ) - 1 ;\n  k >= 0 ;\n  k -- ) {\n    reverse = reverse + res . charAt ( k ) ;\n  }\n  return reverse ;\n}",
    "badcase": "static String longestRepeatedSubSeq ( String str ) {\n    int n = str . length ( ) ;\n    int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) for ( int j = 0 ;\n    j <= n ;\n    j ++ ) dp [ i ] [ j ] = 0 ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) for ( int j = 1 ;\n    j <= n ;\n    j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;\n    else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;\n    String res = \"\" ;\n    int i = n , j = n ;\n    while ( i > 0 && j > 0 ) {\n      if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {\n        res = res + str . charAt ( i - 1 ) ;\n        i -- ;\n        j -- ;\n      }\n      else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;\n      else j -- ;\n    }\n    res = reverse ( res ) ;\n    return res ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static String f_gold ( char [ ] in ) {\n  for ( int i = 0 ;\n  i < in . length ;\n  i ++ ) {\n    if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) {\n      in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ;\n    }\n  }\n  return String . valueOf ( in ) ;\n}",
    "badcase": "static String to_upper ( String in ) {\n  for ( int i = 0 ;\n  i < in . length ( ) ;\n  i ++ ) if ( 'a' <= in . charAt ( i ) && in . charAt ( i ) <= 'z' ) in = in . substring ( 0 , i ) + ( char ) ( in . charAt ( i ) -'a'+'A') + in . substring ( i + 1 ) ;\n  return in ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( double m [ ] [ ] ) {\n  for ( int i = 0 ;\n  i < m . length ;\n  i ++ ) {\n    double sum = 0 ;\n    for ( int j = 0 ;\n    j < m [ i ] . length ;\n    j ++ ) sum = sum + m [ i ] [ j ] ;\n    if ( sum != 1 ) return false ;\n  }\n  return true ;\n}",
    "badcase": "static boolean checkMarkov ( double m [ ] [ ] ) {\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    double sum = 0 ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) sum = sum + m [ i ] [ j ] ;\n    if ( sum != 1 ) return false ;\n  }\n  return true ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  if ( n < 4 ) {\n    System . out . println ( \"The array should have\" + \" atleast 4 elements\" ) ;\n  }\n  int table1 [ ] = new int [ n + 1 ] ;\n  int table2 [ ] = new int [ n ] ;\n  int table3 [ ] = new int [ n - 1 ] ;\n  int table4 [ ] = new int [ n - 2 ] ;\n  Arrays . fill ( table1 , Integer . MIN_VALUE ) ;\n  Arrays . fill ( table2 , Integer . MIN_VALUE ) ;\n  Arrays . fill ( table3 , Integer . MIN_VALUE ) ;\n  Arrays . fill ( table4 , Integer . MIN_VALUE ) ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ;\n  }\n  for ( int i = n - 2 ;\n  i >= 0 ;\n  i -- ) {\n    table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ;\n  }\n  for ( int i = n - 3 ;\n  i >= 0 ;\n  i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ;\n  for ( int i = n - 4 ;\n  i >= 0 ;\n  i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ;\n  return table4 [ 0 ] ;\n}",
    "badcase": "static int findMaxValue ( int arr [ ] , int n ) {\n    if ( n < 4 ) {\n      System . out . println ( \"The array should have atlest 4 elements\" ) ;\n      return Integer . MIN_VALUE ;\n    }\n    int [ ] table1 = new int [ n + 1 ] ;\n    int [ ] table2 = new int [ n ] ;\n    int [ ] table3 = new int [ n - 1 ] ;\n    int [ ] table4 = new int [ n - 2 ] ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4 [ i ] = Integer . MIN_VALUE ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ;\n    for ( int i = n - 2 ;\n    i >= 0 ;\n    i -- ) table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ;\n    for ( int i = n - 3 ;\n    i >= 0 ;\n    i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ;\n    for ( int i = n - 4 ;\n    i >= 0 ;\n    i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ;\n    return table4 [ 0 ] ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( Integer arr [ ] , int n ) {\n  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;\n  int [ ] dimension = {\n    0 , 0 };\n    for ( int i = 0 , j = 0 ;\n    i < n - 1 && j < 2 ;\n    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ;\n    return ( dimension [ 0 ] * dimension [ 1 ] ) ;\n  }",
    "badcase": "static int findArea ( int arr [ ] , int n ) {\n    Arrays . sort ( arr ) ;\n    int dimension [ ] = new int [ 2 ] ;\n    for ( int i = 0 , j = 0 ;\n    i < n - 1 && j < 2 ;\n    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ;\n    return ( dimension [ 0 ] * dimension [ 1 ] ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( String s , String t ) {\n  int count = 0 ;\n  for ( int i = 0 ;\n  i < t . length ( ) ;\n  i ++ ) {\n    if ( count == t . length ( ) ) break ;\n    if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ;\n  }\n  return count ;\n}",
    "badcase": "static int maxPrefix ( char s [ ] , char t [ ] ) {\n  int count = 0 ;\n  for ( int i = 0 ;\n  i < t . length ;\n  i ++ ) {\n    if ( count == s . length ) break ;\n    if ( t [ i ] == s [ count ] ) count ++ ;\n  }\n  return count ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int a [ ] , int n , int k ) {\n  int max_so_far = 0 ;\n  int INT_MIN , max_ending_here = 0 ;\n  for ( int i = 0 ;\n  i < n * k ;\n  i ++ ) {\n    max_ending_here = max_ending_here + a [ i % n ] ;\n    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;\n    if ( max_ending_here < 0 ) max_ending_here = 0 ;\n  }\n  return max_so_far ;\n}",
    "badcase": "static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {\n    int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ;\n    for ( int i = 0 ;\n    i < n * k ;\n    i ++ ) {\n      max_ending_here = max_ending_here + a [ i % n ] ;\n      if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;\n      if ( max_ending_here < 0 ) max_ending_here = 0 ;\n    }\n    return max_so_far ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static int f_gold ( int grid [ ] [ ] , int n ) {\n  int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;\n  int excl = 0 , excl_new ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    excl_new = Math . max ( excl , incl ) ;\n    incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ;\n    excl = excl_new ;\n  }\n  return Math . max ( excl , incl ) ;\n}",
    "badcase": "static int max ( int x , int y ) {\n    return ( x > y ) ? x : y ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n , int k ) {\n  Arrays . sort ( arr ) ;\n  int max = arr [ arr . length - 1 ] ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;\n    else res += ( max - arr [ i ] ) / k ;\n  }\n  return res ;\n}",
    "badcase": "static int minOps ( int arr [ ] , int n , int k ) {\n    int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;\n    int res = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;\n      else res += ( max - arr [ i ] ) / k ;\n    }\n    return res ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( String str ) {\n  String tmp = str + str ;\n  int n = str . length ( ) ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    String substring = tmp . substring ( i , str . length ( ) ) ;\n    if ( str == substring ) return i ;\n  }\n  return n ;\n}",
    "badcase": "static int findRotations ( String str ) {\n    String tmp = str + str ;\n    int n = str . length ( ) ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      String substring = tmp . substring ( i , i + n ) ;\n      if ( str . equals ( substring ) ) return i ;\n    }\n    return n ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int a [ ] , int b [ ] , int n , int k ) {\n  int diff = 0 , res = 0 ;\n  int temp = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int pro = a [ i ] * b [ i ] ;\n    res = res + pro ;\n    if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;\n    else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;\n    else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;\n    else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;\n    int d = Math . abs ( pro - temp ) ;\n    if ( d > diff ) diff = d ;\n  }\n  return res - diff ;\n}",
    "badcase": "static int minproduct ( int a [ ] , int b [ ] , int n , int k ) {\n    int diff = 0 , res = 0 ;\n    int temp ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int pro = a [ i ] * b [ i ] ;\n      res = res + pro ;\n      if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;\n      else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;\n      else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;\n      else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;\n      int d = Math . abs ( pro - temp ) ;\n      if ( d > diff ) diff = d ;\n    }\n    return res - diff ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  int [ ] dp = new int [ n ] ;\n  if ( n == 1 ) return arr [ 0 ] ;\n  if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ;\n  if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ;\n  if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ;\n  dp [ 0 ] = arr [ 0 ] ;\n  dp [ 1 ] = arr [ 1 ] ;\n  dp [ 2 ] = arr [ 2 ] ;\n  dp [ 3 ] = arr [ 3 ] ;\n  for ( int i = 4 ;\n  i < n ;\n  i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ;\n  return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ;\n}",
    "badcase": "static int min ( int a , int b ) {\n    return ( a < b ) ? a : b ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int x , int y ) {\n  if ( y == 0 ) return 0 ;\n  if ( y > 0 ) return ( x + f_gold ( x , y - 1 ) ) ;\n  if ( y < 0 ) return - f_gold ( x , - y ) ;\n  return - 1 ;\n}",
    "badcase": "static int multiply ( int x , int y ) {\n    if ( y == 0 ) return 0 ;\n    if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;\n    if ( y < 0 ) return - multiply ( x , - y ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int x ) {\n  int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ;\n  if ( x > 0 ) {\n    rightOne = x & - x ;\n    nextHigherOneBit = x + rightOne ;\n    rightOnesPattern = x ^ nextHigherOneBit ;\n    rightOnesPattern = ( rightOnesPattern ) / rightOne ;\n    rightOnesPattern >>= 2 ;\n    next = nextHigherOneBit | rightOnesPattern ;\n  }\n  return next ;\n}",
    "badcase": "static int snoob ( int x ) {\n  int rightOne ;\n  int nextHigherOneBit ;\n  int rightOnesPattern ;\n  int next = 0 ;\n  if ( x != 0 ) {\n    rightOne = x & - x ;\n    nextHigherOneBit = x + rightOne ;\n    rightOnesPattern = x ^ nextHigherOneBit ;\n    rightOnesPattern = ( rightOnesPattern ) / rightOne ;\n    rightOnesPattern >>= 2 ;\n    next = nextHigherOneBit ;\n  }\n  return next ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static int f_gold ( int k , int n ) {\n  long f1 = 0 , f2 = 1 , f3 ;\n  int i = 2 ;\n  while ( i != 0 ) {\n    f3 = f1 + f2 ;\n    f1 = f2 ;\n    f2 = f3 ;\n    if ( f2 % k == 0 ) {\n      return n * i ;\n    }\n    i ++ ;\n  }\n  return 0 ;\n}",
    "badcase": "static int findPosition ( int k , int n ) {\n    int f1 = 0 , f2 = 1 , f3 ;\n    for ( int i = 2 ;\n    i <= MAX ;\n    i ++ ) {\n      f3 = f1 + f2 ;\n      f1 = f2 ;\n      f2 = f3 ;\n      if ( f2 % k == 0 ) return n * i ;\n    }\n    return - 1 ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( long n ) {\n  while ( n / 100 > 0 ) {\n    int last_digit = ( int ) n % 10 ;\n    n /= 10 ;\n    n += last_digit * 3 ;\n  }\n  return ( n % 29 == 0 ) ;\n}",
    "badcase": "static boolean isDivisible ( long n ) {\n    while ( n / 100 > 0 ) {\n      int last_digit = ( int ) ( n % 10 ) ;\n      n /= 10 ;\n      n += last_digit * 3 ;\n    }\n    return ( n % 29 == 0 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static long f_gold ( int n ) {\n  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;\n  if ( n == 1 ) return 10 ;\n  for ( int j = 0 ;\n  j <= 9 ;\n  j ++ ) dp [ 1 ] [ j ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= 9 ;\n    j ++ ) {\n      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ;\n    }\n  }\n  long sum = 0 ;\n  for ( int j = 1 ;\n  j <= 9 ;\n  j ++ ) sum += dp [ n ] [ j ] ;\n  return sum ;\n}",
    "badcase": "static int answer ( int n ) {\n    int [ ] [ ] dp = new int [ n + 1 ] [ 10 ] ;\n    if ( n == 1 ) return 10 ;\n    for ( int j = 0 ;\n    j <= 9 ;\n    j ++ ) dp [ 1 ] [ j ] = 1 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j <= 9 ;\n      j ++ ) {\n        if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n        else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;\n        else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ;\n      }\n    }\n    int sum = 0 ;\n    for ( int j = 1 ;\n    j <= 9 ;\n    j ++ ) sum += dp [ n ] [ j ] ;\n    return sum ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static double f_gold ( int A , int N ) {\n  double xPre = Math . random ( ) % 10 ;\n  double eps = 0.001 ;\n  double delX = 2147483647 ;\n  double xK = 0.0 ;\n  while ( delX > eps ) {\n    xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ;\n    delX = Math . abs ( xK - xPre ) ;\n    xPre = xK ;\n  }\n  return xK ;\n}",
    "badcase": "static double nthRoot ( int A , int N ) {\n    double xPre = ( double ) ( Math . random ( ) % 10 ) ;\n    double eps = ( double ) ( 1e - 3 ) ;\n    double delX = Double . MAX_VALUE ;\n    double xK ;\n    while ( delX > eps ) {\n      xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ;\n      delX = Math . abs ( xK - xPre ) ;\n      xPre = xK ;\n    }\n    return xK ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static boolean f_gold ( String str ) {\n  boolean [ ] mark = new boolean [ 26 ] ;\n  int index = 0 ;\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A' ;\n    else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a' ;\n    mark [ index ] = true ;\n  }\n  for ( int i = 0 ;\n  i <= 25 ;\n  i ++ ) if ( mark [ i ] == false ) return ( false ) ;\n  return ( true ) ;\n}",
    "badcase": "static boolean checkPangram ( String str ) {\n    boolean [ ] mark = new boolean [ 26 ] ;\n    int index ;\n    for ( int i = 0 ;\n    i < str . length ( ) ;\n    i ++ ) {\n      if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) -'A';\n      else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) -'a';\n      mark [ index ] = true ;\n    }\n    for ( int i = 0 ;\n    i <= 25 ;\n    i ++ ) if ( mark [ i ] == false ) return false ;\n    return true ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int arr [ ] , int N , int k ) {\n  int M , S = 0 , S1 = 0 , max_difference = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) S += arr [ i ] ;\n  int temp ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < N ;\n    j ++ ) {\n      if ( arr [ i ] < arr [ j ] ) {\n        temp = arr [ i ] ;\n        arr [ i ] = arr [ j ] ;\n        arr [ j ] = temp ;\n      }\n    }\n  }\n  M = Math . max ( k , N - k ) ;\n  for ( int i = 0 ;\n  i < M ;\n  i ++ ) S1 += arr [ i ] ;\n  max_difference = S1 - ( S - S1 ) ;\n  return max_difference ;\n}",
    "badcase": "static int maxDifference ( int arr [ ] , int N , int k ) {\n    int M , S = 0 , S1 = 0 , max_difference = 0 ;\n    for ( int i = 0 ;\n    i < N ;\n    i ++ ) S += arr [ i ] ;\n    Arrays . sort ( arr ) ;\n    M = Math . max ( k , N - k ) ;\n    for ( int i = 0 ;\n    i < M ;\n    i ++ ) S1 += arr [ i ] ;\n    max_difference = S1 - ( S - S1 ) ;\n    return max_difference ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int a [ ] , int b [ ] , int n , int k ) {\n        Arrays . sort ( a ) ;\n        Arrays . sort ( b ) ;\n        for ( int i = 0 ;\n        i < n ;\n        i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;\n        return true ;\n      }",
    "badcase": "static boolean isPossible ( int a [ ] , int b [ ] , int n , int k ) {\n    Arrays . sort ( a ) ;\n    Integer [ ] b1 = new Integer [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) b1 [ i ] = b [ i ] ;\n    Arrays . sort ( b1 , Collections . reverseOrder ( ) ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) if ( a [ i ] + b1 [ i ] < k ) return false ;\n    return true ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static void f_gold ( int a [ ] , int size ) {\n  int positive = 0 , negative = 1 , temp ;\n  while ( true ) {\n    while ( positive < size && a [ positive ] >= 0 ) positive += 2 ;\n    while ( negative < size && a [ negative ] <= 0 ) negative += 2 ;\n    if ( positive < size && negative < size ) {\n      temp = a [ positive ] ;\n      a [ positive ] = a [ negative ] ;\n      a [ negative ] = temp ;\n    }\n    else break ;\n  }\n}",
    "badcase": "static void rearrange ( int a [ ] , int size ) {\n  int positive = 0 , negative = 1 ;\n  while ( true ) {\n    while ( positive < size && a [ positive ] >= 0 ) positive += 2 ;\n    while ( negative < size && a [ negative ] <= 0 ) negative += 2 ;\n    if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ;\n    else break ;\n  }\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  if ( n <= 1 ) return false ;\n  if ( n <= 3 ) return true ;\n  if ( n % 2 == 0 || n % 3 == 0 ) return false ;\n  for ( int i = 5 ;\n  i * i <= n ;\n  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;\n  return true ;\n}",
    "badcase": "static boolean isPrime ( int n ) {\n    if ( n <= 1 ) return false ;\n    if ( n <= 3 ) return true ;\n    if ( n % 2 == 0 n % 3 == 0 ) return false ;\n    for ( int i = 5 ;\n    i * i <= n ;\n    i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;\n    return true ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static boolean f_gold ( int p ) {\n  double checkNumber = Math . pow ( 2 , p ) - 1 ;\n  double nextval = 4 % checkNumber ;\n  for ( int i = 1 ;\n  i < p - 1 ;\n  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;\n  return ( nextval == 0 ) ;\n}",
    "badcase": "static boolean isPrime ( int p ) {\n    long checkNumber = ( long ) Math . pow ( 2 , p ) - 1 ;\n    long nextval = 4 % checkNumber ;\n    for ( int i = 1 ;\n    i < p - 1 ;\n    i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;\n    return ( nextval == 0 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static String f_gold ( String s1 ) {\n  int n = s1 . length ( ) ;\n  char [ ] s = s1 . toCharArray ( ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == s [ i - 1 ] ) {\n      s [ i ] = 'a' ;\n      while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ;\n      i ++ ;\n    }\n  }\n  return ( new String ( s ) ) ;\n}",
    "badcase": "static String noAdjacentDup ( String s ) {\n  int n = s . length ( ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) {\n      s = s . substring ( 0 , i ) +'a'+ s . substring ( i + 1 ) ;\n      i ++ ;\n      while ( i + 1 < n && s . charAt ( i ) == s . charAt ( i + 1 ) ) {\n        s = s . substring ( 0 , i ) + ( char ) ( s . charAt ( i ) + 1 ) + s . substring ( i + 1 ) ;\n      }\n    }\n  }\n  return s ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static double f_gold ( double lat1 , double lat2 , double lon1 , double lon2 ) {\n  lon1 = Math . toRadians ( lon1 ) ;\n  lon2 = Math . toRadians ( lon2 ) ;\n  lat1 = Math . toRadians ( lat1 ) ;\n  lat2 = Math . toRadians ( lat2 ) ;\n  double dlon = lon2 - lon1 ;\n  double dlat = lat2 - lat1 ;\n  double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ;\n  double c = 2 * Math . asin ( Math . sqrt ( a ) ) ;\n  double r = 6371 ;\n  return ( c * r ) ;\n}",
    "badcase": "static double distance ( double lat1 , double long1 , double lat2 , double long2 ) {\n    lat1 = toRadians ( lat1 ) ;\n    long1 = toRadians ( long1 ) ;\n    lat2 = toRadians ( lat2 ) ;\n    long2 = toRadians ( long2 ) ;\n    double dlong = long2 - long1 ;\n    double dlat = lat2 - lat1 ;\n    double ans = pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ) , 2 ) ;\n    ans = 2 * asin ( sqrt ( ans ) ) ;\n    double R = 6371 ;\n    ans = ans * R ;\n    return ans ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static double f_gold ( double r ) {\n  double PI = 3.1415 ;\n  double cir = 2 * PI * r ;\n  return cir ;\n}",
    "badcase": "static double circumference ( double r ) {\n  double cir = 2 * PI * r ;\n  return cir ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static double f_gold ( double side ) {\n  return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;\n}",
    "badcase": "static double surface_area_octahedron ( double side ) {\n    return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( long n ) {\n  return ( int ) Math . pow ( n , 2 ) ;\n}",
    "badcase": "static int summingSeries ( int n ) {\n    return ( int ) Math . pow ( n , 2 ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static void f_gold ( int arr [ ] , int n ) {\n  int i = - 1 , temp = 0 ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    if ( arr [ j ] < 0 ) {\n      i ++ ;\n      temp = arr [ i ] ;\n      arr [ i ] = arr [ j ] ;\n      arr [ j ] = temp ;\n    }\n  }\n  int pos = i + 1 , neg = 0 ;\n  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {\n    temp = arr [ neg ] ;\n    arr [ neg ] = arr [ pos ] ;\n    arr [ pos ] = temp ;\n    pos ++ ;\n    neg += 2 ;\n  }\n}",
    "badcase": "static void rearrange ( int arr [ ] , int n ) {\n  int i = - 1 ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    if ( arr [ j ] < 0 ) {\n      i ++ ;\n      swap ( arr , i , j ) ;\n    }\n  }\n  int pos = i + 1 , neg = 0 ;\n  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {\n    swap ( arr , neg , pos ) ;\n    pos ++ ;\n    neg += 2 ;\n  }\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) {\n  if ( low == high ) {\n    return a [ low ] * turn ;\n  }\n  if ( dp [ low ] [ high ] != 0 ) {\n    return dp [ low ] [ high ] ;\n  }\n  dp [ low ] [ high ] = Math . max ( a [ low ] * turn + f_gold ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + f_gold ( dp , a , low , high - 1 , turn + 1 ) ) ;\n  return dp [ low ] [ high ] ;\n}",
    "badcase": "static int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int high , int turn ) {\n  if ( low == high ) return a [ low ] * turn ;\n  if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ;\n  dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ;\n  return dp [ low ] [ high ] ;\n}"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int x , int y , int z ) {\n  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;\n  return ( ( x / z ) != 1 ) ? x : z ;\n}",
    "badcase": "static int smallest ( int x , int y , int z ) {\n    if ( y % x != 0 ) return ( y % z != 0 ) ? y : z ;\n    return ( x % z != 0 ) ? x : z ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static void f_gold ( int arr [ ] , int n ) {\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;\n  Arrays . sort ( arr ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;\n}",
    "badcase": "static void twoWaySort ( int arr [ ] , int n ) {\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) if ( arr [ i ] % 2 == 1 ) arr [ i ] *= - 1 ;\n    Arrays . sort ( arr ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) if ( arr [ i ] % 2 == 1 ) arr [ i ] *= - 1 ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static void f_gold ( int arr [ ] , int n , int k ) {\n  for ( int i = 0 ;\n  i < k ;\n  i ++ ) {\n    int x = arr [ 0 ] ;\n    for ( int j = 0 ;\n    j < n - 1 ;\n    ++ j ) arr [ j ] = arr [ j + 1 ] ;\n    arr [ n - 1 ] = x ;\n  }\n}",
    "badcase": "static void bitonicGenerator ( int arr [ ] , int n ) {\n    Vector < Integer > evenArr = new Vector < Integer > ( ) ;\n    Vector < Integer > oddArr = new Vector < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( i % 2 == 0 ) evenArr . add ( arr [ i ] ) ;\n      else oddArr . add ( arr [ i ] ) ;\n    }\n    Collections . sort ( evenArr ) ;\n    Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ;\n    int i = 0 ;\n    for ( int j = 0 ;\n    j < evenArr . size ( ) ;\n    j ++ ) arr [ i ++ ] = evenArr . get ( j ) ;\n    for ( int j = 0 ;\n    j < oddArr . size ( ) ;\n    j ++ ) arr [ i ++ ] = oddArr . get ( j ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static String f_gold ( String str ) {\n  String result = \"\" ;\n  boolean v = true ;\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( str . charAt ( i ) == ' ' ) {\n      v = true ;\n    }\n    else if ( str . charAt ( i ) != ' ' && v == true ) {\n      result += ( str . charAt ( i ) ) ;\n      v = false ;\n    }\n  }\n  return result ;\n}",
    "badcase": "static String firstLetterWord ( String str ) {\n    String result = \"\" ;\n    boolean v = true ;\n    for ( int i = 0 ;\n    i < str . length ( ) ;\n    i ++ ) {\n      if ( str . charAt ( i ) =='â–') v = true ;\n      else if ( str . charAt ( i ) !='â–'&& v == true ) {\n        result = result + str . charAt ( i ) ;\n        v = false ;\n      }\n    }\n    return result ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "public static int f_gold ( int [ ] arr , int n ) {\n  Set < Integer > s = new HashSet < > ( ) ;\n  int j = 0 , ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( j < n && ! s . contains ( arr [ j ] ) ) {\n      s . add ( arr [ i ] ) ;\n      j ++ ;\n    }\n    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;\n    s . remove ( arr [ i ] ) ;\n  }\n  return ans ;\n}",
    "badcase": "static int sumoflength ( int arr [ ] , int n ) {\n    HashSet < Integer > s = new HashSet < Integer > ( ) ;\n    int j = 0 , ans = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      while ( j < n && ! s . contains ( arr [ j ] ) ) {\n        s . add ( arr [ j ] ) ;\n        j ++ ;\n      }\n      ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;\n      s . remove ( arr [ i ] ) ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int [ ] a , int n ) {\n  Arrays . sort ( a ) ;\n  int sum = 0 ;\n  boolean flag = false ;\n  int len = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) {\n      flag = true ;\n      len = a [ i + 1 ] ;\n      i ++ ;\n    }\n    else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) {\n      sum = sum + a [ i + 1 ] * len ;\n      flag = false ;\n      i ++ ;\n    }\n  }\n  return sum ;\n}",
    "badcase": "static int MaxTotalRectangleArea ( int a [ ] , int n ) {\n    Arrays . sort ( a ) ;\n    int sum = 0 ;\n    boolean flag = false ;\n    int len ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      if ( ( a [ i ] == a [ i - 1 ] || a [ i ] - a [ i - 1 ] == 1 ) && ( ! flag ) ) {\n        flag = true ;\n        len = a [ i - 1 ] ;\n        i -- ;\n      }\n      else if ( ( a [ i ] == a [ i - 1 ] || a [ i ] - a [ i - 1 ] == 1 ) && ( flag ) ) {\n        sum = sum + a [ i - 1 ] * len ;\n        flag = false ;\n        i -- ;\n      }\n    }\n    return sum ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static double f_gold ( int n ) {\n  return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ;\n}",
    "badcase": "static float sumOfSeries ( int n ) {\n    return ( float ) ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static String f_gold ( String str1 , String str2 ) {\n  if ( str1 . length ( ) > str2 . length ( ) ) {\n    String t = str1 ;\n    str1 = str2 ;\n    str2 = t ;\n  }\n  String str = \"\" ;\n  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;\n  str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ;\n  str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ;\n  int carry = 0 ;\n  for ( int i = 0 ;\n  i < n1 ;\n  i ++ ) {\n    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;\n    str += ( char ) ( sum % 10 + '0' ) ;\n    carry = sum / 10 ;\n  }\n  for ( int i = n1 ;\n  i < n2 ;\n  i ++ ) {\n    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;\n    str += ( char ) ( sum % 10 + '0' ) ;\n    carry = sum / 10 ;\n  }\n  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;\n  str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ;\n  return str ;\n}",
    "badcase": "static String findSum ( String str1 , String str2 ) {\n    if ( str1 . length ( ) > str2 . length ( ) ) {\n      String t = str1 ;\n      str1 = str2 ;\n      str2 = t ;\n    }\n    String str = \"\" ;\n    int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;\n    str1 = reverse ( str1 ) ;\n    str2 = reverse ( str2 ) ;\n    int carry = 0 ;\n    for ( int i = 0 ;\n    i < n1 ;\n    i ++ ) {\n      int sum = ( ( str1 . charAt ( i ) -'0') + ( str2 . charAt ( i ) -'0') + carry ) ;\n      str += ( char ) ( sum % 10 +'0') ;\n      carry = sum / 10 ;\n    }\n    for ( int i = n1 ;\n    i < n2 ;\n    i ++ ) {\n      int sum = ( ( str2 . charAt ( i ) -'0') + carry ) ;\n      str += ( char ) ( sum % 10 +'0') ;\n      carry = sum / 10 ;\n    }\n    if ( carry > 0 ) str += ( char ) ( carry +'0') ;\n    return reverse ( str ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int x , int p1 , int p2 , int n ) {\n  int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;\n  int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;\n  int xor = ( set1 ^ set2 ) ;\n  xor = ( xor << p1 ) | ( xor << p2 ) ;\n  int result = x ^ xor ;\n  return result ;\n}",
    "badcase": "static int swapBits ( int x , int p1 , int p2 , int n ) {\n    int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;\n    int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;\n    int Xor = ( set1 ^ set2 ) ;\n    Xor = ( Xor << p1 ) ;\n    return ( x ^ Xor ) ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static void f_gold ( int [ ] xp , int [ ] yp ) {\n  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;\n  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;\n  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;\n}",
    "badcase": "swap(filled_function_param0.get(i),filled_function_param1.get(i));\n        f_gold(param0.get(i),param1.get(i));\n        if(Arrays.equals(param0.get(i), filled_function_param0.get(i)) && Arrays.equals(param1.get(i), filled_function_param1.get(i)))\n        {\n            n_success+=1;\n        }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int mat [ ] [ ] , int n , int m ) {\n  int [ ] rowsum = new int [ n ] ;\n  int [ ] colsum = new int [ m ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < m ;\n  j ++ ) if ( mat [ i ] [ j ] != 0 ) {\n    rowsum [ i ] ++ ;\n    colsum [ j ] ++ ;\n  }\n  int uniquecount = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < m ;\n  j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ;\n  return uniquecount ;\n}",
    "badcase": "static int countUnique ( int mat [ ] [ ] , int n , int m ) {\n    int rowsum [ ] = new int [ n ] ;\n    int colsum [ ] = new int [ m ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) rowsum [ i ] = 0 ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) colsum [ j ] = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) for ( int j = 0 ;\n    j < m ;\n    j ++ ) if ( mat [ i ] [ j ] == 1 ) {\n      rowsum [ i ] ++ ;\n      colsum [ j ] ++ ;\n    }\n    int uniquecount = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) for ( int j = 0 ;\n    j < m ;\n    j ++ ) if ( mat [ i ] [ j ] == 1 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ;\n    return uniquecount ;\n  }"
  },
  {
    "type": "cpp_to_java",
    "GT": "static int f_gold ( int n ) {\n  int odd_count = 0 ;\n  int even_count = 0 ;\n  if ( n < 0 ) n = - n ;\n  if ( n == 0 ) return 1 ;\n  if ( n == 1 ) return 0 ;\n  while ( n != 0 ) {\n    if ( ( n & 1 ) != 0 ) odd_count ++ ;\n    if ( ( n & 2 ) != 0 ) even_count ++ ;\n    n = n >> 2 ;\n  }\n  return f_gold ( Math . abs ( odd_count - even_count ) ) ;\n}",
    "badcase": "static int isMultipleOf3 ( int n ) {\n    int odd_count = 0 ;\n    int even_count = 0 ;\n    if ( n < 0 ) n = - n ;\n    if ( n == 0 ) return 1 ;\n    if ( n == 1 ) return 0 ;\n    while ( n > 0 ) {\n      if ( n % 2 != 0 ) odd_count ++ ;\n      if ( n % 4 == 0 ) even_count ++ ;\n      n = n >> 2 ;\n    }\n    return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ;\n  }"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( text , s ) :\n    result = \"\"\n    for i in range ( len ( text ) ) :\n        char = text [ i ]\n        if ( char.isupper ( ) ) :\n            result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 )\n        else :\n            result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 )\n    return result",
    "badcase": "def encrypt ( text , s ) :\n    result = \"\"\n    for i in range ( len ( text ) ) :\n        if ( text [ i ].isupper ( ) ) :\n            result += chr ( int ( text [ i ] ) + s - 65 ) % 26 + 65\n        else :\n            result += chr ( int ( text [ i ] ) + s - 97 ) % 26 + 97\n    return result"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( h , m ) :\n    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :\n        print ( 'Wrong input' )\n    if ( h == 12 ) :\n        h = 0\n    if ( m == 60 ) :\n        m = 0\n    hour_angle = 0.5 * ( h * 60 + m )\n    minute_angle = 6 * m\n    angle = abs ( hour_angle - minute_angle )\n    angle = min ( 360 - angle , angle )\n    return angle",
    "badcase": "def calcAngle ( h , m ) :\n    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :\n        print ( \"Wrong input\" )\n    if ( h == 12 ) :\n        h = 0\n    if ( m == 60 ) :\n        m = 0\n    hour_angle = 0.5 * ( h * 60 + m )\n    minute_angle = 6 * m\n    angle = abs ( hour_angle - minute_angle )\n    angle = min ( 360 - angle , angle )\n    return int ( angle )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    i = 0\n    j = n - 1\n    while i < n :\n        if ( i < n // 2 ) :\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        elif ( i > n // 2 ) :\n            diag1_right += mat [ i ] [ i ]\n            diag2_right += mat [ j ] [ i ]\n        i += 1\n        j -= 1\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )",
    "badcase": "def HalfDiagonalSums ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    for i in range ( n ) :\n        j = n - i - 1\n        if ( i < n / 2 ) :\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        elif ( i > n / 2 ) :\n            diag1_right += mat [ i ] [ i ]\n            diag2_right += mat [ j ] [ i ]\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    if ( n < 1 ) :\n        return False\n    Min = min ( arr )\n    Max = max ( arr )\n    if ( Max - Min + 1 == n ) :\n        visited = [ False for i in range ( n ) ]\n        for i in range ( n ) :\n            if ( visited [ arr [ i ] - Min ] != False ) :\n                return False\n            visited [ arr [ i ] - Min ] = True\n        return True\n    return False",
    "badcase": "def areConsecutive ( arr , n ) :\n    if ( n < 1 ) :\n        return False\n    min = getMin ( arr , n )\n    max = getMax ( arr , n )\n    if ( max - min + 1 == n ) :\n        visited = [ False ] * ( n )\n        for i in range ( n ) :\n            if ( visited [ arr [ i ] - min ] != False ) :\n                return False\n            visited [ arr [ i ] - min ] = True\n        return True\n    return False"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( x , y ) :\n    res1 = math.log ( y ) / math.log ( x ) ;\n    res2 = math.log ( y ) / math.log ( x ) ;\n    return 1 if ( res1 == res2 ) else 0 ;\n\n\nimport math",
    "badcase": "def isPower ( x , y ) :\n    res1 = int ( math.log ( y ) / math.log ( x ) )\n    res2 = math.log ( y ) / math.log ( x )\n    return ( res1 == res2 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a * b\n    if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :\n        result = 0\n    if ( a == ( result // b ) ) :\n        print ( result // b )\n        return False\n    else :\n        return True",
    "badcase": "def isOverflow ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a * b\n    if ( a == result // b ) :\n        return False\n    else :\n        return True"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )",
    "badcase": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num += \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num += \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    i = length - 1\n    while ( i >= 0 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    for i in range ( 1 , n ) :\n        if arr [ i - 1 ] < arr [ i ] :\n            if ( i == n ) :\n                return True\n    j = i\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j += 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k += 1\n    return True",
    "badcase": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    while ( i < n and arr [ i - 1 ] < arr [ i ] ) :\n        i += 1\n    if ( i == n ) :\n        return True\n    j = i\n    while ( j < n ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j += 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k += 1\n    return True"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , b ) :\n    return floor ( ( a + b ) / 2 )",
    "badcase": "def compute_average ( a , b ) :\n    return ( a + b ) / 2"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( string , l ) :\n    string = list ( string )\n    i = - 1\n    j = l\n    while i < j :\n        i += 1\n        j -= 1\n        if ( string [ i ] == string [ j ] and string [ i ] != '*' ) :\n            continue\n        elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) :\n            string [ i ] = 'a'\n            string [ j ] = 'a'\n            continue\n        elif string [ i ] == '*' :\n            string [ i ] = string [ j ]\n            continue\n        elif string [ j ] == '*' :\n            string [ j ] = string [ i ]\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return ''.join ( string )",
    "badcase": "def constructPalin ( str , len ) :\n    i = 0\n    j = len - 1\n    while ( i < j ) :\n        if ( str [ i ] == str [ j ] and str [ i ] != '*' ) :\n            i += 1\n            j -= 1\n            continue\n        elif ( str [ i ] == str [ j ] and str [ i ] == '*' ) :\n            str [ i ] = 'a'\n            str [ j ] = 'a'\n            i += 1\n            j -= 1\n            continue\n        elif ( str [ i ] == '*' ) :\n            str [ i ] = str [ j ]\n            i += 1\n            continue\n        elif ( str [ j ] == '*' ) :\n            str [ j ] = str [ i ]\n            j -= 1\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return str"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n , k , x ) :\n    dp = list ( )\n    dp.append ( 0 )\n    dp.append ( 1 )\n    i = 2\n    while i < n :\n        dp.append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] )\n        i = i + 1\n    return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] )",
    "badcase": "def countarray ( n , k , x ) :\n    dp = [ 0 ] * ( MAXN )\n    dp [ 0 ] = 0\n    dp [ 1 ] = 1\n    for i in range ( 2 , n ) :\n        dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ]\n    if ( x == 1 ) :\n        return ( k - 1 ) * dp [ n - 2 ]\n    else :\n        return dp [ n - 1 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( h ) :\n    MOD = 1000000007\n    dp = [ 0 for i in range ( h + 1 ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 1\n    for i in range ( 2 , h + 1 ) :\n        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD\n    return dp [ h ]",
    "badcase": "def countBT ( h ) :\n    dp = [ 0 for i in range ( h + 1 ) ]\n    dp [ 0 ] , dp [ 1 ] = 1 , 1\n    for i in range ( 2 , h + 1 ) :\n        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod\n    return dp [ h ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( k + 1 ) :\n            dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n            if j >= 1 :\n                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]",
    "badcase": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for i in range ( k + 1 ) ] for i in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( i ) :\n            dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n            if ( j - 1 >= 0 ) :\n                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    nCr = 1\n    res = 1\n    for r in range ( 1 , n + 1 ) :\n        nCr = ( nCr * ( n + 1 - r ) ) / r ;\n        res += nCr * nCr ;\n    return res ;",
    "badcase": "def countSeq ( n ) :\n    nCr = 1\n    res = 1\n    for r in range ( 1 , n + 1 ) :\n        nCr = ( nCr * ( n + 1 - r ) ) // r\n        res += nCr * nCr\n    return res"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n , r , b , g ) :\n    fact = [ 0 for i in range ( n + 1 ) ]\n    fact [ 0 ] = 1\n    for i in range ( 1 , n + 1 , 1 ) :\n        fact [ i ] = fact [ i - 1 ] * i\n    left = n - ( r + g + b )\n    sum = 0\n    for i in range ( 0 , left + 1 , 1 ) :\n        for j in range ( 0 , left - i + 1 , 1 ) :\n            k = left - ( i + j )\n            sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) )\n    return sum",
    "badcase": "def possibleStrings ( n , r , b , g ) :\n    fact = [ 0 ] * ( n + 1 )\n    fact [ 0 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        fact [ i ] = fact [ i - 1 ] * i\n    left = n - ( r + g + b )\n    sum = 0\n    for i in range ( left + 1 ) :\n        for j in range ( left - i + 1 ) :\n            k = left - ( i + j )\n            sum = sum + fact [ n ] // ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] )\n    return sum"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        dp [ i ] [ 0 ] = 0\n    for i in range ( k + 1 ) :\n        dp [ 0 ] [ k ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , k + 1 ) :\n            if ( j == 1 or i == j ) :\n                dp [ i ] [ j ] = 1\n            else :\n                dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] )\n    return dp [ n ] [ k ]",
    "badcase": "def countP ( n , k ) :\n    dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        dp [ i ] [ 0 ] = 0\n    for i in range ( k + 1 ) :\n        dp [ 0 ] [ i ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            if ( j == 1 or i == j ) :\n                dp [ i ] [ j ] = 1\n            else :\n                dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ]\n    return dp [ n ] [ k ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold(n):\n    k = n\n    imin = 1\n    ans = 0\n    while (imin <= n):\n        imax = n / k\n        ans += k * (imax - imin + 1)\n        imin = imax + 1\n        k = n / imin\n    return ans",
    "badcase": "def CountPairs ( n ) :\n    k = n\n    imin = 1\n    ans = 0\n    while ( imin <= n ) :\n        imax = n // k\n        ans += k * ( imax - imin + 1 )\n        imin = imax + 1\n        k = n // imin\n    return ans"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( digits , n ) :\n    count = [ 0 ] * ( n + 1 ) ;\n    count [ 0 ] = 1 ;\n    count [ 1 ] = 1 ;\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0 ;\n        if ( digits [ i - 1 ] > '0' ) :\n            count [ i ] = count [ i - 1 ] ;\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] += count [ i - 2 ] ;\n    return count [ n ] ;",
    "badcase": "def countDecodingDP ( digits , n ) :\n    count = [ 0 for i in range ( n + 1 ) ]\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if ( digits [ 0 ] == '0' ) :\n        return 0\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0\n        if ( digits [ i - 1 ] > '0' ) :\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] += count [ i - 2 ]\n    return count [ n ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( p , q ) :\n    dp = [ 1 for i in range ( q ) ]\n    for i in range ( p - 1 ) :\n        for j in range ( 1 , q ) :\n            dp [ j ] += dp [ j - 1 ]\n    return dp [ q - 1 ]",
    "badcase": "def numberOfPaths ( m , n ) :\n    dp = [ 1 for i in range ( n ) ]\n    dp [ 0 ] = 1\n    for i in range ( m ) :\n        for j in range ( 1 , n ) :\n            dp [ j ] += dp [ j - 1 ]\n    return dp [ n - 1 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( mat , r , c ) :\n    result = 0\n    for i in range ( r ) :\n        j = 0\n        for j in range ( c - 1 ) :\n            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :\n                break\n        if j == c - 2 :\n            result += 1\n    for i in range ( 0 , r ) :\n        j = 0\n        for j in range ( c - 1 , 0 , - 1 ) :\n            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :\n                break\n        if c > 1 and j == 1 :\n            result += 1\n    return result",
    "badcase": "def sortedCount ( mat , r , c ) :\n    result = 0\n    for i in range ( r ) :\n        j = 0\n        while ( j < c - 1 ) :\n            if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) :\n                break\n            j += 1\n        if ( j == c - 1 ) :\n            result += 1\n    for i in range ( r ) :\n        j = c - 1\n        while ( j > 0 ) :\n            if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) :\n                break\n            j -= 1\n        if ( c > 1 and j == 0 ) :\n            result += 1\n    return result"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    max = 0\n    msis = [ 0 for x in range ( n ) ]\n    for i in range ( n ) :\n        msis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :\n                msis [ i ] = msis [ j ] + arr [ i ]\n    for i in range ( n ) :\n        if max < msis [ i ] :\n            max = msis [ i ]\n    return max",
    "badcase": "def maxSumIS ( arr , n ) :\n    msis = [ 0 ] * n\n    for i in range ( n ) :\n        msis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :\n                msis [ i ] = msis [ j ] + arr [ i ]\n    for i in range ( n ) :\n        if max < msis [ i ] :\n            max = msis [ i ]\n    return max"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    for i in range ( n ) :\n        P [ i ] [ i ] = True ;\n        C [ i ] [ i ] = 0 ;\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L - 1\n            if L == 2 :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            if P [ i ] [ j ] == True :\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = 100000000\n                for k in range ( i , j ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n    return C [ 0 ] [ n - 1 ]",
    "badcase": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L - 1\n            if ( L == 2 ) :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ]\n            if ( P [ i ] [ j ] == True ) :\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = float ( 'inf' )\n                for k in range ( i , j - 1 ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n    return C [ 0 ] [ n - 1 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( str , l , h ) :\n    if ( l > h ) :\n        return sys.maxsize\n    if ( l == h ) :\n        return 0\n    if ( l == h - 1 ) :\n        return 0 if ( str [ l ] == str [ h ] ) else 1\n    if ( str [ l ] == str [ h ] ) :\n        return f_gold ( str , l + 1 , h - 1 )\n    else :\n        return ( min ( f_gold ( str , l , h - 1 ) , f_gold ( str , l + 1 , h ) ) + 1 )",
    "badcase": "def findMinInsertions ( str , l , h ) :\n    if ( l > h ) :\n        return float ( 'inf' )\n    if ( l == h ) :\n        return 0\n    if ( l == h - 1 ) :\n        return 0 if ( str [ l ] == str [ h ] ) else 1\n    return 0 if ( str [ l ] == str [ h ] ) else ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if symb [ i ] == 'F' :\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' :\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i += 1\n    return T [ 0 ] [ n - 1 ]",
    "badcase": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    T = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n ) :\n        F [ i ] [ i ] = 1 if symb [ i ] == 'F' else 0\n        T [ i ] [ i ] = 1 if symb [ i ] == 'T' else 0\n    for gap in range ( 1 , n ) :\n        for i , j in enumerate ( range ( n ) ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n    return T [ 0 ] [ n - 1 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n , p ) :\n    ans = 0 ;\n    temp = p ;\n    while ( temp <= n ) :\n        ans += n / temp ;\n        temp = temp * p ;\n    return ans ;",
    "badcase": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += n // temp\n        temp = temp * p\n    return ans"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += n / temp\n        temp = temp * p\n    return int ( ans )",
    "badcase": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += n // temp\n        temp = temp * p\n    return ans"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        k = 0\n        for j in range ( i , i + n ) :\n            if brr [ j ] != arr [ k ] :\n                currHam += 1\n                k = k + 1\n        if currHam == n :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam",
    "badcase": "def maxHamming ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        for j , k in zip ( range ( i , i + n ) , range ( n ) ) :\n            if ( brr [ j ] != arr [ k ] ) :\n                currHam += 1\n        if ( currHam == n ) :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( S , n ) :\n    found = False\n    S.sort ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        for j in range ( 0 , n ) :\n            if ( i == j ) :\n                continue\n            for k in range ( j + 1 , n ) :\n                if ( i == k ) :\n                    continue\n                for l in range ( k + 1 , n ) :\n                    if ( i == l ) :\n                        continue\n                    if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :\n                        found = True\n                        return S [ i ]\n    if ( found == False ) :\n        return - 1",
    "badcase": "def findLargestd ( S , n ) :\n    found = False\n    S.sort ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        for j in range ( n ) :\n            if ( i == j ) :\n                continue\n            for k in range ( j + 1 , n ) :\n                if ( i == k ) :\n                    continue\n                for l in range ( k + 1 , n ) :\n                    if ( i == l ) :\n                        continue\n                    if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :\n                        found = True\n                        return S [ i ]\n    if ( found == False ) :\n        return - 9999999999999"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    maxPrime = - 1\n    while n % 2 == 0 :\n        maxPrime = 2\n        n >>= 1\n    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :\n        while n % i == 0 :\n            maxPrime = i\n            n = n / i\n    if n > 2 :\n        maxPrime = n\n    return int ( maxPrime )\n\n\nimport math",
    "badcase": "def maxPrimeFactors ( n ) :\n    maxPrime = - 1\n    while ( n % 2 == 0 ) :\n        maxPrime = 2\n        n >>= 1\n    for i in range ( 3 , int ( math.sqrt ( n ) ) , 2 ) :\n        while ( n % i == 0 ) :\n            maxPrime = i\n            n = n / i\n    if ( n > 2 ) :\n        maxPrime = n\n    return maxPrime"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    arr = sorted ( arr )\n    diff = 10 ** 20\n    for i in range ( n - 1 ) :\n        if arr [ i + 1 ] - arr [ i ] < diff :\n            diff = arr [ i + 1 ] - arr [ i ]\n    return diff",
    "badcase": "def findMinDiff ( arr , n ) :\n    arr.sort ( )\n    diff = 9999999999999\n    for i in range ( n - 1 ) :\n        if ( arr [ i + 1 ] - arr [ i ] < diff ) :\n            diff = arr [ i + 1 ] - arr [ i ]\n    return diff"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( strA , strB ) :\n    res = 0\n    for i in range ( 0 , len ( strA ) ) :\n        res = res ^ ( ord ) ( strA [ i ] )\n    for i in range ( 0 , len ( strB ) ) :\n        res = res ^ ( ord ) ( strB [ i ] )\n    return ( ( chr ) ( res ) ) ;",
    "badcase": "def findExtraCharacter ( strA , strB ) :\n    res = 0\n    for i in range ( len ( strA ) ) :\n        res = res ^ ord ( strA [ i ] )\n    for i in range ( len ( strB ) ) :\n        res = res ^ ord ( strB [ i ] )\n    return chr ( res )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold(n):\n    i = 0\n    j = len(n)\n    pos = 0\n    while (i < j):\n        if (n[i] == '4'):\n            pos = pos * 2 + 1\n        if (n[i] == '7'):\n            pos = pos * 2 + 2\n        i = i + 1\n    return pos",
    "badcase": "def findpos ( n ) :\n    i = 0\n    pos = 0\n    while ( n [ i ] ) :\n        if ( n [ i ] == '4' ) :\n            pos = pos * 2 + 1\n        elif ( n [ i ] == '7' ) :\n            pos = pos * 2 + 2\n        i += 1\n    return pos"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n + 1 ) ) :\n            if j == 0 or j == i :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    sum = 0 ;\n    for i in range ( 0 , n + 1 ) :\n        if n % 2 == 0 :\n            sum = sum + C [ n ] [ i ]\n    return sum",
    "badcase": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )\n    sum = 0\n    for i in range ( 0 , n + 1 , 2 ) :\n        sum += C [ n ] [ i ]\n    return sum"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , low , high ) :\n    max = arr [ low ]\n    i = low\n    for i in range ( high + 1 ) :\n        if arr [ i ] > max :\n            max = arr [ i ]\n    return max",
    "badcase": "def findMaximum ( arr , low , high ) :\n    max = arr [ low ]\n    i = low + 1\n    while i <= high :\n        if arr [ i ] > max :\n            max = arr [ i ]\n        else :\n            break\n        i += 1\n    return max"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n , x , y ) :\n    min_dist = 99999999\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) :\n                min_dist = abs ( i - j )\n        return min_dist",
    "badcase": "def minDist ( arr , n , x , y ) :\n    min_dist = 9999999999999\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) ) :\n                min_dist = abs ( i - j )\n    return min_dist"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( y , x ) :\n    return ( y % pow ( 2 , x ) )",
    "badcase": "def yMod ( y , x ) :\n    if ( math.log2 ( y ) < x ) :\n        return y\n    if ( x > 63 ) :\n        return y\n    return ( y % ( 1 << x ) )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    count = 0\n    if ( n and ( not ( n & ( n - 1 ) ) ) ) :\n        while ( n > 1 ) :\n            n >>= 1\n            count += 1\n        if ( count % 2 == 0 ) :\n            return True\n        else :\n            return False",
    "badcase": "def isPowerOfFour ( n ) :\n    count = 0\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        while ( n > 1 ) :\n            n >>= 1\n            count += 1\n        return 1 if ( count % 2 == 0 ) else 0\n    return 0"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return result",
    "badcase": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ '' ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = chr ( 48 + count )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return \"\".join ( result )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n , x ) :\n    for i in range ( n ) :\n        if arr [ i ] > arr [ i + 1 ] :\n            break\n    l = ( i + 1 ) % n\n    r = i\n    cnt = 0\n    while ( l != r ) :\n        if arr [ l ] + arr [ r ] == x :\n            cnt += 1\n            if l == ( r - 1 + n ) % n :\n                return cnt\n            l = ( l + 1 ) % n\n            r = ( r - 1 + n ) % n\n        elif arr [ l ] + arr [ r ] < x :\n            l = ( l + 1 ) % n\n        else :\n            r = ( n + r - 1 ) % n\n    return cnt",
    "badcase": "def pairsInSortedRotated ( arr , n , x ) :\n    for i in range ( n - 1 ) :\n        if arr [ i ] > arr [ i + 1 ] :\n            break\n    l = ( i + 1 ) % n\n    r = i\n    cnt = 0\n    while ( l != r ) :\n        if ( arr [ l ] + arr [ r ] == x ) :\n            cnt += 1\n            if ( l == ( r - 1 + n ) % n ) :\n                return cnt\n            l = ( l + 1 ) % n\n            r = ( r - 1 + n ) % n\n        elif ( arr [ l ] + arr [ r ] < x ) :\n            l = ( l + 1 ) % n\n        else :\n            r = ( n + r - 1 ) % n\n    return cnt"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( st ) :\n    l = len ( st )\n    arr = [ 0 ] * l\n    for i in range ( 0 , l ) :\n        for j in range ( i , l ) :\n            for k in range ( j , l ) :\n                if ( arr [ i ] % 8 == 0 ) :\n                    return True\n                elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                    return True\n                elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                    return True\n    return False",
    "badcase": "def isSubSeqDivisible ( arr ) :\n    l = len ( arr )\n    for i in range ( l ) :\n        for j in range ( i , l ) :\n            for k in range ( j , l ) :\n                if ( arr [ i ] % 8 == 0 ) :\n                    return True\n                elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :\n                    return True\n                elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :\n                    return True\n    return False"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    index = 0\n    while index < n :\n        if index == 0 :\n            index = index + 1\n        if arr [ index ] >= arr [ index - 1 ] :\n            index = index + 1\n        else :\n            arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ]\n            index = index - 1\n    return arr",
    "badcase": "def gnomeSort ( arr , n ) :\n    index = 0\n    while index < n :\n        if index == 0 :\n            index = index + 1\n        if arr [ index ] >= arr [ index - 1 ] :\n            index = index + 1\n        else :\n            arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ]\n            index = index - 1\n    return"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0 ;\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ;\n                nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]",
    "badcase": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                    nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold(arr, n):\n    hash = dict()\n    maximum = 0\n    for i in arr:\n        if (i < 0):\n            if abs(i) not in hash.keys():\n                hash[abs(i)] = - 1\n            else:\n                hash[abs(i)] -= 1\n        else:\n            hash[i] = hash.get(i, 0) + 1\n    for i in arr:\n        if i in hash.keys() and hash[i] > 0:\n            return i\n    return - 1",
    "badcase": "def findInteger ( arr , n ) :\n    hash = { }\n    maximum = 0\n    for i in range ( n ) :\n        if ( arr [ i ] < 0 ) :\n            hash [ abs ( arr [ i ] ) ] -= 1\n        else :\n            hash [ arr [ i ] ] += 1\n    for i in range ( n ) :\n        if ( hash [ arr [ i ] ] != 0 ) :\n            return arr [ i ]\n    return - 1"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , b , k ) :\n    p = a ** b\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p % 10\n        count = count + 1\n        if ( count == k ) :\n            return rem\n        p = p / 10 ;",
    "badcase": "def kthdigit ( a , b , k ) :\n    p = pow ( a , b )\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p % 10\n        count += 1\n        if ( count == k ) :\n            return rem\n        p = p // 10\n    return 0"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    hash_map = { } ;\n    curr_sum = 0 ;\n    max_len = 0 ;\n    ending_index = - 1 ;\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1 ;\n        else :\n            arr [ i ] = 1 ;\n    for i in range ( 0 , n ) :\n        curr_sum = curr_sum + arr [ i ] ;\n        if ( curr_sum == 0 ) :\n            max_len = i + 1 ;\n            ending_index = i ;\n        if ( curr_sum + n ) in hash_map :\n            max_len = max ( max_len , i - hash_map [ curr_sum + n ] )\n        else :\n            hash_map [ curr_sum ] = i ;\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0 ;\n        else :\n            arr [ i ] = 1 ;\n    print ( ending_index - max_len + 1 , end = \" \" ) ;\n    print ( \"to\" , end = \" \" ) ;\n    print ( ending_index ) ;\n    return max_len ;",
    "badcase": "def maxLen ( arr , n ) :\n    hM = { }\n    Sum = 0\n    max_len = 0\n    ending_index = - 1\n    for i in range ( n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n    for i in range ( n ) :\n        Sum += arr [ i ]\n        if ( Sum == 0 ) :\n            max_len = i + 1\n            ending_index = i\n        if ( Sum + n ) in hM :\n            if ( max_len < i - hM [ Sum + n ] ) :\n                max_len = i - hM [ Sum + n ]\n                ending_index = i\n        else :\n            hM [ Sum + n ] = i\n    for i in range ( n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n    print ( \"%d to %d\" % ( ending_index - max_len + 1 , ending_index ) )\n    return max_len"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n                while ( i >= 0 ) :\n                    L [ i ] [ j ] = 2\n                    i -= 1\n    return llap",
    "badcase": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n        while ( i >= 0 ) :\n            L [ i ] [ j ] = 2\n            i -= 1\n    return llap"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    for ch in string :\n        cnt = 0\n        for i in range ( last , n ) :\n            if s [ i ] == ch :\n                cnt += 1\n        if cnt >= k :\n            for i in range ( last , n ) :\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size += 1\n            last = new_last",
    "badcase": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    for ch in range ( ord ( 'z' ) , ord ( 'a' ) - 1 , - 1 ) :\n        cnt = 0\n        for i in range ( last , n ) :\n            if ( s [ i ] == chr ( ch ) ) :\n                cnt += 1\n        if ( cnt >= k ) :\n            for i in range ( last , n ) :\n                if ( s [ i ] == chr ( ch ) ) :\n                    t [ size ] = chr ( ch )\n                    size += 1\n                    new_last = i\n            last = new_last\n    t [ size ] = '\\0'"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 )\n    return s",
    "badcase": "def nextWord ( s ) :\n    if ( s == \"\" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s [ : i ] + chr ( ord ( s [ i ] ) + 1 ) + s [ i + 1 : ]\n    return s"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True , str",
    "badcase": "def prevPermutation ( st ) :\n    n = len ( st ) - 1\n    i = n\n    while ( i > 0 and st [ i - 1 ] <= st [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and st [ j + 1 ] <= st [ i - 1 ] ) :\n        j += 1\n    st [ i - 1 ] , st [ j ] = st [ j ] , st [ i - 1 ]\n    st [ i : ] = st [ n : i - 1 : - 1 ]\n    return True"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( s ) :\n    n = len ( s )\n    lps = [ 0 ] * n\n    l = 0\n    i = 1\n    while ( i < n ) :\n        if ( s [ i ] == s [ l ] ) :\n            l = l + 1\n            lps [ i ] = l\n            i = i + 1\n        else :\n            if ( l != 0 ) :\n                l = lps [ l - 1 ]\n            else :\n                lps [ i ] = 0\n                i = i + 1\n    res = lps [ n - 1 ]\n    if ( res > n / 2 ) :\n        return n // 2\n    else :\n        return res",
    "badcase": "def longestPrefixSuffix ( s ) :\n    n = len ( s )\n    lps = [ 0 for i in range ( n ) ]\n    lps [ 0 ] = 0\n    len = 0\n    i = 1\n    while ( i < n ) :\n        if ( s [ i ] == s [ len ] ) :\n            len += 1\n            lps [ i ] = len\n            i += 1\n        else :\n            if ( len != 0 ) :\n                len = lps [ len - 1 ]\n            else :\n                lps [ i ] = 0\n                i += 1\n    res = lps [ n - 1 ]\n    if ( res > n / 2 ) :\n        return n / 2\n    else :\n        return res"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    um = { i : 0 for i in range ( 10 ) }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if arr [ i ] == 0 :\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen",
    "badcase": "def lenOfLongSubarr ( arr , n ) :\n    um = { }\n    Sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        Sum += - 1 if ( arr [ i ] == 0 ) else 1\n        if ( Sum == 1 ) :\n            maxLen = i + 1\n        elif ( Sum not in um.keys ( ) ) :\n            um [ Sum ] = i\n        if ( Sum - 1 in um.keys ( ) ) :\n            if ( maxLen < ( i - um [ Sum - 1 ] ) ) :\n                maxLen = i - um [ Sum - 1 ]\n    return maxLen"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( m ) :\n    for i in range ( 0 , len ( m ) ) :\n        sm = 0\n        for j in range ( 0 , len ( m [ i ] ) ) :\n            sm = sm + m [ i ] [ j ]\n        if ( sm != 1 ) :\n            return False\n    return True",
    "badcase": "def checkMarkov ( m ) :\n    for i in range ( len ( m ) ) :\n        sum = 0\n        for j in range ( len ( m ) ) :\n            sum = sum + m [ i ] [ j ]\n        if ( sum != 1 ) :\n            return False\n    return True"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( s ) :\n    length = int ( s / 3 )\n    s -= length\n    breadth = s / 2\n    height = s - breadth\n    return int ( length * breadth * height )",
    "badcase": "def maxvolume ( s ) :\n    length = s // 3\n    s -= length\n    breadth = s // 2\n    height = s - breadth\n    return length * breadth * height"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( A , K ) :\n    n = len ( A ) ;\n    pre_sum = [ 0 ] * ( n + 1 ) ;\n    pre_sum [ 0 ] = 0 ;\n    for i in range ( n ) :\n        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;\n    dp = [ 0 ] * n ;\n    sum = 0 ;\n    for i in range ( n ) :\n        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ;\n    for k in range ( K - 1 ) :\n        for i in range ( n ) :\n            for j in range ( i + 1 , n ) :\n                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ;\n    return int ( dp [ 0 ] ) ;",
    "badcase": "def largestSumOfAverages ( A , K ) :\n    n = len ( A )\n    pre_sum = [ 0 ] * ( n + 1 )\n    pre_sum [ 0 ] = 0\n    for i in range ( n ) :\n        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]\n    dp = [ 0 ] * n\n    sum = 0\n    for i in range ( n ) :\n        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i )\n    for k in range ( K - 1 ) :\n        for i in range ( n ) :\n            for j in range ( i + 1 , n ) :\n                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] )\n    return dp [ 0 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( N ) :\n    dp = [ 0 for i in range ( N ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 2\n    i = 1\n    while dp [ i ] <= N :\n        i = i + 1\n        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]\n    return ( i - 1 )",
    "badcase": "def maxGameByWinner ( N ) :\n    dp = [ 0 ] * ( N + 1 )\n    dp [ 0 ] = 1\n    dp [ 1 ] = 2\n    i = 2\n    while dp [ i ] <= N :\n        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]\n        i += 1\n    return ( i - 2 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , n ) :\n    if n == 1 :\n        return a [ 0 ]\n    max_neg = - 999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            count_zero += 1\n            continue\n        if a [ i ] < 0 :\n            count_neg += 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod * a [ i ]\n    if count_zero == n :\n        return 0\n    if count_neg & 1 :\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = int ( prod / max_neg )\n    return prod",
    "badcase": "def maxProductSubset ( a , n ) :\n    if ( n == 1 ) :\n        return a [ 0 ]\n    max_neg = - 9999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( n ) :\n        if ( a [ i ] == 0 ) :\n            count_zero += 1\n            continue\n        if ( a [ i ] < 0 ) :\n            count_neg += 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod * a [ i ]\n    if ( count_zero == n ) :\n        return 0\n    if ( count_neg & 1 ) :\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = prod // max_neg\n    return prod"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , n , k ) :\n    max_so_far = - 2147483648\n    max_ending_here = 0\n    for i in range ( n * k ) :\n        max_ending_here = max_ending_here + a [ i % n ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far",
    "badcase": "def maxSubArraySumRepeated ( a , n , k ) :\n    max_so_far = - 9999999999999\n    max_ending_here = 0\n    for i in range ( 0 , n * k ) :\n        max_ending_here = max_ending_here + a [ i % n ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n + 1 ) ]\n    inc = [ 0 for i in range ( n + 1 ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result",
    "badcase": "def maxAlternateSum ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n ) ]\n    inc = [ 0 for i in range ( n ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , N , k ) :\n    maxSum = 0 ;\n    arr.sort ( ) ;\n    i = N - 1 ;\n    while ( i >= 0 ) :\n        if ( arr [ i ] - arr [ i - 1 ] < k ) :\n            maxSum += arr [ i ] ;\n            maxSum += arr [ i - 1 ] ;\n            i -= 1 ;\n        i -= 1 ;\n    return maxSum ;",
    "badcase": "def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :\n    maxSum = 0\n    arr.sort ( )\n    i = N - 1\n    while i > 0 :\n        if arr [ i ] - arr [ i - 1 ] < k :\n            maxSum += arr [ i ]\n            maxSum += arr [ i - 1 ]\n            i -= 2\n        i -= 1\n    return maxSum"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    fw = [ 0 for k in range ( n ) ]\n    bw = [ 0 for k in range ( n ) ]\n    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]\n    for i in range ( n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    i = n - 2\n    while i >= 0 :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n        i -= 1\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans",
    "badcase": "def maxSumSubarrayRemovingOneEle ( arr , n ) :\n    fw = [ 0 ] * n\n    bw = [ 0 ] * n\n    cur_max = max_so_far = fw [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n    return ( m1 + m2 ) / 2",
    "badcase": "def getMedian ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n    return ( m1 + m2 ) // 2"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , b , c ) :\n    x = a - b\n    y = b - c\n    z = a - c\n    if x * y > 0 :\n        return b\n    elif ( x * z > 0 ) :\n        return\n    else :\n        return a",
    "badcase": "def middleOfThree ( a , b , c ) :\n    x = a - b\n    y = b - c\n    z = a - c\n    if ( x * y > 0 ) :\n        return b\n    elif ( x * z > 0 ) :\n        return c\n    else :\n        return a"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( X , Y , l , r , k , dp ) :\n    if k == 0 :\n        return 0\n    if l < 0 or r < 0 :\n        return 1000000000\n    if dp [ l ] [ r ] [ k ] != - 1 :\n        return dp [ l ] [ r ] [ k ]\n    cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) )\n    dp [ l ] [ r ] [ k ] = min ( [ cost + f_gold ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , f_gold ( X , Y , l - 1 , r , k , dp ) , f_gold ( X , Y , l , r - 1 , k , dp ) ] )\n    return dp [ l ] [ r ] [ k ]",
    "badcase": "def solve ( X , Y , l , r , k , dp ) :\n    if ( not k ) :\n        return 0\n    if ( l < 0 ) :\n        return 0\n    if ( r < 0 ) :\n        return 0\n    if ( dp [ l ] [ r ] != - 1 ) :\n        return dp [ l ] [ r ]\n    if ( X [ l ] == Y [ r ] ) :\n        dp [ l ] [ r ] = solve ( X , Y , l - 1 , r - 1 , k , dp )\n    else :\n        dp [ l ] [ r ] = min ( solve ( X , Y , l - 1 , r , k - 1 , dp ) , solve ( X , Y , l , r - 1 , k - 1 , dp ) )\n    return dp [ l ] [ r ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( mat , n ) :\n    tot_energy = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            q = mat [ i ] [ j ] // n\n            i_des = q\n            j_des = mat [ i ] [ j ] - ( n * q )\n            tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) )\n    return tot_energy",
    "badcase": "def calculateEnergy ( mat , n ) :\n    for i in range ( n ) :\n        for j in range ( n ) :\n            q = mat [ i ] [ j ] // n\n            i_des = q\n            j_des = mat [ i ] [ j ] - ( n * q )\n            tot_energy += abs ( i_des - i ) + abs ( j_des - j )\n    return tot_energy"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    for i in range ( 0 , n ) :\n        if ( ( max1 - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res += ( max1 - arr [ i ] ) / k\n    return int ( res )",
    "badcase": "def minOps ( arr , n , k ) :\n    max = max ( arr )\n    res = 0\n    for i in range ( n ) :\n        if ( ( max - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res += ( max - arr [ i ] ) // k\n    return res"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :\n        return float ( 'inf' )\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = float ( 'inf' )\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]\n\n\nimport sys",
    "badcase": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 or arr [ 0 ] == 0 ) :\n        return sys.maxsize\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = sys.maxsize\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] and jumps [ j ] != sys.maxsize ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = float ( 'inf' )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( 'inf' )\n            for j in range ( i + 1 , n ) :\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n            if ( min != float ( 'inf' ) ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]",
    "badcase": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    min = 0x7FFFFFFF\n    jumps [ n - 1 ] = 0\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = 0x7FFFFFFF\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = 0x7FFFFFFF\n            for j in range ( i + 1 , n and j <= arr [ i ] + i , 1 ) :\n                if ( min > jumps [ j ] ) :\n                    min = jumps [ j ]\n            if ( min != 0x7FFFFFFF ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    for i in range ( 0 , n ) :\n        count = 1\n        for i in range ( n - 1 ) :\n            if ar [ i ] == ar [ i + 1 ] :\n                count += 1\n            else :\n                break\n        res = max ( res , count )\n    return res",
    "badcase": "def subset ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    i = 0\n    while i < n :\n        count = 1\n        j = i + 1\n        while j < n :\n            if ar [ j ] == ar [ i ] :\n                count += 1\n                j += 1\n            else :\n                break\n        res = max ( res , count )\n        i = j\n    return res"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    l = math.sqrt ( n )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = n / l\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter\n\n\nimport math",
    "badcase": "def minPerimeter ( n ) :\n    l = int ( math.sqrt ( n ) )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = n // l\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( str ) :\n    tmp = str + str\n    n = len ( str )\n    for i in range ( 1 , n + 1 ) :\n        substring = tmp [ i : n ]\n        if ( str == substring ) :\n            return i\n    return n",
    "badcase": "def findRotations ( str ) :\n    tmp = str + str ;\n    n = len ( str ) ;\n    for i in range ( 1 , n + 1 ) :\n        substring = tmp [ i : i + n ] ;\n        if ( str == substring ) :\n            return i ;\n    return n ;"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    arr.sort ( ) ;\n    min_xor = 999999\n    val = 0\n    for i in range ( 0 , n - 1 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            val = arr [ i ] ^ arr [ j ]\n            min_xor = min ( min_xor , val )\n    return min_xor",
    "badcase": "def minXOR ( arr , n ) :\n    min_xor = float ( 'inf' )\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] )\n    return min_xor"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( x ) :\n    next = 0\n    if ( x ) :\n        rightOne = x & - ( x )\n        nextHigherOneBit = x + int ( rightOne )\n        rightOnesPattern = x ^ int ( nextHigherOneBit )\n        rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) )\n        rightOnesPattern = int ( rightOnesPattern ) >> 2\n        next = nextHigherOneBit | rightOnesPattern\n    return next",
    "badcase": "def snoob ( x ) :\n    if ( x ) :\n        rightOne = x & - ( x )\n        nextHigherOneBit = x + rightOne\n        rightOnesPattern = x ^ nextHigherOneBit\n        rightOnesPattern = ( rightOnesPattern ) / rightOne\n        rightOnesPattern >>= 2\n        next = nextHigherOneBit\n    return next"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold(k, n):\n    f1 = 0\n    f2 = 1\n    i = 2\n    while i != 0:\n        f3 = f1 + f2\n        f1 = f2\n        f2 = f3\n        if f2 % k == 0:\n            return n * i\n        i += 1\n    return",
    "badcase": "def findPosition ( k , n ) :\n    f1 = 0\n    f2 = 1\n    for i in range ( 2 , MAX ) :\n        f3 = f1 + f2\n        f1 = f2\n        f2 = f3\n        if ( f2 % k == 0 ) :\n            return n * i"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    while ( int ( n / 100 ) ) :\n        last_digit = int ( n % 10 )\n        n = int ( n / 10 )\n        n += last_digit * 3\n    return ( n % 29 == 0 )",
    "badcase": "def isDivisible ( n ) :\n    while ( n / 100 ) :\n        last_digit = n % 10\n        n //= 10\n        n += last_digit * 3\n    return ( n % 29 == 0 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( mat , r , c ) :\n    a = 0\n    b = 2\n    low_row = 0 if ( 0 > a ) else a\n    low_column = 0 if ( 0 > b ) else b - 1\n    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1\n    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1\n    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :\n        i = low_column + 1\n        while ( i <= high_column and i < c and low_row >= 0 ) :\n            print ( mat [ low_row ] [ i ] , end = \" \" )\n            i += 1\n        low_row -= 1\n        i = low_row + 2\n        while ( i <= high_row and i < r and high_column < c ) :\n            print ( mat [ i ] [ high_column ] , end = \" \" )\n            i += 1\n        high_column += 1\n        i = high_column - 2\n        while ( i >= low_column and i >= 0 and high_row < r ) :\n            print ( mat [ high_row ] [ i ] , end = \" \" )\n            i -= 1\n        high_row += 1\n        i = high_row - 2\n        while ( i > low_row and i >= 0 and low_column >= 0 ) :\n            print ( mat [ i ] [ low_column ] , end = \" \" )\n            i -= 1\n        low_column -= 1\n    print ( )",
    "badcase": "def printSpiral ( mat , r , c ) :\n    i , a , b = 0 , 0 , 2\n    low_row = ( 0 > a ) and 0 or a\n    low_column = ( 0 > b ) and 0 or b - 1\n    high_row = ( ( a + 1 ) >= r ) and r - 1 or a + 1\n    high_column = ( ( b + 1 ) >= c ) and c - 1 or b + 1\n    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :\n        for i in range ( low_column + 1 , high_column + 1 , 1 ) :\n            print ( mat [ low_row ] [ i ] , end = \" \" )\n        low_row -= 1\n        for i in range ( low_row + 2 , high_row + 1 , 1 ) :\n            print ( mat [ i ] [ high_column ] , end = \" \" )\n        high_column += 1\n        for i in range ( high_column - 2 , low_column - 1 , - 1 ) :\n            print ( mat [ high_row ] [ i ] , end = \" \" )\n        high_row += 1\n        for i in range ( high_row - 2 , low_row - 1 , - 1 ) :\n            print ( mat [ i ] [ low_column ] , end = \" \" )\n        low_column -= 1\n    print ( )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*' * len ( word )\n    count = 0\n    index = 0 ;\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    result = ' '.join ( word_list )\n    return result",
    "badcase": "def censor ( text , word ) :\n    word_list = text.split ( \" \" )\n    result = \"\"\n    stars = \"\"\n    for i in range ( len ( word ) ) :\n        stars += '*'\n    index = 0\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    for i in word_list :\n        result += i + ' '\n    return result"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( str ) :\n    stack = [ ]\n    for i in range ( len ( str ) ) :\n        stack.append ( str [ i ] )\n    for i in range ( len ( str ) ) :\n        str [ i ] = stack.pop ( )",
    "badcase": "def recursiveReverse ( st ) :\n    for i in range ( len ( st ) ) :\n        st.append ( st [ i ] )\n    st.reverse ( )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    ar = [ 0 ] * 10\n    while ( n > 0 ) :\n        digit = math.floor ( n % 10 )\n        if ( ar [ digit ] ) :\n            return 0\n        ar [ digit ] = 1\n        n = n / 10\n    return 1",
    "badcase": "def isLucky ( n ) :\n    arr = [ False ] * 10\n    while ( n > 0 ) :\n        digit = n % 10\n        if ( arr [ digit ] ) :\n            return False\n        arr [ digit ] = True\n        n = n // 10\n    return True"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( 0 , n ) :\n        if i % 2 == 0 :\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n    for i in range ( 0 , n ) :\n        arr [ i ] = arr [ i ] / max_elem",
    "badcase": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( n ) :\n        if i % 2 == 0 :\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n    for i in range ( n ) :\n        arr [ i ] = arr [ i ] // max_elem"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( Str ) :\n    Len = len ( Str )\n    res = [ None ] * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if ( Str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        elif ( Str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index += 1\n        elif ( Str [ i ] == '(' and i > 0 ) :\n            if ( Str [ i - 1 ] == '-' ) :\n                x = 0 if ( s [ - 1 ] == 1 ) else 1\n                s.append ( x )\n            elif ( Str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( Str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = Str [ i ]\n            index += 1\n        i += 1\n    return res",
    "badcase": "def simplify ( str ) :\n    l = len ( str )\n    res = [ 0 ] * l\n    index = 0\n    s = [ ]\n    s.append ( 0 )\n    i = 0\n    while ( i < l ) :\n        if ( str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        elif ( str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index += 1\n        elif ( str [ i ] == '(' and i > 0 ) :\n            if ( str [ i - 1 ] == '-' ) :\n                x = ( s [ - 1 ] == 1 )\n                s.append ( x )\n            elif ( str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = str [ i ]\n            index += 1\n        i += 1\n    return \"\".join ( res )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( S ) :\n    n = len ( S )\n    if ( n < 2 ) :\n        return\n    j = 0\n    for i in range ( n ) :\n        if ( S [ j ] != S [ i ] ) :\n            j += 1\n            S [ j ] = S [ i ]\n    j += 1\n    S = S [ : j ]\n    return S",
    "badcase": "def removeDuplicates ( S ) :\n    n = len ( S )\n    if n < 2 :\n        return\n    j = 0\n    for i in range ( 1 , n ) :\n        if S [ j ] != S [ i ] :\n            j += 1\n            S [ j ] = S [ i ]\n    j += 1\n    S [ j ] = '\\0'"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( s , c1 , c2 ) :\n    l = len ( s )\n    for i in range ( l ) :\n        if ( s [ i ] == c1 ) :\n            s = s [ 0 : i ] + c2 + s [ i + 1 : ]\n        elif ( s [ i ] == c2 ) :\n            s = s [ 0 : i ] + c1 + s [ i + 1 : ]\n    return s",
    "badcase": "def replace ( s , c1 , c2 ) :\n    l = len ( s )\n    for i in range ( l ) :\n        if ( s [ i ] == c1 ) :\n            s [ i ] = c2\n        elif ( s [ i ] == c2 ) :\n            s [ i ] = c1\n    return s"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( arr , n ) :\n    for i in range ( n - 1 , 0 , - 1 ) :\n        j = random.randint ( 0 , i + 1 )\n        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    return arr\n\n\nimport random",
    "badcase": "def randomize ( arr , n ) :\n    for i in range ( n - 1 , 0 , - 1 ) :\n        j = random.randint ( 0 , i + 1 )\n        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , arr_size ) :\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    while mid <= hi :\n        if a [ mid ] == 0 :\n            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]\n            lo = lo + 1\n            mid = mid + 1\n        elif a [ mid ] == 1 :\n            mid = mid + 1\n        else :\n            a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]\n            hi = hi - 1",
    "badcase": "def sort012 ( a , arr_size ) :\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    while mid <= hi :\n        if a [ mid ] == 0 :\n            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]\n            lo = lo + 1\n            mid = mid + 1\n        elif a [ mid ] == 1 :\n            mid = mid + 1\n        elif a [ mid ] == 2 :\n            a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]\n            hi = hi - 1"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold(arr, n, A, B, C):\n    for i in range(n):\n        arr[i] = (A * arr[i] * arr[i] + B * arr[i] + C)\n    index = - (sys.maxsize - 1)\n    maximum = - (sys.maxsize - 1)\n    for i in range(n):\n        if maximum < arr[i]:\n            index = i\n            maximum = arr[i]\n    i = 0\n    j = n - 1\n    new_arr = [0] * n\n    k = 0\n    while i < index and j > index:\n        if arr[i] < arr[j]:\n            new_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            new_arr[k] = arr[j]\n            k += 1\n            j -= 1\n    while i < index:\n        new_arr[k] = arr[i]\n        k += 1\n        i += 1\n    while j > index:\n        new_arr[k] = arr[j]\n        k += 1\n        j -= 1\n        new_arr[n - 1] = maximum\n    for i in range(n):\n        arr[i] = new_arr[i]",
    "badcase": "def sortArray ( arr , n , A , B , C ) :\n    for i in range ( n ) :\n        arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C\n    maximum = - 10 ** 9\n    for i in range ( n ) :\n        if ( maximum < arr [ i ] ) :\n            index = i\n            maximum = arr [ i ]\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while ( i < index and j > index ) :\n        if ( arr [ i ] < arr [ j ] ) :\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n    while ( i < index ) :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while ( j > index ) :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n    new_arr [ n - 1 ] = maximum\n    for i in range ( n ) :\n        arr [ i ] = new_arr [ i ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( s ) :\n    _sum = 0\n    n = 1\n    while ( _sum < s ) :\n        _sum += n * n\n        n += 1\n    n -= 1\n    if _sum == s :\n        return n\n    return - 1",
    "badcase": "def findS ( s ) :\n    sum = 0\n    n = 1\n    while sum < s :\n        sum += n * n\n        n += 1\n        if sum == s :\n            return n\n    return - 1"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( string ) :\n    string = string [ : : - 1 ]\n    return string",
    "badcase": "def reverse ( str ) :\n    n = len ( str )\n    for i in range ( 0 , n // 2 ) :\n        str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ]"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( a , b ) :\n    if ( a == b ) :\n        return a\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    if ( ( ~ a & 1 ) == 1 ) :\n        if ( ( b & 1 ) == 1 ) :\n            return f_gold ( a >> 1 , b )\n        else :\n            return ( f_gold ( a >> 1 , b >> 1 ) << 1 )\n    if ( ( ~ b & 1 ) == 1 ) :\n        return f_gold ( a , b >> 1 )\n    if ( a > b ) :\n        return f_gold ( ( a - b ) >> 1 , b )\n    return f_gold ( ( b - a ) >> 1 , a )",
    "badcase": "def gcd ( a , b ) :\n    if ( a == b ) :\n        return a\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    if ( a & 1 ) :\n        if ( b & 1 ) :\n            return gcd ( a >> 1 , b )\n        else :\n            return gcd ( a >> 1 , b >> 1 ) << 1\n    if ( b & 1 ) :\n        return gcd ( a , b >> 1 )\n    if ( a > b ) :\n        return gcd ( ( a - b ) >> 1 , b )\n    return gcd ( ( b - a ) >> 1 , a )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    ans = 0 ; temp = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        if temp < n :\n            temp = i - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans += i * num\n                else :\n                    ans += ( n - temp ) * num\n                temp += i\n                num += 1\n    return ans",
    "badcase": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    for i in range ( 1 , n + 1 ) :\n        temp = i - 1\n        num = 1\n        while ( temp < n ) :\n            if ( temp + i <= n ) :\n                ans += ( i * num )\n            else :\n                ans += ( ( n - temp ) * num )\n            temp += i\n            num += 1\n    return ans"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( n ) :\n    i = 1 ;\n    res = 0.0 ;\n    sign = True ;\n    while ( n > 0 ) :\n        n = n - 1 ;\n        if ( sign ) :\n            sign = False ;\n            res = res + ( i + 1 ) / ( i + 2 ) ;\n            i = i + 2 ;\n        else :\n            sign = True ;\n            res = res - ( i + 1 ) / ( i + 2 ) ;\n            i = i + 2 ;\n    return res ;",
    "badcase": "def seriesSum ( n ) :\n    i = 1\n    res = 0.0\n    sign = True\n    while ( n > 0 ) :\n        n -= 1\n        if ( sign ) :\n            sign = not sign\n            i += 1\n            res = res + float ( i ) / float ( i + 1 )\n        else :\n            sign = not sign\n            i += 1\n            res = res - float ( i ) / float ( i + 1 )\n    return res"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )\n    xor = ( set1 ^ set2 )\n    xor = ( xor << p1 ) | ( xor << p2 )\n    result = x ^ xor\n    return result",
    "badcase": "def swapBits ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )\n    Xor = ( set1 ^ set2 )\n    Xor = ( Xor << p1 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( x ) :\n    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )",
    "badcase": "def swapNibbles ( x ) :\n    return ( ( x & 0x0F ) << 4 )"
  },
  {
    "type": "cpp_to_python",
    "GT": "def f_gold ( xp , yp ) :\n    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]",
    "badcase": "def swap ( xp , yp ) :\n    xp = xp ^ yp\n    yp = xp ^ yp\n    xp = xp ^ yp"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string str ) {\n  int res = str [ 0 ] - '0';\n  for ( int i = 1;\n  i < str . length ( );\n  i ++ ) {\n    if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) res += ( str [ i ] - '0' );\n    else res *= ( str [ i ] - '0' );\n  }\n  return res;\n}",
    "badcase": "int calcMaxValue ( string str ) {\n  int res = str [ 0 ] - '0' ;\n  for ( int i = 1 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( str [ i ] == '0' str [ i ] == '1' res < 2 ) res += ( str [ i ] - '0' ) ;\n    else res *= ( str [ i ] - '0' ) ;\n  }\n  return res ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string str ) {\n  string temp = \"\";\n  int sum = 0;\n  for ( char ch : str ) {\n    if ( isdigit ( ch ) ) temp += ch;\n    else {\n      sum += atoi ( temp . c_str ( ) );\n      temp = \"\";\n    }\n  }\n  return sum + atoi ( temp . c_str ( ) );\n}",
    "badcase": "int findSum ( string str ) {\n  string temp = \"0\" ;\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    char ch = str [ i ] ;\n    if ( isdigit ( ch ) ) temp += ch ;\n    else {\n      sum += stoi ( temp ) ;\n      temp = \"0\" ;\n    }\n  }\n  return sum + stoi ( temp ) ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( string s ) {\n  if ( s . size ( ) >= 10 ) return true;\n  for ( int i = 1;\n  i < s . size ( );\n  i ++ ) {\n    for ( int j = i + 1;\n    j < s . size ( );\n    j ++ ) {\n      for ( int k = j + 1;\n      k < s . size ( );\n      k ++ ) {\n        string s1 = s . substr ( 0, i );\n        string s2 = s . substr ( i, j - i );\n        string s3 = s . substr ( j, k - j );\n        string s4 = s . substr ( k, s . size ( ) - k );\n        if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true;\n      }\n    }\n  }\n  return false;\n}",
    "badcase": "bool strcheck ( string s1 , string s2 ) {\n  if ( s1 . length ( ) != s2 . length ( ) ) return false ;\n  for ( int i = 0 ;\n  i < s1 . length ( ) ;\n  i ++ ) {\n    if ( s1 [ i ] != s2 [ i ] ) return false ;\n  }\n  return true ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( string str ) {\n  int n = str . length ( );\n  int i;\n  for ( i = 0;\n  i < n;\n  i ++ ) if ( str [ i ] != 'a' ) break;\n  if ( i * 2 != n ) return false;\n  int j;\n  for ( j = i;\n  j < n;\n  j ++ ) if ( str [ j ] != 'b' ) return false;\n  return true;\n}",
    "badcase": "bool isAnBn ( string s ) {\n  int l = s . length ( ) ;\n  if ( l % 2 == 1 ) {\n    return false ;\n  }\n  int i = 0 ;\n  int j = l - 1 ;\n  while ( i < j ) {\n    if ( s [ i ] != 'a' s [ j ] != 'b' ) {\n      return false ;\n    }\n    i ++ ;\n    j -- ;\n  }\n  return true ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( char str [ ], int n ) {\n  int ans = ( n * ( n + 1 ) ) / 2;\n  int a_index = 0;\n  int b_index = 0;\n  int c_index = 0;\n  for ( int i = 0;\n  i < n;\n  i ++ ) {\n    if ( str [ i ] == 'a' ) {\n      a_index = i + 1;\n      ans -= min ( b_index, c_index );\n    }\n    else if ( str [ i ] == 'b' ) {\n      b_index = i + 1;\n      ans -= min ( a_index, c_index );\n    }\n    else {\n      c_index = i + 1;\n      ans -= min ( a_index, b_index );\n    }\n  }\n  return ans;\n}",
    "badcase": "int CountSubstring ( string str , int n ) {\n  int ans = ( n * ( n + 1 ) ) / 2 ;\n  int a_index = 0 , b_index = 0 , c_index = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( str [ i ] == 'a' ) {\n      a_index = i + 1 ;\n      ans -= min ( b_index , c_index ) ;\n    }\n    else if ( str [ i ] == 'b' ) {\n      b_index = i + 1 ;\n      ans -= min ( a_index , c_index ) ;\n    }\n    else {\n      c_index = i + 1 ;\n      ans -= min ( a_index , b_index ) ;\n    }\n  }\n  return ans ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( char str [ ], int n ) {\n  int dp [ n ] [ n ];\n  memset ( dp, 0, sizeof ( dp ) );\n  bool P [ n ] [ n ];\n  memset ( P, false, sizeof ( P ) );\n  for ( int i = 0;\n  i < n;\n  i ++ ) P [ i ] [ i ] = true;\n  for ( int i = 0;\n  i < n - 1;\n  i ++ ) {\n    if ( str [ i ] == str [ i + 1 ] ) {\n      P [ i ] [ i + 1 ] = true;\n      dp [ i ] [ i + 1 ] = 1;\n    }\n  }\n  for ( int gap = 2;\n  gap < n;\n  gap ++ ) {\n    for ( int i = 0;\n    i < n - gap;\n    i ++ ) {\n      int j = gap + i;\n      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true;\n      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ];\n      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ];\n    }\n  }\n  return dp [ 0 ] [ n - 1 ];\n}",
    "badcase": "int CountPS ( string str , int n ) {\n  int dp [ n ] [ n ] ;\n  bool P [ n ] [ n ] ;\n  memset ( P , false , sizeof ( P ) ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) P [ i ] [ i ] = true ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( str [ i ] == str [ i + 1 ] ) {\n      P [ i ] [ i + 1 ] = true ;\n      dp [ i ] [ i + 1 ] = 1 ;\n    }\n  }\n  for ( int gap = 2 ;\n  gap < n ;\n  gap ++ ) {\n    for ( int i = 0 ;\n    i < n - gap ;\n    i ++ ) {\n      int j = gap + i ;\n      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;\n      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;\n    }\n  }\n  return dp [ 0 ] [ n - 1 ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string str ) {\n  int N = str . length ( );\n  int cps [ N + 1 ] [ N + 1 ];\n  memset ( cps, 0, sizeof ( cps ) );\n  for ( int i = 0;\n  i < N;\n  i ++ ) cps [ i ] [ i ] = 1;\n  for ( int L = 2;\n  L <= N;\n  L ++ ) {\n    for ( int i = 0;\n    i < N;\n    i ++ ) {\n      int k = L + i - 1;\n      if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1;\n      else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ];\n    }\n  }\n  return cps [ 0 ] [ N - 1 ];\n}",
    "badcase": "int countPS ( string str ) {\n  int N = str . length ( ) ;\n  int cps [ N + 1 ] [ N + 1 ] ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) cps [ i ] [ i ] = 1 ;\n  for ( int L = 2 ;\n  L <= N ;\n  L ++ ) {\n    for ( int i = 0 ;\n    i < N ;\n    i ++ ) {\n      int k = L + i - 1 ;\n      if ( k < N ) {\n        if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ;\n        else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ;\n      }\n    }\n  }\n  return cps [ 0 ] [ N - 1 ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int m, int n ) {\n  int dp [ n ] = {\n    1 };\n    dp [ 0 ] = 1;\n    for ( int i = 0;\n    i < m;\n    i ++ ) {\n      for ( int j = 1;\n      j < n;\n      j ++ ) {\n        dp [ j ] += dp [ j - 1 ];\n      }\n    }\n    return dp [ n - 1 ];\n  }",
    "badcase": "int numberOfPaths ( int m , int n ) {\n  int dp [ n ] ;\n  dp [ 0 ] = 1 ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j < n ;\n    j ++ ) {\n      dp [ j ] += dp [ j - 1 ] ;\n    }\n  }\n  return dp [ n - 1 ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( char str [ ], int len ) {\n  int count = 1;\n  if ( len == 1 ) return count;\n  if ( str [ 0 ] == str [ 1 ] ) count *= 1;\n  else count *= 2;\n  for ( int j = 1;\n  j < len - 1;\n  j ++ ) {\n    if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1;\n    else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2;\n    else count *= 3;\n  }\n  if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1;\n  else count *= 2;\n  return count;\n}",
    "badcase": "int countWords ( string str , int len ) {\n  int count = 1 ;\n  if ( len == 1 ) return count ;\n  if ( str [ 0 ] == str [ 1 ] ) count *= 1 ;\n  else count *= 2 ;\n  for ( int j = 1 ;\n  j < len - 1 ;\n  j ++ ) {\n    if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ;\n    else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ;\n    else count *= 3 ;\n  }\n  if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ;\n  else count *= 2 ;\n  return count ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int n, int m ) {\n  int dp [ m + 1 ] [ n + 1 ];\n  for ( int i = 0;\n  i <= m;\n  i ++ ) dp [ i ] [ 0 ] = 1;\n  for ( int i = 0;\n  i <= m;\n  i ++ ) dp [ 0 ] [ i ] = 1;\n  for ( int i = 1;\n  i <= m;\n  i ++ ) for ( int j = 1;\n  j <= n;\n  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ];\n  return dp [ m ] [ n ];\n}",
    "badcase": "int dealnnoy ( int n , int m ) {\n  int dp [ m + 1 ] [ n + 1 ] ;\n  for ( int i = 0 ;\n  i <= m ;\n  i ++ ) dp [ i ] [ 0 ] = 1 ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) dp [ 0 ] [ i ] = 1 ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) for ( int j = 1 ;\n  j <= n ;\n  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ;\n  return dp [ m ] [ n ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int m, int n, int x ) {\n  int table [ n + 1 ] [ x + 1 ];\n  memset ( table, 0, sizeof ( table ) );\n  for ( int j = 1;\n  j <= m && j <= x;\n  j ++ ) table [ 1 ] [ j ] = 1;\n  for ( int i = 2;\n  i <= n;\n  i ++ ) for ( int j = 1;\n  j <= x;\n  j ++ ) for ( int k = 1;\n  k <= m && k < j;\n  k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ];\n  return table [ n ] [ x ];\n}",
    "badcase": "long long findWays ( int m , int n , int x ) {\n  long long table [ n + 1 ] [ x + 1 ] ;\n  memset ( table , 0 , sizeof ( table ) ) ;\n  for ( int j = 1 ;\n  j <= m && j <= x ;\n  j ++ ) table [ 1 ] [ j ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= x ;\n    j ++ ) {\n      for ( int k = 1 ;\n      k < j && k <= m ;\n      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;\n    }\n  }\n  return table [ n ] [ x ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "string f_gold ( string number, int divisor ) {\n  string ans;\n  int idx = 0;\n  int temp = number [ idx ] - '0';\n  while ( temp < divisor ) temp = temp * 10 + ( number [ ++ idx ] - '0' );\n  while ( number . size ( ) > idx ) {\n    ans += ( temp / divisor ) + '0';\n    temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0';\n  }\n  if ( ans . length ( ) == 0 ) return \"0\";\n  return ans;\n}",
    "badcase": "string longDivision ( string number , int divisor ) {\n  string ans = \"\" ;\n  int idx = 0 ;\n  int temp = number [ idx ] - '0' ;\n  while ( temp < divisor ) temp = temp * 10 + ( number [ ++ idx ] - '0' ) ;\n  idx ++ ;\n  while ( number . size ( ) > idx ) {\n    ans += ( temp / divisor ) + '0' ;\n    temp = ( temp % divisor ) * 10 + number [ idx ++ ] - '0' ;\n  }\n  if ( ans . size ( ) == 0 ) return \"0\" ;\n  return ans ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( int n ) {\n  if ( n == 0 || n == 9 ) return true;\n  if ( n < 9 ) return false;\n  return f_gold ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) );\n}",
    "badcase": "bool isDivBy9 ( int n ) {\n  if ( n == 0 || n == 9 ) return true ;\n  if ( n < 9 ) return false ;\n  return isDivBy9 ( n >> 3 ) - ( n & 7 ) ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int lbs(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return lbs(&arr.front(), n);\n    } else {\n        return lbs(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( char symb [ ], char oper [ ], int n ) {\n  int F [ n ] [ n ], T [ n ] [ n ];\n  for ( int i = 0;\n  i < n;\n  i ++ ) {\n    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0;\n    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0;\n  }\n  for ( int gap = 1;\n  gap < n;\n  ++ gap ) {\n    for ( int i = 0, j = gap;\n    j < n;\n    ++ i, ++ j ) {\n      T [ i ] [ j ] = F [ i ] [ j ] = 0;\n      for ( int g = 0;\n      g < gap;\n      g ++ ) {\n        int k = i + g;\n        int tik = T [ i ] [ k ] + F [ i ] [ k ];\n        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ];\n        if ( oper [ k ] == '&' ) {\n          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ];\n          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] );\n        }\n        if ( oper [ k ] == '|' ) {\n          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ];\n          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] );\n        }\n        if ( oper [ k ] == '^' ) {\n          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ];\n          F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ];\n        }\n      }\n    }\n  }\n  return T [ 0 ] [ n - 1 ];\n}",
    "badcase": "int countParenth ( char symb [ ] , char oper [ ] , int n ) {\n  int F [ n ] [ n ] ;\n  int T [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ;\n    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ;\n  }\n  for ( int gap = 1 ;\n  gap < n ;\n  ++ gap ) {\n    for ( int i = 0 , j = gap ;\n    j < n ;\n    ++ i , ++ j ) {\n      T [ i ] [ j ] = F [ i ] [ j ] = 0 ;\n      for ( int g = 0 ;\n      g < gap ;\n      g ++ ) {\n        int k = i + g ;\n        int tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n        if ( oper [ k ] == '&' ) {\n          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '|' ) {\n          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          T [ i ] [ j ] += tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n        }\n      }\n    }\n  }\n  return T [ 0 ] [ n - 1 ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int lis(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return lis(&arr.front(), n);\n    } else {\n        return lis(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int n, int p ) {\n  int ans = 0;\n  int temp = p;\n  while ( temp <= n ) {\n    ans += n / temp;\n    temp = temp * p;\n  }\n  return ans;\n}",
    "badcase": "int PowerOFPINnfactorial ( int n , int p ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    int count = 0 , temp = i ;\n    while ( temp % p == 0 ) {\n      count ++ ;\n      temp = temp / p ;\n    }\n    ans += count ;\n  }\n  return ans ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int n, int p ) {\n  int ans = 0;\n  int temp = p;\n  while ( temp <= n ) {\n    ans += n / temp;\n    temp = temp * p;\n  }\n  return ans;\n}",
    "badcase": "int PowerOFPINnfactorial ( int n , int p ) {\n  int ans = 0 ;\n  int temp = p ;\n  while ( temp <= n ) {\n    ans += n / temp ;\n    temp = temp * p ;\n  }\n  return ans ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findLargestd(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findLargestd(&arr.front(), n);\n    } else {\n        return findLargestd(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int findMaxAverage(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxAverage(&arr.front(), n, k);\n    } else {\n        return findMaxAverage(arr, n, k);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(int k, T x, T y, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(k, &x.front(), &y.front(), n);\n    } else {\n        return f_gold(k, x, y, n);\n    }\n}",
    "badcase": "int minRadius(int k, T x, T y, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return minRadius(k, &x.front(), &y.front(), n);\n    } else {\n        return minRadius(k, x, y, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int a, int b ) {\n  int cnt = 0;\n  for ( int i = a;\n  i <= b;\n  i ++ ) for ( int j = 1;\n  j * j <= i;\n  j ++ ) if ( j * j == i ) cnt ++;\n  return cnt;\n}",
    "badcase": "int countSquares ( int a , int b ) {\n  int cnt = 0 ;\n  for ( int i = a ;\n  i <= b ;\n  i ++ ) for ( int j = 1 ;\n  j * j <= i ;\n  j ++ ) if ( j * j == i ) csnt ++ ;\n  return cnt ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findMaxGCD(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxGCD(&arr.front(), n);\n    } else {\n        return findMaxGCD(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findMaxGCD(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxGCD(&arr.front(), n);\n    } else {\n        return findMaxGCD(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( const vector < vector < int > > & m ) {\n  int rows = m . size ( );\n  if ( rows == 0 ) return false;\n  int columns = m [ 0 ] . size ( );\n  for ( int y1 = 0;\n  y1 < rows;\n  y1 ++ ) for ( int x1 = 0;\n  x1 < columns;\n  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1;\n  y2 < rows;\n  y2 ++ ) for ( int x2 = x1 + 1;\n  x2 < columns;\n  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true;\n  return false;\n}",
    "badcase": "bool isRectangle ( vector < vector < int >> m ) {\n  int rows = m . size ( ) ;\n  if ( rows == 0 ) return false ;\n  int columns = m [ 0 ] . size ( ) ;\n  for ( int y1 = 0 ;\n  y1 < rows ;\n  y1 ++ ) for ( int x1 = 0 ;\n  x1 < columns ;\n  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ;\n  y2 < rows ;\n  y2 ++ ) for ( int x2 = x1 + 1 ;\n  x2 < columns ;\n  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ;\n  return false ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n  if constexpr (is_same_v<T, vector<int>>) {\n    return f_gold(&arr.front(), n);\n  } else {\n    return f_gold(arr, n);\n  }\n}",
    "badcase": "int findElement(T arr, int n) {\n  if constexpr (is_same_v<T, vector<int>>) {\n    return findElement(&arr.front(), n);\n  } else {\n    return findElement(arr, n);\n  }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int low, int high) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), low, high);\n    } else {\n        return f_gold(arr, low, high);\n    }\n}",
    "badcase": "int findMaximum(T arr, int low, int high) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaximum(&arr.front(), low, high);\n    } else {\n        return findMaximum(arr, low, high);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "string f_gold ( string seq ) {\n  int n = seq . length ( );\n  if ( n >= 9 ) return \"-1\";\n  string result ( n + 1, ' ' );\n  int count = 1;\n  for ( int i = 0;\n  i <= n;\n  i ++ ) {\n    if ( i == n || seq [ i ] == 'I' ) {\n      for ( int j = i - 1;\n      j >= - 1;\n      j -- ) {\n        result [ j + 1 ] = '0' + count ++;\n        if ( j >= 0 && seq [ j ] == 'I' ) break;\n      }\n    }\n  }\n  return result;\n}",
    "badcase": "string getMinNumberForPattern ( string seq ) {\n  int n = seq . length ( ) ;\n  if ( n >= 9 ) return \"-1\" ;\n  char result [ n + 1 ] ;\n  int count = 1 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i == n || seq [ i ] == 'I') {\n      for ( int j = i - 1 ;\n      j >= -1 ;\n      j -- ) {\n        result [ j + 1 ] = '0' + count ++ ;\n        if ( j >= 0 && seq [ j ] == 'I') break ;\n      }\n    }\n  }\n  return string ( result ) ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( string str ) {\n  int n = str . length ( );\n  int dp [ n + 1 ] [ 10 ];\n  memset ( dp, 0, sizeof ( dp ) );\n  int arr [ n + 1 ];\n  for ( int i = 1;\n  i <= n;\n  i ++ ) arr [ i ] = str [ i - 1 ] - '0';\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    dp [ i ] [ arr [ i ] % 8 ] = 1;\n    for ( int j = 0;\n    j < 8;\n    j ++ ) {\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ];\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ];\n    }\n  }\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    if ( dp [ i ] [ 0 ] == 1 ) return true;\n  }\n  return false;\n}",
    "badcase": "bool isSubSeqDivisible ( string str ) {\n  int n = str . length ( ) ;\n  int dp [ n + 1 ] [ 10 ] ;\n  int arr [ n + 1 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) arr [ i ] = str [ i - 1 ] - '0' ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    dp [ i ] [ arr [ i ] % 8 ] = 1 ;\n    for ( int j = 0 ;\n    j < 8 ;\n    j ++ ) {\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ;\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;\n    }\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    if ( dp [ i ] [ 0 ] == 1 ) return true ;\n  }\n  return false ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int a, int b, int k ) {\n  int p = pow ( a, b );\n  int count = 0;\n  while ( p > 0 && count < k ) {\n    int rem = p % 10;\n    count ++;\n    if ( count == k ) return rem;\n    p = p / 10;\n  }\n  return 0;\n}",
    "badcase": "int kthdigit ( int a , int b , int k ) {\n  int p = pow ( a , b ) ;\n  int count = 0 ;\n  while ( p > 0 && count < k ) {\n    int rem = p % 10 ;\n    count ++ ;\n    if ( count == k ) return rem ;\n    p = p / 10 ;\n  }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int k, string s1, string s2 ) {\n  int n = s1 . length ( );\n  int m = s2 . length ( );\n  int lcs [ n + 1 ] [ m + 1 ];\n  int cnt [ n + 1 ] [ m + 1 ];\n  memset ( lcs, 0, sizeof ( lcs ) );\n  memset ( cnt, 0, sizeof ( cnt ) );\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    for ( int j = 1;\n    j <= m;\n    j ++ ) {\n      lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ], lcs [ i ] [ j - 1 ] );\n      if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1;\n      if ( cnt [ i ] [ j ] >= k ) {\n        for ( int a = k;\n        a <= cnt [ i ] [ j ];\n        a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ], lcs [ i - a ] [ j - a ] + a );\n      }\n    }\n  }\n  return lcs [ n ] [ m ];\n}",
    "badcase": "int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) {\n  int n = s1 . length ( ) ;\n  int m = s2 . length ( ) ;\n  int lcs [ n + 1 ] [ m + 1 ] ;\n  int cnt [ n + 1 ] [ m + 1 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= m ;\n    j ++ ) {\n      lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ;\n      if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ;\n      if ( cnt [ i ] [ j ] >= k ) {\n        for ( int a = k ;\n        a <= cnt [ i ] [ j ] ;\n        a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ;\n      }\n    }\n  }\n  return lcs [ n ] [ m ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string str ) {\n  int n = str . length ( );\n  int dp [ n + 1 ] [ n + 1 ];\n  for ( int i = 0;\n  i <= n;\n  i ++ ) for ( int j = 0;\n  j <= n;\n  j ++ ) dp [ i ] [ j ] = 0;\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    for ( int j = 1;\n    j <= n;\n    j ++ ) {\n      if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ];\n      else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ], dp [ i - 1 ] [ j ] );\n    }\n  }\n  return dp [ n ] [ n ];\n}",
    "badcase": "int findLongestRepeatingSubSeq ( string str ) {\n  int n = str . length ( ) ;\n  int dp [ n + 1 ] [ n + 1 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;\n    }\n  }\n  return dp [ n ] [ n ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n, int num, int maxLimit) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, num, maxLimit);\n    } else {\n        return f_gold(arr, n, num, maxLimit);\n    }\n}",
    "badcase": "int findMaxVal(T arr, int n, int num, int maxLimit) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxVal(&arr.front(), n, num, maxLimit);\n    } else {\n        return findMaxVal(arr, n, num, maxLimit);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int maxSubArraySumRepeated(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxSubArraySumRepeated(&arr.front(), n, k);\n    } else {\n        return maxSubArraySumRepeated(arr, n, k);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int maxSumBitonicSubArr(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxSumBitonicSubArr(&arr.front(), n);\n    } else {\n        return maxSumBitonicSubArr(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string slots [ ], int n, int m ) {\n  int counts [ m ] = {\n    0 };\n    for ( int i = 0;\n    i < n;\n    i ++ ) for ( int j = 0;\n    j < m;\n    j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++;\n    return * max_element ( counts, counts + m );\n  }",
    "badcase": "int findMinRooms ( vector < string > & slots , int n , int m ) {\n  vector < int > counts ( m , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < m ;\n  j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ;\n  int max = -1 ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ;\n  return max ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T a, T b, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&a.front(), &b.front(), n, k);\n    } else {\n        return f_gold(a, b, n, k);\n    }\n}",
    "badcase": "int minproduct(T a, T b, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return minproduct(&a.front(), &b.front(), n, k);\n    } else {\n        return minproduct(a, b, n, k);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int N, int insert, int remove, int copy ) {\n  if ( N == 0 ) return 0;\n  if ( N == 1 ) return insert;\n  int dp [ N + 1 ];\n  memset ( dp, 0, sizeof ( dp ) );\n  for ( int i = 1;\n  i <= N;\n  i ++ ) {\n    if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert, dp [ i / 2 ] + copy );\n    else dp [ i ] = min ( dp [ i - 1 ] + insert, dp [ ( i + 1 ) / 2 ] + copy + remove );\n  }\n  return dp [ N ];\n}",
    "badcase": "int minTimeForWritingChars ( int N , int insert , int remove , int copy ) {\n  if ( N == 0 ) return 0 ;\n  if ( N == 1 ) return insert ;\n  int dp [ N + 1 ] ;\n  for ( int i = 1 ;\n  i <= N ;\n  i ++ ) {\n    if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ;\n    else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ;\n  }\n  return dp [ N ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "string f_gold ( string str, int n ) {\n  string reverseAlphabet = \"zyxwvutsrqponmlkjihgfedcba\";\n  int l = str . length ( );\n  for ( int i = n;\n  i < l;\n  i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - 'a' ];\n  return str;\n}",
    "badcase": "string compute ( string str , int n ) {\n  string reverseAlphabet = \"zyxwvutsrqponmlkjihgfedcba\" ;\n  int l = str . length ( ) ;\n  string answer = \"\" ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) answer = answer + str [ i ] ;\n  for ( int i = n ;\n  i < l ;\n  i ++ ) answer = answer + reverseAlphabet [ str [ i ] - 'a' ] ;\n  return answer ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string s, int K ) {\n  int n = s . length ( );\n  int C, c1 = 0, c2 = 0;\n  for ( int i = 0;\n  i < n;\n  i ++ ) {\n    if ( s [ i ] == 'a' ) c1 ++;\n    if ( s [ i ] == 'b' ) {\n      c2 ++;\n      C += c1;\n    }\n  }\n  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2;\n}",
    "badcase": "int countOccurrences ( string s , int K ) {\n  int n = s . length ( ) ;\n  int C = 0 , c1 = 0 , c2 = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == 'a' ) c1 ++ ;\n    if ( s [ i ] == 'b' ) {\n      c2 ++ ;\n      C += c1 ;\n    }\n  }\n  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( string & str ) {\n  vector < bool > mark ( 26, false );\n  int index;\n  for ( int i = 0;\n  i < str . length ( );\n  i ++ ) {\n    if ( 'A' <= str [ i ] && str [ i ] <= 'Z' ) index = str [ i ] - 'A';\n    else if ( 'a' <= str [ i ] && str [ i ] <= 'z' ) index = str [ i ] - 'a';\n    mark [ index ] = true;\n  }\n  for ( int i = 0;\n  i <= 25;\n  i ++ ) if ( mark [ i ] == false ) return ( false );\n  return ( true );\n}",
    "badcase": "bool checkPangram ( string & str ) {\n  vector < bool > mark ( 26 , false ) ;\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( ' A ' <= str [ i ] && str [ i ] <= ' Z ' ) mark [ str [ i ] - ' A ' ] = true ;\n    else if ( ' a ' <= str [ i ] && str [ i ] <= ' z ' ) mark [ str [ i ] - ' a ' ] = true ;\n  }\n  for ( int i = 0 ;\n  i <= 25 ;\n  i ++ ) if ( mark [ i ] == false ) return false ;\n  return true ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int N, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), N, k);\n    } else {\n        return f_gold(arr, N, k);\n    }\n}",
    "badcase": "int maxDifference ( int arr [ ] , int N , int k ) {\n  int M , S = 0 , S1 = 0 , max_difference = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) S += arr [ i ] ;\n  sort ( arr , arr + N ) ;\n  M = max ( k , N - k ) ;\n  for ( int i = 0 ;\n  i < M ;\n  i ++ ) S1 += arr [ i ] ;\n  max_difference = S1 - ( S - S1 ) ;\n  return max_difference ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold(T arr, int N) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), N);\n    } else {\n        return f_gold(arr, N);\n    }\n}",
    "badcase": "bool isPossibleTriangle(T arr, int N) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return isPossibleTriangle(&arr.front(), N);\n    } else {\n        return isPossibleTriangle(arr, N);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( int n ) {\n  if ( n <= 1 ) return false;\n  if ( n <= 3 ) return true;\n  if ( n % 2 == 0 || n % 3 == 0 ) return false;\n  for ( int i = 5;\n  i * i <= n;\n  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false;\n  return true;\n}",
    "badcase": "bool isPrime ( int n ) {\n  if ( n <= 1 ) return false ;\n  if ( n <= 3 ) return true ;\n  if ( n % 2 == 0 n % 3 == 0 ) return false ;\n  for ( int i = 5 ;\n  i * i <= n ;\n  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;\n  return true ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "bool f_gold ( int p ) {\n  long long checkNumber = pow ( 2, p ) - 1;\n  long long nextval = 4 % checkNumber;\n  for ( int i = 1;\n  i < p - 1;\n  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber;\n  return ( nextval == 0 );\n}",
    "badcase": "bool isPrime ( int p ) {\n  double checkNumber = pow ( 2 , p ) - 1 ;\n  double nextval = 4 % checkNumber ;\n  for ( int i = 1 ;\n  i < p - 1 ;\n  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;\n  return ( nextval == 0 ) ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int a, int b, bool x ) {\n  int arr [ ] = {\n    a, b };\n    return ( arr [ x ] );\n  }",
    "badcase": "int assignValue ( int a , int b , int x ) {\n  int arr [ ] = {\n    a , b }\n    ;\n    return ( arr [ x ] ) ;\n  }"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int n ) {\n  if ( n == 0 || n == 1 ) return n;\n  return max ( ( f_gold ( n / 2 ) + f_gold ( n / 3 ) + f_gold ( n / 4 ) ), n );\n}",
    "badcase": "int breakSum ( int n ) {\n  if ( n == 0 n == 1 ) return n ;\n  return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int x, int y, int z ) {\n  if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z;\n  return ( ! ( x / z ) ) ? x : z;\n}",
    "badcase": "int smallest ( int x , int y , int z ) {\n  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;\n  return ( ( x / z ) != 1 ) ? x : z ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T val, T wt, int n, int W) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&val.front(), &wt.front(), n, W);\n    } else {\n        return f_gold(val, wt, n, W);\n    }\n}",
    "badcase": "int KnapSack(T val, T wt, int n, int W) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return KnapSack(&val.front(), &wt.front(), n, W);\n    } else {\n        return KnapSack(val, wt, n, W);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int MaxTotalRectangleArea(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return MaxTotalRectangleArea(&arr.front(), n);\n    } else {\n        return MaxTotalRectangleArea(arr, n);\n    }\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( int n ) {\n  int table [ n + 1 ];\n  memset ( table, 0, sizeof ( table ) );\n  table [ 0 ] = 1;\n  for ( int i = 1;\n  i < n;\n  i ++ ) for ( int j = i;\n  j <= n;\n  j ++ ) table [ j ] += table [ j - i ];\n  return table [ n ];\n}",
    "badcase": "int countWays ( int n ) {\n  int table [ n + 1 ] ;\n  memset ( table , 0 , sizeof ( table ) ) ;\n  table [ 0 ] = 1 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) for ( int j = i ;\n  j <= n ;\n  j ++ ) table [ j ] += table [ j - i ] ;\n  return table [ n ] ;\n}"
  },
  {
    "type": "java_to_cpp",
    "GT": "int f_gold ( string a, string b ) {\n  int n = a . size ( ), m = b . size ( );\n  if ( m == 0 ) return 1;\n  int dp [ m + 1 ] [ n + 1 ];\n  memset ( dp, 0, sizeof ( dp ) );\n  for ( int i = 0;\n  i < m;\n  i ++ ) {\n    for ( int j = i;\n    j < n;\n    j ++ ) {\n      if ( i == 0 ) {\n        if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0;\n        else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1;\n        else dp [ i ] [ j ] = dp [ i ] [ j - 1 ];\n      }\n      else {\n        if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ];\n        else dp [ i ] [ j ] = dp [ i ] [ j - 1 ];\n      }\n    }\n  }\n  return dp [ m - 1 ] [ n - 1 ];\n}",
    "badcase": "int countTransformation ( string a , string b ) {\n  int n = a . length ( ) , m = b . length ( ) ;\n  if ( m == 0 ) {\n    return 1 ;\n  }\n  int dp [ m + 1 ] [ n + 1 ] ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      if ( i == 0 ) {\n        if ( j == 0 ) {\n          dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ;\n        }\n        else if ( a [ j ] == b [ i ] ) {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ;\n        }\n        else {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;\n        }\n      }\n      else if ( a [ j ] == b [ i ] ) {\n        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ;\n      }\n      else {\n        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;\n      }\n    }\n  }\n  return dp [ m - 1 ] [ n - 1 ] ;\n}"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( h , m ) :\n    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :\n        print ( 'Wrong input' )\n    if ( h == 12 ) :\n        h = 0\n    if ( m == 60 ) :\n        m = 0\n    hour_angle = 0.5 * ( h * 60 + m )\n    minute_angle = 6 * m\n    angle = abs ( hour_angle - minute_angle )\n    angle = min ( 360 - angle , angle )\n    return angle",
    "badcase": "def calcAngle ( h , m ) :\n    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :\n        print ( \"Wrong input\" )\n    if ( h == 12 ) :\n        h = 0\n    if ( m == 60 ) :\n        m = 0\n    hour_angle = 0.5 * ( h * 60 + m )\n    minute_angle = 6 * m\n    angle = abs ( hour_angle - minute_angle )\n    angle = min ( 360 - angle , angle )\n    return int ( angle )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    i = 0\n    j = n - 1\n    while i < n :\n        if ( i < n // 2 ) :\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        elif ( i > n // 2 ) :\n            diag1_right += mat [ i ] [ i ]\n            diag2_right += mat [ j ] [ i ]\n        i += 1\n        j -= 1\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )",
    "badcase": "def HalfDiagonalSums ( mat , n ) :\n    diag1_left = 0\n    diag1_right = 0\n    diag2_left = 0\n    diag2_right = 0\n    for i in range ( n ) :\n        j = n - i - 1\n        if ( i < n / 2 ) :\n            diag1_left += mat [ i ] [ i ]\n            diag2_left += mat [ j ] [ i ]\n        elif ( i > n / 2 ) :\n            diag1_right += mat [ i ] [ i ]\n            diag2_right += mat [ j ] [ i ]\n    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( s ) :\n    if ( len ( s ) >= 10 ) :\n        return True\n    for i in range ( 1 , len ( s ) ) :\n        for j in range ( i + 1 , len ( s ) ) :\n            for k in range ( j + 1 , len ( s ) ) :\n                s1 = s [ 0 : i ]\n                s2 = s [ i : j - i ]\n                s3 = s [ j : k - j ]\n                s4 = s [ k : len ( s ) - k ]\n                if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) :\n                    return True\n    return False",
    "badcase": "def check ( s ) :\n    if len ( s ) >= 10 :\n        return True\n    for i in range ( 1 , len ( s ) ) :\n        for j in range ( i + 1 , len ( s ) ) :\n            for k in range ( j + 1 , len ( s ) ) :\n                s1 = s [ 0 : i ]\n                s2 = s [ i : j - i ]\n                s3 = s [ j : k - j ]\n                s4 = s [ k : len ( s ) - k ]\n                if ( strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s1 , s4 ) and strcheck ( s2 , s3 ) and strcheck ( s2 , s4 ) and strcheck ( s3 , s4 ) ) :\n                    return True\n    return False"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    if ( n < 1 ) :\n        return False\n    Min = min ( arr )\n    Max = max ( arr )\n    if ( Max - Min + 1 == n ) :\n        visited = [ False for i in range ( n ) ]\n        for i in range ( n ) :\n            if ( visited [ arr [ i ] - Min ] != False ) :\n                return False\n            visited [ arr [ i ] - Min ] = True\n        return True\n    return False",
    "badcase": "def areConsecutive ( arr , n ) :\n    if ( n < 1 ) :\n        return False\n    min = min ( arr )\n    max = max ( arr )\n    if ( max - min + 1 == n ) :\n        visited = [ False ] * ( n )\n        for i in range ( n ) :\n            if ( visited [ arr [ i ] - min ] != False ) :\n                return False\n            visited [ arr [ i ] - min ] = True\n        return True\n    return False"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( x , y ) :\n    res1 = math.log ( y ) / math.log ( x ) ;\n    res2 = math.log ( y ) / math.log ( x ) ;\n    return 1 if ( res1 == res2 ) else 0 ;\n\n\nimport math",
    "badcase": "def isPower ( x , y ) :\n    res1 = int ( math.log ( y ) / math.log ( x ) )\n    res2 = math.log ( y ) / math.log ( x )\n    return ( res1 == res2 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a * b\n    if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :\n        result = 0\n    if ( a == ( result // b ) ) :\n        print ( result // b )\n        return False\n    else :\n        return True",
    "badcase": "def isOverflow ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return False\n    result = a * b\n    if ( a == result // b ) :\n        return False\n    else :\n        return True"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    for i in range ( length - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )",
    "badcase": "def checkDivisibility ( num ) :\n    length = len ( num )\n    if ( length == 1 and num [ 0 ] == '0' ) :\n        return True\n    if ( length % 3 == 1 ) :\n        num += \"00\"\n        length += 2\n    elif ( length % 3 == 2 ) :\n        num += \"0\"\n        length += 1\n    sum = 0\n    p = 1\n    i = length - 1\n    while ( i >= 0 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        sum = sum + group * p\n        p *= ( - 1 )\n    sum = abs ( sum )\n    return ( sum % 13 == 0 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    for i in range ( 1 , n ) :\n        if arr [ i - 1 ] < arr [ i ] :\n            if ( i == n ) :\n                return True\n    j = i\n    while ( arr [ j ] < arr [ j - 1 ] ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j += 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k += 1\n    return True",
    "badcase": "def checkReverse ( arr , n ) :\n    if ( n == 1 ) :\n        return True\n    i = 1\n    while ( arr [ i - 1 ] < arr [ i ] and i < n ) :\n        i += 1\n    if ( i == n ) :\n        return True\n    j = i\n    i += 1\n    while ( j < n ) :\n        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :\n            return False\n        j += 1\n    if ( j == n ) :\n        return True\n    k = j\n    if ( arr [ k ] < arr [ i - 1 ] ) :\n        return False\n    while ( k > 1 and k < n ) :\n        if ( arr [ k ] < arr [ k - 1 ] ) :\n            return False\n        k += 1\n    return True"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , b ) :\n    return floor ( ( a + b ) / 2 )",
    "badcase": "def compute_average ( a , b ) :\n    return ( a + b ) / 2"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( k + 1 ) :\n            dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n            if j >= 1 :\n                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]",
    "badcase": "def countStrings ( n , k ) :\n    dp = [ [ [ 0 , 0 ] for i in range ( 2 ) ] for j in range ( k + 1 ) ] for i in range ( n + 1 ) ]\n    dp [ 1 ] [ 0 ] [ 0 ] = 1\n    dp [ 1 ] [ 0 ] [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( min ( i , k + 1 ) ) :\n            dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )\n            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]\n            if ( j - 1 >= 0 ) :\n                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]\n    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    nCr = 1\n    res = 1\n    for r in range ( 1 , n + 1 ) :\n        nCr = ( nCr * ( n + 1 - r ) ) / r ;\n        res += nCr * nCr ;\n    return res ;",
    "badcase": "def countSeq ( n ) :\n    nCr = 1\n    res = 1\n    for r in range ( 1 , n + 1 ) :\n        nCr = ( nCr * ( n + 1 - r ) ) // r\n        res += nCr * nCr\n    return res"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n , r , b , g ) :\n    fact = [ 0 for i in range ( n + 1 ) ]\n    fact [ 0 ] = 1\n    for i in range ( 1 , n + 1 , 1 ) :\n        fact [ i ] = fact [ i - 1 ] * i\n    left = n - ( r + g + b )\n    sum = 0\n    for i in range ( 0 , left + 1 , 1 ) :\n        for j in range ( 0 , left - i + 1 , 1 ) :\n            k = left - ( i + j )\n            sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) )\n    return sum",
    "badcase": "def possibleStrings ( n , r , b , g ) :\n    fact = [ 0 ] * ( n + 1 )\n    fact [ 0 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        fact [ i ] = fact [ i - 1 ] * i\n    left = n - ( r + g + b )\n    sum = 0\n    for i in range ( left + 1 ) :\n        for j in range ( left - i + 1 ) :\n            k = left - ( i + j )\n            sum = sum + fact [ n ] // ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] )\n    return sum"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold(n):\n    k = n\n    imin = 1\n    ans = 0\n    while (imin <= n):\n        imax = n / k\n        ans += k * (imax - imin + 1)\n        imin = imax + 1\n        k = n / imin\n    return ans",
    "badcase": "def CountPairs ( n ) :\n    k = n\n    imin = 1\n    ans = 0\n    while ( imin <= n ) :\n        imax = n // k\n        ans += k * ( imax - imin + 1 )\n        imin = imax + 1\n        k = n // imin\n    return ans"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( digits , n ) :\n    count = [ 0 ] * ( n + 1 ) ;\n    count [ 0 ] = 1 ;\n    count [ 1 ] = 1 ;\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0 ;\n        if ( digits [ i - 1 ] > '0' ) :\n            count [ i ] = count [ i - 1 ] ;\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] += count [ i - 2 ] ;\n    return count [ n ] ;",
    "badcase": "def countDecodingDP ( digits , n ) :\n    count = [ 0 for i in range ( n + 1 ) ]\n    count [ 0 ] = 1\n    count [ 1 ] = 1\n    if digits [ 0 ] == '0' :\n        return 0\n    for i in range ( 2 , n + 1 ) :\n        count [ i ] = 0\n        if digits [ i - 1 ] > '0' :\n            count [ i ] = count [ i - 1 ]\n        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :\n            count [ i ] += count [ i - 2 ]\n    return count [ n ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( mat , r , c ) :\n    result = 0\n    for i in range ( r ) :\n        j = 0\n        for j in range ( c - 1 ) :\n            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :\n                break\n        if j == c - 2 :\n            result += 1\n    for i in range ( 0 , r ) :\n        j = 0\n        for j in range ( c - 1 , 0 , - 1 ) :\n            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :\n                break\n        if c > 1 and j == 1 :\n            result += 1\n    return result",
    "badcase": "def sortedCount ( mat , r , c ) :\n    result = 0\n    for i in range ( r ) :\n        j = 0\n        while ( j < c - 1 ) :\n            if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) :\n                break\n            j += 1\n        if ( j == c - 1 ) :\n            result += 1\n    for i in range ( r ) :\n        j = c - 1\n        while ( j > 0 ) :\n            if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) :\n                break\n            j -= 1\n        if ( c > 1 and j == 0 ) :\n            result += 1\n    return result"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    return max ( arr )",
    "badcase": "def largest ( arr , n ) :\n    arr.sort ( )\n    return arr [ n - 1 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( m , n , x ) :\n    table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]\n    for j in range ( 1 , min ( m + 1 , x + 1 ) ) :\n        table [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 1 , x + 1 ) :\n            for k in range ( 1 , min ( m + 1 , j ) ) :\n                table [ i ] [ j ] += table [ i - 1 ] [ j - k ]\n    return table [ - 1 ] [ - 1 ]",
    "badcase": "def findWays ( m , n , x ) :\n    table = [ [ 0 for i in range ( x + 1 ) ] for j in range ( n + 1 ) ]\n    for j in range ( 1 , m + 1 , 1 ) :\n        table [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 , 1 ) :\n        for j in range ( 1 , x + 1 , 1 ) :\n            for k in range ( 1 , j ) :\n                if ( k <= m ) :\n                    table [ i ] [ j ] += table [ i - 1 ] [ j - k ]\n    return table [ n ] [ x ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    if ( n == 0 or n == 9 ) :\n        return True\n    if ( n < 9 ) :\n        return False\n    return f_gold ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )",
    "badcase": "def isDivBy9 ( n ) :\n    if ( n == 0 or n == 9 ) :\n        return True\n    if ( n < 9 ) :\n        return False\n    return isDivBy9 ( n >> 3 - n & 7 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    max = 0\n    msis = [ 0 for x in range ( n ) ]\n    for i in range ( n ) :\n        msis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :\n                msis [ i ] = msis [ j ] + arr [ i ]\n    for i in range ( n ) :\n        if max < msis [ i ] :\n            max = msis [ i ]\n    return max",
    "badcase": "def maxSumIS ( arr , n ) :\n    msis = [ 0 ] * n\n    for i in range ( n ) :\n        msis [ i ] = arr [ i ]\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :\n                msis [ i ] = msis [ j ] + arr [ i ]\n    for i in range ( n ) :\n        if max < msis [ i ] :\n            max = msis[i]\n    return max"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( str ) :\n    n = len ( str )\n    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]\n    j = 0\n    k = 0\n    L = 0\n    for i in range ( n ) :\n        P [ i ] [ i ] = True ;\n        C [ i ] [ i ] = 0 ;\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L - 1\n            if L == 2 :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )\n            if P [ i ] [ j ] == True :\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = 100000000\n                for k in range ( i , j ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n    return C [ 0 ] [ n - 1 ]",
    "badcase": "def minPalPartion ( str ) :\n    n = len ( str )\n    C = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n        C [ i ] [ i ] = 0\n    for L in range ( 2 , n + 1 ) :\n        for i in range ( n - L + 1 ) :\n            j = i + L - 1\n            if ( L == 2 ) :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] )\n            else :\n                P [ i ] [ j ] = ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ]\n            if ( P [ i ] [ j ] == True ) :\n                C [ i ] [ j ] = 0\n            else :\n                C [ i ] [ j ] = 9999999999999\n                for k in range ( i , j - 1 ) :\n                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )\n    return C [ 0 ] [ n - 1 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( str , l , h ) :\n    if ( l > h ) :\n        return sys.maxsize\n    if ( l == h ) :\n        return 0\n    if ( l == h - 1 ) :\n        return 0 if ( str [ l ] == str [ h ] ) else 1\n    if ( str [ l ] == str [ h ] ) :\n        return f_gold ( str , l + 1 , h - 1 )\n    else :\n        return ( min ( f_gold ( str , l , h - 1 ) , f_gold ( str , l + 1 , h ) ) + 1 )",
    "badcase": "def findMinInsertions ( str , l , h ) :\n    if ( l > h ) :\n        return float ( 'inf' )\n    if ( l == h ) :\n        return 0\n    if ( l == h - 1 ) :\n        return 0 if ( str [ l ] == str [ h ] ) else 1\n    return 0 if ( str [ l ] == str [ h ] ) else ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if symb [ i ] == 'F' :\n            F [ i ] [ i ] = 1\n        else :\n            F [ i ] [ i ] = 0\n        if symb [ i ] == 'T' :\n            T [ i ] [ i ] = 1\n        else :\n            T [ i ] [ i ] = 0\n    for gap in range ( 1 , n ) :\n        i = 0\n        for j in range ( gap , n ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                if oper [ k ] == '^' :\n                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )\n                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n            i += 1\n    return T [ 0 ] [ n - 1 ]",
    "badcase": "def countParenth ( symb , oper , n ) :\n    F = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    T = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n ) :\n        F [ i ] [ i ] = 1 if symb [ i ] == 'F' else 0\n        T [ i ] [ i ] = 1 if symb [ i ] == 'T' else 0\n    for gap in range ( 1 , n ) :\n        for i , j in enumerate ( range ( n ) ) :\n            T [ i ] [ j ] = F [ i ] [ j ] = 0\n            for g in range ( gap ) :\n                k = i + g\n                tik = T [ i ] [ k ] + F [ i ] [ k ]\n                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ]\n                if oper [ k ] == '&' :\n                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]\n                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )\n                if oper [ k ] == '|' :\n                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]\n                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )\n    return T [ 0 ] [ n - 1 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n , p ) :\n    ans = 0 ;\n    temp = p ;\n    while ( temp <= n ) :\n        ans += n / temp ;\n        temp = temp * p ;\n    return ans ;",
    "badcase": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    for i in range ( 1 , n + 1 ) :\n        count = 0\n        temp = i\n        while ( temp % p == 0 ) :\n            count += 1\n            temp = temp // p\n        ans += count\n    return ans"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += n / temp\n        temp = temp * p\n    return int ( ans )",
    "badcase": "def PowerOFPINnfactorial ( n , p ) :\n    ans = 0\n    temp = p\n    while ( temp <= n ) :\n        ans += n // temp\n        temp = temp * p\n    return ans"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        k = 0\n        for j in range ( i , i + n ) :\n            if brr [ j ] != arr [ k ] :\n                currHam += 1\n                k = k + 1\n        if currHam == n :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam",
    "badcase": "def maxHamming ( arr , n ) :\n    brr = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        brr [ i ] = arr [ i ]\n    for i in range ( n ) :\n        brr [ n + i ] = arr [ i ]\n    maxHam = 0\n    for i in range ( 1 , n ) :\n        currHam = 0\n        for j , k in zip ( range ( i , i + n ) , range ( n ) ) :\n            if ( brr [ j ] != arr [ k ] ) :\n                currHam += 1\n        if ( currHam == n ) :\n            return n\n        maxHam = max ( maxHam , currHam )\n    return maxHam"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( S , n ) :\n    found = False\n    S.sort ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        for j in range ( 0 , n ) :\n            if ( i == j ) :\n                continue\n            for k in range ( j + 1 , n ) :\n                if ( i == k ) :\n                    continue\n                for l in range ( k + 1 , n ) :\n                    if ( i == l ) :\n                        continue\n                    if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :\n                        found = True\n                        return S [ i ]\n    if ( found == False ) :\n        return - 1",
    "badcase": "def findLargestd ( S , n ) :\n    found = False\n    S.sort ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        for j in range ( n ) :\n            if ( i == j ) :\n                continue\n            for k in range ( j + 1 , n ) :\n                if ( i == k ) :\n                    continue\n                for l in range ( k + 1 , n ) :\n                    if ( i == l ) :\n                        continue\n                    if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :\n                        found = True\n                        return S [ i ]\n    if ( found == False ) :\n        return float ( 'inf' )\n    return - 1"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            mp [ arr [ i ] + arr [ j ] ] = ( i , j )\n    d = - 10 ** 9\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            abs_diff = abs ( arr [ i ] - arr [ j ] )\n            if abs_diff in mp.keys ( ) :\n                p = mp [ abs_diff ]\n                if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) :\n                    d = max ( d , max ( arr [ i ] , arr [ j ] ) )\n    return d\n\n\nimport sys",
    "badcase": "def findFourElements ( arr , n ) :\n    map = dict ( )\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            map [ arr [ i ] + arr [ j ] ] = [ i , j ]\n    d = - sys.maxsize - 1\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            abs_diff = abs ( arr [ i ] - arr [ j ] )\n            if abs_diff in map :\n                indexes = map [ abs_diff ]\n                if ( indexes [ 0 ] != i and indexes [ 0 ] != j and indexes [ 1 ] != i and indexes [ 1 ] != j ) :\n                    d = max ( d , max ( arr [ i ] , arr [ j ] ) )\n    return d"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    maxPrime = - 1\n    while n % 2 == 0 :\n        maxPrime = 2\n        n >>= 1\n    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :\n        while n % i == 0 :\n            maxPrime = i\n            n = n / i\n    if n > 2 :\n        maxPrime = n\n    return int ( maxPrime )\n\n\nimport math",
    "badcase": "def maxPrimeFactors ( n ) :\n    maxPrime = - 1\n    while ( n % 2 == 0 ) :\n        maxPrime = 2\n        n >>= 1\n    for i in range ( 3 , int ( math.sqrt ( n ) ) , 2 ) :\n        while ( n % i == 0 ) :\n            maxPrime = i\n            n = n / i\n    if ( n > 2 ) :\n        maxPrime = n\n    return maxPrime"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    arr = sorted ( arr )\n    diff = 10 ** 20\n    for i in range ( n - 1 ) :\n        if arr [ i + 1 ] - arr [ i ] < diff :\n            diff = arr [ i + 1 ] - arr [ i ]\n    return diff",
    "badcase": "def findMinDiff ( arr , n ) :\n    arr.sort ( )\n    diff = 9999999999999\n    for i in range ( n - 1 ) :\n        if ( arr [ i + 1 ] - arr [ i ] < diff ) :\n            diff = arr [ i + 1 ] - arr [ i ]\n    return diff"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )",
    "badcase": "def findRepeating ( arr , n ) :\n    sum = 0\n    for i in range ( n ) :\n        sum += arr [ i ]\n    return sum - ( ( ( n - 1 ) * n ) // 2 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n + 1 ) ) :\n            if j == 0 or j == i :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    sum = 0 ;\n    for i in range ( 0 , n + 1 ) :\n        if n % 2 == 0 :\n            sum = sum + C [ n ] [ i ]\n    return sum",
    "badcase": "def evenSum ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )\n    sum = 0\n    for i in range ( 0 , n + 1 , 2 ) :\n        sum += C [ n ] [ i ]\n    return sum"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , low , high ) :\n    max = arr [ low ]\n    i = low\n    for i in range ( high + 1 ) :\n        if arr [ i ] > max :\n            max = arr [ i ]\n    return max",
    "badcase": "def findMaximum ( arr , low , high ) :\n    max = arr [ low ]\n    for i in range ( low , high + 1 ) :\n        if arr [ i ] > max :\n            max = arr [ i ]\n    return max"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n , x , y ) :\n    min_dist = 99999999\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) :\n                min_dist = abs ( i - j )\n        return min_dist",
    "badcase": "def minDist ( arr , n , x , y ) :\n    min_dist = 9999999999999\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) ) :\n                min_dist = abs ( i - j )\n    return min_dist"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( y , x ) :\n    return ( y % pow ( 2 , x ) )",
    "badcase": "def yMod ( y , x ) :\n    if ( math.log ( y ) / math.log ( 2 ) ) < x :\n        return y\n    if x > 63 :\n        return y\n    return ( y % ( 1 << x ) )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    count = 0\n    if ( n and ( not ( n & ( n - 1 ) ) ) ) :\n        while ( n > 1 ) :\n            n >>= 1\n            count += 1\n        if ( count % 2 == 0 ) :\n            return True\n        else :\n            return False",
    "badcase": "def isPowerOfFour ( n ) :\n    count = 0\n    x = n & ( n - 1 )\n    if ( n > 0 and x == 0 ) :\n        while ( n > 1 ) :\n            n >>= 1\n            count += 1\n        return 1 if ( count % 2 == 0 ) else 0\n    return 0"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ None ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = int ( '0' + str ( count ) )\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return result",
    "badcase": "def getMinNumberForPattern ( seq ) :\n    n = len ( seq )\n    if ( n >= 9 ) :\n        return \"-1\"\n    result = [ 0 ] * ( n + 1 )\n    count = 1\n    for i in range ( n + 1 ) :\n        if ( i == n or seq [ i ] == 'I' ) :\n            for j in range ( i - 1 , - 2 , - 1 ) :\n                result [ j + 1 ] = ord ( '0' ) + count\n                count += 1\n                if ( j >= 0 and seq [ j ] == 'I' ) :\n                    break\n    return \"\".join ( result )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n , x ) :\n    for i in range ( n ) :\n        if arr [ i ] > arr [ i + 1 ] :\n            break\n    l = ( i + 1 ) % n\n    r = i\n    cnt = 0\n    while ( l != r ) :\n        if arr [ l ] + arr [ r ] == x :\n            cnt += 1\n            if l == ( r - 1 + n ) % n :\n                return cnt\n            l = ( l + 1 ) % n\n            r = ( r - 1 + n ) % n\n        elif arr [ l ] + arr [ r ] < x :\n            l = ( l + 1 ) % n\n        else :\n            r = ( n + r - 1 ) % n\n    return cnt",
    "badcase": "def pairsInSortedRotated ( arr , n , x ) :\n    for i in range ( n - 1 ) :\n        if ( arr [ i ] > arr [ i + 1 ] ) :\n            break\n    l = ( i + 1 ) % n\n    r = i\n    cnt = 0\n    while ( l != r ) :\n        if ( arr [ l ] + arr [ r ] == x ) :\n            cnt += 1\n            if ( l == ( r - 1 + n ) % n ) :\n                return cnt\n            l = ( l + 1 ) % n\n            r = ( r - 1 + n ) % n\n        elif ( arr [ l ] + arr [ r ] < x ) :\n            l = ( l + 1 ) % n\n        else :\n            r = ( n + r - 1 ) % n\n    return cnt"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    index = 0\n    while index < n :\n        if index == 0 :\n            index = index + 1\n        if arr [ index ] >= arr [ index - 1 ] :\n            index = index + 1\n        else :\n            arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ]\n            index = index - 1\n    return arr",
    "badcase": "def gnomeSort ( arr , n ) :\n    index = 0\n    while index < n :\n        if index == 0 :\n            index = index + 1\n        if arr [ index ] >= arr [ index - 1 ] :\n            index = index + 1\n        else :\n            temp = 0\n            temp = arr [ index ]\n            arr [ index ] = arr [ index - 1 ]\n            arr [ index - 1 ] = temp\n            index = index - 1\n    return"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0 ;\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ;\n                nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]",
    "badcase": "def maxRevenue ( m , x , revenue , n , t ) :\n    maxRev = [ 0 ] * ( m + 1 )\n    nxtbb = 0\n    for i in range ( 1 , m + 1 ) :\n        if ( nxtbb < n ) :\n            if ( x [ nxtbb ] != i ) :\n                maxRev [ i ] = maxRev [ i - 1 ]\n            else :\n                if ( i <= t ) :\n                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )\n                else :\n                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] )\n                    nxtbb += 1\n        else :\n            maxRev [ i ] = maxRev [ i - 1 ]\n    return maxRev [ m ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold(arr, n):\n    hash = dict()\n    maximum = 0\n    for i in arr:\n        if (i < 0):\n            if abs(i) not in hash.keys():\n                hash[abs(i)] = - 1\n            else:\n                hash[abs(i)] -= 1\n        else:\n            hash[i] = hash.get(i, 0) + 1\n    for i in arr:\n        if i in hash.keys() and hash[i] > 0:\n            return i\n    return - 1",
    "badcase": "def findInteger ( arr , n ) :\n    hash = { }\n    maximum = 0\n    for i in range ( n ) :\n        if ( arr [ i ] < 0 ) :\n            hash [ abs ( arr [ i ] ) ] = hash.get ( abs ( arr [ i ] ) , 0 ) - 1\n        else :\n            hash [ abs ( arr [ i ] ) ] = hash.get ( abs ( arr [ i ] ) , 0 ) + 1\n    for i in range ( n ) :\n        if ( hash [ arr [ i ] ] > 0 ) :\n            return arr [ i ]\n    return - 1"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , b , k ) :\n    p = a ** b\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p % 10\n        count = count + 1\n        if ( count == k ) :\n            return rem\n        p = p / 10 ;",
    "badcase": "def kthdigit ( a , b , k ) :\n    p = pow ( a , b )\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p % 10\n        count += 1\n        if ( count == k ) :\n            return rem\n        p = p // 10\n    return 0"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    hash_map = { } ;\n    curr_sum = 0 ;\n    max_len = 0 ;\n    ending_index = - 1 ;\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1 ;\n        else :\n            arr [ i ] = 1 ;\n    for i in range ( 0 , n ) :\n        curr_sum = curr_sum + arr [ i ] ;\n        if ( curr_sum == 0 ) :\n            max_len = i + 1 ;\n            ending_index = i ;\n        if ( curr_sum + n ) in hash_map :\n            max_len = max ( max_len , i - hash_map [ curr_sum + n ] )\n        else :\n            hash_map [ curr_sum ] = i ;\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0 ;\n        else :\n            arr [ i ] = 1 ;\n    print ( ending_index - max_len + 1 , end = \" \" ) ;\n    print ( \"to\" , end = \" \" ) ;\n    print ( ending_index ) ;\n    return max_len ;",
    "badcase": "def maxLen ( arr , n ) :\n    hM = dict ( )\n    sum = 0\n    max_len = 0\n    ending_index = - 1\n    start_index = 0\n    for i in range ( n ) :\n        if ( arr [ i ] == 0 ) :\n            arr [ i ] = - 1\n        else :\n            arr [ i ] = 1\n    for i in range ( n ) :\n        sum += arr [ i ]\n        if ( sum == 0 ) :\n            max_len = i + 1\n            ending_index = i\n        if sum + n in hM :\n            if max_len < i - hM [ sum + n ] :\n                max_len = i - hM [ sum + n ]\n                ending_index = i\n        else :\n            hM [ sum + n ] = i\n    for i in range ( n ) :\n        if ( arr [ i ] == - 1 ) :\n            arr [ i ] = 0\n        else :\n            arr [ i ] = 1\n    end = ending_index - max_len + 1\n    print ( end , \"to\" , ending_index )\n    return max_len"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n                while ( i >= 0 ) :\n                    L [ i ] [ j ] = 2\n                    i -= 1\n    return llap",
    "badcase": "def lenghtOfLongestAP ( set , n ) :\n    if n <= 2 :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while i >= 0 and k <= n - 1 :\n            if set [ i ] + set [ k ] < 2 * set [ j ] :\n                k += 1\n            elif set [ i ] + set [ k ] > 2 * set [ j ] :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n        while i >= 0 :\n            L [ i ] [ j ] = 2\n            i -= 1\n    return llap"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    string = 'zyxwvutsrqponmlkjihgfedcba'\n    for ch in string :\n        cnt = 0\n        for i in range ( last , n ) :\n            if s [ i ] == ch :\n                cnt += 1\n        if cnt >= k :\n            for i in range ( last , n ) :\n                if s [ i ] == ch :\n                    t [ size ] = ch\n                    new_last = i\n                    size += 1\n            last = new_last",
    "badcase": "def subsequence ( s , t , n , k ) :\n    last = 0\n    cnt = 0\n    new_last = 0\n    size = 0\n    for ch in range ( ord ( 'z' ) , ord ( 'a' ) - 1 , - 1 ) :\n        cnt = 0\n        for i in range ( last , n ) :\n            if ( s [ i ] == ch ) :\n                cnt += 1\n        if ( cnt >= k ) :\n            for i in range ( last , n ) :\n                if ( s [ i ] == ch ) :\n                    t [ size ] = ch\n                    size += 1\n                    new_last = i\n            last = new_last\n    t [ size ] = '\\0'"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 )\n    return s",
    "badcase": "def nextWord ( st ) :\n    if ( st == \"\" ) :\n        return \"a\"\n    i = len ( st ) - 1\n    while ( st [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        st += 'a'\n    else :\n        st = st [ 0 : i ] + chr ( ord ( st [ i ] ) + 1 ) + st [ i + 1 : ]\n    return st"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True , str",
    "badcase": "def prevPermutation ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = str [ : i - 1 ] + str [ j ] + str [ i : j ] + str [ i - 1 ] + str [ j + 1 : ]\n    str = str [ : : - 1 ]\n    return str"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( s ) :\n    n = len ( s )\n    lps = [ 0 ] * n\n    l = 0\n    i = 1\n    while ( i < n ) :\n        if ( s [ i ] == s [ l ] ) :\n            l = l + 1\n            lps [ i ] = l\n            i = i + 1\n        else :\n            if ( l != 0 ) :\n                l = lps [ l - 1 ]\n            else :\n                lps [ i ] = 0\n                i = i + 1\n    res = lps [ n - 1 ]\n    if ( res > n / 2 ) :\n        return n // 2\n    else :\n        return res",
    "badcase": "def longestPrefixSuffix ( s ) :\n    n = len ( s )\n    lps = [ 0 for i in range ( n ) ]\n    lps [ 0 ] = 0\n    len = 0\n    i = 1\n    while ( i < n ) :\n        if ( s [ i ] == s [ len ] ) :\n            len += 1\n            lps [ i ] = len\n            i += 1\n        else :\n            if ( len != 0 ) :\n                len = lps [ len - 1 ]\n            else :\n                lps [ i ] = 0\n                i += 1\n    res = lps [ n - 1 ]\n    if ( res > n / 2 ) :\n        return n / 2\n    else :\n        return res"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    um = { i : 0 for i in range ( 10 ) }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if arr [ i ] == 0 :\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen",
    "badcase": "def lenOfLongSubarr ( arr , n ) :\n    um = dict ( )\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if ( arr [ i ] == 0 ) :\n            sum -= 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( s ) :\n    length = int ( s / 3 )\n    s -= length\n    breadth = s / 2\n    height = s - breadth\n    return int ( length * breadth * height )",
    "badcase": "def maxvolume ( s ) :\n    length = s // 3\n    s -= length\n    breadth = s // 2\n    height = s - breadth\n    return length * breadth * height"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    arr.sort ( reverse = True )\n    dimension = [ 0 , 0 ]\n    i = 0\n    j = 0\n    while ( i < n - 1 and j < 2 ) :\n        if ( arr [ i ] == arr [ i + 1 ] ) :\n            dimension [ j ] = arr [ i ]\n            j += 1\n            i += 1\n        i += 1\n    return ( dimension [ 0 ] * dimension [ 1 ] )",
    "badcase": "def findArea ( arr , n ) :\n    arr.sort ( reverse = True )\n    dimension = [ 0 , 0 ]\n    i = 0\n    j = 0\n    while i < n - 1 and j < 2 :\n        if arr [ i ] == arr [ i + 1 ] :\n            dimension [ j ] = arr [ i ]\n            j += 1\n            i += 1\n    return ( dimension [ 0 ] * dimension [ 1 ] )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( A , K ) :\n    n = len ( A ) ;\n    pre_sum = [ 0 ] * ( n + 1 ) ;\n    pre_sum [ 0 ] = 0 ;\n    for i in range ( n ) :\n        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;\n    dp = [ 0 ] * n ;\n    sum = 0 ;\n    for i in range ( n ) :\n        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ;\n    for k in range ( K - 1 ) :\n        for i in range ( n ) :\n            for j in range ( i + 1 , n ) :\n                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ;\n    return int ( dp [ 0 ] ) ;",
    "badcase": "def largestSumOfAverages ( A , K ) :\n    n = len ( A )\n    pre_sum = [ 0 ] * ( n + 1 )\n    for i in range ( n ) :\n        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]\n    dp = [ 0 ] * n\n    for i in range ( n ) :\n        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i )\n    for k in range ( K - 1 ) :\n        for i in range ( n ) :\n            for j in range ( i + 1 , n ) :\n                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] )\n    return dp [ 0 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( N ) :\n    dp = [ 0 for i in range ( N ) ]\n    dp [ 0 ] = 1\n    dp [ 1 ] = 2\n    i = 1\n    while dp [ i ] <= N :\n        i = i + 1\n        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]\n    return ( i - 1 )",
    "badcase": "def maxGameByWinner ( N ) :\n    dp = [ 0 ] * ( N + 1 )\n    dp [ 0 ] = 1\n    dp [ 1 ] = 2\n    i = 2\n    while dp [ i ] <= N :\n        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]\n        i += 1\n    return ( i - 2 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , n ) :\n    if n == 1 :\n        return a [ 0 ]\n    max_neg = - 999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( n ) :\n        if a [ i ] == 0 :\n            count_zero += 1\n            continue\n        if a [ i ] < 0 :\n            count_neg += 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod * a [ i ]\n    if count_zero == n :\n        return 0\n    if count_neg & 1 :\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = int ( prod / max_neg )\n    return prod",
    "badcase": "def maxProductSubset ( a , n ) :\n    if ( n == 1 ) :\n        return a [ 0 ]\n    max_neg = - 9999999999999\n    count_neg = 0\n    count_zero = 0\n    prod = 1\n    for i in range ( n ) :\n        if ( a [ i ] == 0 ) :\n            count_zero += 1\n            continue\n        if ( a [ i ] < 0 ) :\n            count_neg += 1\n            max_neg = max ( max_neg , a [ i ] )\n        prod = prod * a [ i ]\n    if ( count_zero == n ) :\n        return 0\n    if ( count_neg % 2 == 1 ) :\n        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :\n            return 0\n        prod = prod // max_neg\n    return prod"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , n , k ) :\n    max_so_far = - 2147483648\n    max_ending_here = 0\n    for i in range ( n * k ) :\n        max_ending_here = max_ending_here + a [ i % n ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far",
    "badcase": "def maxSubArraySumRepeated ( a , n , k ) :\n    max_so_far = 0\n    max_ending_here = 0\n    for i in range ( 0 , n * k ) :\n        max_ending_here = max_ending_here + a [ i % n ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n + 1 ) ]\n    inc = [ 0 for i in range ( n + 1 ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result",
    "badcase": "def maxAlternateSum ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n ) ]\n    inc = [ 0 for i in range ( n ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , N , k ) :\n    maxSum = 0 ;\n    arr.sort ( ) ;\n    i = N - 1 ;\n    while ( i >= 0 ) :\n        if ( arr [ i ] - arr [ i - 1 ] < k ) :\n            maxSum += arr [ i ] ;\n            maxSum += arr [ i - 1 ] ;\n            i -= 1 ;\n        i -= 1 ;\n    return maxSum ;",
    "badcase": "def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :\n    maxSum = 0\n    arr.sort ( )\n    i = N - 1\n    while i > 0 :\n        if arr [ i ] - arr [ i - 1 ] < k :\n            maxSum += arr [ i ]\n            maxSum += arr [ i - 1 ]\n            i -= 2\n        i -= 1\n    return maxSum"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    fw = [ 0 for k in range ( n ) ]\n    bw = [ 0 for k in range ( n ) ]\n    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]\n    for i in range ( n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    i = n - 2\n    while i >= 0 :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n        i -= 1\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans",
    "badcase": "def maxSumSubarrayRemovingOneEle ( arr , n ) :\n    fw = [ 0 ] * n\n    bw = [ 0 ] * n\n    cur_max = max_so_far = fw [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        fw [ i ] = cur_max\n    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )\n        max_so_far = max ( max_so_far , cur_max )\n        bw [ i ] = cur_max\n    fans = max_so_far\n    for i in range ( 1 , n - 1 ) :\n        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )\n    return fans"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    arr.sort ( )\n    return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )",
    "badcase": "def maxTripletSum ( arr , n ) :\n    arr.sort ( reverse = True )\n    return arr [ 0 ] + arr [ 1 ] + arr [ 2 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n    return ( m1 + m2 ) / 2",
    "badcase": "def getMedian ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n    return ( m1 + m2 ) // 2"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , b , c ) :\n    x = a - b\n    y = b - c\n    z = a - c\n    if x * y > 0 :\n        return b\n    elif ( x * z > 0 ) :\n        return\n    else :\n        return a",
    "badcase": "def middleOfThree ( a , b , c ) :\n    x = a - b\n    y = b - c\n    z = a - c\n    if ( x * y > 0 ) :\n        return b\n    elif ( x * z > 0 ) :\n        return c\n    else :\n        return a"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    for i in range ( 0 , n ) :\n        if ( ( max1 - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res += ( max1 - arr [ i ] ) / k\n    return int ( res )",
    "badcase": "def minOps ( arr , n , k ) :\n    arr.sort ( )\n    max = arr [ n - 1 ]\n    res = 0\n    for i in range ( n ) :\n        if ( ( max - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res += ( max - arr [ i ] ) // k\n    return res"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :\n        return float ( 'inf' )\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = float ( 'inf' )\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]\n\n\nimport sys",
    "badcase": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 or arr [ 0 ] == 0 ) :\n        return sys.maxsize\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = sys.maxsize\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] and jumps [ j ] != sys.maxsize ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = float ( 'inf' )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( 'inf' )\n            for j in range ( i + 1 , n ) :\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n            if ( min != float ( 'inf' ) ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]\n\n\nimport sys",
    "badcase": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    min1 = 0\n    jumps [ n - 1 ] = 0\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = sys.maxsize\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min1 = sys.maxsize\n            for j in range ( i + 1 , n and j <= arr [ i ] + i , 1 ) :\n                if ( min1 > jumps [ j ] ) :\n                    min1 = jumps [ j ]\n            if ( min1 != sys.maxsize ) :\n                jumps [ i ] = min1 + 1\n            else :\n                jumps [ i ] = min1\n    return jumps [ 0 ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    for i in range ( 0 , n ) :\n        count = 1\n        for i in range ( n - 1 ) :\n            if ar [ i ] == ar [ i + 1 ] :\n                count += 1\n            else :\n                break\n        res = max ( res , count )\n    return res",
    "badcase": "def subset ( ar , n ) :\n    res = 0\n    ar.sort ( )\n    for i in range ( n ) :\n        count = 1\n        while i < n - 1 and ar [ i ] == ar [ i + 1 ] :\n            i += 1\n            count += 1\n        res = max ( res , count )\n    return res"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    l = math.sqrt ( n )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = n / l\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter\n\n\nimport math",
    "badcase": "def minPerimeter ( n ) :\n    l = int ( math.sqrt ( n ) )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = n // l\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( str ) :\n    tmp = str + str\n    n = len ( str )\n    for i in range ( 1 , n + 1 ) :\n        substring = tmp [ i : n ]\n        if ( str == substring ) :\n            return i\n    return n",
    "badcase": "def findRotations ( str ) :\n    tmp = str + str ;\n    n = len ( str ) ;\n    for i in range ( 1 , n + 1 ) :\n        if ( str == tmp [ i : i + n ] ) :\n            return i ;\n    return n ;"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    arr.sort ( ) ;\n    min_xor = 999999\n    val = 0\n    for i in range ( 0 , n - 1 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            val = arr [ i ] ^ arr [ j ]\n            min_xor = min ( min_xor , val )\n    return min_xor",
    "badcase": "def minXOR ( arr , n ) :\n    min_xor = float ( 'inf' )\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] )\n    return min_xor"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( x ) :\n    next = 0\n    if ( x ) :\n        rightOne = x & - ( x )\n        nextHigherOneBit = x + int ( rightOne )\n        rightOnesPattern = x ^ int ( nextHigherOneBit )\n        rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) )\n        rightOnesPattern = int ( rightOnesPattern ) >> 2\n        next = nextHigherOneBit | rightOnesPattern\n    return next",
    "badcase": "def snoob ( x ) :\n    if ( x ) :\n        rightOne = x & - x\n        nextHigherOneBit = x + rightOne\n        rightOnesPattern = x ^ nextHigherOneBit\n        rightOnesPattern = ( rightOnesPattern ) / rightOne\n        rightOnesPattern >>= 2\n        next = nextHigherOneBit\n    return next"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    while ( int ( n / 100 ) ) :\n        last_digit = int ( n % 10 )\n        n = int ( n / 10 )\n        n += last_digit * 3\n    return ( n % 29 == 0 )",
    "badcase": "def isDivisible ( n ) :\n    while ( n / 100 > 0 ) :\n        last_digit = n % 10\n        n /= 10\n        n += last_digit * 3\n    return ( n % 29 == 0 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] ;\n    if ( n == 1 ) :\n        return 10 ;\n    for j in range ( 10 ) :\n        dp [ 1 ] [ j ] = 1 ;\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 10 ) :\n            if ( j == 0 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n            elif ( j == 9 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;\n            else :\n                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ;\n    sum = 0 ;\n    for j in range ( 1 , 10 ) :\n        sum = sum + dp [ n ] [ j ] ;\n    return sum ;",
    "badcase": "def answer ( n ) :\n    dp = [ [ 0 for i in range ( 10 ) ] for j in range ( n + 1 ) ]\n    if ( n == 1 ) :\n        return 10\n    for j in range ( 10 ) :\n        dp [ 1 ] [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 10 ) :\n            if ( j == 0 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]\n            elif ( j == 9 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )\n    sum = 0\n    for j in range ( 10 ) :\n        sum += dp [ n ] [ j ]\n    return sum"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    q = collections.deque ( [ ] )\n    arr.sort ( )\n    q.append ( arr [ 0 ] )\n    for i in range ( 1 , n ) :\n        now = q [ 0 ]\n        if ( arr [ i ] >= 2 * now ) :\n            q.popleft ( )\n        q.append ( arr [ i ] )\n    return len ( q )",
    "badcase": "def minimumBox ( arr , n ) :\n    q = [ ]\n    arr.sort ( )\n    q.append ( arr [ 0 ] )\n    for i in range ( 1 , n ) :\n        now = q [ 0 ]\n        if ( arr [ i ] >= 2 * now ) :\n            q.pop ( )\n        q.append ( arr [ i ] )\n    return len ( q )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , N ) :\n    if N < 3 :\n        return False\n    arr.sort ( )\n    for i in range ( N - 2 ) :\n        if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :\n            return True",
    "badcase": "def isPossibleTriangle ( arr , N ) :\n    if ( N < 3 ) :\n        return False\n    arr.sort ( )\n    for i in range ( 0 , N - 2 ) :\n        if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) :\n            return True\n    return False"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( text , word ) :\n    word_list = text.split ( )\n    result = ''\n    stars = '*' * len ( word )\n    count = 0\n    index = 0 ;\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    result = ' '.join ( word_list )\n    return result",
    "badcase": "def censor ( text , word ) :\n    word_list = text.split ( )\n    result = \"\"\n    stars = \"\"\n    for i in range ( len ( word ) ) :\n        stars += '*'\n    index = 0\n    for i in word_list :\n        if i == word :\n            word_list [ index ] = stars\n        index += 1\n    for i in word_list :\n        result += i + ' '\n    return result"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    ar = [ 0 ] * 10\n    while ( n > 0 ) :\n        digit = math.floor ( n % 10 )\n        if ( ar [ digit ] ) :\n            return 0\n        ar [ digit ] = 1\n        n = n / 10\n    return 1",
    "badcase": "def isLucky ( n ) :\n    arr = [ False ] * 10\n    while ( n > 0 ) :\n        digit = n % 10\n        if ( arr [ digit ] ) :\n            return False\n        arr [ digit ] = True\n        n = n // 10\n    return True"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( 0 , n ) :\n        if i % 2 == 0 :\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n    for i in range ( 0 , n ) :\n        arr [ i ] = arr [ i ] / max_elem",
    "badcase": "def rearrange ( arr , n ) :\n    max_idx = n - 1\n    min_idx = 0\n    max_elem = arr [ n - 1 ] + 1\n    for i in range ( n ) :\n        if i % 2 == 0 :\n            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem\n            max_idx -= 1\n        else :\n            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem\n            min_idx += 1\n    for i in range ( n ) :\n        arr [ i ] = arr [ i ] // max_elem"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( Str ) :\n    Len = len ( Str )\n    res = [ None ] * Len\n    index = 0\n    i = 0\n    s = [ ]\n    s.append ( 0 )\n    while ( i < Len ) :\n        if ( Str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        elif ( Str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index += 1\n        elif ( Str [ i ] == '(' and i > 0 ) :\n            if ( Str [ i - 1 ] == '-' ) :\n                x = 0 if ( s [ - 1 ] == 1 ) else 1\n                s.append ( x )\n            elif ( Str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( Str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = Str [ i ]\n            index += 1\n        i += 1\n    return res",
    "badcase": "def simplify ( str ) :\n    l = len ( str )\n    res = [ '' ] * l\n    index = 0\n    s = [ ]\n    s.append ( 0 )\n    i = 0\n    while ( i < l ) :\n        if ( str [ i ] == '+' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '-'\n                index += 1\n            if ( s [ - 1 ] == 0 ) :\n                res [ index ] = '+'\n                index += 1\n        elif ( str [ i ] == '-' ) :\n            if ( s [ - 1 ] == 1 ) :\n                res [ index ] = '+'\n                index += 1\n            elif ( s [ - 1 ] == 0 ) :\n                res [ index ] = '-'\n                index += 1\n        elif ( str [ i ] == '(' and i > 0 ) :\n            if ( str [ i - 1 ] == '-' ) :\n                x = 0 if s [ - 1 ] == 1 else 1\n                s.append ( x )\n            elif ( str [ i - 1 ] == '+' ) :\n                s.append ( s [ - 1 ] )\n        elif ( str [ i ] == ')' ) :\n            s.pop ( )\n        else :\n            res [ index ] = str [ i ]\n            index += 1\n        i += 1\n    return \"\".join ( res )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    longest_start = - 1 ;\n    longest_end = 0 ;\n    for start in range ( n ) :\n        min = sys.maxsize ;\n        max = - sys.maxsize ;\n        for end in range ( start , n ) :\n            val = arr [ end ] ;\n            if ( val < min ) :\n                min = val ;\n            if ( val > max ) :\n                max = val ;\n            if ( 2 * min <= max ) :\n                break ;\n            if ( end - start > longest_end - longest_start or longest_start == - 1 ) :\n                longest_start = start ;\n                longest_end = end ;\n    if ( longest_start == - 1 ) :\n        return n ;\n    return ( n - ( longest_end - longest_start + 1 ) ) ;\n\n\npython",
    "badcase": "def minRemovalsDP ( arr , n ) :\n    longest_start = - 1\n    longest_end = 0\n    for start in range ( n ) :\n        min = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n , key , capacity ) :\n    if ( n >= capacity ) :\n        return n\n    i = n - 1\n    while i >= 0 and arr [ i ] > key :\n        arr [ i + 1 ] = arr [ i ]\n        i -= 1\n    arr [ i + 1 ] = key\n    return ( n + 1 )",
    "badcase": "def insertSorted ( arr , n , key ) :\n    if ( n >= len ( arr ) ) :\n        return n\n    i = n - 1\n    while ( i >= 0 and arr [ i ] > key ) :\n        arr [ i + 1 ] = arr [ i ]\n        i -= 1\n    arr [ i + 1 ] = key\n    return ( n + 1 )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( x ) :\n    res = 0 ;\n    count = 0 ;\n    count += 1 ;\n    if ( count == 1 ) :\n        res = x ;\n    else :\n        i = random.randrange ( count ) ;\n        if ( i == count - 1 ) :\n            res = x ;\n    return res ;\n\n\nimport random\ncount = 0\nres = 0",
    "badcase": "def selectRandom ( x ) :\n    global count\n    global res\n    count += 1\n    if ( count == 1 ) :\n        res = x\n    else :\n        i = random.randint ( 0 , count - 1 )\n        if ( i == count - 1 ) :\n            res = x\n    return res"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( arr , n ) :\n    for i in range ( n - 1 , 0 , - 1 ) :\n        j = random.randint ( 0 , i + 1 )\n        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    return arr\n\n\nimport random",
    "badcase": "def randomize ( arr , n ) :\n    for i in range ( n - 1 , 0 , - 1 ) :\n        j = random.randint ( 0 , i + 1 )\n        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    print ( arr )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( x , y , z ) :\n    if ( not ( y / x ) ) :\n        return y if ( not ( y / z ) ) else z\n    return x if ( not ( x / z ) ) else z",
    "badcase": "def smallest ( x , y , z ) :\n    if ( ( y / x ) != 1 ) :\n        return y if ( ( y / z ) != 1 ) else z\n    return x if ( ( x / z ) != 1 ) else z"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , arr_size ) :\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    while mid <= hi :\n        if a [ mid ] == 0 :\n            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]\n            lo = lo + 1\n            mid = mid + 1\n        elif a [ mid ] == 1 :\n            mid = mid + 1\n        else :\n            a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]\n            hi = hi - 1",
    "badcase": "def sort012 ( a , arr_size ) :\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    temp = 0\n    while mid <= hi :\n        if a [ mid ] == 0 :\n            temp = a [ lo ]\n            a [ lo ] = a [ mid ]\n            a [ mid ] = temp\n            lo += 1\n            mid += 1\n        elif a [ mid ] == 1 :\n            mid += 1\n        elif a [ mid ] == 2 :\n            temp = a [ mid ]\n            a [ mid ] = a [ hi ]\n            a [ hi ] = temp\n            hi -= 1"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold(arr, n, A, B, C):\n    for i in range(n):\n        arr[i] = (A * arr[i] * arr[i] + B * arr[i] + C)\n    index = - (sys.maxsize - 1)\n    maximum = - (sys.maxsize - 1)\n    for i in range(n):\n        if maximum < arr[i]:\n            index = i\n            maximum = arr[i]\n    i = 0\n    j = n - 1\n    new_arr = [0] * n\n    k = 0\n    while i < index and j > index:\n        if arr[i] < arr[j]:\n            new_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            new_arr[k] = arr[j]\n            k += 1\n            j -= 1\n    while i < index:\n        new_arr[k] = arr[i]\n        k += 1\n        i += 1\n    while j > index:\n        new_arr[k] = arr[j]\n        k += 1\n        j -= 1\n        new_arr[n - 1] = maximum\n    for i in range(n):\n        arr[i] = new_arr[i]",
    "badcase": "def sortArray ( arr , n , A , B , C ) :\n    for i in range ( n ) :\n        arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C\n    index = - 1\n    maximum = - 999999\n    for i in range ( n ) :\n        if ( maximum < arr [ i ] ) :\n            index = i\n            maximum = arr [ i ]\n    i = 0\n    j = n - 1\n    new_arr = [ 0 ] * n\n    k = 0\n    while ( i < index and j > index ) :\n        if ( arr [ i ] < arr [ j ] ) :\n            new_arr [ k ] = arr [ i ]\n            k += 1\n            i += 1\n        else :\n            new_arr [ k ] = arr [ j ]\n            k += 1\n            j -= 1\n    while ( i < index ) :\n        new_arr [ k ] = arr [ i ]\n        k += 1\n        i += 1\n    while ( j > index ) :\n        new_arr [ k ] = arr [ j ]\n        k += 1\n        j -= 1\n    new_arr [ n - 1 ] = maximum\n    for p in range ( n ) :\n        arr [ p ] = new_arr [ p ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( s ) :\n    _sum = 0\n    n = 1\n    while ( _sum < s ) :\n        _sum += n * n\n        n += 1\n    n -= 1\n    if _sum == s :\n        return n\n    return - 1",
    "badcase": "def findS ( s ) :\n    sum = 0\n    n = 1\n    while sum < s :\n        sum += n * n\n        n += 1\n        if sum == s :\n            return n\n    return - 1"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( string ) :\n    string = string [ : : - 1 ]\n    return string",
    "badcase": "def reverse ( str ) :\n    n = len ( str )\n    for i in range ( 0 , n // 2 ) :\n        str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ]"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( a , b ) :\n    if ( a == b ) :\n        return a\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    if ( ( ~ a & 1 ) == 1 ) :\n        if ( ( b & 1 ) == 1 ) :\n            return f_gold ( a >> 1 , b )\n        else :\n            return ( f_gold ( a >> 1 , b >> 1 ) << 1 )\n    if ( ( ~ b & 1 ) == 1 ) :\n        return f_gold ( a , b >> 1 )\n    if ( a > b ) :\n        return f_gold ( ( a - b ) >> 1 , b )\n    return f_gold ( ( b - a ) >> 1 , a )",
    "badcase": "def gcd ( a , b ) :\n    if ( a == b ) :\n        return a\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    if ( a & 1 ) :\n        if ( b & 1 ) :\n            return gcd ( a >> 1 , b )\n        else :\n            return gcd ( a >> 1 , b >> 1 ) << 1\n    if ( b & 1 ) :\n        return gcd ( a , b >> 1 )\n    if ( a > b ) :\n        return gcd ( a - b >> 1 , b )\n    return gcd ( b - a >> 1 , a )"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    ans = 0 ; temp = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        if temp < n :\n            temp = i - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans += i * num\n                else :\n                    ans += ( n - temp ) * num\n                temp += i\n                num += 1\n    return ans",
    "badcase": "def findSum ( n ) :\n    ans = 0\n    temp = 0\n    for i in range ( 1 , n + 1 ) :\n        temp = i - 1\n        num = 1\n        while ( temp < n ) :\n            if ( temp + i <= n ) :\n                ans += ( i * num )\n            else :\n                ans += ( ( n - temp ) * num )\n            temp += i\n            num += 1\n    return ans"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( n ) :\n    i = 1 ;\n    res = 0.0 ;\n    sign = True ;\n    while ( n > 0 ) :\n        n = n - 1 ;\n        if ( sign ) :\n            sign = False ;\n            res = res + ( i + 1 ) / ( i + 2 ) ;\n            i = i + 2 ;\n        else :\n            sign = True ;\n            res = res - ( i + 1 ) / ( i + 2 ) ;\n            i = i + 2 ;\n    return res ;",
    "badcase": "def seriesSum ( n ) :\n    i = 1\n    res = 0.0\n    sign = True\n    while ( n > 0 ) :\n        n -= 1\n        if ( sign ) :\n            sign = not sign\n            i += 1\n            res = res + float ( i ) / float ( i + 1 )\n        else :\n            sign = not sign\n            i += 1\n            res = res - float ( i ) / float ( i + 1 )\n    return res"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold(str1, str2):\n    if (len(str1) > len(str2)):\n        t = str1\n        str1 = str2\n        str2 = t\n    str = \"\"\n    n1 = len(str1)\n    n2 = len(str2)\n    str1 = str1[:: - 1]\n    str2 = str2[:: - 1]\n    carry = 0\n    for i in range(n1):\n        sum = ((ord(str1[i]) - 48) + ((ord(str2[i]) - 48) + carry))\n        str += chr(sum % 10 + 48)\n        carry = int(sum / 10)\n    for i in range(n1, n2):\n        sum = ((ord(str2[i]) - 48) + carry)\n        str += chr(sum % 10 + 48)\n        carry = (int)(sum / 10)\n    if (carry):\n        str += chr(carry + 48)\n    str = str[:: - 1]\n    return str",
    "badcase": "def findSum ( str1 , str2 ) :\n    if ( len ( str1 ) > len ( str2 ) ) :\n        t = str1\n        str1 = str2\n        str2 = t\n    str3 = \"\"\n    n1 = len ( str1 )\n    n2 = len ( str2 )\n    str1 = str1 [ : : - 1 ]\n    str2 = str2 [ : : - 1 ]\n    carry = 0\n    for i in range ( n1 ) :\n        sum = ( ord ( str1 [ i ] ) - ord ( '0' ) + ord ( str2 [ i ] ) - ord ( '0' ) + carry )\n        str3 += chr ( sum % 10 + ord ( '0' ) )\n        carry = sum // 10\n    for i in range ( n1 , n2 ) :\n        sum = ( ord ( str2 [ i ] ) - ord ( '0' ) + carry )\n        str3 += chr ( sum % 10 + ord ( '0' ) )\n        carry = sum // 10\n    if ( carry > 0 ) :\n        str3 += chr ( carry + ord ( '0' ) )\n    str3 = str3 [ : : - 1 ]\n    return str3"
  },
  {
    "type": "java_to_python",
    "GT": "def f_gold ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )\n    xor = ( set1 ^ set2 )\n    xor = ( xor << p1 ) | ( xor << p2 )\n    result = x ^ xor\n    return result",
    "badcase": "def swapBits ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )\n    xor = ( set1 ^ set2 )\n    xor = ( xor << p1 )"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( string text, int s ) {\n  string result = \"\";\n  for ( int i = 0;\n  i < text . length ( );\n  i ++ ) {\n    if ( isupper ( text [ i ] ) ) result += char ( int ( text [ i ] + s - 65 ) % 26 + 65 );\n    else result += char ( int ( text [ i ] + s - 97 ) % 26 + 97 );\n  }\n  return result;\n}",
    "badcase": "string encrypt ( string text , int s ) {\n  string result = \"\" ;\n  for ( int i = 0 ;\n  i < text . length ( ) ;\n  i ++ ) {\n    char ch = text [ i ] ;\n    if ( ch >= 'a' && ch <= 'z' ) result += char ( int ( ch + s - 97 ) % 26 + 97 ) ;\n    else if ( ch >= 'A' && ch <= 'Z' ) result += char ( int ( ch + s - 65 ) % 26 + 65 ) ;\n  }\n  return result ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( double h, double m ) {\n  if ( h < 0 || m < 0 || h > 12 || m > 60 ) printf ( \"Wrong input\" );\n  if ( h == 12 ) h = 0;\n  if ( m == 60 ) m = 0;\n  int hour_angle = 0.5 * ( h * 60 + m );\n  int minute_angle = 6 * m;\n  int angle = abs ( hour_angle - minute_angle );\n  angle = min ( 360 - angle, angle );\n  return angle;\n}",
    "badcase": "int calcAngle ( int h , int m ) {\n  if ( h < 0 || m < 0 || h > 12 || m > 60 ) {\n    cout << \"Wrong input\" ;\n  }\n  if ( h == 12 ) h = 0 ;\n  if ( m == 60 ) m = 0 ;\n  int hour_angle = 0.5 * ( h * 60 + m ) ;\n  int minute_angle = 6 * m ;\n  int angle = abs ( hour_angle - minute_angle ) ;\n  angle = min ( 360 - angle , angle ) ;\n  return angle ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string str ) {\n  int res = str [ 0 ] - '0';\n  for ( int i = 1;\n  i < str . length ( );\n  i ++ ) {\n    if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) res += ( str [ i ] - '0' );\n    else res *= ( str [ i ] - '0' );\n  }\n  return res;\n}",
    "badcase": "int calcMaxValue ( string str ) {\n  int res = str [ 0 ] - '0' ;\n  for ( int i = 1 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( str [ i ] == '0' str [ i ] == '1' res < 2 ) res += str [ i ] - '0' ;\n    else res *= str [ i ] - '0' ;\n  }\n  return res ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( string num ) {\n  int n = num . length ( );\n  if ( n == 0 && num [ 0 ] == '0' ) return true;\n  if ( n % 3 == 1 ) num = \"00\" + num;\n  if ( n % 3 == 2 ) num = \"0\" + num;\n  int gSum = 0;\n  for ( int i = 0;\n  i < n;\n  i ++ ) {\n    int group = 0;\n    group += ( num [ i ++ ] - '0' ) * 100;\n    group += ( num [ i ++ ] - '0' ) * 10;\n    group += num [ i ] - '0';\n    gSum += group;\n  }\n  if ( gSum > 1000 ) {\n    num = to_string ( gSum );\n    n = num . length ( );\n    gSum = f_gold ( num );\n  }\n  return ( gSum == 999 );\n}",
    "badcase": "bool isDivisible999 ( string num ) {\n  int n = num . length ( ) ;\n  if ( n == 0 || num [ 0 ] == '0' ) return true ;\n  if ( ( n % 3 ) == 1 ) num = \"00\" + num ;\n  if ( ( n % 3 ) == 2 ) num = \"0\" + num ;\n  int gSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i += 3 ) {\n    int group = 0 ;\n    group += ( num [ i ] - 48 ) * 100 ;\n    group += ( num [ i + 1 ] - 48 ) * 10 ;\n    group += ( num [ i + 2 ] - 48 ) ;\n    gSum += group ;\n  }\n  if ( gSum > 1000 ) {\n    num = to_string ( gSum ) ;\n    n = num . length ( ) ;\n    gSum = isDivisible999 ( num ) ;\n  }\n  return ( gSum == 999 ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( int x, int y ) {\n  int res1 = log ( y ) / log ( x );\n  double res2 = log ( y ) / log ( x );\n  return ( res1 == res2 );\n}",
    "badcase": "bool isPower ( int x , int y ) {\n  int res1 = log ( y ) / log ( x ) ;\n  int res2 = log ( y ) / log ( x ) ;\n  return ( res1 == res2 ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( long long a, long long b ) {\n  if ( a == 0 || b == 0 ) return false;\n  long long result = a * b;\n  if ( a == result / b ) return false;\n  else return true;\n}",
    "badcase": "bool isOverflow ( long long a , long long b ) {\n  if ( a == 0 || b == 0 ) return false ;\n  long long result = a * b ;\n  if ( result >= 9223372036854775807 result <= -9223372036854775808 ) result = 0 ;\n  if ( a == ( result / b ) ) {\n    cout << result / b ;\n    return false ;\n  }\n  else return true ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string str ) {\n  int n = str . length ( );\n  int digitSum = 0;\n  for ( int i = 0;\n  i < n;\n  i ++ ) digitSum += ( str [ i ] - '0' );\n  return ( digitSum % 9 == 0 );\n}",
    "badcase": "bool check ( string st ) {\n  int n = st . length ( ) ;\n  int digitSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    digitSum = digitSum + ( int ) ( st [ i ] ) ;\n  }\n  return ( digitSum % 9 == 0 ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( string s1, string s2 ) {\n  int n = s1 . length ( );\n  int m = s2 . length ( );\n  bool dp [ n + 1 ] [ m + 1 ];\n  for ( int i = 0;\n  i <= n;\n  i ++ ) {\n    for ( int j = 0;\n    j <= m;\n    j ++ ) {\n      dp [ i ] [ j ] = false;\n    }\n  }\n  dp [ 0 ] [ 0 ] = true;\n  for ( int i = 0;\n  i < s1 . length ( );\n  i ++ ) {\n    for ( int j = 0;\n    j <= s2 . length ( );\n    j ++ ) {\n      if ( dp [ i ] [ j ] ) {\n        if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true;\n        if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true;\n      }\n    }\n  }\n  return ( dp [ n ] [ m ] );\n}",
    "badcase": "bool check ( string s1 , string s2 ) {\n  int n = s1 . length ( ) ;\n  int m = s2 . length ( ) ;\n  bool dp [ n + 1 ] [ m + 1 ] ;\n  memset ( dp , false , sizeof ( dp ) ) ;\n  dp [ 0 ] [ 0 ] = true ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= m ;\n    j ++ ) {\n      if ( dp [ i ] [ j ] ) {\n        if ( j < m && s1 [ i ] == s2 [ j ] ) dp [ i + 1 ] [ j + 1 ] = true ;\n        if ( islower ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true ;\n      }\n    }\n  }\n  return ( dp [ n ] [ m ] ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "bool checkReverse ( int arr [ ] , int n ) {\n  if ( n == 1 ) return true ;\n  int i ;\n  for ( i = 1 ;\n  i < n ;\n  i ++ ) if ( arr [ i - 1 ] < arr [ i ] ) break ;\n  if ( i == n ) return true ;\n  int j = i ;\n  while ( arr [ j ] < arr [ j - 1 ] ) {\n    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ;\n    j ++ ;\n  }\n  if ( j == n ) return true ;\n  int k = j ;\n  if ( arr [ k ] < arr [ i - 1 ] ) return false ;\n  while ( k > 1 && k < n ) {\n    if ( arr [ k ] < arr [ k - 1 ] ) return false ;\n    k ++ ;\n  }\n  return true ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( double num, int k_prec ) {\n  string binary = \"\";\n  int Integral = num;\n  double fractional = num - Integral;\n  while ( Integral ) {\n    int rem = Integral % 2;\n    binary . push_back ( rem + '0' );\n    Integral /= 2;\n  }\n  reverse ( binary . begin ( ), binary . end ( ) );\n  binary . push_back ( '.' );\n  while ( k_prec -- ) {\n    fractional *= 2;\n    int fract_bit = fractional;\n    if ( fract_bit == 1 ) {\n      fractional -= fract_bit;\n      binary . push_back ( 1 + '0' );\n    }\n    else binary . push_back ( 0 + '0' );\n  }\n  return binary;\n}",
    "badcase": "string decimalToBinary ( double num , int k_prec ) {\n  string binary = \"\" ;\n  int Integral = num ;\n  double fractional = num - Integral ;\n  while ( Integral ) {\n    int rem = Integral % 2 ;\n    binary . push_back ( rem + '0' ) ;\n    Integral /= 2 ;\n  }\n  reverse ( binary . begin ( ) , binary . end ( ) ) ;\n  binary . push_back ( '.' ) ;\n  while ( k_prec -- ) {\n    fractional *= 2 ;\n    int fract_bit = fractional ;\n    if ( fract_bit ) {\n      fractional -= fract_bit ;\n      binary . push_back ( '1' ) ;\n    }\n    else binary . push_back ( '0' ) ;\n  }\n  return binary ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int x ) {\n  int dp [ x + 1 ];\n  dp [ 0 ] = dp [ 1 ] = 1;\n  for ( int i = 2;\n  i <= x;\n  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ];\n  return dp [ x ];\n}",
    "badcase": "int numberOfWays ( int x ) {\n  if ( x == 0 || x == 1 ) return 1 ;\n  else return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string S, string T ) {\n  int m = T . length ( ), n = S . length ( );\n  if ( m > n ) return 0;\n  int mat [ m + 1 ] [ n + 1 ];\n  for ( int i = 1;\n  i <= m;\n  i ++ ) mat [ i ] [ 0 ] = 0;\n  for ( int j = 0;\n  j <= n;\n  j ++ ) mat [ 0 ] [ j ] = 1;\n  for ( int i = 1;\n  i <= m;\n  i ++ ) {\n    for ( int j = 1;\n    j <= n;\n    j ++ ) {\n      if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ];\n      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ];\n    }\n  }\n  return mat [ m ] [ n ];\n}",
    "badcase": "int findSubsequenceCount ( string S , string T ) {\n  int m = T . length ( ) ;\n  int n = S . length ( ) ;\n  if ( m > n ) return 0 ;\n  int mat [ m + 1 ] [ n + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) mat [ 0 ] [ i ] = 1 ;\n  for ( int i = 0 ;\n  i <= m ;\n  i ++ ) mat [ i ] [ 0 ] = 0 ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;\n      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ;\n    }\n  }\n  return mat [ m ] [ n ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( char str [ ], int n ) {\n  int dp [ n ] [ n ];\n  memset ( dp, 0, sizeof ( dp ) );\n  bool P [ n ] [ n ];\n  memset ( P, false, sizeof ( P ) );\n  for ( int i = 0;\n  i < n;\n  i ++ ) P [ i ] [ i ] = true;\n  for ( int i = 0;\n  i < n - 1;\n  i ++ ) {\n    if ( str [ i ] == str [ i + 1 ] ) {\n      P [ i ] [ i + 1 ] = true;\n      dp [ i ] [ i + 1 ] = 1;\n    }\n  }\n  for ( int gap = 2;\n  gap < n;\n  gap ++ ) {\n    for ( int i = 0;\n    i < n - gap;\n    i ++ ) {\n      int j = gap + i;\n      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true;\n      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ];\n      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ];\n    }\n  }\n  return dp [ 0 ] [ n - 1 ];\n}",
    "badcase": "int CountPS ( string str , int n ) {\n  int dp [ n ] [ n ] ;\n  bool P [ n ] [ n ] ;\n  memset ( P , false , sizeof ( P ) ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) P [ i ] [ i ] = true ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( str [ i ] == str [ i + 1 ] ) {\n      P [ i ] [ i + 1 ] = true ;\n      dp [ i ] [ i + 1 ] = 1 ;\n    }\n  }\n  for ( int gap = 2 ;\n  gap < n ;\n  gap ++ ) {\n    for ( int i = 0 ;\n    i < n - gap ;\n    i ++ ) {\n      int j = gap + i ;\n      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) {\n        P [ i ] [ j ] = true ;\n      }\n      if ( P [ i ] [ j ] == true ) {\n        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;\n      }\n      else {\n        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;\n      }\n    }\n  }\n  return dp [ 0 ] [ n - 1 ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string str ) {\n  int N = str . length ( );\n  int cps [ N + 1 ] [ N + 1 ];\n  memset ( cps, 0, sizeof ( cps ) );\n  for ( int i = 0;\n  i < N;\n  i ++ ) cps [ i ] [ i ] = 1;\n  for ( int L = 2;\n  L <= N;\n  L ++ ) {\n    for ( int i = 0;\n    i < N;\n    i ++ ) {\n      int k = L + i - 1;\n      if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1;\n      else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ];\n    }\n  }\n  return cps [ 0 ] [ N - 1 ];\n}",
    "badcase": "int countPS ( string str ) {\n  int N = str . length ( ) ;\n  int cps [ N + 1 ] [ N + 1 ] ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) cps [ i ] [ i ] = 1 ;\n  for ( int L = 2 ;\n  L <= N ;\n  L ++ ) {\n    for ( int i = 0 ;\n    i <= N - L ;\n    i ++ ) {\n      int k = L + i - 1 ;\n      if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ;\n      else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ;\n    }\n  }\n  return cps [ 0 ] [ N - 1 ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int m, int n ) {\n  int path = 1;\n  for ( int i = n;\n  i < ( m + n - 1 );\n  i ++ ) {\n    path *= i;\n    path /= ( i - n + 1 );\n  }\n  return path;\n}",
    "badcase": "int numberOfPaths ( int m , int n ) {\n  for ( int i = n ;\n  i <= ( m + n - 1 ) ;\n  i ++ ) {\n    path *= i ;\n    path /= ( i - n + 1 ) ;\n  }\n  return path ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "long f_gold ( int n ) {\n  long dp [ 2 ] [ n + 1 ];\n  dp [ 0 ] [ 1 ] = 1;\n  dp [ 1 ] [ 1 ] = 2;\n  for ( int i = 2;\n  i <= n;\n  i ++ ) {\n    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ];\n    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ];\n  }\n  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ];\n}",
    "badcase": "int countWays ( int n ) {\n  int dp [ 2 ] [ n + 1 ] ;\n  dp [ 0 ] [ 1 ] = 1 ;\n  dp [ 1 ] [ 1 ] = 2 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;\n    dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ;\n  }\n  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string str [ ], int n ) {\n  unordered_map < string, int > m;\n  for ( int i = 0;\n  i < n;\n  i ++ ) m [ str [ i ] ] += 1;\n  int res = 0;\n  for ( auto it = m . begin ( );\n  it != m . end ( );\n  it ++ ) if ( ( it -> second == 2 ) ) res ++;\n  return res;\n}",
    "badcase": "int countWords ( string str , int n ) {\n  unordered_map < char , int > m ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) m [ str [ i ] ] ++ ;\n  int res = 0 ;\n  for ( auto i : m ) if ( i . second == 2 ) res ++ ;\n  return res ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( char str [ ], int len ) {\n  int count = 1;\n  if ( len == 1 ) return count;\n  if ( str [ 0 ] == str [ 1 ] ) count *= 1;\n  else count *= 2;\n  for ( int j = 1;\n  j < len - 1;\n  j ++ ) {\n    if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1;\n    else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2;\n    else count *= 3;\n  }\n  if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1;\n  else count *= 2;\n  return count;\n}",
    "badcase": "int countWords ( string str , int l ) {\n  int count = 1 ;\n  if ( l == 1 ) return count ;\n  if ( str [ 0 ] == str [ 1 ] ) count *= 1 ;\n  else count *= 2 ;\n  for ( int j = 1 ;\n  j < l - 1 ;\n  j ++ ) {\n    if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ;\n    else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ;\n    else count *= 3 ;\n  }\n  if ( str [ l - 1 ] == str [ l - 2 ] ) count *= 1 ;\n  else count *= 2 ;\n  return count ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( int n ) {\n  if ( n == 0 ) return \"0\";\n  string bin = \"\";\n  while ( n > 0 ) {\n    bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin;\n    n >>= 1;\n  }\n  return bin;\n}",
    "badcase": "string decToBin ( int n ) {\n  if ( n == 0 ) return \"0\" ;\n  string bin = \"\" ;\n  while ( n > 0 ) {\n    if ( n & 1 == 0 ) bin = '0' + bin ;\n    else bin = '1' + bin ;\n    n = n >> 1 ;\n  }\n  return bin ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n, int m ) {\n  int dp [ m + 1 ] [ n + 1 ];\n  for ( int i = 0;\n  i <= m;\n  i ++ ) dp [ i ] [ 0 ] = 1;\n  for ( int i = 0;\n  i <= m;\n  i ++ ) dp [ 0 ] [ i ] = 1;\n  for ( int i = 1;\n  i <= m;\n  i ++ ) for ( int j = 1;\n  j <= n;\n  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ];\n  return dp [ m ] [ n ];\n}",
    "badcase": "int dealnnoy ( int n , int m ) {\n  int dp [ m + 1 ] [ n + 1 ] ;\n  memset ( dp , 0 , sizeof ( dp ) ) ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) dp [ 0 ] [ i ] = 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) dp [ i ] [ 0 ] = 1 ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) for ( int j = 1 ;\n  j <= n ;\n  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ;\n  return dp [ m ] [ n ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( string number, int divisor ) {\n  string ans;\n  int idx = 0;\n  int temp = number [ idx ] - '0';\n  while ( temp < divisor ) temp = temp * 10 + ( number [ ++ idx ] - '0' );\n  while ( number . size ( ) > idx ) {\n    ans += ( temp / divisor ) + '0';\n    temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0';\n  }\n  if ( ans . length ( ) == 0 ) return \"0\";\n  return ans;\n}",
    "badcase": "string longDivision ( string number , int divisor ) {\n  string ans ;\n  int idx = 0 ;\n  int temp = number [ idx ] - '0' ;\n  while ( temp < divisor ) {\n    temp = ( temp * 10 + number [ ++ idx ] - '0' ) ;\n  }\n  while ( number . size ( ) > idx ) {\n    ans . push_back ( temp / divisor + '0' ) ;\n    temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0' ;\n  }\n  ans . push_back ( temp / divisor + '0' ) ;\n  if ( ans . length ( ) == 0 ) return \"0\" ;\n  return ans ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( int n ) {\n  if ( n == 0 || n == 9 ) return true;\n  if ( n < 9 ) return false;\n  return f_gold ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) );\n}",
    "badcase": "bool isDivBy9 ( int n ) {\n  if ( n == 0 n == 9 ) return true ;\n  if ( n < 9 ) return false ;\n  return isDivBy9 ( n >> 3 ) - n & 7 ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int num ) {\n  if ( num < 0 ) return f_gold ( - num );\n  if ( num == 0 || num == 7 ) return 1;\n  if ( num < 10 ) return 0;\n  return f_gold ( num / 10 - 2 * ( num - num / 10 * 10 ) );\n}",
    "badcase": "bool isDivisibleBy7 ( int num ) {\n  if ( num < 0 ) return isDivisibleBy7 ( - num ) ;\n  if ( num == 0 num == 7 ) return true ;\n  if ( num < 10 ) return false ;\n  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "unsigned int f_gold ( unsigned int n ) {\n  int res = 1;\n  for ( int i = n;\n  i >= 0;\n  i = i - 2 ) {\n    if ( i == 0 || i == 1 ) return res;\n    else res *= i;\n  }\n}",
    "badcase": "int doublefactorial ( int n ) {\n  int res = 1 ;\n  for ( int i = n ;\n  i >= 0 ;\n  i -= 2 ) {\n    if ( i == 0 i == 1 ) return res ;\n    else res *= i ;\n  }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int maxSumIS(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxSumIS(&arr.front(), n);\n    } else {\n        return maxSumIS(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int lbs(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return lbs(&arr.front(), n);\n    } else {\n        return lbs(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n ) {\n  if ( n == 2 || n == 3 ) return ( n - 1 );\n  int res = 1;\n  while ( n > 4 ) {\n    n -= 3;\n    res *= 3;\n  }\n  return ( n * res );\n}",
    "badcase": "int maxProd ( int n ) {\n  if ( n == 2 n == 3 ) return ( n - 1 ) ;\n  int res = 1 ;\n  while ( n > 4 ) {\n    n -= 3 ;\n    res *= 3 ;\n  }\n  return ( n * res ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( char symb [ ], char oper [ ], int n ) {\n  int F [ n ] [ n ], T [ n ] [ n ];\n  for ( int i = 0;\n  i < n;\n  i ++ ) {\n    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0;\n    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0;\n  }\n  for ( int gap = 1;\n  gap < n;\n  ++ gap ) {\n    for ( int i = 0, j = gap;\n    j < n;\n    ++ i, ++ j ) {\n      T [ i ] [ j ] = F [ i ] [ j ] = 0;\n      for ( int g = 0;\n      g < gap;\n      g ++ ) {\n        int k = i + g;\n        int tik = T [ i ] [ k ] + F [ i ] [ k ];\n        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ];\n        if ( oper [ k ] == '&' ) {\n          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ];\n          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] );\n        }\n        if ( oper [ k ] == '|' ) {\n          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ];\n          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] );\n        }\n        if ( oper [ k ] == '^' ) {\n          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ];\n          F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ];\n        }\n      }\n    }\n  }\n  return T [ 0 ] [ n - 1 ];\n}",
    "badcase": "int countParenth ( char symb [ ] , char oper [ ] , int n ) {\n  int F [ n ] [ n ] , T [ n ] [ n ] ;\n  memset ( F , 0 , sizeof ( F ) ) ;\n  memset ( T , 0 , sizeof ( T ) ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ;\n    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ;\n  }\n  for ( int gap = 1 ;\n  gap < n ;\n  gap ++ ) {\n    for ( int i = 0 , j = gap ;\n    j < n ;\n    i ++ , j ++ ) {\n      T [ i ] [ j ] = F [ i ] [ j ] = 0 ;\n      for ( int g = 0 ;\n      g < gap ;\n      g ++ ) {\n        int k = i + g ;\n        int tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n        if ( oper [ k ] == '&' ) {\n          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '|' ) {\n          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '^' ) {\n          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += T [ i ] [ k ] * F [ k + 1 ] [ j ] + F [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n        }\n      }\n    }\n  }\n  return T [ 0 ] [ n - 1 ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int lis(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return lis(&arr.front(), n);\n    } else {\n        return lis(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n, int p ) {\n  int ans = 0;\n  int temp = p;\n  while ( temp <= n ) {\n    ans += n / temp;\n    temp = temp * p;\n  }\n  return ans;\n}",
    "badcase": "int PowerOFPINnfactorial ( int n , int p ) {\n  int ans = 0 ;\n  int temp = p ;\n  while ( temp <= n ) {\n    ans += n / temp ;\n    temp = temp * p ;\n  }\n  return ans ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n, int p ) {\n  int ans = 0;\n  int temp = p;\n  while ( temp <= n ) {\n    ans += n / temp;\n    temp = temp * p;\n  }\n  return ans;\n}",
    "badcase": "int PowerOFPINnfactorial ( int n , int p ) {\n  int ans = 0 ;\n  int temp = p ;\n  while ( temp <= n ) {\n    ans += n / temp ;\n    temp = temp * p ;\n  }\n  return ans ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "double f_gold ( int a, int b ) {\n  double AM, GM, HM;\n  AM = ( a + b ) / 2;\n  GM = sqrt ( a * b );\n  HM = ( GM * GM ) / AM;\n  return HM;\n}",
    "badcase": "double compute ( int a , int b ) {\n  double AM = ( a + b ) / 2.0 ;\n  double GM = sqrt ( a * b ) ;\n  double HM = ( GM * GM ) / AM ;\n  return HM ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findLargestd(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findLargestd(&arr.front(), n);\n    } else {\n        return findLargestd(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int findMaxAverage(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxAverage(&arr.front(), n, k);\n    } else {\n        return findMaxAverage(arr, n, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T stack1, T stack2, T stack3, int n1, int n2, int n3) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&stack1.front(), &stack2.front(), &stack3.front(), n1, n2, n3);\n    } else {\n        return f_gold(stack1, stack2, stack3, n1, n2, n3);\n    }\n}",
    "badcase": "int maxSum(T stack1, T stack2, T stack3, int n1, int n2, int n3) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxSum(&stack1.front(), &stack2.front(), &stack3.front(), n1, n2, n3);\n    } else {\n        return maxSum(stack1, stack2, stack3, n1, n2, n3);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(int k, T x, T y, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(k, &x.front(), &y.front(), n);\n    } else {\n        return f_gold(k, x, y, n);\n    }\n}",
    "badcase": "int minRadius(int k, T x, T y, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return minRadius(k, &x.front(), &y.front(), n);\n    } else {\n        return minRadius(k, x, y, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findMaxGCD(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxGCD(&arr.front(), n);\n    } else {\n        return findMaxGCD(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findMaxGCD(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxGCD(&arr.front(), n);\n    } else {\n        return findMaxGCD(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( const vector < vector < int > > & m ) {\n  int rows = m . size ( );\n  if ( rows == 0 ) return false;\n  int columns = m [ 0 ] . size ( );\n  for ( int y1 = 0;\n  y1 < rows;\n  y1 ++ ) for ( int x1 = 0;\n  x1 < columns;\n  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1;\n  y2 < rows;\n  y2 ++ ) for ( int x2 = x1 + 1;\n  x2 < columns;\n  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true;\n  return false;\n}",
    "badcase": "bool isRectangle ( vector < vector < int >> m ) {\n  int rows = m . size ( ) ;\n  if ( rows == 0 ) return false ;\n  int columns = m [ 0 ] . size ( ) ;\n  for ( int y1 = 0 ;\n  y1 < rows ;\n  y1 ++ ) {\n    for ( int x1 = 0 ;\n    x1 < columns ;\n    x1 ++ ) {\n      if ( m [ y1 ] [ x1 ] == 1 ) {\n        for ( int y2 = y1 + 1 ;\n        y2 < rows ;\n        y2 ++ ) {\n          for ( int x2 = x1 + 1 ;\n          x2 < columns ;\n          x2 ++ ) {\n            if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ;\n          }\n        }\n      }\n    }\n  }\n  return false ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int findRepeating(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findRepeating(&arr.front(), n);\n    } else {\n        return findRepeating(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n ) {\n  int C [ n + 1 ] [ n + 1 ];\n  int i, j;\n  for ( i = 0;\n  i <= n;\n  i ++ ) {\n    for ( j = 0;\n    j <= min ( i, n );\n    j ++ ) {\n      if ( j == 0 || j == i ) C [ i ] [ j ] = 1;\n      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ];\n    }\n  }\n  int sum = 0;\n  for ( int i = 0;\n  i <= n;\n  i += 2 ) sum += C [ n ] [ i ];\n  return sum;\n}",
    "badcase": "int evenSum ( int n ) {\n  int C [ n + 1 ] [ n + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= min ( i , n ) ;\n    j ++ ) {\n      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;\n      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;\n    }\n  }\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( n % 2 == 0 ) sum = sum + C [ n ] [ i ] ;\n  }\n  return sum ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int singleNumber(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return singleNumber(&arr.front(), n);\n    } else {\n        return singleNumber(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int low, int high) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), low, high);\n    } else {\n        return f_gold(arr, low, high);\n    }\n}",
    "badcase": "int findMaximum(T arr, int low, int high) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaximum(&arr.front(), low, high);\n    } else {\n        return findMaximum(arr, low, high);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( unsigned int n ) {\n  int count = 0;\n  if ( n && ! ( n & ( n - 1 ) ) ) {\n    while ( n > 1 ) {\n      n >>= 1;\n      count += 1;\n    }\n    return ( count % 2 == 0 ) ? 1 : 0;\n  }\n  return 0;\n}",
    "badcase": "bool isPowerOfFour ( int n ) {\n  int count = 0 ;\n  if ( n && ( ! ( n & ( n - 1 ) ) ) ) {\n    while ( n > 1 ) {\n      n >>= 1 ;\n      count ++ ;\n    }\n    if ( count % 2 == 0 ) return true ;\n    else return false ;\n  }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int x) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, x);\n    } else {\n        return f_gold(arr, n, x);\n    }\n}",
    "badcase": "int floorSearch(T arr, int n, int x) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return floorSearch(&arr.front(), n, x);\n    } else {\n        return floorSearch(arr, n, x);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( string seq ) {\n  int n = seq . length ( );\n  if ( n >= 9 ) return \"-1\";\n  string result ( n + 1, ' ' );\n  int count = 1;\n  for ( int i = 0;\n  i <= n;\n  i ++ ) {\n    if ( i == n || seq [ i ] == 'I' ) {\n      for ( int j = i - 1;\n      j >= - 1;\n      j -- ) {\n        result [ j + 1 ] = '0' + count ++;\n        if ( j >= 0 && seq [ j ] == 'I' ) break;\n      }\n    }\n  }\n  return result;\n}",
    "badcase": "string getMinNumberForPattern ( string seq ) {\n  int n = seq . length ( ) ;\n  if ( n >= 9 ) return \"-1\" ;\n  int result [ n + 1 ] ;\n  int count = 1 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i == n || seq [ i ] == 'I' ) {\n      for ( int j = i - 1 ;\n      j >= 0 ;\n      j -- ) {\n        result [ j + 1 ] = count ++ ;\n        if ( j >= 0 && seq [ j ] == 'I' ) break ;\n      }\n    }\n  }\n  stringstream ss ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) ss << result [ i ] ;\n  ss << result [ 0 ] ;\n  return ss . str ( ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( string str ) {\n  int n = str . length ( );\n  int dp [ n + 1 ] [ 10 ];\n  memset ( dp, 0, sizeof ( dp ) );\n  int arr [ n + 1 ];\n  for ( int i = 1;\n  i <= n;\n  i ++ ) arr [ i ] = str [ i - 1 ] - '0';\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    dp [ i ] [ arr [ i ] % 8 ] = 1;\n    for ( int j = 0;\n    j < 8;\n    j ++ ) {\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ];\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ];\n    }\n  }\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    if ( dp [ i ] [ 0 ] == 1 ) return true;\n  }\n  return false;\n}",
    "badcase": "bool isSubSeqDivisible ( string str ) {\n  int n = str . length ( ) ;\n  int dp [ n + 1 ] [ 10 ] ;\n  int arr [ n + 1 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    arr [ i ] = str [ i - 1 ] - '0' ;\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    dp [ i ] [ arr [ i ] % 8 ] = 1 ;\n    for ( int j = 0 ;\n    j < 8 ;\n    j ++ ) {\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ;\n      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;\n    }\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    if ( dp [ i ] [ 0 ] == 1 ) return true ;\n  }\n  return false ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int N ) {\n  return ceil ( log2 ( N + 1 ) ) - 1;\n}",
    "badcase": "int height ( int N ) {\n  return log2 ( N + 1 ) - 1 ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int a, int b, int k ) {\n  int p = pow ( a, b );\n  int count = 0;\n  while ( p > 0 && count < k ) {\n    int rem = p % 10;\n    count ++;\n    if ( count == k ) return rem;\n    p = p / 10;\n  }\n  return 0;\n}",
    "badcase": "int kthdigit ( int a , int b , int k ) {\n  int p = pow ( a , b ) ;\n  int count = 0 ;\n  while ( p > 0 && count < k ) {\n    int rem = p % 10 ;\n    count ++ ;\n    if ( count == k ) return rem ;\n    p = p / 10 ;\n  }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int maxLen(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxLen(&arr.front(), n);\n    } else {\n        return maxLen(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int lenghtOfLongestAP(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return lenghtOfLongestAP(&arr.front(), n);\n    } else {\n        return lenghtOfLongestAP(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int longSubarrWthSumDivByK(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return longSubarrWthSumDivByK(&arr.front(), n, k);\n    } else {\n        return longSubarrWthSumDivByK(arr, n, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( string str, int k ) {\n  string palin = str;\n  int l = 0;\n  int r = str . length ( ) - 1;\n  while ( l < r ) {\n    if ( str [ l ] != str [ r ] ) {\n      palin [ l ] = palin [ r ] = max ( str [ l ], str [ r ] );\n      k --;\n    }\n    l ++;\n    r --;\n  }\n  if ( k < 0 ) return \"Not possible\";\n  l = 0;\n  r = str . length ( ) - 1;\n  while ( l <= r ) {\n    if ( l == r ) {\n      if ( k > 0 ) palin [ l ] = '9';\n    }\n    if ( palin [ l ] < '9' ) {\n      if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) {\n        k -= 2;\n        palin [ l ] = palin [ r ] = '9';\n      }\n      else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin [ r ] != str [ r ] ) ) {\n        k --;\n        palin [ l ] = palin [ r ] = '9';\n      }\n    }\n    l ++;\n    r --;\n  }\n  return palin;\n}",
    "badcase": "string maximumPalinUsingKChanges ( string str , int k ) {\n  string palin = str ;\n  int l = 0 ;\n  int r = str . length ( ) - 1 ;\n  while ( l <= r ) {\n    if ( str [ l ] != str [ r ] ) {\n      palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) ;\n      k -- ;\n    }\n    l ++ ;\n    r -- ;\n  }\n  if ( k < 0 ) return \"Not possible\" ;\n  l = 0 ;\n  r = str . length ( ) - 1 ;\n  while ( l <= r ) {\n    if ( l == r ) {\n      if ( k > 0 ) {\n        palin [ l ] = '9' ;\n      }\n    }\n    if ( palin [ l ] < '9' ) {\n      if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) {\n        k -- ;\n        palin [ l ] = palin [ r ] = '9' ;\n      }\n      else if ( k >= 1 && ( palin [ l ] != str [ l ] palin [ r ] != str [ r ] ) ) {\n        k -- ;\n        palin [ l ] = palin [ r ] = '9' ;\n      }\n    }\n    l ++ ;\n    r -- ;\n  }\n  return palin ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int num, int maxLimit) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, num, maxLimit);\n    } else {\n        return f_gold(arr, n, num, maxLimit);\n    }\n}",
    "badcase": "int findMaxVal(T arr, int n, int num, int maxLimit) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return findMaxVal(&arr.front(), n, num, maxLimit);\n    } else {\n        return findMaxVal(arr, n, num, maxLimit);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "double f_gold ( vector < int > & A, int K ) {\n  int n = A . size ( );\n  double pre_sum [ n + 1 ];\n  pre_sum [ 0 ] = 0;\n  for ( int i = 0;\n  i < n;\n  i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ];\n  double dp [ n ] = {\n    0 };\n    double sum = 0;\n    for ( int i = 0;\n    i < n;\n    i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i );\n    for ( int k = 0;\n    k < K - 1;\n    k ++ ) for ( int i = 0;\n    i < n;\n    i ++ ) for ( int j = i + 1;\n    j < n;\n    j ++ ) dp [ i ] = max ( dp [ i ], ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] );\n    return dp [ 0 ];\n  }",
    "badcase": "int largestSumOfAverages ( int A [ ] , int N , int K ) {\n  int n = N ;\n  int pre_sum [ n + 1 ] ;\n  pre_sum [ 0 ] = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;\n  double dp [ n ] ;\n  double sum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ;\n  }\n  for ( int k = 0 ;\n  k < K - 1 ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = i + 1 ;\n      j < n ;\n      j ++ ) {\n        dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ;\n      }\n    }\n  }\n  return dp [ 0 ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int maxNumOfChocolates(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxNumOfChocolates(&arr.front(), n, k);\n    } else {\n        return maxNumOfChocolates(arr, n, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int maxDiff(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxDiff(&arr.front(), n);\n    } else {\n        return maxDiff(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int maxSumBitonicSubArr(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxSumBitonicSubArr(&arr.front(), n);\n    } else {\n        return maxSumBitonicSubArr(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int N, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), N, k);\n    } else {\n        return f_gold(arr, N, k);\n    }\n}",
    "badcase": "int maxSumPairWithDifferenceLessThanK(T arr, int N, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return maxSumPairWithDifferenceLessThanK(&arr.front(), N, k);\n    } else {\n        return maxSumPairWithDifferenceLessThanK(arr, N, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int subset(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return subset(&arr.front(), n);\n    } else {\n        return subset(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int minProduct(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return minProduct(&arr.front(), n, k);\n    } else {\n        return minProduct(arr, n, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int minProductSubset(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return minProductSubset(&arr.front(), n);\n    } else {\n        return minProductSubset(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string slots [ ], int n, int m ) {\n  int counts [ m ] = {\n    0 };\n    for ( int i = 0;\n    i < n;\n    i ++ ) for ( int j = 0;\n    j < m;\n    j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++;\n    return * max_element ( counts, counts + m );\n  }",
    "badcase": "int findMinRooms ( vector < vector < char >> slots , int n , int m ) {\n  vector < int > counts ( m , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) {\n      if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ;\n    }\n  }\n  return * max_element ( counts . begin ( ) , counts . end ( ) ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T a, T b, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&a.front(), &b.front(), n, k);\n    } else {\n        return f_gold(a, b, n, k);\n    }\n}",
    "badcase": "int minproduct(T a, T b, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return minproduct(&a.front(), &b.front(), n, k);\n    } else {\n        return minproduct(a, b, n, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int N, int insert, int remove, int copy ) {\n  if ( N == 0 ) return 0;\n  if ( N == 1 ) return insert;\n  int dp [ N + 1 ];\n  memset ( dp, 0, sizeof ( dp ) );\n  for ( int i = 1;\n  i <= N;\n  i ++ ) {\n    if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert, dp [ i / 2 ] + copy );\n    else dp [ i ] = min ( dp [ i - 1 ] + insert, dp [ ( i + 1 ) / 2 ] + copy + remove );\n  }\n  return dp [ N ];\n}",
    "badcase": "int minTimeForWritingChars ( int N , int insrt , int remov , int cpy ) {\n  if ( N == 0 ) return 0 ;\n  if ( N == 1 ) return insrt ;\n  int dp [ N + 1 ] ;\n  for ( int i = 1 ;\n  i <= N ;\n  i ++ ) {\n    if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i / 2 ] + cpy ) ;\n    else dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) / 2 ] + cpy + remov ) ;\n  }\n  return dp [ N ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "string f_gold ( string str, int n ) {\n  string reverseAlphabet = \"zyxwvutsrqponmlkjihgfedcba\";\n  int l = str . length ( );\n  for ( int i = n;\n  i < l;\n  i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - 'a' ];\n  return str;\n}",
    "badcase": "string compute ( string st , int n ) {\n  string reverseAlphabet = \"zyxwvutsrqponmlkjihgfedcba\" ;\n  int l = st . length ( ) ;\n  string answer = \"\" ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    answer = answer + st [ i ] ;\n  }\n  for ( int i = n ;\n  i < l ;\n  i ++ ) {\n    answer = answer + reverseAlphabet [ st [ i ] - 'a' ] ;\n  }\n  return answer ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "double f_gold ( double a, double b ) {\n  double mod;\n  if ( a < 0 ) mod = - a;\n  else mod = a;\n  if ( b < 0 ) b = - b;\n  while ( mod >= b ) mod = mod - b;\n  if ( a < 0 ) return - mod;\n  return mod;\n}",
    "badcase": "int findMod ( int a , int b ) {\n  if ( a < 0 ) a = - a ;\n  if ( b < 0 ) b = - b ;\n  int mod = a ;\n  while ( mod >= b ) mod = mod - b ;\n  if ( a < 0 ) return - mod ;\n  return mod ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "long long f_gold ( int n ) {\n  int dp [ n + 1 ] [ 10 ];\n  if ( n == 1 ) return 10;\n  for ( int j = 0;\n  j <= 9;\n  j ++ ) dp [ 1 ] [ j ] = 1;\n  for ( int i = 2;\n  i <= n;\n  i ++ ) {\n    for ( int j = 0;\n    j <= 9;\n    j ++ ) {\n      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ];\n      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ];\n      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ];\n    }\n  }\n  long long sum = 0;\n  for ( int j = 1;\n  j <= 9;\n  j ++ ) sum += dp [ n ] [ j ];\n  return sum;\n}",
    "badcase": "int answer ( int n ) {\n  int dp [ n + 1 ] [ 10 ] ;\n  if ( n == 1 ) return 10 ;\n  for ( int j = 0 ;\n  j < 10 ;\n  j ++ ) dp [ 1 ] [ j ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 10 ;\n    j ++ ) {\n      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ;\n    }\n  }\n  int sum = 0 ;\n  for ( int j = 1 ;\n  j < 10 ;\n  j ++ ) sum += dp [ n ] [ j ] ;\n  return sum ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string s, int K ) {\n  int n = s . length ( );\n  int C, c1 = 0, c2 = 0;\n  for ( int i = 0;\n  i < n;\n  i ++ ) {\n    if ( s [ i ] == 'a' ) c1 ++;\n    if ( s [ i ] == 'b' ) {\n      c2 ++;\n      C += c1;\n    }\n  }\n  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2;\n}",
    "badcase": "int countOccurrences ( string s , int K ) {\n  int n = s . length ( ) ;\n  int c1 = 0 , c2 = 0 , C = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == 'a' ) c1 ++ ;\n    if ( s [ i ] == 'b' ) c2 ++ , C += c1 ;\n  }\n  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( int n ) {\n  if ( n <= 1 ) return false;\n  if ( n <= 3 ) return true;\n  if ( n % 2 == 0 || n % 3 == 0 ) return false;\n  for ( int i = 5;\n  i * i <= n;\n  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false;\n  return true;\n}",
    "badcase": "bool isPrime ( int n ) {\n  if ( n <= 1 ) return false ;\n  if ( n <= 3 ) return true ;\n  if ( n % 2 == 0 n % 3 == 0 ) return false ;\n  for ( int i = 5 ;\n  i * i <= n ;\n  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;\n  return true ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( int p ) {\n  long long checkNumber = pow ( 2, p ) - 1;\n  long long nextval = 4 % checkNumber;\n  for ( int i = 1;\n  i < p - 1;\n  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber;\n  return ( nextval == 0 );\n}",
    "badcase": "bool isPrime ( int p ) {\n  int checkNumber = pow ( 2 , p ) - 1 ;\n  int nextval = 4 % checkNumber ;\n  for ( int i = 1 ;\n  i < p - 1 ;\n  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;\n  if ( nextval == 0 ) return true ;\n  else return false ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n, k);\n    } else {\n        return f_gold(arr, n, k);\n    }\n}",
    "badcase": "int find_maximum(T arr, int n, int k) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return find_maximum(&arr.front(), n, k);\n    } else {\n        return find_maximum(arr, n, k);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int a, int b, bool x ) {\n  int arr [ ] = {\n    a, b };\n    return ( arr [ x ] );\n  }",
    "badcase": "int assignValue ( int a , int b , int x ) {\n  int arr [ ] = {\n    a , b }\n    ;\n    return ( arr [ x ] ) ;\n  }"
  },
  {
    "type": "python_to_cpp",
    "GT": "bool f_gold ( string & isbn ) {\n  int n = isbn . length ( );\n  if ( n != 10 ) return false;\n  int sum = 0;\n  for ( int i = 0;\n  i < 9;\n  i ++ ) {\n    int digit = isbn [ i ] - '0';\n    if ( 0 > digit || 9 < digit ) return false;\n    sum += ( digit * ( 10 - i ) );\n  }\n  char last = isbn [ 9 ];\n  if ( last != 'X' && ( last < '0' || last > '9' ) ) return false;\n  sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) );\n  return ( sum % 11 == 0 );\n}",
    "badcase": "bool isValidISBN ( string isbn ) {\n  if ( isbn . length ( ) != 10 ) return false ;\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < 9 ;\n  i ++ ) {\n    if ( 0 <= isbn [ i ] - '0' && isbn [ i ] - '0' <= 9 ) sum += ( isbn [ i ] - '0' ) * ( 10 - i ) ;\n    else return false ;\n  }\n  if ( isbn [ 9 ] != 'X' && 0 <= isbn [ 9 ] - '0' && isbn [ 9 ] - '0' <= 9 ) return false ;\n  sum += ( isbn [ 9 ] == 'X' ) ? 10 : isbn [ 9 ] - '0' ;\n  return ( sum % 11 == 0 ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n ) {\n  if ( n == 0 || n == 1 ) return n;\n  return max ( ( f_gold ( n / 2 ) + f_gold ( n / 3 ) + f_gold ( n / 4 ) ), n );\n}",
    "badcase": "int breakSum ( int n ) {\n  if ( n == 0 n == 1 ) return n ;\n  return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T val, T wt, int n, int W) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&val.front(), &wt.front(), n, W);\n    } else {\n        return f_gold(val, wt, n, W);\n    }\n}",
    "badcase": "int KnapSack(T val, T wt, int n, int W) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return KnapSack(&val.front(), &wt.front(), n, W);\n    } else {\n        return KnapSack(val, wt, n, W);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return f_gold(&arr.front(), n);\n    } else {\n        return f_gold(arr, n);\n    }\n}",
    "badcase": "int MaxTotalRectangleArea(T arr, int n) {\n    if constexpr (is_same_v<T, vector<int>>) {\n        return MaxTotalRectangleArea(&arr.front(), n);\n    } else {\n        return MaxTotalRectangleArea(arr, n);\n    }\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n ) {\n  if ( n <= 0 ) return 0;\n  int fibo [ n + 1 ];\n  fibo [ 0 ] = 0, fibo [ 1 ] = 1;\n  int sum = fibo [ 0 ] + fibo [ 1 ];\n  for ( int i = 2;\n  i <= n;\n  i ++ ) {\n    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ];\n    sum += fibo [ i ];\n  }\n  return sum;\n}",
    "badcase": "int calculateSum ( int n ) {\n  if ( n <= 0 ) return 0 ;\n  int fibo [ n + 1 ] ;\n  fibo [ 1 ] = 1 ;\n  int sm = fibo [ 0 ] + fibo [ 1 ] ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;\n    sm = sm + fibo [ i ] ;\n  }\n  return sm ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "double f_gold ( int n ) {\n  int i = 1;\n  double res = 0.0;\n  bool sign = true;\n  while ( n > 0 ) {\n    n --;\n    if ( sign ) {\n      sign = ! sign;\n      res = res + ( double ) ++ i / ++ i;\n    }\n    else {\n      sign = ! sign;\n      res = res - ( double ) ++ i / ++ i;\n    }\n  }\n  return res;\n}",
    "badcase": "double seriesSum ( int n ) {\n  int i = 1 ;\n  double res = 0.0 ;\n  bool sign = true ;\n  while ( n > 0 ) {\n    n -- ;\n    if ( sign ) {\n      sign = false ;\n      res = res + ( i + 1 ) / ( i + 2 ) ;\n      i = i + 2 ;\n    }\n    else {\n      sign = true ;\n      res = res - ( i + 1 ) / ( i + 2 ) ;\n      i = i + 2 ;\n    }\n  }\n  return res ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( unsigned int x, unsigned int p1, unsigned int p2, unsigned int n ) {\n  unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 );\n  unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 );\n  unsigned int Xor = ( set1 ^ set2 );\n  Xor = ( Xor << p1 ) | ( Xor << p2 );\n  unsigned int result = x ^ Xor;\n  return result;\n}",
    "badcase": "int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) {\n  unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ;\n  unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ;\n  unsigned int xor = ( set1 ^ set2 ) ;\n  xor = ( xor << p1 ) ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "long long int f_gold ( int n ) {\n  int N = 10;\n  long long count = 1;\n  for ( int i = 1;\n  i <= n;\n  i ++ ) {\n    count *= ( N + i - 1 );\n    count /= i;\n  }\n  return count;\n}",
    "badcase": "int countNonDecreasing ( int n ) {\n  int N = 10 ;\n  int count = 1 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    count = count * ( N + i - 1 ) ;\n    count = count / i ;\n  }\n  return count ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( string a, string b ) {\n  int n = a . size ( ), m = b . size ( );\n  if ( m == 0 ) return 1;\n  int dp [ m + 1 ] [ n + 1 ];\n  memset ( dp, 0, sizeof ( dp ) );\n  for ( int i = 0;\n  i < m;\n  i ++ ) {\n    for ( int j = i;\n    j < n;\n    j ++ ) {\n      if ( i == 0 ) {\n        if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0;\n        else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1;\n        else dp [ i ] [ j ] = dp [ i ] [ j - 1 ];\n      }\n      else {\n        if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ];\n        else dp [ i ] [ j ] = dp [ i ] [ j - 1 ];\n      }\n    }\n  }\n  return dp [ m - 1 ] [ n - 1 ];\n}",
    "badcase": "int countTransformation ( string a , string b ) {\n  int n = a . length ( ) , m = b . length ( ) ;\n  if ( m == 0 ) return 1 ;\n  int dp [ m ] [ n ] ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      if ( i == 0 ) {\n        if ( j == 0 ) {\n          dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ;\n        }\n        else if ( a [ j ] == b [ i ] ) {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ;\n        }\n        else {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;\n        }\n      }\n      else {\n        if ( a [ j ] == b [ i ] ) {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ;\n        }\n        else {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;\n        }\n      }\n    }\n  }\n  return dp [ m - 1 ] [ n - 1 ] ;\n}"
  },
  {
    "type": "python_to_cpp",
    "GT": "int f_gold ( int n ) {\n  if ( n == 0 || n == 1 ) return n;\n  int f1 = 0, f2 = 1, f3 = 1;\n  while ( f3 <= n ) {\n    f1 = f2;\n    f2 = f3;\n    f3 = f1 + f2;\n  }\n  return f2;\n}",
    "badcase": "int nearestSmallerEqFib ( int n ) {\n  if ( n == 0 n == 1 ) return n ;\n  int f1 = 0 , f2 = 1 , f3 = 1 ;\n  while ( f3 <= n ) {\n    f1 = f2 ;\n    f2 = f3 ;\n    f3 = f1 + f2 ;\n  }\n  return f2 ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( long n ) {\n  long count = 0 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) for ( int j = 0 ;\n  j <= n ;\n  j ++ ) for ( int k = 0 ;\n  k <= n ;\n  k ++ ) if ( i + j + k == n ) count ++ ;\n  return count ;\n}",
    "badcase": "static int count_of_ways ( int n ) {\n    int count = 0 ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j <= n ;\n      j ++ ) {\n        for ( int k = 0 ;\n        k <= n ;\n        k ++ ) {\n          if ( i + j + k == n ) count ++ ;\n        }\n      }\n    }\n    return count ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( long n ) {\n  long count = 0 ;\n  count = ( n + 1 ) * ( n + 2 ) / 2 ;\n  return count ;\n}",
    "badcase": "static int count_of_ways ( int n ) {\n    int count = 0 ;\n    count = ( n + 1 ) * ( n + 2 ) / 2 ;\n    return count ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( double h , double m ) {\n  if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( \"Wrong input\" ) ;\n  if ( h == 12 ) h = 0 ;\n  if ( m == 60 ) m = 0 ;\n  int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ;\n  int minute_angle = ( int ) ( 6 * m ) ;\n  int angle = Math . abs ( hour_angle - minute_angle ) ;\n  angle = Math . min ( 360 - angle , angle ) ;\n  return angle ;\n}",
    "badcase": "static int calcAngle ( int h , int m ) {\n    if ( h < 0 || m < 0 || h > 12 || m > 60 ) {\n      System . out . println ( \"Wrong input\" ) ;\n    }\n    if ( h == 12 ) {\n      h = 0 ;\n    }\n    if ( m == 60 ) {\n      m = 0 ;\n    }\n    int hour_angle = 0 ;\n    int minute_angle = 0 ;\n    hour_angle = ( h * 60 + m ) * 0.5 ;\n    minute_angle = m * 6 ;\n    int angle = Math . abs ( hour_angle - minute_angle ) ;\n    angle = Math . min ( 360 - angle , angle ) ;\n    return angle ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int a [ ] , int n ) {\n  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ;\n  else mp . put ( a [ i ] , 1 ) ;\n  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ;\n  return false ;\n}",
    "badcase": "static boolean isMajority ( int a [ ] ) {\n    Map < Integer , Integer > mp = new HashMap < > ( ) ;\n    for ( int i = 0 ;\n    i < a . length ;\n    i ++ ) {\n      if ( mp . containsKey ( a [ i ] ) ) {\n        mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ;\n      }\n      else {\n        mp . put ( a [ i ] , 1 ) ;\n      }\n    }\n    for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) {\n      if ( x . getValue ( ) >= a . length / 2 ) {\n        return true ;\n      }\n    }\n    return false ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( String num ) {\n  int n = num . length ( ) ;\n  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;\n  if ( n % 3 == 1 ) num = \"00\" + num ;\n  if ( n % 3 == 2 ) num = \"0\" + num ;\n  int gSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int group = 0 ;\n    group += ( num . charAt ( i ++ ) - '0' ) * 100 ;\n    group += ( num . charAt ( i ++ ) - '0' ) * 10 ;\n    group += num . charAt ( i ) - '0' ;\n    gSum += group ;\n  }\n  if ( gSum > 1000 ) {\n    num = Integer . toString ( gSum ) ;\n    n = num . length ( ) ;\n    gSum = f_gold ( num ) ? 1 : 0 ;\n  }\n  return ( gSum == 999 ) ;\n}",
    "badcase": "static boolean isDivisible999 ( String num ) {\n    int n = num . length ( ) ;\n    if ( n == 0 || num . charAt ( 0 ) =='0') return true ;\n    if ( ( n % 3 ) == 1 ) num = \"00\" + num ;\n    if ( ( n % 3 ) == 2 ) num = \"0\" + num ;\n    int gSum = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i += 3 ) {\n      int group = 0 ;\n      group += ( num . charAt ( i ) -'0') * 100 ;\n      group += ( num . charAt ( i + 1 ) -'0') * 10 ;\n      group += ( num . charAt ( i + 2 ) -'0') ;\n      gSum += group ;\n    }\n    if ( gSum > 1000 ) {\n      num = String . valueOf ( gSum ) ;\n      n = num . length ( ) ;\n      gSum = isDivisible999 ( num ) ? 1 : 0 ;\n    }\n    return ( gSum == 999 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int [ ] a , int n ) {\n  int count_odd = 0 , count_even = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ;\n    else count_even ++ ;\n  }\n  if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ;\n  else return true ;\n}",
    "badcase": "static boolean flipsPossible ( int a [ ] , int n ) {\n    int count_odd = 0 , count_even = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( a [ i ] & 1 ) count_odd ++ ;\n      else count_even ++ ;\n    }\n    if ( count_odd % 2 != 0 && count_even % 2 != 0 ) return false ;\n    else return true ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int x , int y ) {\n  int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ;\n  double res2 = Math . log ( y ) / Math . log ( x ) ;\n  return ( res1 == res2 ) ;\n}",
    "badcase": "static boolean isPower ( int x , int y ) {\n    double res1 = Math . log ( y ) / Math . log ( x ) ;\n    double res2 = Math . log ( y ) / Math . log ( x ) ;\n    return ( res1 == res2 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( String str ) {\n  int n = str . length ( ) ;\n  int oddDigSum = 0 , evenDigSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ;\n    else evenDigSum += ( str . charAt ( i ) - '0' ) ;\n  }\n  return ( ( oddDigSum - evenDigSum ) % 11 == 0 )  ? 1 : 0 ;\n}",
    "badcase": "static boolean check ( String st ) {\n    int n = st . length ( ) ;\n    int oddDigSum = 0 ;\n    int evenDigSum = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( i % 2 == 0 ) oddDigSum = oddDigSum + ( st . charAt ( i ) -'0') ;\n      else evenDigSum = evenDigSum + ( st . charAt ( i ) -'0') ;\n    }\n    return ( oddDigSum - evenDigSum ) % 11 == 0 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( String str ) {\n  int n = str . length ( ) ;\n  int digitSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;\n  return ( digitSum % 9 == 0 ) ? 1 : 0  ;\n}",
    "badcase": "static boolean check ( String st ) {\n    int n = st . length ( ) ;\n    int digitSum = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      digitSum = digitSum + ( int ) ( st . charAt ( i ) ) ;\n    }\n    return ( digitSum % 9 == 0 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( String s1 , String s2 ) {\n  int n = s1 . length ( ) ;\n  int m = s2 . length ( ) ;\n  boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= m ;\n    j ++ ) {\n      dp [ i ] [ j ] = false ;\n    }\n  }\n  dp [ 0 ] [ 0 ] = true ;\n  for ( int i = 0 ;\n  i < s1 . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= s2 . length ( ) ;\n    j ++ ) {\n      if ( dp [ i ] [ j ] ) {\n        if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ;\n        if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ;\n      }\n    }\n  }\n  return ( dp [ n ] [ m ] ) ;\n}",
    "badcase": "static boolean check ( String s1 , String s2 ) {\n    int n = s1 . length ( ) ;\n    int m = s2 . length ( ) ;\n    boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ;\n    dp [ 0 ] [ 0 ] = true ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j <= m ;\n      j ++ ) {\n        if ( dp [ i ] [ j ] ) {\n          if ( j < m && ( s1 . charAt ( i ) == s2 . charAt ( j ) ) ) {\n            dp [ i + 1 ] [ j + 1 ] = true ;\n          }\n          if ( ! ( s1 . charAt ( i ) >='a'&& s1 . charAt ( i ) <='z') ) {\n            dp [ i + 1 ] [ j ] = true ;\n          }\n        }\n      }\n    }\n    return ( dp [ n ] [ m ] ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int arr [ ] , int n ) {\n  if ( n == 1 ) {\n    return true ;\n  }\n  int i ;\n  for ( i = 1 ;\n  arr [ i - 1 ] < arr [ i ] && i < n ;\n  i ++ ) ;\n  if ( i == n ) {\n    return true ;\n  }\n  int j = i ++ ;\n  while ( arr [ j ] < arr [ j - 1 ] ) {\n    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) {\n      return false ;\n    }\n    j ++ ;\n  }\n  if ( j == n ) {\n    return true ;\n  }\n  int k = j ;\n  if ( arr [ k ] < arr [ i - 1 ] ) {\n    return false ;\n  }\n  while ( k > 1 && k < n ) {\n    if ( arr [ k ] < arr [ k - 1 ] ) {\n      return false ;\n    }\n    k ++ ;\n  }\n  return true ;\n}",
    "badcase": "static boolean checkReverse ( int arr [ ] , int n ) {\n    if ( n == 1 ) return true ;\n    int i ;\n    for ( i = 1 ;\n    i < n ;\n    i ++ ) if ( arr [ i - 1 ] < arr [ i ] ) break ;\n    if ( i == n ) return true ;\n    int j = i ;\n    while ( arr [ j ] < arr [ j - 1 ] ) {\n      if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ;\n      j ++ ;\n    }\n    if ( j == n ) return true ;\n    int k = j ;\n    if ( arr [ k ] < arr [ i - 1 ] ) return false ;\n    while ( k > 1 && k < n ) {\n      if ( arr [ k ] < arr [ k - 1 ] ) return false ;\n      k ++ ;\n    }\n    return true ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( String num ) {\n  int n = num . length ( ) ;\n  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;\n  if ( n % 3 == 1 ) num = \"00\" + num ;\n  if ( n % 3 == 2 ) num = \"0\" + num ;\n  n = num . length ( ) ;\n  int gSum = 0 , p = 1 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    int group = 0 ;\n    group += num . charAt ( i -- ) - '0' ;\n    group += ( num . charAt ( i -- ) - '0' ) * 10 ;\n    group += ( num . charAt ( i ) - '0' ) * 100 ;\n    gSum = gSum + group * p ;\n    p = p * - 1 ;\n  }\n  return ( gSum % 7 == 0 )  ? 1 : 0 ;\n}",
    "badcase": "static boolean isdivisible7 ( String num ) {\n    int n = num . length ( ) ;\n    if ( n == 0 && num . charAt ( 0 ) =='â–') return true ;\n    if ( n % 3 == 1 ) {\n      num += \"00\" ;\n      n += 2 ;\n    }\n    else if ( n % 3 == 2 ) {\n      num += \"0\" ;\n      n += 1 ;\n    }\n    int GSum = 0 ;\n    int p = 1 ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      int group = 0 ;\n      group += num . charAt ( i -- ) -'0';\n      group += ( num . charAt ( i -- ) -'0') * 10 ;\n      group += ( num . charAt ( i ) -'0') * 100 ;\n      GSum = GSum + group * p ;\n      p *= - 1 ;\n    }\n    return ( GSum % 7 == 0 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( char [ ] str , int len ) {\n  int i = 0 , j = len - 1 ;\n  for ( ;\n  i < j ;\n  i ++ , j -- ) {\n    if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ;\n    else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {\n      str [ i ] = 'a' ;\n      str [ j ] = 'a' ;\n      continue ;\n    }\n    else if ( str [ i ] == '*' ) {\n      str [ i ] = str [ j ] ;\n      continue ;\n    }\n    else if ( str [ j ] == '*' ) {\n      str [ j ] = str [ i ] ;\n      continue ;\n    }\n    System . out . println ( \"Not Possible\" ) ;\n    return \"\" ;\n  }\n  return String . valueOf ( str ) ;\n}",
    "badcase": "static String constructPalin ( String str , int l ) {\n    char [ ] string = str . toCharArray ( ) ;\n    int i = - 1 ;\n    int j = l ;\n    while ( i < j ) {\n      i ++ ;\n      j -- ;\n      if ( string [ i ] == string [ j ] && string [ i ] !='*') {\n        continue ;\n      }\n      else if ( string [ i ] == string [ j ] && string [ i ] =='*') {\n        string [ i ] ='a';\n        string [ j ] ='a';\n        continue ;\n      }\n      else if ( string [ i ] =='*') {\n        string [ i ] = string [ j ] ;\n        continue ;\n      }\n      else if ( string [ j ] =='*') {\n        string [ j ] = string [ i ] ;\n        continue ;\n      }\n      System . out . println ( \"Not Possible\" ) ;\n      return \"\" ;\n    }\n    return String . valueOf ( string ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int x ) {\n  int dp [ ] = new int [ x + 1 ] ;\n  dp [ 0 ] = dp [ 1 ] = 1 ;\n  for ( int i = 2 ;\n  i <= x ;\n  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;\n  return dp [ x ] ;\n}",
    "badcase": "static int numberOfWays ( int x ) {\n    if ( x == 0 || x == 1 ) return 1 ;\n    else return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  if ( n < 0 ) return 0 ;\n  if ( n <= 1 ) return 1 ;\n  double digits = 0 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) digits += Math . log10 ( i ) ;\n  return ( int ) ( Math . floor ( digits ) ) + 1 ;\n}",
    "badcase": "static int findDigits ( int n ) {\n    if ( n < 0 ) return 0 ;\n    if ( n <= 1 ) return 1 ;\n    int digits = 0 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) digits += Math . log10 ( i ) ;\n    return ( int ) digits + 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( String S , String T ) {\n  int m = T . length ( ) ;\n  int n = S . length ( ) ;\n  if ( m > n ) return 0 ;\n  int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) mat [ i ] [ 0 ] = 0 ;\n  for ( int j = 0 ;\n  j <= n ;\n  j ++ ) mat [ 0 ] [ j ] = 1 ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;\n      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ;\n    }\n  }\n  return mat [ m ] [ n ] ;\n}",
    "badcase": "static int findSubsequenceCount ( String S , String T ) {\n    int m = T . length ( ) ;\n    int n = S . length ( ) ;\n    if ( m > n ) return 0 ;\n    int [ ] [ ] mat = new int [ m + 1 ] [ n + 1 ] ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) mat [ 0 ] [ i ] = 1 ;\n    for ( int i = 0 ;\n    i <= m ;\n    i ++ ) mat [ i ] [ 0 ] = 0 ;\n    for ( int i = 1 ;\n    i <= m ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j <= n ;\n      j ++ ) {\n        if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;\n        else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ;\n      }\n    }\n    return mat [ m ] [ n ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n , int k ) {\n  int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) dp [ i ] [ 0 ] = 0 ;\n  for ( int i = 0 ;\n  i <= k ;\n  i ++ ) dp [ 0 ] [ k ] = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) for ( int j = 1 ;\n  j <= k ;\n  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;\n  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ;\n  return dp [ n ] [ k ] ;\n}",
    "badcase": "static int countP ( int n , int k ) {\n    int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) dp [ i ] [ 0 ] = 0 ;\n    for ( int i = 0 ;\n    i <= k ;\n    i ++ ) dp [ 0 ] [ i ] = 0 ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j <= k ;\n      j ++ ) {\n        if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ;\n        else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ;\n      }\n    }\n    return dp [ n ] [ k ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char str [ ] , int n ) {\n  int ans = ( n * ( n + 1 ) ) / 2 ;\n  int a_index = 0 ;\n  int b_index = 0 ;\n  int c_index = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( str [ i ] == 'a' ) {\n      a_index = i + 1 ;\n      ans -= Math . min ( b_index , c_index ) ;\n    }\n    else if ( str [ i ] == 'b' ) {\n      b_index = i + 1 ;\n      ans -= Math . min ( a_index , c_index ) ;\n    }\n    else {\n      c_index = i + 1 ;\n      ans -= Math . min ( a_index , b_index ) ;\n    }\n  }\n  return ans ;\n}",
    "badcase": "static int CountSubString ( String Str , int n ) {\n    int ans = ( n * ( n + 1 ) ) / 2 ;\n    int a_index = 0 , b_index = 0 , c_index = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( Str . charAt ( i ) =='a') {\n        a_index = i + 1 ;\n        ans -= Math . min ( b_index , c_index ) ;\n      }\n      else if ( Str . charAt ( i ) =='b') {\n        b_index = i + 1 ;\n        ans -= Math . min ( a_index , c_index ) ;\n      }\n      else {\n        c_index = i + 1 ;\n        ans -= Math . min ( a_index , b_index ) ;\n      }\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char [ ] s ) {\n  int b_count = 0 ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < s . length ;\n  i ++ ) {\n    if ( s [ s . length - i - 1 ] == 'a' ) {\n      res = ( res + b_count ) ;\n      b_count = ( b_count * 2 ) ;\n    }\n    else {\n      b_count += 1 ;\n    }\n  }\n  return res ;\n}",
    "badcase": "static int abFree ( String s ) {\n    int b_count = 0 ;\n    int res = 0 ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      if ( s . charAt ( ~ i ) =='a') {\n        res = ( res + b_count ) ;\n        b_count = ( b_count * 2 ) ;\n      }\n      else b_count ++ ;\n    }\n    return res ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char str [ ] , int n ) {\n  int dp [ ] [ ] = new int [ n ] [ n ] ;\n  boolean P [ ] [ ] = new boolean [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) P [ i ] [ i ] = true ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( str [ i ] == str [ i + 1 ] ) {\n      P [ i ] [ i + 1 ] = true ;\n      dp [ i ] [ i + 1 ] = 1 ;\n    }\n  }\n  for ( int gap = 2 ;\n  gap < n ;\n  gap ++ ) {\n    for ( int i = 0 ;\n    i < n - gap ;\n    i ++ ) {\n      int j = gap + i ;\n      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;\n      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;\n    }\n  }\n  return dp [ 0 ] [ n - 1 ] ;\n}",
    "badcase": "static int CountPS ( String str , int n ) {\n    int dp [ ] [ ] = new int [ n ] [ n ] ;\n    boolean P [ ] [ ] = new boolean [ n ] [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) P [ i ] [ i ] = true ;\n    for ( int i = 0 ;\n    i < n - 1 ;\n    i ++ ) {\n      if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) {\n        P [ i ] [ i + 1 ] = true ;\n        dp [ i ] [ i + 1 ] = 1 ;\n      }\n    }\n    for ( int gap = 2 ;\n    gap < n ;\n    gap ++ ) {\n      for ( int i = 0 ;\n      i < n - gap ;\n      i ++ ) {\n        int j = gap + i ;\n        if ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) {\n          P [ i ] [ j ] = true ;\n        }\n        if ( P [ i ] [ j ] == true ) {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;\n        }\n        else {\n          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;\n        }\n      }\n    }\n    return dp [ 0 ] [ n - 1 ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char digits [ ] , int n ) {\n  int count [ ] = new int [ n + 1 ] ;\n  count [ 0 ] = 1 ;\n  count [ 1 ] = 1 ;\n  if ( digits [ 0 ] == '0' ) return 0 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    count [ i ] = 0 ;\n    if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ;\n    if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ;\n  }\n  return count [ n ] ;\n}",
    "badcase": "static int countDecodingDP ( char digits [ ] , int n ) {\n  int count [ ] = new int [ n + 1 ] ;\n  count [ 0 ] = 1 ;\n  count [ 1 ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    count [ i ] = 0 ;\n    if ( digits [ i - 1 ] >'0') count [ i ] = count [ i - 1 ] ;\n    if ( digits [ i - 2 ] =='1'|| ( digits [ i - 2 ] =='2' && digits [ i - 1 ] <'7')) count [ i ] += count [ i - 2 ] ;\n  }\n  return count [ n ] ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int mat [ ] [ ] , int r , int c ) {\n  int result = 0 ;\n  for ( int i = 0 ;\n  i < r ;\n  i ++ ) {\n    int j ;\n    for ( j = 0 ;\n    j < c - 1 ;\n    j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ;\n    if ( j == c - 1 ) result ++ ;\n  }\n  for ( int i = 0 ;\n  i < r ;\n  i ++ ) {\n    int j ;\n    for ( j = c - 1 ;\n    j > 0 ;\n    j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ;\n    if ( c > 1 && j == 0 ) result ++ ;\n  }\n  return result ;\n}",
    "badcase": "static int sortedCount ( int mat [ ] [ ] , int r , int c ) {\n    int result = 0 ;\n    for ( int i = 0 ;\n    i < r ;\n    i ++ ) {\n      int j ;\n      for ( j = 0 ;\n      j < c - 1 ;\n      j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ;\n      if ( j == c - 2 ) result ++ ;\n    }\n    for ( int i = 0 ;\n    i < r ;\n    i ++ ) {\n      int j ;\n      for ( j = 0 ;\n      j > c - 1 ;\n      j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ;\n      if ( c > 1 && j == 1 ) result ++ ;\n    }\n    return result ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int i = 0 ;\n  int ans = 0 ;\n  while ( ( 1 << i ) <= n ) {\n    boolean k = false ;\n    int change = 1 << i ;\n    for ( int j = 0 ;\n    j <= n ;\n    j ++ ) {\n      if ( k == true ) ans += 1 ;\n      else ans += 0 ;\n      if ( change == 1 ) {\n        k = ! k ;\n        change = 1 << i ;\n      }\n      else {\n        change -- ;\n      }\n    }\n    i ++ ;\n  }\n  return ans ;\n}",
    "badcase": "static int countSetBits ( int n ) {\n    int i , k , change ;\n    int ans = 0 ;\n    for ( i = 0 ;\n    ( 1 << i ) <= n ;\n    ++ i ) {\n      for ( k = 0 , change = 1 << i ;\n      j <= n ;\n      ++ j ) {\n        ans += k ;\n        if ( change == 1 ) {\n          k ^= 1 ;\n          change = 1 << i ;\n        }\n        else change -- ;\n      }\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( int n ) {\n  long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ;\n  dp [ 0 ] [ 1 ] = 1 ;\n  dp [ 1 ] [ 1 ] = 2 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;\n    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ;\n  }\n  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;\n}",
    "badcase": "static int countWays ( int n ) {\n    int dp [ ] [ ] = new int [ 2 ] [ n + 1 ] ;\n    dp [ 0 ] [ 1 ] = 1 ;\n    dp [ 1 ] [ 1 ] = 2 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) {\n      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;\n      dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ;\n    }\n    return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( String str [ ] , int n ) {\n  HashMap < String , Integer > m = new HashMap < > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( m . containsKey ( str [ i ] ) ) {\n      int get = m . get ( str [ i ] ) ;\n      m . put ( str [ i ] , get + 1 ) ;\n    }\n    else {\n      m . put ( str [ i ] , 1 ) ;\n    }\n  }\n  int res = 0 ;\n  for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) {\n    if ( it . getValue ( ) == 2 ) res ++ ;\n  }\n  return res ;\n}",
    "badcase": "static int countWords ( String str , int n ) {\n    HashMap < Character , Integer > m = new HashMap < > ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      m . put ( str . charAt ( i ) , m . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ;\n    }\n    int res = 0 ;\n    for ( Map . Entry < Character , Integer > i : m . entrySet ( ) ) {\n      if ( i . getValue ( ) == 2 ) {\n        res ++ ;\n      }\n    }\n    return res ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  Arrays . sort ( arr ) ;\n  return arr [ n - 1 ] ;\n}",
    "badcase": "static int largest ( int arr [ ] , int n ) {\n    int i ;\n    int max = - 2147483648 ;\n    for ( i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( arr [ i ] > max ) {\n        max = arr [ i ] ;\n      }\n    }\n    return max ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static long f_gold ( int m , int n , int x ) {\n  long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ;\n  for ( int j = 1 ;\n  j <= m && j <= x ;\n  j ++ ) table [ 1 ] [ j ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= x ;\n    j ++ ) {\n      for ( int k = 1 ;\n      k < j && k <= m ;\n      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;\n    }\n  }\n  return table [ n ] [ x ] ;\n}",
    "badcase": "static int findWays ( int m , int n , int x ) {\n    int [ ] [ ] table = new int [ n + 1 ] [ x + 1 ] ;\n    for ( int j = 1 ;\n    j < Math . min ( m + 1 , x + 1 ) ;\n    j ++ ) table [ 1 ] [ j ] = 1 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j <= x ;\n      j ++ ) {\n        for ( int k = 1 ;\n        k < Math . min ( m + 1 , j ) ;\n        k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;\n      }\n    }\n    return table [ n ] [ x ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  if ( n == 0 || n == 9 ) return true ;\n  if ( n < 9 ) return false ;\n  return f_gold ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ;\n}",
    "badcase": "static boolean isDivBy9 ( int n ) {\n    if ( n == 0 n ==9 ) return true ;\n    if ( n < 9 ) return false ;\n    return isDivBy9 ( n >> 3 - n & 7 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( String num ) {\n  if ( num . length ( ) >= 3 ) {\n    int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ;\n    if ( d1 % 2 != 0 ) return false ;\n    int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ;\n    int sum = 0 ;\n    for ( int i = 0 ;\n    i < num . length ( ) ;\n    i ++ ) sum += num . charAt ( i ) ;\n    return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;\n  }\n  else {\n    int number = Integer . parseInt ( num ) ;\n    return ( number % 12 == 0 ) ;\n  }\n}",
    "badcase": "static boolean isDivisibleBy12 ( String num ) {\n    if ( num . length ( ) >= 3 ) {\n      int d1 = num . charAt ( num . length ( ) - 1 ) -'0';\n      if ( d1 % 2 != 0 ) return false ;\n      int d2 = num . charAt ( num . length ( ) - 2 ) -'0';\n      int sum = 0 ;\n      for ( int i = 0 ;\n      i < num . length ( ) ;\n      i ++ ) {\n        sum += num . charAt ( i ) -'0';\n      }\n      return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;\n    }\n    else {\n      int number = Integer . parseInt ( num ) ;\n      return ( number % 12 == 0 ) ;\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int num ) {\n  if ( num < 0 ) return f_gold ( - num ) ;\n  if ( num == 0 || num == 7 ) return 1 ;\n  if ( num < 10 ) return 0 ;\n  return f_gold ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;\n}",
    "badcase": "static boolean isDivisibleBy7 ( int num ) {\n    if ( num < 0 ) return isDivisibleBy7 ( - num ) ;\n    if ( num == 0 || num == 7 ) return true ;\n    if ( num < 10 ) return false ;\n    return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int res = 1 ;\n  for ( int i = n ;\n  i >= 0 ;\n  i = i - 2 ) {\n    if ( i == 0 || i == 1 ) return res ;\n    else res *= i ;\n  }\n  return res ;\n}",
    "badcase": "static int doublefactorial ( int n ) {\n    int res = 1 ;\n    for ( int i = n ;\n    i >= 0 ;\n    i -= 2 ) {\n      if ( i == 0 i == 1 ) return res ;\n      else res *= i ;\n    }\n    return res ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  int i , j , max = 0 ;\n  int msis [ ] = new int [ n ] ;\n  for ( i = 0 ;\n  i < n ;\n  i ++ ) msis [ i ] = arr [ i ] ;\n  for ( i = 1 ;\n  i < n ;\n  i ++ ) for ( j = 0 ;\n  j < i ;\n  j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ;\n  for ( i = 0 ;\n  i < n ;\n  i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;\n  return max ;\n}",
    "badcase": "static int maxSumIS ( int arr [ ] , int n ) {\n    int i , j , max = 0 ;\n    int msis [ ] = new int [ n ] ;\n    for ( i = 0 ;\n    i < n ;\n    i ++ ) msis [ i ] = arr [ i ] ;\n    for ( i = 1 ;\n    i < n ;\n    i ++ ) for ( j = 0 ;\n    j < i ;\n    j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = ms [ j ] + arr [ i ] ;\n    for ( i = 0 ;\n    i < n ;\n    i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;\n    return max ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char str [ ] , int l , int h ) {\n  if ( l > h ) return Integer . MAX_VALUE ;\n  if ( l == h ) return 0 ;\n  if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;\n  return ( str [ l ] == str [ h ] ) ? f_gold ( str , l + 1 , h - 1 ) : ( Integer . min ( f_gold ( str , l , h - 1 ) , f_gold ( str , l + 1 , h ) ) + 1 ) ;\n}",
    "badcase": "static int findMinInsertions ( String str , int l , int h ) {\n    if ( l > h ) return Integer . MAX_VALUE ;\n    if ( l == h ) return 0 ;\n    if ( l == h - 1 ) return ( str . charAt ( l ) == str . charAt ( h ) ) ? 0 : 1 ;\n    if ( str . charAt ( l ) == str . charAt ( h ) ) return findMinInsertions ( str , l + 1 , h - 1 ) ;\n    else return Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  if ( n == 2 || n == 3 ) return ( n - 1 ) ;\n  int res = 1 ;\n  while ( n > 4 ) {\n    n -= 3 ;\n    res *= 3 ;\n  }\n  return ( n * res ) ;\n}",
    "badcase": "static int maxProd ( int n ) {\n    if ( n == 2 n == 3 ) return ( n - 1 ) ;\n    int res = 1 ;\n    while ( n > 4 ) {\n      n -= 3 ;\n      res *= 3 ;\n    }\n    return ( n * res ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char symb [ ] , char oper [ ] , int n ) {\n  int F [ ] [ ] = new int [ n ] [ n ] ;\n  int T [ ] [ ] = new int [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ;\n    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ;\n  }\n  for ( int gap = 1 ;\n  gap < n ;\n  ++ gap ) {\n    for ( int i = 0 , j = gap ;\n    j < n ;\n    ++ i , ++ j ) {\n      T [ i ] [ j ] = F [ i ] [ j ] = 0 ;\n      for ( int g = 0 ;\n      g < gap ;\n      g ++ ) {\n        int k = i + g ;\n        int tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n        if ( oper [ k ] == '&' ) {\n          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '|' ) {\n          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;\n        }\n        if ( oper [ k ] == '^' ) {\n          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n          F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n        }\n      }\n    }\n  }\n  return T [ 0 ] [ n - 1 ] ;\n}",
    "badcase": "static int countParenth ( char symb [ ] , char oper [ ] , int n ) {\n    int F [ ] [ ] = new int [ n ] [ n ] ;\n    int T [ ] [ ] = new int [ n ] [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      F [ i ] [ i ] = ( symb [ i ] =='F') ? 1 : 0 ;\n      T [ i ] [ i ] = ( symb [ i ] =='T') ? 1 : 0 ;\n    }\n    for ( int gap = 1 ;\n    gap < n ;\n    ++ gap ) {\n      for ( int i = 0 , j = gap ;\n      j < n ;\n      ++ i , ++ j ) {\n        T [ i ] [ j ] = F [ i ] [ j ] = 0 ;\n        for ( int g = 0 ;\n        g < gap ;\n        g ++ ) {\n          int k = i + g ;\n          int tik = T [ i ] [ k ] + F [ i ] [ k ] ;\n          int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;\n          if ( oper [ k ] =='&') {\n            T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;\n            F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;\n          }\n          if ( oper [ k ] =='|') {\n            F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;\n            T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;\n          }\n        }\n      }\n    }\n    return T [ 0 ] [ n - 1 ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  int i , j ;\n  int leftsum , rightsum ;\n  for ( i = 0 ;\n  i < n ;\n  ++ i ) {\n    leftsum = 0 ;\n    for ( j = 0 ;\n    j < i ;\n    j ++ ) leftsum += arr [ j ] ;\n    rightsum = 0 ;\n    for ( j = i + 1 ;\n    j < n ;\n    j ++ ) rightsum += arr [ j ] ;\n    if ( leftsum == rightsum ) return i ;\n  }\n  return - 1 ;\n}",
    "badcase": "static int equilibrium ( int arr [ ] ) {\n    int leftsum , rightsum = 0 ;\n    int i , j ;\n    int n = arr . length ;\n    for ( i = 0 ;\n    i < n ;\n    ++ i ) {\n      leftsum = 0 ;\n      rightsum = 0 ;\n      for ( j = 0 ;\n      j < i ;\n      ++ j ) leftsum += arr [ j ] ;\n      for ( j = i + 1 ;\n      j < n ;\n      ++ j ) rightsum += arr [ j ] ;\n      if ( leftsum == rightsum ) return i ;\n    }\n    return - 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  int sum = 0 ;\n  int leftsum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) sum += arr [ i ] ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    sum -= arr [ i ] ;\n    if ( leftsum == sum ) return i ;\n    leftsum += arr [ i ] ;\n  }\n  return - 1 ;\n}",
    "badcase": "static int equilibrium ( int arr [ ] ) {\n    int total_sum = 0 ;\n    for ( int num : arr ) total_sum += num ;\n    int leftsum = 0 ;\n    for ( int i = 0 ;\n    i < arr . length ;\n    ++ i ) {\n      total_sum -= arr [ i ] ;\n      if ( leftsum == total_sum ) return i ;\n      leftsum += arr [ i ] ;\n    }\n    return - 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int p ) {\n  int first = 1 , second = 1 , number = 2 , next = 1 ;\n  while ( next > 0 ) {\n    next = ( first + second ) % p ;\n    first = second ;\n    second = next ;\n    number ++ ;\n  }\n  return number ;\n}",
    "badcase": "static int findMinZero ( int p ) {\n    int first = 1 , second = 1 ;\n    int number = 2 ;\n    int next = 1 ;\n    do {\n      next = ( first + second ) % p ;\n      first = second ;\n      second = next ;\n      number ++ ;\n    }\n    while ( next != 1 ) ;\n    return number ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n , int p ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    int count = 0 , temp = i ;\n    while ( temp % p == 0 ) {\n      count ++ ;\n      temp = temp / p ;\n    }\n    ans += count ;\n  }\n  return ans ;\n}",
    "badcase": "static int PowerOFPINnfactorial ( int n , int p ) {\n    int ans = 0 ;\n    int temp = p ;\n    while ( temp <= n ) {\n      ans += n / temp ;\n      temp = temp * p ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n , int p ) {\n  int ans = 0 ;\n  int temp = p ;\n  while ( temp <= n ) {\n    ans += n / temp ;\n    temp = temp * p ;\n  }\n  return ans ;\n}",
    "badcase": "static int PowerOFPINnfactorial ( int n , int p ) {\n    int ans = 0 ;\n    int temp = p ;\n    while ( temp <= n ) {\n      ans += n / temp ;\n      temp = temp * p ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  int brr [ ] = new int [ 2 * n + 1 ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) brr [ i ] = arr [ i ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) brr [ n + i ] = arr [ i ] ;\n  int maxHam = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    int currHam = 0 ;\n    for ( int j = i , k = 0 ;\n    j < ( i + n ) ;\n    j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;\n    if ( currHam == n ) return n ;\n    maxHam = Math . max ( maxHam , currHam ) ;\n  }\n  return maxHam ;\n}",
    "badcase": "static int maxHamming ( int arr [ ] , int n ) {\n    int brr [ ] = new int [ 2 * n + 1 ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) brr [ i ] = arr [ i ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) brr [ n + i ] = arr [ i ] ;\n    int maxHam = 0 ;\n    for ( int i = 1 ;\n    i < n ;\n    i ++ ) {\n      int currHam = 0 ;\n      int k = 0 ;\n      for ( int j = i ;\n      j < i + n ;\n      j ++ ) {\n        if ( brr [ j ] != arr [ k ] ) {\n          currHam ++ ;\n          k = k + 1 ;\n        }\n      }\n      if ( currHam == n ) return n ;\n      maxHam = Math . max ( maxHam , currHam ) ;\n    }\n    return maxHam ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] S , int n ) {\n  boolean found = false ;\n  Arrays . sort ( S ) ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( i == j ) continue ;\n      for ( int k = j + 1 ;\n      k < n ;\n      k ++ ) {\n        if ( i == k ) continue ;\n        for ( int l = k + 1 ;\n        l < n ;\n        l ++ ) {\n          if ( i == l ) continue ;\n          if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {\n            found = true ;\n            return S [ i ] ;\n          }\n        }\n      }\n    }\n  }\n  if ( found == false ) return Integer . MAX_VALUE ;\n  return - 1 ;\n}",
    "badcase": "static int findLargestd ( int [ ] S , int n ) {\n    boolean found = false ;\n    Arrays . sort ( S ) ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      for ( int j = 0 ;\n      j < n ;\n      j ++ ) {\n        if ( i == j ) continue ;\n        for ( int k = j + 1 ;\n        k < n ;\n        k ++ ) {\n          if ( i == k ) continue ;\n          for ( int l = k + 1 ;\n          l < n ;\n          l ++ ) {\n            if ( i == l ) continue ;\n            if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {\n              found = true ;\n              return S [ i ] ;\n            }\n          }\n        }\n      }\n    }\n    if ( found == false ) return - 1 ;\n    return - 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( long n ) {\n  long maxPrime = - 1 ;\n  while ( n % 2 == 0 ) {\n    maxPrime = 2 ;\n    n >>= 1 ;\n  }\n  for ( int i = 3 ;\n  i <= Math . sqrt ( n ) ;\n  i += 2 ) {\n    while ( n % i == 0 ) {\n      maxPrime = i ;\n      n = n / i ;\n    }\n  }\n  if ( n > 2 ) maxPrime = n ;\n  return maxPrime ;\n}",
    "badcase": "static int maxPrimeFactors ( int n ) {\n    int maxPrime = - 1 ;\n    while ( n % 2 == 0 ) {\n      maxPrime = 2 ;\n      n >>= 1 ;\n    }\n    for ( int i = 3 ;\n    i <= Math . sqrt ( n ) ;\n    i += 2 ) {\n      while ( n % i == 0 ) {\n        maxPrime = i ;\n        n = n / i ;\n      }\n    }\n    if ( n > 2 ) maxPrime = n ;\n    return maxPrime ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( long A , long B ) {\n  int variable = 1 ;\n  if ( A == B ) return 1 ;\n  else if ( ( B - A ) >= 5 ) return 0 ;\n  else {\n    for ( long i = A + 1 ;\n    i <= B ;\n    i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ;\n    return variable % 10 ;\n  }\n}",
    "badcase": "static int computeLastDigit ( int A , int B ) {\n    int variable = 1 ;\n    if ( A == B ) return 1 ;\n    else if ( ( B - A ) >= 5 ) return 0 ;\n    else {\n      for ( int i = A + 1 ;\n      i <= B ;\n      i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ;\n      return variable % 10 ;\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static int f_gold ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) {\n  int sum1 = 0 , sum2 = 0 , sum3 = 0 ;\n  for ( int i = 0 ;\n  i < n1 ;\n  i ++ ) sum1 += stack1 [ i ] ;\n  for ( int i = 0 ;\n  i < n2 ;\n  i ++ ) sum2 += stack2 [ i ] ;\n  for ( int i = 0 ;\n  i < n3 ;\n  i ++ ) sum3 += stack3 [ i ] ;\n  int top1 = 0 , top2 = 0 , top3 = 0 ;\n  int ans = 0 ;\n  while ( true ) {\n    if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ;\n    if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;\n    if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ;\n    else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ;\n    else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ;\n  }\n}",
    "badcase": "static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) {\n    int sum1 = 0 , sum2 = 0 , sum3 = 0 ;\n    for ( int i = 0 ;\n    i < n1 ;\n    i ++ ) sum1 += stack1 [ i ] ;\n    for ( int i = 0 ;\n    i < n2 ;\n    i ++ ) sum2 += stack2 [ i ] ;\n    for ( int i = 0 ;\n    i < n3 ;\n    i ++ ) sum3 += stack3 [ i ] ;\n    int top1 = 0 , top2 = 0 , top3 = 0 ;\n    int ans = 0 ;\n    while ( true ) {\n      if ( top1 == n1 top2 == n2 top3 == n3 ) return 0 ;\n      if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;\n      if ( sum1 >= sum2 && sum1 >= sum3 ) {\n        sum1 -= stack1 [ top1 ] ;\n        top1 ++ ;\n      }\n      else if ( sum2 >= sum3 && sum2 >= sum1 ) {\n        sum2 -= stack2 [ top2 ] ;\n        top2 ++ ;\n      }\n      else if ( sum3 >= sum2 && sum3 >= sum1 ) {\n        sum3 -= stack3 [ top3 ] ;\n        top3 ++ ;\n      }\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int m [ ] [ ] , int r , int c ) {\n  int max = Integer . MIN_VALUE ;\n  int min = Integer . MAX_VALUE ;\n  for ( int i = 0 ;\n  i < r ;\n  i ++ ) {\n    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;\n    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;\n  }\n  int desired = ( r * c + 1 ) / 2 ;\n  while ( min < max ) {\n    int mid = min + ( max - min ) / 2 ;\n    int place = 0 ;\n    int get = 0 ;\n    for ( int i = 0 ;\n    i < r ;\n    ++ i ) {\n      get = Arrays . binarySearch ( m [ i ] , mid ) ;\n      if ( get < 0 ) get = Math . abs ( get ) - 1 ;\n      else {\n        while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ;\n      }\n      place = place + get ;\n    }\n    if ( place < desired ) min = mid + 1 ;\n    else max = mid ;\n  }\n  return min ;\n}",
    "badcase": "static int upper_bound ( int [ ] a , int key ) {\n    int l = 0 , h = a . length ;\n    while ( l < h ) {\n      int mid = l + ( h - l ) / 2 ;\n      if ( key < a [ mid ] ) h = mid ;\n      else l = mid + 1 ;\n    }\n    return l ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( boolean input [ ] [ ] , int n ) {\n  boolean row [ ] [ ] = new boolean [ n ] [ n ] ;\n  boolean col [ ] [ ] = new boolean [ n ] [ n ] ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    boolean isEndless = true ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      if ( input [ i ] [ j ] == false ) isEndless = false ;\n      col [ i ] [ j ] = isEndless ;\n    }\n  }\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    boolean isEndless = true ;\n    for ( int j = n - 1 ;\n    j >= 0 ;\n    j -- ) {\n      if ( input [ i ] [ j ] == false ) isEndless = false ;\n      row [ i ] [ j ] = isEndless ;\n    }\n  }\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 1 ;\n  j < n ;\n  j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;\n  return ans ;\n}",
    "badcase": "static int countEndless ( int input_mat [ ] [ ] , int n ) {\n    int row [ ] [ ] = new int [ n ] [ n ] ;\n    int col [ ] [ ] = new int [ n ] [ n ] ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      int isEndless = 1 ;\n      for ( int i = n - 1 ;\n      i >= 0 ;\n      i -- ) {\n        if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 ;\n        col [ i ] [ j ] = isEndless ;\n      }\n    }\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int isEndless = 1 ;\n      for ( int j = n - 1 ;\n      j >= 0 ;\n      j -- ) {\n        if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 ;\n        row [ i ] [ j ] = isEndless ;\n      }\n    }\n    int ans = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j < n ;\n      j ++ ) {\n        if ( row [ i ] [ j ] != 0 && col [ i ] [ j ] != 0 ) ans ++ ;\n      }\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int a , int b ) {\n  int cnt = 0 ;\n  for ( int i = a ;\n  i <= b ;\n  i ++ ) for ( int j = 1 ;\n  j * j <= i ;\n  j ++ ) if ( j * j == i ) cnt ++ ;\n  return cnt ;\n}",
    "badcase": "static int CountSquares ( int a , int b ) {\n    int cnt = 0 ;\n    for ( int i = a ;\n    i <= b ;\n    i ++ ) {\n      for ( int j = 1 ;\n      j * j <= i ;\n      j ++ ) {\n        if ( j * j == i ) cnt ++ ;\n      }\n    }\n    return cnt ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) sum += arr [ i ] ;\n  return sum - ( ( ( n - 1 ) * n ) / 2 ) ;\n}",
    "badcase": "static int findRepeating ( int arr [ ] , int n ) {\n    return ( sum ( arr ) - ( ( n - 1 ) * n ) / 2 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;\n  int i , j ;\n  for ( i = 0 ;\n  i <= n ;\n  i ++ ) {\n    for ( j = 0 ;\n    j <= Math . min ( i , n ) ;\n    j ++ ) {\n      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;\n      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;\n    }\n  }\n  int sum = 0 ;\n  for ( i = 0 ;\n  i <= n ;\n  i += 2 ) sum += C [ n ] [ i ] ;\n  return sum ;\n}",
    "badcase": "static int evenSum ( int n ) {\n    int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j <= Math . min ( i , n ) ;\n      j ++ ) {\n        if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;\n        else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;\n      }\n    }\n    int sum = 0 ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) {\n      if ( n % 2 == 0 ) sum = sum + C [ n ] [ i ] ;\n    }\n    return sum ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static double f_gold ( int l ) {\n  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;\n  double sumLastLevel = 0 ;\n  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ;\n  double sum = sumLastLevel * l ;\n  return sum ;\n}",
    "badcase": "static int sumNodes ( int l ) {\n    int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ;\n    int sumLastLevel = 0 ;\n    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ;\n    int sum = sumLastLevel * l ;\n    return sum ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int a [ ] , int n ) {\n  HashSet < Integer > s = new HashSet < Integer > ( ) ;\n  for ( int i : a ) {\n    s . add ( i ) ;\n  }\n  int arr_sum = 0 ;\n  for ( int i : a ) {\n    arr_sum += i ;\n  }\n  int set_sum = 0 ;\n  for ( int i : s ) {\n    set_sum += i ;\n  }\n  return ( 3 * set_sum - arr_sum ) / 2 ;\n}",
    "badcase": "static int singleNumber ( int [ ] nums ) {\n    Set < Integer > set = new HashSet < > ( ) ;\n    int sumSet = 0 , sumArray = 0 ;\n    for ( int i = 0 ;\n    i < nums . length ;\n    i ++ ) {\n      if ( ! set . contains ( nums [ i ] ) ) {\n        set . add ( nums [ i ] ) ;\n        sumSet += nums [ i ] ;\n      }\n      sumArray += nums [ i ] ;\n    }\n    return ( 3 * sumSet - sumArray ) / 2 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  int max_len = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int curr_sum = 0 ;\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      curr_sum += arr [ j ] ;\n      if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ;\n    }\n  }\n  return max_len ;\n}",
    "badcase": "static int maxLen ( int arr [ ] ) {\n    int max_len = 0 ;\n    for ( int i = 0 ;\n    i < arr . length ;\n    i ++ ) {\n      int curr_sum = 0 ;\n      for ( int j = i ;\n      j < arr . length ;\n      j ++ ) {\n        curr_sum += arr [ j ] ;\n        if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ;\n      }\n    }\n    return max_len ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n , int x , int y ) {\n  int i , j ;\n  int min_dist = Integer . MAX_VALUE ;\n  for ( i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ;\n    }\n  }\n  return min_dist ;\n}",
    "badcase": "static int minDist ( int arr [ ] , int n , int x , int y ) {\n    int min_dist = 99999999 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = i + 1 ;\n      j < n ;\n      j ++ ) {\n        if ( ( x == arr [ i ] && y == arr [ j ] ) || ( y == arr [ i ] && x == arr [ j ] ) ) if ( min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ;\n      }\n    }\n    return min_dist ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int ar [ ] , int ar_size ) {\n  int i ;\n  int res = 0 ;\n  for ( i = 0 ;\n  i < ar_size ;\n  i ++ ) {\n    res = res ^ ar [ i ] ;\n  }\n  return res ;\n}",
    "badcase": "static int getOddOccurrence ( int arr [ ] ) {\n  int res = 0 ;\n  for ( int element : arr ) res = res ^ element ;\n  return res ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( long y , long x ) {\n  if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ;\n  if ( x > 63 ) return y ;\n  return ( y % ( 1 << ( int ) x ) ) ;\n}",
    "badcase": "static int yMod ( int y , int x ) {\n  return ( y % ( int ) Math . pow ( 2 , x ) ) ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  return 1162261467 % n == 0 ;\n}",
    "badcase": "static int check ( int n ) {\n  return 1162261467 % n == 0 ? 1 : 0 ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( String seq ) {\n  int n = seq . length ( ) ;\n  if ( n >= 9 ) return \"-1\" ;\n  char result [ ] = new char [ n + 1 ] ;\n  int count = 1 ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i == n || seq . charAt ( i ) == 'I' ) {\n      for ( int j = i - 1 ;\n      j >= - 1 ;\n      j -- ) {\n        result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ;\n        if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ;\n      }\n    }\n  }\n  return new String ( result ) ;\n}",
    "badcase": "param0.add(\"D\");\n    param0.add(\"I\");\n    param0.add(\"DD\");\n    param0.add(\"II\");\n    param0.add(\"DIDI\");\n    param0.add(\"IIDDD\");\n    param0.add(\"DDIDDIID\");\n    param0.add(\"176297\");\n    param0.add(\"1\");\n    param0.add(\"XHkhZq\");\n    for(int i = 0; i < param0.size(); ++i)\n    {\n        if(getMinNumberForPattern(param0.get(i)).equals(f_gold(param0.get(i))))\n        {\n            n_success+=1;\n        }\n    }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int a = 1 , b = 2 , c = 0 ;\n  if ( n <= 2 ) {\n    return n ;\n  }\n  for ( int i = 3 ;\n  i <= n ;\n  i ++ ) {\n    c = b + ( i - 1 ) * a ;\n    a = b ;\n    b = c ;\n  }\n  return c ;\n}",
    "badcase": "static int countFriendsPairings ( int n ) {\n    int a = 1 , b = 2 ;\n    if ( n <= 2 ) return n ;\n    int c ;\n    for ( int i = 3 ;\n    i <= n ;\n    i ++ ) {\n      c = b + ( i - 1 ) * a ;\n      a = b ;\n      b = c ;\n    }\n    return c ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n , int x ) {\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] == x ) return i ;\n  }\n  return - 1 ;\n}",
    "badcase": "static int search ( int arr [ ] , int x ) {\n    int n = arr . length ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( x == arr [ j ] ) {\n        return j ;\n      }\n    }\n    return - 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n , int k ) {\n  int sum [ ] = new int [ n + 1 ] ;\n  sum [ 0 ] = 0 ;\n  sum [ 1 ] = arr [ 0 ] ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;\n  PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = i ;\n    j <= n ;\n    j ++ ) {\n      int x = sum [ j ] - sum [ i - 1 ] ;\n      if ( Q . size ( ) < k ) Q . add ( x ) ;\n      else {\n        if ( Q . peek ( ) < x ) {\n          Q . poll ( ) ;\n          Q . add ( x ) ;\n        }\n      }\n    }\n  }\n  return Q . poll ( ) ;\n}",
    "badcase": "static int kthLargestSum ( int arr [ ] , int n , int k ) {\n    int sum [ ] = new int [ n + 1 ] ;\n    sum [ 0 ] = 0 ;\n    sum [ 1 ] = arr [ 0 ] ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;\n    PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = i ;\n      j <= n ;\n      j ++ ) {\n        int x = sum [ j ] - sum [ i - 1 ] ;\n        if ( Q . size ( ) < k ) Q . add ( x ) ;\n        else {\n          if ( Q . peek ( ) < x ) {\n            Q . poll ( ) ;\n            Q . add ( x ) ;\n          }\n        }\n      }\n    }\n    return Q . peek ( ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  int sum = 0 ;\n  int maxsize = - 1 , startindex = 0 ;\n  int endindex = 0 ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      if ( arr [ j ] == 0 ) sum += - 1 ;\n      else sum += 1 ;\n      if ( sum == 0 && maxsize < j - i + 1 ) {\n        maxsize = j - i + 1 ;\n        startindex = i ;\n      }\n    }\n  }\n  endindex = startindex + maxsize - 1 ;\n  if ( maxsize == - 1 ) System . out . println ( \"No such subarray\" ) ;\n  else System . out . println ( startindex + \" to \" + endindex ) ;\n  return maxsize ;\n}",
    "badcase": "static int findSubArray ( int arr [ ] , int n ) {\n    int sum = 0 ;\n    int maxsize = - 1 ;\n    for ( int i = 0 ;\n    i < n - 1 ;\n    i ++ ) {\n      sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;\n      for ( int j = i + 1 ;\n      j < n ;\n      j ++ ) {\n        sum = ( arr [ j ] == 0 ) ? sum - 1 : sum + 1 ;\n        if ( sum == 0 && maxsize < j - i + 1 ) {\n          maxsize = j - i + 1 ;\n          startindex = i ;\n        }\n      }\n    }\n    if ( maxsize == - 1 ) System . out . println ( \"No such subarray\" ) ;\n    else System . out . println ( startindex + \" to \" + ( startindex + maxsize - 1 ) ) ;\n    return maxsize ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n ) {\n  HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ;\n  int sum = 0 ;\n  int max_len = 0 ;\n  int ending_index = - 1 ;\n  int start_index = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;\n  }\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    sum += arr [ i ] ;\n    if ( sum == 0 ) {\n      max_len = i + 1 ;\n      ending_index = i ;\n    }\n    if ( hM . containsKey ( sum + n ) ) {\n      if ( max_len < i - hM . get ( sum + n ) ) {\n        max_len = i - hM . get ( sum + n ) ;\n        ending_index = i ;\n      }\n    }\n    else hM . put ( sum + n , i ) ;\n  }\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;\n  }\n  int end = ending_index - max_len + 1 ;\n  System . out . println ( end + \" to \" + ending_index ) ;\n  return max_len ;\n}",
    "badcase": "static int maxLen ( int arr [ ] , int n ) {\n    HashMap < Integer , Integer > hash_map = new HashMap < > ( ) ;\n    int curr_sum = 0 ;\n    int max_len = 0 ;\n    int ending_index = - 1 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( arr [ i ] == 0 ) arr [ i ] = - 1 ;\n      else arr [ i ] = 1 ;\n    }\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      curr_sum = curr_sum + arr [ i ] ;\n      if ( curr_sum == 0 ) {\n        max_len = i + 1 ;\n        ending_index = i ;\n      }\n      if ( hash_map . containsKey ( curr_sum + n ) ) {\n        max_len = Math . max ( max_len , i - hash_map . get ( curr_sum + n ) ) ;\n      }\n      else {\n        hash_map . put ( curr_sum , i ) ;\n      }\n    }\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( arr [ i ] == - 1 ) arr [ i ] = 0 ;\n      else arr [ i ] = 1 ;\n    }\n    System . out . print ( ending_index - max_len + 1 + \" to \" + ending_index ) ;\n    return max_len ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int set [ ] , int n ) {\n  if ( n <= 2 ) return n ;\n  int L [ ] [ ] = new int [ n ] [ n ] ;\n  int llap = 2 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) L [ i ] [ n - 1 ] = 2 ;\n  for ( int j = n - 2 ;\n  j >= 1 ;\n  j -- ) {\n    int i = j - 1 , k = j + 1 ;\n    while ( i >= 0 && k <= n - 1 ) {\n      if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;\n      else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {\n        L [ i ] [ j ] = 2 ;\n        i -- ;\n      }\n      else {\n        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;\n        llap = Math . max ( llap , L [ i ] [ j ] ) ;\n        i -- ;\n        k ++ ;\n      }\n    }\n    while ( i >= 0 ) {\n      L [ i ] [ j ] = 2 ;\n      i -- ;\n    }\n  }\n  return llap ;\n}",
    "badcase": "static int lenghtOfLongestAP ( int set [ ] , int n ) {\n    if ( n <= 2 ) return n ;\n    int L [ ] [ ] = new int [ n ] [ n ] ;\n    int llap = 2 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) L [ i ] [ n - 1 ] = 2 ;\n    for ( int j = n - 2 ;\n    j >= 1 ;\n    j -- ) {\n      int i = j - 1 , k = j + 1 ;\n      while ( i >= 0 && k <= n - 1 ) {\n        if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;\n        else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {\n          L [ i ] [ j ] = 2 ;\n          i -- ;\n        }\n        else {\n          L [ i ] [ j ] = L [ j ] [ k ] + 1 ;\n          llap = Math . max ( llap , L [ i ] [ j ] ) ;\n          i -- ;\n          k ++ ;\n          while ( i >= 0 ) {\n            L [ i ] [ j ] = 2 ;\n            i -- ;\n          }\n        }\n      }\n    }\n    return llap ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( char X [ ] , char Y [ ] , int m , int n ) {\n  int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;\n  int result = 0 ;\n  for ( int i = 0 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= n ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ;\n      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {\n        LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ;\n        result = Integer . max ( result , LCStuff [ i ] [ j ] ) ;\n      }\n      else LCStuff [ i ] [ j ] = 0 ;\n    }\n  }\n  return result ;\n}",
    "badcase": "static int LCSubStr ( String X , String Y , int m , int n ) {\n    int result = 0 ;\n    int [ ] [ ] LCSuff = new int [ m + 1 ] [ n + 1 ] ;\n    for ( int i = 0 ;\n    i <= m ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j <= n ;\n      j ++ ) {\n        if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ;\n        else {\n          if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {\n            LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ;\n            result = Math . max ( result , LCSuff [ i ] [ j ] ) ;\n          }\n          else LCSuff [ i ] [ j ] = 0 ;\n        }\n      }\n    }\n    return result ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] arr , int n ) {\n  HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ;\n  int longLen = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int len = 0 ;\n    if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ;\n    if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ;\n    um . put ( arr [ i ] , len + 1 ) ;\n    if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ;\n  }\n  return longLen ;\n}",
    "badcase": "static int longLenSub ( int arr [ ] , int n ) {\n    HashMap < Integer , Integer > um = new HashMap < > ( ) ;\n    int longLen = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int len1 = 0 ;\n      if ( um . containsKey ( arr [ i - 1 ] ) && len1 < um . get ( arr [ i ] - 1 ) ) {\n        len1 = um . get ( arr [ i ] - 1 ) ;\n      }\n      if ( um . containsKey ( arr [ i ] + 1 ) && len1 < um . get ( arr [ i ] + 1 ) ) {\n        len1 = um . get ( arr [ i ] + 1 ) ;\n      }\n      um . put ( arr [ i ] , len1 + 1 ) ;\n      if ( longLen < um . get ( arr [ i ] ) ) {\n        longLen = um . get ( arr [ i ] ) ;\n      }\n    }\n    return longLen ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( char [ ] in ) {\n  for ( int i = 0 ;\n  i < in . length ;\n  i ++ ) {\n    if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) {\n      in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ;\n    }\n  }\n  return String . valueOf ( in ) ;\n}",
    "badcase": "static String to_upper ( String str ) {\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( str . charAt ( i ) >='a'&& str . charAt ( i ) <='z') {\n      str = str . substring ( 0 , i ) + ( char ) ( str . charAt ( i ) -'a'+'A') + str . substring ( i + 1 ) ;\n    }\n  }\n  return str ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( String str , int k ) {\n  char palin [ ] = str . toCharArray ( ) ;\n  String ans = \"\" ;\n  int l = 0 ;\n  int r = str . length ( ) - 1 ;\n  while ( l < r ) {\n    if ( str . charAt ( l ) != str . charAt ( r ) ) {\n      palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ;\n      k -- ;\n    }\n    l ++ ;\n    r -- ;\n  }\n  if ( k < 0 ) {\n    return \"Not possible\" ;\n  }\n  l = 0 ;\n  r = str . length ( ) - 1 ;\n  while ( l <= r ) {\n    if ( l == r ) {\n      if ( k > 0 ) {\n        palin [ l ] = '9' ;\n      }\n    }\n    if ( palin [ l ] < '9' ) {\n      if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) {\n        k -= 2 ;\n        palin [ l ] = palin [ r ] = '9' ;\n      }\n      else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) {\n        k -- ;\n        palin [ l ] = palin [ r ] = '9' ;\n      }\n    }\n    l ++ ;\n    r -- ;\n  }\n  for ( int i = 0 ;\n  i < palin . length ;\n  i ++ ) ans += palin [ i ] ;\n  return ans ;\n}",
    "badcase": "static String maximumPalinUsingKChanges ( String str , int k ) {\n    char [ ] palin = str . toCharArray ( ) ;\n    int l = 0 ;\n    int r = str . length ( ) - 1 ;\n    while ( l <= r ) {\n      if ( str . charAt ( l ) != str . charAt ( r ) ) {\n        palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ;\n        k -- ;\n      }\n      l ++ ;\n      r -- ;\n    }\n    if ( k < 0 ) return \"Not possible\" ;\n    l = 0 ;\n    r = str . length ( ) - 1 ;\n    while ( l <= r ) {\n      if ( l == r ) {\n        if ( k > 0 ) {\n          palin [ l ] ='9';\n        }\n      }\n      if ( palin [ l ] <'9') {\n        if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) {\n          k -- ;\n          palin [ l ] = palin [ r ] ='9';\n        }\n        else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) palin [ r ] != str . charAt ( r ) ) ) {\n          k -- ;\n          palin [ l ] = palin [ r ] ='9';\n        }\n      }\n      l ++ ;\n      r -- ;\n    }\n    return new String ( palin ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( Integer arr [ ] , int n ) {\n  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;\n  int [ ] dimension = {\n    0 , 0 };\n    for ( int i = 0 , j = 0 ;\n    i < n - 1 && j < 2 ;\n    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ;\n    return ( dimension [ 0 ] * dimension [ 1 ] ) ;\n  }",
    "badcase": "static int findArea ( int [ ] arr , int n ) {\n    Arrays . sort ( arr ) ;\n    int [ ] dimension = new int [ 2 ] ;\n    int i = 0 , j = 0 ;\n    while ( i < n - 1 && j < 2 ) {\n      if ( arr [ i ] == arr [ i + 1 ] ) {\n        dimension [ j ] = arr [ i ] ;\n        j ++ ;\n        i ++ ;\n      }\n      i ++ ;\n    }\n    return ( dimension [ 0 ] * dimension [ 1 ] ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( long [ ] arr , int n ) {\n    long [ ] mpis = new long [ n ] ;\n    long max = Integer . MIN_VALUE ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) mpis [ i ] = arr [ i ] ;\n    for ( int i = 1 ;\n    i < n ;\n    i ++ ) for ( int j = 0 ;\n    j < i ;\n    j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ;\n    for ( int k = 0 ;\n    k < mpis . length ;\n    k ++ ) {\n      if ( mpis [ k ] > max ) {\n        max = mpis [ k ] ;\n      }\n    }\n    return max ;\n  }",
    "badcase": "static int lis ( int arr [ ] , int n ) {\n    int mpis [ ] = new int [ n ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) mpis [ i ] = arr [ i ] ;\n    for ( int i = 1 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < i ;\n      j ++ ) {\n        if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) {\n          mpis [ i ] = mp [ j ] * arr [ i ] ;\n        }\n      }\n    }\n    int res = mpis [ 0 ] ;\n    for ( int i = 1 ;\n    i < n ;\n    i ++ ) res = Math . max ( res , mpis [ i ] ) ;\n    return res ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int a [ ] , int n , int k ) {\n  int max_so_far = 0 ;\n  int INT_MIN , max_ending_here = 0 ;\n  for ( int i = 0 ;\n  i < n * k ;\n  i ++ ) {\n    max_ending_here = max_ending_here + a [ i % n ] ;\n    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;\n    if ( max_ending_here < 0 ) max_ending_here = 0 ;\n  }\n  return max_so_far ;\n}",
    "badcase": "static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {\n    int max_so_far = Integer . MIN_VALUE ;\n    int max_ending_here = 0 ;\n    for ( int i = 0 ;\n    i < n * k ;\n    i ++ ) {\n      max_ending_here = max_ending_here + a [ i % n ] ;\n      if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;\n      if ( max_ending_here < 0 ) max_ending_here = 0 ;\n    }\n    return max_so_far ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int ar1 [ ] , int ar2 [ ] , int n ) {\n  int i = 0 ;\n  int j = 0 ;\n  int count ;\n  int m1 = - 1 , m2 = - 1 ;\n  for ( count = 0 ;\n  count <= n ;\n  count ++ ) {\n    if ( i == n ) {\n      m1 = m2 ;\n      m2 = ar2 [ 0 ] ;\n      break ;\n    }\n    else if ( j == n ) {\n      m1 = m2 ;\n      m2 = ar1 [ 0 ] ;\n      break ;\n    }\n    if ( ar1 [ i ] < ar2 [ j ] ) {\n      m1 = m2 ;\n      m2 = ar1 [ i ] ;\n      i ++ ;\n    }\n    else {\n      m1 = m2 ;\n      m2 = ar2 [ j ] ;\n      j ++ ;\n    }\n  }\n  return ( m1 + m2 ) / 2 ;\n}",
    "badcase": "static double getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {\n    int i = 0 , j = 0 ;\n    int count ;\n    int m1 = - 1 , m2 = - 1 ;\n    for ( count = 0 ;\n    count <= n ;\n    count ++ ) {\n      if ( i == n ) {\n        m1 = m2 ;\n        m2 = ar2 [ 0 ] ;\n        break ;\n      }\n      else if ( j == n ) {\n        m1 = m2 ;\n        m2 = ar1 [ 0 ] ;\n        break ;\n      }\n      if ( ar1 [ i ] < ar2 [ j ] ) {\n        m1 = m2 ;\n        m2 = ar1 [ i ] ;\n        i ++ ;\n      }\n      else {\n        m1 = m2 ;\n        m2 = ar2 [ j ] ;\n        j ++ ;\n      }\n    }\n    return ( m1 + m2 ) / 2.0 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] a , int n ) {\n  int min = a [ 0 ] ;\n  for ( int i = 1 ;\n  i < a . length ;\n  i ++ ) {\n    if ( a [ i ] < min ) min = a [ i ] ;\n  }\n  return ( n - 1 ) * min ;\n}",
    "badcase": "static int cost ( int a [ ] , int n ) {\n    return ( ( n - 1 ) * Collections . min ( Arrays . asList ( a ) ) ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int n , int k ) {\n  Arrays . sort ( arr ) ;\n  int max = arr [ arr . length - 1 ] ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;\n    else res += ( max - arr [ i ] ) / k ;\n  }\n  return res ;\n}",
    "badcase": "static int minOps ( int arr [ ] , int n , int k ) {\n    int max1 = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;\n    int res = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( ( max1 - arr [ i ] ) % k != 0 ) return - 1 ;\n      else res += ( max1 - arr [ i ] ) / k ;\n    }\n    return res ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( String str ) {\n  String tmp = str + str ;\n  int n = str . length ( ) ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    String substring = tmp . substring ( i , str . length ( ) ) ;\n    if ( str == substring ) return i ;\n  }\n  return n ;\n}",
    "badcase": "static int findRotations ( String str ) {\n    String tmp = str + str ;\n    int n = str . length ( ) ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      String substring = tmp . substring ( i , i + n ) ;\n      if ( str . equals ( substring ) ) return i ;\n    }\n    return n ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] A , int n ) {\n  int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ;\n  return ( min_val * ( n - 1 ) ) ;\n}",
    "badcase": "static int minSum ( int A [ ] ) {\n    int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ;\n    return min_val * ( A . length - 1 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static double f_gold ( double a , double b ) {\n  if ( a < 0 ) a = - a ;\n  if ( b < 0 ) b = - b ;\n  double mod = a ;\n  while ( mod >= b ) mod = mod - b ;\n  if ( a < 0 ) return - mod ;\n  return mod ;\n}",
    "badcase": "static int findMod ( int a , int b ) {\n    if ( a < 0 ) a = - a ;\n    if ( b < 0 ) b = - b ;\n    int mod = a ;\n    while ( mod >= b ) mod = mod - b ;\n    if ( a < 0 ) return - mod ;\n    return mod ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( long a , long b , long mod ) {\n  long res = 0 ;\n  a %= mod ;\n  while ( b > 0 ) {\n    if ( ( b & 1 ) > 0 ) {\n      res = ( res + a ) % mod ;\n    }\n    a = ( 2 * a ) % mod ;\n    b >>= 1 ;\n  }\n  return res ;\n}",
    "badcase": "static int moduloMultiplication ( int a , int b , int mod ) {\n  int res = 0 ;\n  a = a % mod ;\n  while ( b > 0 ) {\n    if ( ( b & 1 ) != 0 ) res = ( res + a ) % mod ;\n    a = ( 2 * a ) % mod ;\n    b >>= 1 ;\n  }\n  return res ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int f [ ] = new int [ n + 1 ] ;\n  f [ 0 ] = 0 ;\n  f [ 1 ] = 1 ;\n  f [ 2 ] = 1 ;\n  int i ;\n  for ( i = 3 ;\n  i <= n ;\n  i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;\n  return f [ n ] ;\n}",
    "badcase": "static int sequence ( int n ) {\n    int f [ ] = {\n      0 , 1 , 1 }\n      ;\n      int r = 0 ;\n      for ( int i = 3 ;\n      i <= n ;\n      i ++ ) {\n        r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;\n        f [ i ] = r ;\n      }\n      return r ;\n    }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int x ) {\n  int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ;\n  if ( x > 0 ) {\n    rightOne = x & - x ;\n    nextHigherOneBit = x + rightOne ;\n    rightOnesPattern = x ^ nextHigherOneBit ;\n    rightOnesPattern = ( rightOnesPattern ) / rightOne ;\n    rightOnesPattern >>= 2 ;\n    next = nextHigherOneBit | rightOnesPattern ;\n  }\n  return next ;\n}",
    "badcase": "static void snoob ( int x ) {\n    int next = 0 ;\n    if ( x != 0 ) {\n      int rightOne ;\n      rightOne = x & - x ;\n      int nextHigherOneBit = x + rightOne ;\n      int rightOnesPattern = x ^ nextHigherOneBit ;\n      rightOnesPattern = rightOnesPattern / rightOne ;\n      rightOnesPattern = rightOnesPattern >> 2 ;\n      next = nextHigherOneBit ;\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static int f_gold ( int k , int n ) {\n  long f1 = 0 , f2 = 1 , f3 ;\n  int i = 2 ;\n  while ( i != 0 ) {\n    f3 = f1 + f2 ;\n    f1 = f2 ;\n    f2 = f3 ;\n    if ( f2 % k == 0 ) {\n      return n * i ;\n    }\n    i ++ ;\n  }\n  return 0 ;\n}",
    "badcase": "static int findPosition ( int k , int n ) {\n    int f1 = 0 , f2 = 1 ;\n    int i = 2 ;\n    while ( true ) {\n      int f3 = f1 + f2 ;\n      f1 = f2 ;\n      f2 = f3 ;\n      if ( f2 % k == 0 ) return n * i ;\n      i ++ ;\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static int f_gold ( int a , int b ) {\n  if ( a == 0 || b == 0 ) return 1 ;\n  return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ;\n}",
    "badcase": "static int countDigits ( int a , int b ) {\n    if ( a == 0 b == 0 ) return 1 ;\n    return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( long n ) {\n  while ( n / 100 > 0 ) {\n    int last_digit = ( int ) n % 10 ;\n    n /= 10 ;\n    n += last_digit * 3 ;\n  }\n  return ( n % 29 == 0 ) ;\n}",
    "badcase": "static boolean isDivisible ( int n ) {\n    while ( n / 100 > 0 ) {\n      int last_digit = n % 10 ;\n      n = n / 10 ;\n      n += last_digit * 3 ;\n    }\n    return ( n % 29 == 0 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( int n ) {\n  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;\n  if ( n == 1 ) return 10 ;\n  for ( int j = 0 ;\n  j <= 9 ;\n  j ++ ) dp [ 1 ] [ j ] = 1 ;\n  for ( int i = 2 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= 9 ;\n    j ++ ) {\n      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;\n      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ;\n    }\n  }\n  long sum = 0 ;\n  for ( int j = 1 ;\n  j <= 9 ;\n  j ++ ) sum += dp [ n ] [ j ] ;\n  return sum ;\n}",
    "badcase": "static int answer ( int n ) {\n    int [ ] [ ] dp = new int [ n + 1 ] [ 10 ] ;\n    if ( n == 1 ) return 10 ;\n    for ( int j = 0 ;\n    j < 10 ;\n    j ++ ) dp [ 1 ] [ j ] = 1 ;\n    for ( int i = 2 ;\n    i <= n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < 10 ;\n      j ++ ) {\n        if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n        else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;\n        else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ;\n      }\n    }\n    int sum = 0 ;\n    for ( int j = 1 ;\n    j < 10 ;\n    j ++ ) sum += dp [ n ] [ j ] ;\n    return sum ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static double f_gold ( int A , int N ) {\n  double xPre = Math . random ( ) % 10 ;\n  double eps = 0.001 ;\n  double delX = 2147483647 ;\n  double xK = 0.0 ;\n  while ( delX > eps ) {\n    xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ;\n    delX = Math . abs ( xK - xPre ) ;\n    xPre = xK ;\n  }\n  return xK ;\n}",
    "badcase": "static double nthRoot ( int A , int N ) {\n    double xPre = ( int ) ( Math . random ( ) * 101 ) % 10 ;\n    double eps = 0.001 ;\n    double delX = Integer . MAX_VALUE ;\n    double xK ;\n    while ( delX > eps ) {\n      xK = ( ( N - 1.0 ) * xPre + A / Math . pow ( xPre , N - 1 ) ) / N ;\n      delX = Math . abs ( xK - xPre ) ;\n      xPre = xK ;\n    }\n    return xK ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static boolean f_gold ( String str ) {\n  boolean [ ] mark = new boolean [ 26 ] ;\n  int index = 0 ;\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= 'Z' ) index = str . charAt ( i ) - 'A' ;\n    else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) <= 'z' ) index = str . charAt ( i ) - 'a' ;\n    mark [ index ] = true ;\n  }\n  for ( int i = 0 ;\n  i <= 25 ;\n  i ++ ) if ( mark [ i ] == false ) return ( false ) ;\n  return ( true ) ;\n}",
    "badcase": "static boolean checkPangram ( String str ) {\n    Vector < Boolean > v = new Vector < > ( ) ;\n    for ( int i = 0 ;\n    i < 26 ;\n    i ++ ) v . add ( false ) ;\n    for ( int i = 0 ;\n    i < str . length ( ) ;\n    i ++ ) {\n      if ( str . charAt ( i ) !='â–') {\n        v . set ( str . charAt ( i ) -'a', true ) ;\n      }\n    }\n    for ( int i = 0 ;\n    i < v . size ( ) ;\n    i ++ ) {\n      if ( v . get ( i ) == false ) return false ;\n    }\n    return true ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int arr [ ] , int N , int k ) {\n  int M , S = 0 , S1 = 0 , max_difference = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) S += arr [ i ] ;\n  int temp ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < N ;\n    j ++ ) {\n      if ( arr [ i ] < arr [ j ] ) {\n        temp = arr [ i ] ;\n        arr [ i ] = arr [ j ] ;\n        arr [ j ] = temp ;\n      }\n    }\n  }\n  M = Math . max ( k , N - k ) ;\n  for ( int i = 0 ;\n  i < M ;\n  i ++ ) S1 += arr [ i ] ;\n  max_difference = S1 - ( S - S1 ) ;\n  return max_difference ;\n}",
    "badcase": "static int maxDifference ( int arr [ ] , int N , int k ) {\n    int S = 0 , S1 = 0 ;\n    int max_difference = 0 ;\n    for ( int i = 0 ;\n    i < N ;\n    i ++ ) S += arr [ i ] ;\n    Arrays . sort ( arr ) ;\n    int M = Math . max ( k , N - k ) ;\n    for ( int i = 0 ;\n    i < M ;\n    i ++ ) S1 += arr [ i ] ;\n    max_difference = S1 - ( S - S1 ) ;\n    return max_difference ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  if ( n <= 1 ) return false ;\n  if ( n <= 3 ) return true ;\n  if ( n % 2 == 0 || n % 3 == 0 ) return false ;\n  for ( int i = 5 ;\n  i * i <= n ;\n  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;\n  return true ;\n}",
    "badcase": "static boolean isPrime ( int n ) {\n    if ( n <= 1 ) return false ;\n    if ( n <= 3 ) return true ;\n    if ( n % 2 == 0 n % 3 == 0 ) return false ;\n    for ( int i = 5 ;\n    i * i <= n ;\n    i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;\n    return true ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int a [ ] , int n , int k ) {\n  HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int x = a [ i ] ;\n    int d = Math . min ( 1 + i , n - i ) ;\n    if ( ! b . containsKey ( x ) ) b . put ( x , d ) ;\n    else {\n      b . put ( x , Math . min ( d , b . get ( x ) ) ) ;\n    }\n  }\n  int ans = Integer . MAX_VALUE ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int x = a [ i ] ;\n    if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ;\n  }\n  return ans ;\n}",
    "badcase": "static int find_maximum ( int a [ ] , int n , int k ) {\n    HashMap < Integer , Integer > b = new HashMap < > ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int x = a [ i ] ;\n      int d = Math . min ( 1 + i , n - i ) ;\n      if ( ! b . containsKey ( x ) ) b . put ( x , d ) ;\n      else b . put ( x , Math . min ( d , b . get ( x ) ) ) ;\n    }\n    int ans = ( int ) 1e9 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int x = a [ i ] ;\n      if ( x != ( k - x ) && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( String text , String word ) {\n  String [ ] word_list = text . split ( \"\\\\s+\" ) ;\n  String result = \"\" ;\n  String stars = \"\" ;\n  for ( int i = 0 ;\n  i < word . length ( ) ;\n  i ++ ) stars += '*' ;\n  int index = 0 ;\n  for ( String i : word_list ) {\n    if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ;\n    index ++ ;\n  }\n  for ( String i : word_list ) result += i + ' ' ;\n  return result ;\n}",
    "badcase": "static String censor ( String text , String word ) {\n    String [ ] word_list = text . split ( \" \" ) ;\n    String result = \"\" ;\n    String stars = \"*\" . repeat ( word . length ( ) ) ;\n    int count = 0 ;\n    int index = 0 ;\n    for ( String i : word_list ) {\n      if ( i . equals ( word ) ) {\n        word_list [ index ] = stars ;\n      }\n      index ++ ;\n    }\n    result = String . join ( \" \" , word_list ) ;\n    return result ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( String isbn ) {\n  int n = isbn . length ( ) ;\n  if ( n != 10 ) return false ;\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < 9 ;\n  i ++ ) {\n    int digit = isbn . charAt ( i ) - '0' ;\n    if ( 0 > digit || 9 < digit ) return false ;\n    sum += ( digit * ( 10 - i ) ) ;\n  }\n  char last = isbn . charAt ( 9 ) ;\n  if ( last != 'X' && ( last < '0' || last > '9' ) ) return false ;\n  sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ;\n  return ( sum % 11 == 0 ) ;\n}",
    "badcase": "static boolean isValidISBN ( String isbn ) {\n    if ( isbn . length ( ) != 10 ) {\n      return false ;\n    }\n    int sum = 0 ;\n    for ( int i = 0 ;\n    i < 9 ;\n    i ++ ) {\n      if ( 0 <= isbn . charAt ( i ) -'0'&& isbn . charAt ( i ) -'0'<= 9 ) {\n        sum += ( isbn . charAt ( i ) -'0') * ( 10 - i ) ;\n      }\n      else {\n        return false ;\n      }\n    }\n    if ( isbn . charAt ( 9 ) !='X'&& 0 <= isbn . charAt ( 9 ) -'0'&& isbn . charAt ( 9 ) -'0'<= 9 ) {\n      return false ;\n    }\n    sum += ( isbn . charAt ( 9 ) =='X') ? 10 : ( isbn . charAt ( 9 ) -'0') ;\n    return ( sum % 11 == 0 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static double f_gold ( double r ) {\n  double PI = 3.1415 ;\n  double cir = 2 * PI * r ;\n  return cir ;\n}",
    "badcase": "static double circumference ( double r ) {\n    return ( 2 * PI * r ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static double f_gold ( double side ) {\n  return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;\n}",
    "badcase": "static double surface_area_octahedron ( double side ) {\n    return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( long n ) {\n  return ( int ) Math . pow ( n , 2 ) ;\n}",
    "badcase": "static int summingSeries ( int n ) {\n    return ( int ) Math . pow ( n , 2 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int n ) {\n  boolean arr [ ] = new boolean [ 10 ] ;\n  for ( int i = 0 ;\n  i < 10 ;\n  i ++ ) arr [ i ] = false ;\n  while ( n > 0 ) {\n    int digit = n % 10 ;\n    if ( arr [ digit ] ) return false ;\n    arr [ digit ] = true ;\n    n = n / 10 ;\n  }\n  return true ;\n}",
    "badcase": "static int isLucky ( long n ) {\n    int ar [ ] = new int [ 10 ] ;\n    while ( n > 0 ) {\n      int digit = ( int ) n % 10 ;\n      if ( ar [ digit ] != 0 ) return 0 ;\n      ar [ digit ] = 1 ;\n      n = n / 10 ;\n    }\n    return 1 ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  if ( n == 0 || n == 1 ) return n ;\n  return Math . max ( ( f_gold ( n / 2 ) + f_gold ( n / 3 ) + f_gold ( n / 4 ) ) , n ) ;\n}",
    "badcase": "static int breakSum ( int n ) {\n    if ( n == 0 n == 1 ) return n ;\n    return Math . max ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) , n ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static boolean f_gold ( int n , int i ) {\n  if ( n <= 2 ) return ( n == 2 ) ? true : false ;\n  if ( n % i == 0 ) return false ;\n  if ( i * i > n ) return true ;\n  return f_gold ( n , i + 1 ) ;\n}",
    "badcase": "static boolean isPrime ( int n , int i = 2 ) {\n    if ( n <= 2 ) return ( n == 2 ) ;\n    if ( n % i == 0 ) return false ;\n    if ( i * i > n ) return true ;\n    return isPrime ( n , i + 1 ) ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( String str ) {\n  int len = str . length ( ) ;\n  char res [ ] = new char [ len ] ;\n  int index = 0 , i = 0 ;\n  Stack < Integer > s = new Stack < Integer > ( ) ;\n  s . push ( 0 ) ;\n  while ( i < len ) {\n    if ( str . charAt ( i ) == '+' ) {\n      if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ;\n      if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ;\n    }\n    else if ( str . charAt ( i ) == '-' ) {\n      if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ;\n      else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ;\n    }\n    else if ( str . charAt ( i ) == '(' && i > 0 ) {\n      if ( str . charAt ( i - 1 ) == '-' ) {\n        int x = ( s . peek ( ) == 1 ) ? 0 : 1 ;\n        s . push ( x ) ;\n      }\n      else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s . peek ( ) ) ;\n    }\n    else if ( str . charAt ( i ) == ')' ) s . pop ( ) ;\n    else res [ index ++ ] = str . charAt ( i ) ;\n    i ++ ;\n  }\n  return new String ( res ) ;\n}",
    "badcase": "param0.add(\"ggbsMvMZcMOVd\");\n    param0.add(\"384292670\");\n    param0.add(\"10000100\");\n    param0.add(\"fdHME\");\n    param0.add(\"09198832\");\n    param0.add(\"0011111011\");\n    param0.add(\"SnXwRS\");\n    param0.add(\"071\");\n    param0.add(\"01101\");\n    param0.add(\"xwmqxgBa\");\n    for(int i = 0; i < param0.size(); ++i)\n    {\n        if(simplify(param0.get(i)).equals(f_gold(param0.get(i))))\n        {\n            n_success+=1;\n        }\n    }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int x , int y , int z ) {\n  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;\n  return ( ( x / z ) != 1 ) ? x : z ;\n}",
    "badcase": "static int smallest ( int x , int y , int z ) {\n    if ( y % x != 0 ) return ( y % z != 0 ) ? y : z ;\n    return ( x % z != 0 ) ? x : z ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static void f_gold ( int arr [ ] , int n ) {\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;\n  Arrays . sort ( arr ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;\n}",
    "badcase": "static void twoWaySort ( int [ ] arr , int n ) {\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ;\n    }\n    Arrays . sort ( arr ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ;\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static void f_gold ( int arr [ ] , int n , int k ) {\n  for ( int i = 0 ;\n  i < k ;\n  i ++ ) {\n    int x = arr [ 0 ] ;\n    for ( int j = 0 ;\n    j < n - 1 ;\n    ++ j ) arr [ j ] = arr [ j + 1 ] ;\n    arr [ n - 1 ] = x ;\n  }\n}",
    "badcase": "static void bitonicGenerator ( int arr [ ] , int n ) {\n    Vector < Integer > evenArr = new Vector < > ( ) ;\n    Vector < Integer > oddArr = new Vector < > ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( ( i % 2 ) == 0 ) evenArr . add ( arr [ i ] ) ;\n      else oddArr . add ( arr [ i ] ) ;\n    }\n    Collections . sort ( evenArr ) ;\n    Collections . sort ( oddArr ) ;\n    Collections . reverse ( oddArr ) ;\n    int i = 0 ;\n    for ( int j = 0 ;\n    j < evenArr . size ( ) ;\n    j ++ ) {\n      arr [ i ] = evenArr . get ( j ) ;\n      i ++ ;\n    }\n    for ( int j = 0 ;\n    j < oddArr . size ( ) ;\n    j ++ ) {\n      arr [ i ] = oddArr . get ( j ) ;\n      i ++ ;\n    }\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static float f_gold ( float n ) {\n  float x = n ;\n  float y = 1 ;\n  double e = 0.000001 ;\n  while ( x - y > e ) {\n    x = ( x + y ) / 2 ;\n    y = n / x ;\n  }\n  return x ;\n}",
    "badcase": "static double squareRoot ( int n ) {\n    double x = n ;\n    double y = 1 ;\n    double e = 0.000001 ;\n    while ( x - y > e ) {\n      x = ( x + y ) / 2 ;\n      y = n / x ;\n    }\n    return x ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( String str ) {\n  String result = \"\" ;\n  boolean v = true ;\n  for ( int i = 0 ;\n  i < str . length ( ) ;\n  i ++ ) {\n    if ( str . charAt ( i ) == ' ' ) {\n      v = true ;\n    }\n    else if ( str . charAt ( i ) != ' ' && v == true ) {\n      result += ( str . charAt ( i ) ) ;\n      v = false ;\n    }\n  }\n  return result ;\n}",
    "badcase": "static String firstLetterWord ( String str ) {\n    String result = \"\" ;\n    boolean v = true ;\n    for ( int i = 0 ;\n    i < str . length ( ) ;\n    i ++ ) {\n      if ( str . charAt ( i ) =='â–') v = true ;\n      else if ( str . charAt ( i ) !='â–'&& v == true ) {\n        result += ( str . charAt ( i ) ) ;\n        v = false ;\n      }\n    }\n    return result ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static int f_gold ( int [ ] arr , int n ) {\n  Set < Integer > s = new HashSet < > ( ) ;\n  int j = 0 , ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( j < n && ! s . contains ( arr [ j ] ) ) {\n      s . add ( arr [ i ] ) ;\n      j ++ ;\n    }\n    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;\n    s . remove ( arr [ i ] ) ;\n  }\n  return ans ;\n}",
    "badcase": "static int sumoflength ( int arr [ ] , int n ) {\n    Set < Integer > s = new HashSet < > ( ) ;\n    int j = 0 ;\n    int ans = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      while ( j < n && ! s . contains ( arr [ j ] ) ) {\n        s . add ( arr [ j ] ) ;\n        j ++ ;\n      }\n      ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;\n      s . remove ( arr [ i ] ) ;\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int [ ] a , int n ) {\n  Arrays . sort ( a ) ;\n  int sum = 0 ;\n  boolean flag = false ;\n  int len = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) {\n      flag = true ;\n      len = a [ i + 1 ] ;\n      i ++ ;\n    }\n    else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) {\n      sum = sum + a [ i + 1 ] * len ;\n      flag = false ;\n      i ++ ;\n    }\n  }\n  return sum ;\n}",
    "badcase": "static int MaxTotalRectangleArea ( int a [ ] , int n ) {\n    Arrays . sort ( a ) ;\n    int sum = 0 ;\n    boolean flag = false ;\n    int len = 0 ;\n    for ( int i = 0 ;\n    i < n - 1 ;\n    i ++ ) {\n      if ( i != 0 ) i ++ ;\n      if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) {\n        flag = true ;\n        len = a [ i + 1 ] ;\n        i ++ ;\n      }\n      else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) {\n        sum = sum + a [ i + 1 ] * len ;\n        flag = false ;\n        i ++ ;\n      }\n    }\n    return sum ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int ans = 0 , temp = 0 , num ;\n  for ( int i = 1 ;\n  i <= n && temp < n ;\n  i ++ ) {\n    temp = i - 1 ;\n    num = 1 ;\n    while ( temp < n ) {\n      if ( temp + i <= n ) ans += ( i * num ) ;\n      else ans += ( ( n - temp ) * num ) ;\n      temp += i ;\n      num ++ ;\n    }\n  }\n  return ans ;\n}",
    "badcase": "static int findSum ( int n ) {\n    int ans = 0 ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      int temp = 0 ;\n      int num = 1 ;\n      while ( temp < n ) {\n        if ( temp + i <= n ) {\n          ans += i * num ;\n        }\n        else {\n          ans += ( n - temp ) * num ;\n        }\n        temp += i ;\n        num ++ ;\n      }\n    }\n    return ans ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static double f_gold ( int n ) {\n  int i = 1 ;\n  double res = 0.0 ;\n  boolean sign = true ;\n  while ( n > 0 ) {\n    n -- ;\n    if ( sign ) {\n      sign = ! sign ;\n      res = res + ( double ) ++ i / ++ i ;\n    }\n    else {\n      sign = ! sign ;\n      res = res - ( double ) ++ i / ++ i ;\n    }\n  }\n  return res ;\n}",
    "badcase": "static double seriesSum ( int n ) {\n    int i = 1 ;\n    double res = 0.0 ;\n    boolean sign = true ;\n    while ( n > 0 ) {\n      n -- ;\n      if ( sign ) {\n        sign = false ;\n        res = res + ( i + 1 ) / ( i + 2 ) ;\n        i = i + 2 ;\n      }\n      else {\n        sign = true ;\n        res = res - ( i + 1 ) / ( i + 2 ) ;\n        i = i + 2 ;\n      }\n    }\n    return res ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static String f_gold ( String str1 , String str2 ) {\n  if ( str1 . length ( ) > str2 . length ( ) ) {\n    String t = str1 ;\n    str1 = str2 ;\n    str2 = t ;\n  }\n  String str = \"\" ;\n  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;\n  str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ;\n  str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ;\n  int carry = 0 ;\n  for ( int i = 0 ;\n  i < n1 ;\n  i ++ ) {\n    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;\n    str += ( char ) ( sum % 10 + '0' ) ;\n    carry = sum / 10 ;\n  }\n  for ( int i = n1 ;\n  i < n2 ;\n  i ++ ) {\n    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;\n    str += ( char ) ( sum % 10 + '0' ) ;\n    carry = sum / 10 ;\n  }\n  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;\n  str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ;\n  return str ;\n}",
    "badcase": "static String findSum ( String str1 , String str2 ) {\n    if ( str1 . length ( ) > str2 . length ( ) ) {\n      String t = str1 ;\n      str1 = str2 ;\n      str2 = t ;\n    }\n    String str = \"\" ;\n    int n1 = str1 . length ( ) ;\n    int n2 = str2 . length ( ) ;\n    int diff = n2 - n1 ;\n    str1 = reverse ( str1 ) ;\n    str2 = reverse ( str2 ) ;\n    int carry = 0 ;\n    for ( int i = 0 ;\n    i < n1 ;\n    i ++ ) {\n      int sum = ( ( str1 . charAt ( i ) -'0') + ( str2 . charAt ( i ) -'0') + carry ) ;\n      str += ( char ) ( sum % 10 +'0') ;\n      carry = sum / 10 ;\n    }\n    for ( int i = n1 ;\n    i < n2 ;\n    i ++ ) {\n      int sum = ( ( str2 . charAt ( i ) -'0') + carry ) ;\n      str += ( char ) ( sum % 10 +'0') ;\n      carry = sum / 10 ;\n    }\n    if ( carry > 0 ) str += ( char ) ( carry +'0') ;\n    str = reverse ( str ) ;\n    return str ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int x , int p1 , int p2 , int n ) {\n  int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;\n  int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;\n  int xor = ( set1 ^ set2 ) ;\n  xor = ( xor << p1 ) | ( xor << p2 ) ;\n  int result = x ^ xor ;\n  return result ;\n}",
    "badcase": "static int swapBits ( int x , int p1 , int p2 , int n ) {\n  int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;\n  int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;\n  int xor = ( set1 ^ set2 ) ;\n  xor = ( xor << p1 ) ;\n  return x ;\n}"
  },
  {
    "type": "python_to_java",
    "GT": "static long f_gold ( int n ) {\n  int N = 10 ;\n  long count = 1 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    count *= ( N + i - 1 ) ;\n    count /= i ;\n  }\n  return count ;\n}",
    "badcase": "static int countNonDecreasing ( int n ) {\n    int N = 10 ;\n    int count = 1 ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      count = count * ( N + i - 1 ) ;\n      count = count / i ;\n    }\n    return count ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int mat [ ] [ ] , int n , int m ) {\n  int [ ] rowsum = new int [ n ] ;\n  int [ ] colsum = new int [ m ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < m ;\n  j ++ ) if ( mat [ i ] [ j ] != 0 ) {\n    rowsum [ i ] ++ ;\n    colsum [ j ] ++ ;\n  }\n  int uniquecount = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < m ;\n  j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ;\n  return uniquecount ;\n}",
    "badcase": "static int countUnique ( int mat [ ] [ ] , int n , int m ) {\n    int rowsum [ ] = new int [ n ] ;\n    int colsum [ ] = new int [ m ] ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < m ;\n      j ++ ) {\n        if ( mat [ i ] [ j ] != 0 ) {\n          rowsum [ i ] ++ ;\n          colsum [ j ] ++ ;\n        }\n      }\n    }\n    int uniquecount = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < m ;\n      j ++ ) {\n        if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) {\n          uniquecount ++ ;\n        }\n      }\n    }\n    return uniquecount ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "static int f_gold ( int n ) {\n  int table [ ] = new int [ n + 1 ] ;\n  Arrays . fill ( table , 0 ) ;\n  table [ 0 ] = 1 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) for ( int j = i ;\n  j <= n ;\n  j ++ ) table [ j ] += table [ j - i ] ;\n  return table [ n ] ;\n}",
    "badcase": "static int CountWays ( int n ) {\n    int [ ] table = new int [ n + 1 ] ;\n    table [ 0 ] = 1 ;\n    for ( int i = 1 ;\n    i < n ;\n    i ++ ) {\n      for ( int j = i ;\n      j <= n ;\n      j ++ ) {\n        table [ j ] += table [ j - i ] ;\n      }\n    }\n    return table [ n ] ;\n  }"
  },
  {
    "type": "python_to_java",
    "GT": "public static int f_gold ( int n ) {\n  if ( n == 0 || n == 1 ) return n ;\n  int f1 = 0 , f2 = 1 , f3 = 1 ;\n  while ( f3 <= n ) {\n    f1 = f2 ;\n    f2 = f3 ;\n    f3 = f1 + f2 ;\n  }\n  return f2 ;\n}",
    "badcase": "static int nearestSmallerEqFib ( int n ) {\n    if ( n == 0 n == 1 ) return n ;\n    int f1 = 0 , f2 = 1 , f3 = 1 ;\n    while ( f3 <= n ) {\n      f1 = f2 ;\n      f2 = f3 ;\n      f3 = f1 + f2 ;\n    }\n    return f2 ;\n  }"
  }
]